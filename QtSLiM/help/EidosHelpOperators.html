<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.5">
  <style type="text/css">
    p.p1 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px Optima}
    p.p3 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px Optima; color: #000000}
    p.p4 {margin: 9.0px 0.0px 9.0px 27.4px; font: 9.0px Menlo}
    p.p5 {margin: 2.0px 0.0px 2.0px 0.0px; font: 11.0px Optima}
    p.p6 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 27.4px; font: 11.0px Optima}
    span.s1 {font: 9.0px Menlo}
    span.s2 {font: 11.0px 'Times New Roman'}
    span.s3 {font-kerning: none}
    span.s4 {font: 9.0px Menlo; font-kerning: none}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><i>2.2.2<span class="Apple-converted-space">  </span>ITEM: 1. Sequences: operator </i><span class="s1"><i>:</i></span></p>
<p class="p2">The <span class="s1">:</span> operator is used to construct vectors with (usually) more than one value.<span class="Apple-converted-space">  </span>In particular, it is used to construct <i>sequences</i>, and so it is called the sequence operator.<span class="Apple-converted-space">  </span>Given operands <span class="s1">x</span> and <span class="s1">y</span> (standing for any two numbers), the sequence operator starts at <span class="s1">x</span> and counts, by <span class="s1">1</span> (or <span class="s1">-1</span>, as appropriate) toward <span class="s1">y</span> without passing it.<span class="Apple-converted-space">  </span>It yields a vector containing all of the numbers it encounters along the way.</p>
<p class="p2">Note that the sequence operator can count down as well as up, that it can handle <span class="s1">float</span> as well as <span class="s1">integer</span> operands, and that negative numbers are allowed.</p>
<p class="p1"><i>2.2.4<span class="Apple-converted-space">  </span>ITEM: 2. Subsets: operator </i><span class="s1"><i>[]</i></span></p>
<p class="p2">The <span class="s1">[]</span> operator selects a subset of the vector upon which it operates; it is thus often called the subset operator.<span class="Apple-converted-space">  </span>It can work in one of two different ways, depending upon whether it is given an <span class="s1">integer</span> vector of indices, or is given a <span class="s1">logical</span> vector of selectors.</p>
<p class="p2">First of all, a subset can be selected with an <span class="s1">integer</span> vector of indices.<span class="Apple-converted-space">  </span>These indices are zero-based, like C but unlike R; the first value in a vector is thus at index <span class="s1">0</span>, not index <span class="s1">1</span>.<span class="Apple-converted-space">  </span>Note that a given index can be used multiple times.</p>
<p class="p2">Second, a subset can be selected with a <span class="s1">logical</span> vector of selectors.<span class="Apple-converted-space">  </span>In this case, the <span class="s1">logical</span> vector must be the same length as the vector being selected; each <span class="s1">logical</span> value indicates whether the corresponding vector value should be selected (<span class="s1">T</span>) or not (<span class="s1">F</span>).</p>
<p class="p1"><i>2.3.1<span class="Apple-converted-space">  </span>ITEM: 3. Arithmetic operators: </i><span class="s1"><i>+</i></span><i>, </i><span class="s1"><i>-</i></span><i>, </i><span class="s1"><i>*</i></span><i>, </i><span class="s1"><i>/</i></span><i>, </i><span class="s1"><i>%</i></span><i>, </i><span class="s1"><i>^</i></span></p>
<p class="p2">These are the standard operators of arithmetic; <span class="s1">+</span> performs addition, <span class="s1">-</span> performs subtraction, <span class="s1">*</span> performs multiplication, <span class="s1">/</span> performs division, <span class="s1">%</span> performs a modulo operation (more on that below), and <span class="s1">^</span> performs exponentiation.<span class="Apple-converted-space">  </span>Not a great deal needs to be said about these operators, which behave according to the standard rules of mathematics.<span class="Apple-converted-space">  </span>They also follow the standard rules of “precedence”; exponentiation is the highest precedence, addition and subtraction are the lowest precedence, and the other three are in the middle, so <span class="s1">4^2+5*6^7</span> is grouped as (<span class="s1">4^3)+(5*(6^7))</span>, as expected if you remember your grade-school math.</p>
<p class="p2">There are only a few minor twists to be discussed.<span class="Apple-converted-space">  </span>One is the meaning of the <span class="s1">%</span> operator, which many people have not previously encountered.<span class="Apple-converted-space">  </span>This computes the “modulo” from a division, which is the remainder left behind after division.<span class="Apple-converted-space">  </span>For example, <span class="s1">13%6</span> is <span class="s1">1</span>, because after <span class="s1">13</span> is divided evenly by <span class="s1">6</span> (taking care of <span class="s1">12</span> of the <span class="s1">13</span>), <span class="s1">1</span> is left as a remainder.<span class="Apple-converted-space">  </span>Probably the most common use of <span class="s1">%</span> is in determining whether a number is even or odd by looking at the result of a <span class="s1">%2</span> operation; <span class="s1">5%2</span> is <span class="s1">1</span>, indicating that <span class="s1">5</span> is odd, whereas <span class="s1">6%2</span> is <span class="s1">0</span>, indicating that <span class="s1">6</span> is even.</p>
<p class="p2">Another twist is that both the division and modulo operators in Eidos operate on <span class="s1">float</span> values – even if <span class="s1">integer</span> values are passed – and return <span class="s1">float</span> results.<span class="Apple-converted-space">  </span>(For those who care, division is performed internally using the C++ division operator <span class="s1">/</span>, and modulo is performed using the C++ <span class="s1">fmod()</span> function).<span class="Apple-converted-space">  </span>This policy was chosen because the definitions of integer division and modulo vary widely among programming languages and are contested and unclear (see Bantchev 2006, http://www.math.bas.bg/bantchev/articles/divmod.pdf).<span class="Apple-converted-space">  </span>If you are sure that you want <span class="s1">integer</span> division or modulo, and understand the issues involved, Eidos provides the functions <span class="s1">integerDiv()</span> and <span class="s1">integerMod()</span> for this purpose.<span class="Apple-converted-space">  </span>Besides side-stepping the vague definitions of the <span class="s1">integer</span> operator, this policy also avoids rather common bugs involving the accidental use of <span class="s1">integer</span> division when <span class="s1">float</span> division was desired – a much more common occurrence than <i>vice versa</i><span class="s2">.</span></p>
<p class="p2">A third twist is that <span class="s1">+</span> and <span class="s1">-</span> can both act as “unary” operators, meaning that they are happy to take just a single operand.<span class="Apple-converted-space">  </span>This is standard math notation, as in the expressions <span class="s1">-6+3</span> or <span class="s1">7*-5</span>; but it can sometimes look a bit strange, as in the expression <span class="s1">5--6</span> (more easily read as <span class="s1">5 - -6</span>).</p>
<p class="p2">A fourth twist is that the <span class="s1">^</span> operator is right-associative, whereas all other binary Eidos operators are left-associative.<span class="Apple-converted-space">  </span>For example, <span class="s1">2-3-4</span> is evaluated as <span class="s1">(2-3)-4</span>, not as <span class="s1">2-(3-4)</span>; this is left-associativity.<span class="Apple-converted-space">  </span>However, <span class="s1">2^3^4</span> is evaluated as <span class="s1">2^(3^4)</span>, not <span class="s1">(2^3)^4</span>; this is right-associativity.<span class="Apple-converted-space">  </span>Since this follows the standard associativity for these operators, in both mathematics and most other programming languages, the result should generally be intuitive, but if you have never explicitly thought about associativity before you might be taken by surprise.</p>
<p class="p2">A fifth twist is that the arithmetic operators and functions in Eidos are guaranteed to handle overflows safely.<span class="Apple-converted-space">  </span>The <span class="s1">float</span> type is safe because it uses IEEE-standard arithmetic, including the use of <span class="s1">INF</span> to indicate infinities and the use of <span class="s1">NAN</span> to represent not-a-number results; this is the same as in most languages.<span class="Apple-converted-space">  </span>In Eidos, however, the <span class="s1">integer</span> type is also safe, unlike in C, C++, and many other languages.<span class="Apple-converted-space">  </span>All operations on <span class="s1">integer</span> values in Eidos either (1) will always produce <span class="s1">float</span> results, as the <span class="s1">/</span> and <span class="s1">%</span> operators do; (2) will produce <span class="s1">float</span> results when needed to avoid overflow, as the <span class="s1">product()</span> and <span class="s1">sum()</span> functions do; or (3) will raise an error condition on an overflow, as the Eidos operators <span class="s1">+</span>, <span class="s1">-</span>, and <span class="s1">*</span> do, as well as the <span class="s1">abs()</span> and <span class="s1">asInteger()</span> functions.<span class="Apple-converted-space">  </span>This means that the <span class="s1">integer</span> type in Eidos can be used without fear that overflows might cause results to be incorrect.</p>
<p class="p2">The final twist is really a reminder: <i>everything is a vector</i>.<span class="Apple-converted-space">  </span>These operators are designed to do something smart, when possible, with vectors of any length, not just with single-valued vectors as shown above.<span class="Apple-converted-space">  </span>In general, the operands of these arithmetic operators must either be the same length (in which case the elements in the operand vectors are paired off and the operation is performed between each pair), or one or the other vector must be of length <span class="s1">1</span> (in which case the operation is performed using that single value, paired with each value in the other operand vector).</p>
<p class="p1"><i>2.3.2<span class="Apple-converted-space">  </span>ITEM: 4. Logical operators: </i><span class="s1"><i>|</i></span><i>, </i><span class="s1"><i>&amp;</i></span><i>, </i><span class="s1"><i>!</i></span></p>
<p class="p2">The <span class="s1">|</span>, <span class="s1">&amp;</span>, and <span class="s1">!</span> operators act upon <span class="s1">logical</span> values.<span class="Apple-converted-space">  </span>If they are given operands of other types, those operands will be “coerced” to <span class="s1">logical</span> values following the rule mentioned above: zero is <span class="s1">F</span>, non-zero is <span class="s1">T</span> (and for <span class="s1">string</span> operands, a <span class="s1">string</span> that is zero characters long – the empty string, <span class="s1">""</span> – is considered <span class="s1">F</span>, while all other <span class="s1">string</span> values are considered <span class="s1">T</span>).</p>
<p class="p2">As to what they do: <span class="s1">|</span> is the “or” operation, <span class="s1">&amp;</span> is the “and” operation, and <span class="s1">!</span> is the “not” operation.<span class="Apple-converted-space">  </span>As in common parlance, “or” is <span class="s1">T</span> if either of its operands is <span class="s1">T</span>, whereas “and” is <span class="s1">T</span> only if both of its operands are <span class="s1">T</span>.<span class="Apple-converted-space">  </span>The “not” operator is unary (it takes only one operand), and it negates its operand; <span class="s1">T</span> becomes <span class="s1">F</span>, <span class="s1">F</span> becomes <span class="s1">T</span>.<span class="Apple-converted-space">  </span>As with the arithmetic operators, these operators work with vector operands, too – either matching up values pairwise between the two operands, or applying a single value across a multivalued operand.</p>
<p class="p2">Those familiar with programming might wish to know that the <span class="s1">|</span> and <span class="s1">&amp;</span> operators do not “short-circuit” – they can’t, because they are vector operators. If the <span class="s1">&amp;</span> operator first sees an operand that evaluates to <span class="s1">F</span>, for example, it knows that it will produce <span class="s1">F</span> value(s) as a result; but it does not know what size result vector to make. If a later operand is a multivalued vector, the <span class="s1">&amp;</span> operator will produce a result vector of matching length; if all later operands are also length <span class="s1">1</span>, however, <span class="s1">&amp;</span> will produce a result vector of length <span class="s1">1</span>.<span class="Apple-converted-space">  </span>To know this for sure (and to make sure that there are no illegal length mismatches between later operands), it must evaluate all of its operands; it cannot short-circuit.<span class="Apple-converted-space">  </span>Similarly for the <span class="s1">|</span> operator.</p>
<p class="p2">These semantics match those in R, for its <span class="s1">|</span> and <span class="s1">&amp;</span> operators, but they might seem a little strange to those used to C and other scalar-based languages.<span class="Apple-converted-space">  </span>For those used to R, on the other hand, it should be noted here that Eidos does not support the <span class="s1">&amp;&amp;</span> and <span class="s1">||</span> operators of R, for reasons of simplicity; it is safer to use the <span class="s1">any()</span> or <span class="s1">all()</span> functions to simplify multivalued <span class="s1">logical</span> vectors before using <span class="s1">&amp;</span> or <span class="s1">|</span><span class="s2">.</span><span class="Apple-converted-space">  </span>If this is gibberish to you, it is not important; the point here is only to prevent confusion among users accustomed to R.</p>
<p class="p1"><i>2.3.3<span class="Apple-converted-space">  </span>ITEM: 5. Comparative operators: </i><span class="s1"><i>==</i></span><i>, </i><span class="s1"><i>!=</i></span><i>, </i><span class="s1"><i>&lt;</i></span><i>, </i><span class="s1"><i>&lt;=</i></span><i>, </i><span class="s1"><i>&gt;</i></span><i>, </i><span class="s1"><i>&gt;=</i></span></p>
<p class="p2">These operators compare their left and right operand.<span class="Apple-converted-space">  </span>The operators test for equality (<span class="s1">==</span>), inequality (<span class="s1">!=</span>), less-than (<span class="s1">&lt;</span>), less-than-or-equality (<span class="s1">&lt;=</span>), greater-than (<span class="s1">&gt;</span>), and greater-than-or-equality (<span class="s1">&gt;=</span>) relationships.<span class="Apple-converted-space">  </span>As seen above with the arithmetic and logical operators, this can work in two different ways: if the operands are the same length, their elements are paired up and the comparison is done between each pair, whereas if the operands are not the same length then one operand must be of length one, and its value is compared against all of the values of the other operand.</p>
<p class="p2">Regardless of the types of the operands, these operators all produce a <span class="s1">logical</span> result vector.<span class="Apple-converted-space">  </span>If the operands are of different types, promotion will be used to coerce them to be the same type (i.e. <span class="s1">logical</span> will be coerced to <span class="s1">integer</span>, <span class="s1">integer</span> to <span class="s1">float</span>, and <span class="s1">float</span> to <span class="s1">string</span>).<span class="Apple-converted-space">  </span>Note that this is often not what you want!<span class="Apple-converted-space">  </span>You might not want the automatic type promotion that makes <span class="s1">5=="5"</span> evaluate as <span class="s1">T</span>, or the vectorized comparison that makes <span class="s1">1:5==4</span> evaluate as something other than simply <span class="s1">F</span>.<span class="Apple-converted-space">  </span>You might really want to ask: are two values <i>identical?</i><span class="Apple-converted-space">  </span>For such purposes, the <span class="s1">identical()</span> function is a better choice.</p>
<p class="p1"><i>2.3.4<span class="Apple-converted-space">  </span>ITEM: 6. String concatenation: operator </i><span class="s1"><i>+</i></span></p>
<p class="p2">The <span class="s1">+</span> operator is often used as an arithmetic operator, but it can also act as a concatenation operator for string operands. Concatenation is pasting together; the <span class="s1">+</span> operator simply pastes its string operands together, end to end.</p>
<p class="p2">In fact, this works with non-<span class="s1">string</span> operands too, as long as a <span class="s1">string</span> operand is nearby; the interpretation of <span class="s1">+</span> as a concatenation operator is preferred by Eidos, and wins out over its arithmetic interpretation, as long as a <span class="s1">string</span> operand is present to suggest doing so. The other non-<span class="s1">string</span> operands will be coerced to <span class="s1">string</span>.<span class="Apple-converted-space">  </span>However, this does not work retroactively; if Eidos has already done arithmetic addition on some operands, it will not go back and perform concatenation instead.<span class="Apple-converted-space">  </span>To force concatenation in such situations, you can simply begin the expression with an empty string, <span class="s1">""</span>.</p>
<p class="p2">The concatenation operator also works with vectors, as usual.</p>
<p class="p3"><span class="s3">Beginning with Eidos 2.2, string concatenation involving </span><span class="s4">NULL</span><span class="s3"> concatenates the </span><span class="s4">string</span><span class="s3"> value </span><span class="s4">"NULL"</span><span class="s3">, just as if </span><span class="s4">NULL</span><span class="s3"> were a singleton </span><span class="s4">string</span><span class="s3"> vector containing that value.</span></p>
<p class="p1"><i>2.4.1<span class="Apple-converted-space">  </span>ITEM: 7. Assignment: operator </i><span class="s1"><i>=</i></span></p>
<p class="p2">The results of expressions can be saved in variables.<span class="Apple-converted-space">  </span>As in many languages, this is done with the <span class="s1">=</span> operator, often called the assignment operator.</p>
<p class="p2">The assignment operator, <span class="s1">=</span>, is different from the equality comparison operator, <span class="s1">==</span>.<span class="Apple-converted-space">  </span>In many languages, confusing the two can cause bugs that are hard to find; in C, for example, it is legal to write:</p>
<p class="p4">if (x=y) ...</p>
<p class="p2">In C, this would assign the value of <span class="s1">y</span> to <span class="s1">x</span>, and then the expression <span class="s1">x=y</span> would evaluate to the value that was assigned, and that value would be tested by the <span class="s1">if</span> statement.<span class="Apple-converted-space">  </span>This can be useful as a way of writing extremely compact code; but it is also a very common source of bugs, especially for inexperienced programmers.<span class="Apple-converted-space">  </span>In Eidos using assignment in this way is simply illegal; assignment is allowed only in the context of a statement like <span class="s1">x=y;</span> to prevent these issues.<span class="Apple-converted-space">  </span>(This point is mostly of interest to experienced programmers, so if it is unclear, don’t worry.)</p>
<p class="p2">Variable names are fairly unrestricted.<span class="Apple-converted-space">  </span>They may begin with a letter (uppercase or lowercase) or an underscore, and subsequently may contain all of those characters, and numerical digits as well.<span class="Apple-converted-space">  </span>So <span class="s1">x_23</span>, <span class="s1">fooBar</span>, and <span class="s1">MyVariable23</span> are all legal variable names (although not good ones – good variable names explain what the variable represents, such as <span class="s1">selection_coeff</span>).<span class="Apple-converted-space">  </span>However, <span class="s1">4by4</span> would not be a legal variable name, since it begins with a digit.</p>
<p class="p1"><i>2.3.5<span class="Apple-converted-space">  </span>ITEM: 8. The ternary conditional: operator </i><span class="s1"><i>? else</i></span></p>
<p class="p2">Eidos, like many languages, has an <span class="s1">if</span> statement that can be used to specify conditional execution of statements, and an <span class="s1">if-else</span> construct can be used to provide an alternative code path.<span class="Apple-converted-space">  </span>Sometimes, however, one wishes to have conditional execution of an expression, rather than an entire statement.<span class="Apple-converted-space">  </span>The <span class="s1">if-else</span> construct is particularly inconvenient with assignments involving complex lvalues, such as:</p>
<p class="p4">if (condition)</p>
<p class="p4"><span class="Apple-tab-span">	</span>x[index].property = a;</p>
<p class="p4">else</p>
<p class="p4"><span class="Apple-tab-span">	</span>x[index].property = b;</p>
<p class="p2">It is desirable to provide a way for the user to specify that the choice of rvalue, <span class="s1">a</span> or <span class="s1">b</span>, should depend upon <span class="s1">condition</span> without having to duplicate the lvalue and the assignment.<span class="Apple-converted-space">  </span>The R language provides this functionality by making <span class="s1">if-else</span> statements result in an rvalue, like an expression.<span class="Apple-converted-space">  </span>The C language, on the other hand, provides a <i>ternary conditional</i> operator, <span class="s1">?:</span><span class="s2">,</span> that can be used in expressions to much the same effect.<span class="Apple-converted-space">  </span>Eidos straddles the gap with a ternary conditional operator, <span class="s1">? else</span>, that uses the <span class="s1">?</span> initiator of C, but the <span class="s1">else</span> token as a continuation as in R.<span class="Apple-converted-space">  </span>In the syntax of Eidos, the above conditional assignment can be rewritten as:</p>
<p class="p4">x[index].property = condition ? a else b;</p>
<p class="p2">This will evaluate <span class="s1">condition</span> and result in <span class="s1">a</span> if <span class="s1">condition</span> is <span class="s1">T</span>, or <span class="s1">b</span> if <span class="s1">condition</span> is <span class="s1">F</span>.<span class="Apple-converted-space">  </span>That result is then assigned into the lvalue.<span class="Apple-converted-space">  </span>Note that, as in C, the precedence of the ternary conditional operator is very low, but higher than operator <span class="s1">=</span>, so that parentheses are often not needed to group statements of this type.<span class="Apple-converted-space">  </span>The <span class="s1">else</span> clause of the ternary conditional is required; there is no equivalent of an <span class="s1">if</span> statement without an <span class="s1">else</span>, since an rvalue must be produced.</p>
<p class="p2">Just as with <span class="s1">if-else</span> statements, only the selected subexpression, as determined by the condition, is evaluated; the other subexpression will not be evaluated, so any side effects it might have will not occur.<span class="Apple-converted-space">  </span>For example, with the statement:</p>
<p class="p4">x = condition ? f1() else f2();</p>
<p class="p5">here <span class="s1">f1()</span> will be called if <span class="s1">condition</span> is <span class="s1">T</span>, <span class="s1">f2()</span> if <span class="s1">condition</span> is <span class="s1">F</span>; only the subexpression selected by the condition is evaluated, and so it is never the case that both <span class="s1">f1()</span> and <span class="s1">f2()</span> are called.</p>
<p class="p2">Ternary conditionals may be nested.<span class="Apple-converted-space">  </span>Because the operator is right-associative, an expression such as:</p>
<p class="p4">z = (a == b ? a else b ? c else d);</p>
<p class="p5">is grouped as:</p>
<p class="p4">z = (a == b ? a else (b ? c else d));</p>
<p class="p5">rather than</p>
<p class="p4">z = ((a == b ? a else b) ? c else d);</p>
<p class="p2">This is generally desirable, since it provides a flow similar to chaining of <span class="s1">if-else if-else</span> statements.<span class="Apple-converted-space">  </span>In any case, parentheses may be used to change the order to evaluation as usual.</p>
<p class="p1"><i>2.3.6<span class="Apple-converted-space">  </span>ITEM: 9. Grouping: operator </i><span class="s1"><i>()</i></span></p>
<p class="p2">All of the discussion above involved simple expressions that allowed the standard precedence rules of mathematics to determine the order of operations; <span class="s1">1+2*3</span> is evaluated as <span class="s1">1+(2*3)</span> rather than <span class="s1">(1+2)*3</span> because the <span class="s1">*</span> operator is higher precedence than the <span class="s1">+</span> operator.<span class="Apple-converted-space">  </span>For the record, here is the full precedence hierarchy for operators in Eidos, from highest to lowest precedence:</p>
<p class="p6"><span class="s1">[]</span>, <span class="s1">()</span>, <span class="s1">.</span><span class="s2"><span class="Apple-tab-span">	</span></span>subscript, function call, and member access</p>
<p class="p6"><span class="s1">^</span><span class="s2"><span class="Apple-tab-span">	</span></span>exponentiation <i>(right-associative)</i></p>
<p class="p6"><span class="s1">+</span>, <span class="s1">-</span>, <span class="s1">!</span><span class="s2"><span class="Apple-tab-span">	</span></span>unary plus, unary minus, logical (Boolean) negation <i>(right-associative)</i></p>
<p class="p6"><span class="s1">:</span><span class="s2"><span class="Apple-tab-span">	</span></span>sequence construction</p>
<p class="p6"><span class="s1">*</span>, <span class="s1">/</span>, <span class="s1">%</span><span class="s2"><span class="Apple-tab-span">	</span></span>multiplication, division, and modulo</p>
<p class="p6"><span class="s1">+</span>, <span class="s1">-</span><span class="s2"><span class="Apple-tab-span">	</span></span>addition and subtraction</p>
<p class="p6"><span class="s1">&lt;</span>, <span class="s1">&gt;</span>, <span class="s1">&lt;=</span>, <span class="s1">&gt;=</span><span class="s2"><span class="Apple-tab-span">	</span></span>less-than, greater-than, less-than-or-equality, greater-than-or-equality</p>
<p class="p6"><span class="s1">==</span>, <span class="s1">!=</span><span class="s2"><span class="Apple-tab-span">	</span></span>equality and inequality</p>
<p class="p6"><span class="s1">&amp;</span><span class="s2"><span class="Apple-tab-span">	</span></span>logical (Boolean) and</p>
<p class="p6"><span class="s1">|</span><span class="s2"><span class="Apple-tab-span">	</span></span>logical (Boolean) or</p>
<p class="p6"><span class="s1">=</span><span class="s2"><span class="Apple-tab-span">	</span></span>assignment</p>
<p class="p2">Operators at the same precedence level are generally evaluated in the order in which they are encountered.<span class="Apple-converted-space">  </span>Put more technically, Eidos operators are generally left-associative; <span class="s1">3*5%2</span> evaluates as <span class="s1">(3*5)%2</span>, which is <span class="s1">1</span><span class="s2">,</span> not as <span class="s1">3*(5%2)</span>, which is <span class="s1">3</span>.<span class="Apple-converted-space">  </span>The only binary operator in Eidos that is an exception to this rule is the <span class="s1">^</span> operator, which (following standard mathematical convention) is right-associative; <span class="s1">2^3^4</span> is evaluated as <span class="s1">2^(3^4)</span>, not <span class="s1">(2^3)^4</span>.<span class="Apple-converted-space">  </span>The unary <span class="s1">+</span>, unary <span class="s1">-</span>, and <span class="s1">!</span> operators are also technically right-associative; for unary operators this is of little practical import, however (it basically just implies that the unary operators must occur to the left of their operand; you write <span class="s1">-x</span>, not <span class="s1">x-</span>, to express the negation of <span class="s1">x</span>).</p>
<p class="p2">In any case, parentheses can be used to modify the order of operations, just as in math.<span class="Apple-converted-space">  </span>This works just as you would expect.</p>
<p class="p2">Note that this use of parentheses is distinct from the <span class="s1">()</span> operator as used in making function calls.</p>
<p class="p3">Finally, note that Eidos 2.4 and earlier (SLiM 3.4 and earlier) had an operator precedence bug: exponentiation was given a lower precedence than unary minus and its siblings, and so the expression <span class="s1">-2^2</span> would evaluate to <span class="s1">4</span>, as <span class="s1">(-2)^2</span>, rather than <span class="s1">-4</span>, as <span class="s1">-(2^2)</span>.<span class="Apple-converted-space">  </span>This violated standard mathematical precedence rules, and was fixed in Eidos 2.4.1 (SLiM 3.4.1).</p>
<p class="p1"><i>2.7.1<span class="Apple-converted-space">  </span>ITEM: 10. Function calls: operator </i><span class="s1"><i>()</i></span></p>
<p class="p2">A function is simply a block of code which has been given a name.<span class="Apple-converted-space">  </span>Using that name, you can then cause the execution of that block of code whenever you wish.<span class="Apple-converted-space">  </span>That is the first major purpose of functions: the <i>reuseability</i> of a useful chunk of code.<span class="Apple-converted-space">  </span>A function can be supplied with the particular variables upon which it should act, called the function’s “parameters” or “arguments”; you can execute a function with the sequence <span class="s1">5:15</span> as an argument in one place, and with the string <span class="s1">"foo"</span> as an argument in another.<span class="Apple-converted-space">  </span>That is the second major purpose of functions: the <i>generalization</i> of a useful chunk of code to easily act on different inputs.</p>
<p class="p2">In Eidos, you may define your own functions, or you may execute a <i>lambda</i> (i.e., a snippet of code represented as a <span class="s1">string</span> value) directly in the Eidos interpreter.<span class="Apple-converted-space">  </span>However, a fairly large set of built-in functions are supplied for your use, and the hope is that they will suffice for most purposes.</p>
<p class="p2">Functions are called using the <span class="s1">()</span> operator.<span class="Apple-converted-space">  </span>Function arguments go between the parentheses of the <span class="s1">()</span> operator, separated by commas.<span class="Apple-converted-space">  </span>Most functions expect an exact number of arguments; many functions, in fact, are even fussier than that, requiring each parameter to be of a particular type, a particular size, or both.<span class="Apple-converted-space">  </span>But some, such as <span class="s1">c()</span>, are more flexible.</p>
<p class="p2">Many functions provide a return value.<span class="Apple-converted-space">  </span>In other words, a function call like <span class="s1">c(5,6)</span> can evaluate to a particular value, just as an expression like <span class="s1">5+6</span> evaluates to a particular value.<span class="Apple-converted-space">  </span>The result from a function call can be used in an expression or assigned to a variable, as you might expect.</p>
<p class="p1"><i>2.8.3<span class="Apple-converted-space">  </span>ITEM: 11. Properties: operator </i><span class="s1"><i>.</i></span></p>
<p class="p2">Objects encapsulate behaviors as well as elements.<span class="Apple-converted-space">  </span>One type of behavior is called a <i>property</i>.<span class="Apple-converted-space">  </span>A property is a simple attribute of each element in an <span class="s1">object</span>.<span class="Apple-converted-space">  </span>Properties can be read using the member-access operator, written as <span class="s1">.</span> (a period).<span class="Apple-converted-space">  </span>The name of a particular property can be used with <span class="s1">.</span> to get that property’s value.<span class="Apple-converted-space">  </span>Operations on <span class="s1">object</span> are vectorized just as they are for all other types in Eidos; the result of the <span class="s1">.</span> operator is a vector containing the value of the property for all of the elements of the <span class="s1">object</span> operand.</p>
<p class="p2">You can also use the member-access operator to write new values to properties that are not read-only, using the <span class="s1">=</span> operator to do the assignment into the property selected by the <span class="s1">.</span> operator.</p>
<p class="p1"><i>2.8.6<span class="Apple-converted-space">  </span>ITEM: 12. Method calls: operator </i><span class="s1"><i>()</i></span><i> and operator </i><span class="s1"><i>.</i></span></p>
<p class="p2">Objects encapsulate behaviors as well as elements.<span class="Apple-converted-space">  </span>In addition to properties, another type of behavior is called a <i>method</i>.<span class="Apple-converted-space">  </span>Methods are very much like functions; they are chunks of code that you can call to perform tasks.<span class="Apple-converted-space">  </span>However, each type of <span class="s1">object</span> has its own particular methods – unlike functions, which are defined globally.<span class="Apple-converted-space">  </span>Methods are more heavyweight than properties; they might involve quite a lot of computation, they might create a completely new <span class="s1">object</span> as their result, and they might even modify the <span class="s1">object</span> upon which they are called.<span class="Apple-converted-space">  </span>Not all methods are heavyweight in this sort of way, however; anything that one might want an <span class="s1">object</span> to do, but that does not feel like a simple property of the <span class="s1">object</span>, can be a method.<span class="Apple-converted-space">  </span>Methods can also take arguments, just like functions, and they can return whole vectors as their result, unlike (read-write) properties, which must refer to singleton values so that multiplexed assignment can work.<span class="Apple-converted-space">  </span>Methods are therefore much more powerful than properties.</p>
<p class="p2">Methods are called using the member-access operator, <span class="s1">.</span>, with a syntax that looks a lot like accessing a property, but combined with the function call operator, <span class="s1">()</span>.<span class="Apple-converted-space">  </span>That might look like:</p>
<p class="p4">object.method()</p>
<p class="p2">Naturally, method calls are also vector operations.<span class="Apple-converted-space">  </span>For a multi-element <span class="s1">object</span>, a single method call will result in the method call being multiplexed out to all of the elements of the <span class="s1">object</span>, and the results from all of those method calls will be concatenated together in the same way that the <span class="s1">c()</span> function performs concatenation (including dropping of <span class="s1">NULL</span>s and type promotion, potentially).</p>
</body>
</html>
