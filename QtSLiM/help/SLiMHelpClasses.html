<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2487.7">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p3 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo}
    p.p4 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima}
    p.p5 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p6 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p7 {margin: 0.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p8 {margin: 0.0px 0.0px 9.0px 27.4px; font: 9.0px Menlo; color: #000000}
    p.p9 {margin: 6.0px 0.0px 3.0px 0.0px; font: 9.0px Menlo}
    p.p10 {margin: 3.0px 0.0px 3.0px 27.4px; font: 9.0px Menlo; color: #000000}
    p.p11 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima; color: #000000}
    p.p12 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima; color: #000000}
    p.p13 {margin: 3.0px 0.0px 3.0px 27.4px; font: 11.0px Optima}
    p.p14 {margin: 3.0px 0.0px 3.0px 27.4px; font: 11.0px Optima; color: #000000}
    p.p15 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px 'Times New Roman'; min-height: 12.0px}
    p.p16 {margin: 3.0px 0.0px 3.0px 27.4px; font: 9.0px Menlo}
    span.s1 {font: 9.0px Menlo}
    span.s2 {font: 10.0px 'Times New Roman'}
    span.s3 {font-kerning: none}
    span.s4 {font: 9.0px Menlo; font-kerning: none}
    span.s5 {color: #000000}
    span.s6 {font: 9.0px Menlo; color: #000000}
    span.s7 {font-kerning: none; color: #000000}
    span.s8 {font: 9.0px Menlo; font-kerning: none; color: #000000}
    span.s9 {font: 9.0px 'Times New Roman'}
    span.s10 {font: 11.0px Optima}
    span.s11 {font: 10.0px Optima}
    span.s12 {text-decoration: underline ; color: #0000ff}
    span.s13 {font: 6.7px 'Times New Roman'}
    span.s14 {font: 10.0px 'Lucida Grande'}
    span.s15 {font: 10.0px 'Times New Roman'; color: #000000}
    span.s16 {font: 11.0px 'Times New Roman'}
    span.s17 {font: 11.0px Helvetica}
    span.s18 {font: 6.7px Optima}
    span.s19 {font: 10.0px Optima; color: #000000}
    span.s20 {font: 6.7px Optima; font-kerning: none}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><b>5.2<span class="Apple-converted-space">  </span>Class Chromosome</b></p>
<p class="p2"><i>5.2.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Chromosome</i></span><i> properties</i></p>
<p class="p3">colorSubstitution &lt;–&gt; (string$)</p>
<p class="p4">The color used to display substitutions in SLiMgui when both mutations and substitutions are being displayed in the chromosome view.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">colorSubstitution</span> is the empty string, <span class="s1">""</span>, SLiMgui will defer to the color scheme of each <span class="s1">MutationType</span>, just as it does when only substitutions are being displayed.<span class="Apple-converted-space">  </span>The default, <span class="s1">"3333FF"</span>, causes all substitutions to be shown as dark blue when displayed in conjunction with mutations, to prevent the view from becoming too noisy.<span class="Apple-converted-space">  </span>Note that when substitutions are displayed without mutations also being displayed, this value is ignored by SLiMgui and the substitutions use the color scheme of each <span class="s1">MutationType</span><span class="s2">.</span></p>
<p class="p5"><span class="s3">geneConversionEnabled =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">When gene conversion has been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, switching to the DSB recombination model, this property is </span><span class="s4">T</span><span class="s3">; otherwise, when using the crossover breakpoints model, it is </span><span class="s4">F</span><span class="s3">.</span></p>
<p class="p5"><span class="s3">geneConversionGCBias =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The gene conversion bias coefficient, which expresses a bias in the resolution of heteroduplex mismatches in complex gene conversion tracts.<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p5"><span class="s3">geneConversionNonCrossoverFraction =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The fraction of double-stranded breaks that result in non-crossover events.<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p5"><span class="s3">geneConversionMeanLength =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The mean length of a gene conversion tract (in base positions).<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p5"><span class="s3">geneConversionSimpleConversionFraction =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The fraction of gene conversion tracts that are “simple” (i.e., not involving resolution of heteroduplex mismatches); the remainder will be “complex”.<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p3">genomicElements =&gt; (object&lt;GenomicElement&gt;)</p>
<p class="p6"><span class="s5">All of the </span><span class="s6">GenomicElement</span><span class="s5"> objects that comprise the chromosome</span>, in sorted order (not necessarily in the order in which they were defined).</p>
<p class="p5"><span class="s3">hotspotEndPositions =&gt; (integer)</span></p>
<p class="p6"><span class="s3">The end positions for hotspot map regions along the chromosome.<span class="Apple-converted-space">  </span>Each hotspot map region is assumed to start at the position following the end of the previous hotspot map region; in other words, the regions are assumed to be contiguous.<span class="Apple-converted-space">  </span>When using sex-specific hotspot maps, this property will unavailable; see </span><span class="s4">hotspotEndPositionsF</span><span class="s3"> and </span><span class="s4">hotspotEndPositionsM</span><span class="s3">.</span></p>
<p class="p5"><span class="s3">hotspotEndPositionsF =&gt; (integer)</span></p>
<p class="p6"><span class="s3">The end positions for hotspot map regions for females, when using sex-specific hotspot maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">hotspotEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p5"><span class="s3">hotspotEndPositionsM =&gt; (integer)</span></p>
<p class="p6"><span class="s3">The end positions for hotspot map regions for males, when using sex-specific hotspot maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">hotspotEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p5"><span class="s3">hotspotMultipliers =&gt; (float)</span></p>
<p class="p6"><span class="s3">The hotspot multiplier for each of the hotspot map regions specified by </span><span class="s4">hotspotEndPositions</span><span class="s3">.<span class="Apple-converted-space">  </span>When using sex-specific hotspot maps, this property will be unavailable; see </span><span class="s4">hotspotMultipliersF</span><span class="s3"> and </span><span class="s4">hotspotMultipliersM</span><span class="s3">.</span></p>
<p class="p5"><span class="s3">hotspotMultipliersF =&gt; (float)</span></p>
<p class="p6"><span class="s3">The hotspot multiplier for each of the hotspot map regions specified by </span><span class="s4">hotspotEndPositionsF</span><span class="s3">, when using sex-specific hotspot maps; unavailable otherwise.</span></p>
<p class="p5"><span class="s3">hotspotMultipliersM =&gt; (float)</span></p>
<p class="p6"><span class="s3">The hotspot multiplier for each of the hotspot map regions specified by </span><span class="s4">hotspotEndPositionsM</span><span class="s3">, when using sex-specific hotspot maps; unavailable otherwise.</span></p>
<p class="p5">id =&gt; (integer$)</p>
<p class="p6">The id for the chromosome, as given to <span class="s1">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>For an implicitly defined chromosome, the <span class="s1">id</span> will be <span class="s1">1</span>.<span class="Apple-converted-space">  </span>The <span class="s1">id</span> can be used to refer to the chromosome; see also <span class="s1">symbol</span>.</p>
<p class="p5">intrinsicPloidy =&gt; (integer$)</p>
<p class="p6">The intrinsic ploidy of the chromosome, meaning the number of haplosome objects that are allocated in each individual, associated with the chromosome (even if some of those haplosomes are null haplosomes acting as placeholders).<span class="Apple-converted-space">  </span>This is a consequence of the chromosome’s type.<span class="Apple-converted-space">  </span>Chromosome types <span class="s1">"A"</span>, <span class="s1">"X"</span>, and <span class="s1">"Z"</span> are intrinsically diploid (and thus this property would have the value <span class="s1">2</span>), as are the backwards-compatibility chromosome types <span class="s1">"H-"</span> and <span class="s1">"-Y"</span>.<span class="Apple-converted-space">  </span>All other chromosome types are intrinsically haploid (and thus this property would have the value <span class="s1">1</span>).</p>
<p class="p5">isSexChromosome =&gt; (logical$)</p>
<p class="p6">Indicates whether the chromosome is a sex chromosome (T) or not (F).<span class="Apple-converted-space">  </span>This is a consequence of the chromosome’s type.<span class="Apple-converted-space">  </span>Chromosome types <span class="s1">"X"</span>, <span class="s1">"Y"</span>, <span class="s1">"Z"</span>, and <span class="s1">"W"</span> are considered sex chromosomes, as is the backwards-compatibility type <span class="s1">"-Y"</span>; all other chromosome types are not.<span class="Apple-converted-space">  </span>See also the <span class="s1">sexChromosomes</span> property of <span class="s1">Species</span>.</p>
<p class="p5">lastPosition =&gt; (integer$)</p>
<p class="p6">The last valid position in the chromosome; equal to <span class="s1">length-1</span>, where <span class="s1">length</span> is the length as given to <span class="s1">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>For an implicitly defined chromosome, the chromosome’s last position is determined by the <i>maximum</i> of the end of the last genomic element, the end of the last recombination region, and the end of the last mutation map region (or hotspot map region).<span class="Apple-converted-space">  </span>See also <span class="s1">length</span>.</p>
<p class="p5">length =&gt; (integer$)</p>
<p class="p6">The length of the chromosome (meaning the number of valid base positions it contains), as given to <span class="s1">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>The length is simply equal to the last position plus <span class="s1">1</span>, since the chromosome always starts at <span class="s1">0</span>.<span class="Apple-converted-space">  </span>See also <span class="s1">lastPosition</span>.</p>
<p class="p3">mutationEndPositions =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for mutation rate regions along the chromosome.<span class="Apple-converted-space">  </span>Each mutation rate region is assumed to start at the position following the end of the previous mutation rate region; in other words, the regions are assumed to be contiguous.<span class="Apple-converted-space">  </span>When using sex-specific mutation rate maps, this property will unavailable; see </span><span class="s4">mutationEndPositionsF</span><span class="s3"> and </span><span class="s4">mutationEndPositionsM</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationEndPositionsF =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for mutation rate regions for females, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">mutationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationEndPositionsM =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for mutation rate regions for males, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">mutationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationRates =&gt; (float)</p>
<p class="p6"><span class="s3">The mutation rate for each of the mutation rate regions specified by </span><span class="s4">mutationEndPositions</span><span class="s3">.<span class="Apple-converted-space">  </span>When using sex-specific mutation rate maps, this property will be unavailable; see </span><span class="s4">mutationRatesF</span><span class="s3"> and </span><span class="s4">mutationRatesM</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationRatesF =&gt; (float)</p>
<p class="p6"><span class="s3">The mutation rate for each of the mutation rate regions specified by </span><span class="s4">mutationEndPositionsF</span><span class="s3">, when using sex-specific mutation rate maps; unavailable otherwise.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationRatesM =&gt; (float)</p>
<p class="p6"><span class="s3">The mutation rate for each of the mutation rate regions specified by </span><span class="s4">mutationEndPositionsM</span><span class="s3">, when using sex-specific mutation rate maps; unavailable otherwise.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p5">name &lt;–&gt; (string$)</p>
<p class="p6">The name of the chromosome, as given to <span class="s1">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>The chromosome name is not used by SLiM, and may be whatever you wish.</p>
<p class="p3">overallMutationRate =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall mutation rate across the whole chromosome determining the overall number of mutation events that will occur anywhere in the chromosome, as calculated from the individual mutation ranges and rates as well as the coverage of the chromosome by genomic elements (since mutations are only generated within genomic elements, regardless of the mutation rate map).<span class="Apple-converted-space">  </span>When using sex-specific mutation rate maps, this property will unavailable; see </span><span class="s4">overallMutationRateF</span><span class="s3"> and </span><span class="s4">overallMutationRateM</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">overallMutationRateF =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall mutation rate for females, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallMutationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">overallMutationRateM =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall mutation rate for males, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallMutationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">overallRecombinationRate =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall recombination rate across the whole chromosome determining the overall number of recombination events that will occur anywhere in the chromosome, as calculated from the individual recombination ranges and rates.<span class="Apple-converted-space">  </span>When using sex-specific recombination maps, this property will unavailable; see </span><span class="s4">overallRecombinationRateF</span><span class="s3"> and </span><span class="s4">overallRecombinationRateM</span><span class="s3">.</span></p>
<p class="p3">overallRecombinationRateF =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall recombination rate for females, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallRecombinationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p3">overallRecombinationRateM =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall recombination rate for males, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallRecombinationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p3">recombinationEndPositions =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for recombination regions along the chromosome.<span class="Apple-converted-space">  </span>Each recombination region is assumed to start at the position following the end of the previous recombination region; in other words, the regions are assumed to be contiguous.<span class="Apple-converted-space">  </span>When using sex-specific recombination maps, this property will unavailable; see </span><span class="s4">recombinationEndPositionsF</span><span class="s3"> and </span><span class="s4">recombinationEndPositionsM</span><span class="s3">.</span></p>
<p class="p3">recombinationEndPositionsF =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for recombination regions for females, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">recombinationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p3">recombinationEndPositionsM =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for recombination regions for males, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">recombinationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p3">recombinationRates =&gt; (float)</p>
<p class="p6"><span class="s3">The recombination rate for each of the recombination regions specified by </span><span class="s4">recombinationEndPositions</span><span class="s3">.<span class="Apple-converted-space">  </span>When using sex-specific recombination maps, this property will unavailable; see </span><span class="s4">recombinationRatesF</span><span class="s3"> and </span><span class="s4">recombinationRatesM</span><span class="s3">.</span></p>
<p class="p3">recombinationRatesF =&gt; (float)</p>
<p class="p6"><span class="s3">The recombination rate for each of the recombination regions specified by </span><span class="s4">recombinationEndPositionsF</span><span class="s3">, when using sex-specific recombination maps; unavailable otherwise.</span></p>
<p class="p3">recombinationRatesM =&gt; (float)</p>
<p class="p6"><span class="s3">The recombination rate for each of the recombination regions specified by </span><span class="s4">recombinationEndPositionsM</span><span class="s3">, when using sex-specific recombination maps; unavailable otherwise.</span></p>
<p class="p3">species =&gt; (object&lt;Species&gt;$)</p>
<p class="p6"><span class="s3">The species to which the target object belongs.</span></p>
<p class="p5">symbol =&gt; (string$)</p>
<p class="p6">The symbol for the chromosome, as given to <span class="s1">initializeChromosome()</span>; see the documentation for that function.<span class="Apple-converted-space">  </span>For an implicitly defined chromosome, the symbol is <span class="s1">"A"</span> for non-sexual models, and for sexual models (for historical reasons) is determined by the model type passed to <span class="s1">initializeSex()</span> as documented there.<span class="Apple-converted-space">  </span>The <span class="s1">symbol</span> can be used to refer to the chromosome; see also <span class="s1">id</span>.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p5">type =&gt; (string$)</p>
<p class="p6">The type of the chromosome, as given to <span class="s1">initializeChromosome()</span>; see the documentation for that function for a list of the supported chromosome types.<span class="Apple-converted-space">  </span>For an implicitly defined chromosome, the type is <span class="s1">"A"</span> for non-sexual models, and for sexual models (for historical reasons) is determined by the model type passed to <span class="s1">initializeSex()</span> as documented there.</p>
<p class="p2"><i>5.2.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Chromosome</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (is)ancestralNucleotides([Ni$ start = NULL], [Ni$ end = NULL], [string$ format = "string"])</span></p>
<p class="p6"><span class="s3">Returns the ancestral nucleotide sequence originally supplied to </span><span class="s4">initializeAncestralNucleotides()</span><span class="s3">, including any sequence changes due to nucleotide mutations that have fixed and substituted.<span class="Apple-converted-space">  </span>This nucleotide sequence is the reference sequence for positions in a haplosome that do not contain a nucleotide-based mutation.<span class="Apple-converted-space">  </span>The range of the returned sequence may be constrained by a start position given in </span><span class="s4">start</span><span class="s3"> and/or an end position given in </span><span class="s4">end</span><span class="s3">; nucleotides will be returned from </span><span class="s4">start</span><span class="s3"> to </span><span class="s4">end</span><span class="s3">, inclusive.<span class="Apple-converted-space">  </span>The default value of </span><span class="s4">NULL</span><span class="s3"> for </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> represent the first and last base positions of the chromosome, respectively.</span></p>
<p class="p6"><span class="s3">The format of the returned sequence is controlled by the </span><span class="s4">format</span><span class="s3"> parameter.<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"string"</span><span class="s3"> will return the sequence as a singleton </span><span class="s4">string</span><span class="s3"> (e.g., </span><span class="s4">"TATA"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"char"</span><span class="s3"> will return a </span><span class="s4">string</span><span class="s3"> vector with one element per nucleotide (e.g., </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"integer"</span><span class="s3"> will return an </span><span class="s4">integer</span><span class="s3"> vector with values A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3"> (e.g., </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">).<span class="Apple-converted-space">  </span>If the sequence returned is likely to be long, the </span><span class="s4">"string"</span><span class="s3"> format will be the most memory-efficient, and may also be the fastest (but may be harder to work with).</span></p>
<p class="p6"><span class="s3">For purposes related to interpreting the nucleotide sequence as a coding sequence, a format of </span><span class="s4">"codon"</span><span class="s3"> is also supported.<span class="Apple-converted-space">  </span>This format will return an </span><span class="s4">integer</span><span class="s3"> vector with values from </span><span class="s4">0</span><span class="s3"> to </span><span class="s4">63</span><span class="s3">, based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three).<span class="Apple-converted-space">  </span>The codon value for a given nucleotide triplet XYZ is 16X + 4Y + Z, where X, Y, and Z have the usual values A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3">.<span class="Apple-converted-space">  </span>For example, the triplet AAA has a codon value of </span><span class="s4">0</span><span class="s3">, AAC is </span><span class="s4">1</span><span class="s3">, AAG is </span><span class="s4">2</span><span class="s3">, AAT is </span><span class="s4">3</span><span class="s3">, ACA is </span><span class="s4">4</span><span class="s3">, and on upward to TTT which is </span><span class="s4">63</span><span class="s3">.<span class="Apple-converted-space">  </span>If the nucleotide sequence AACACATTT is requested in codon format, the codon vector </span><span class="s4">1 4 63</span><span class="s3"> will therefore be returned.<span class="Apple-converted-space">  </span>These codon values can be useful in themselves; they can also be passed to </span><span class="s4">codonToAminoAcid()</span><span class="s3"> to translate them into the corresponding amino acid sequence if desired.</span></p>
<p class="p5"><span class="s5">– </span><span class="s3">(integer)drawBreakpoints([No&lt;Individual&gt;$ parent = NULL], [Ni$ n = NULL])</span></p>
<p class="p6"><span class="s3">Draw recombination breakpoints, using the chromosome’s recombination rate map, the current gene conversion parameters, and (in some cases – see below) any active and applicable </span><span class="s4">recombination()</span><span class="s3"> callbacks.<span class="Apple-converted-space">  </span>The number of breakpoints to generate, </span><span class="s4">n</span><span class="s3">, may be supplied; if it is </span><span class="s4">NULL</span><span class="s3"> (the default), the number of breakpoints will be drawn based upon the overall recombination rate and the chromosome length (following the standard procedure in SLiM).<span class="Apple-converted-space">  </span>Note that if the double-stranded breaks model has been chosen, the number of breakpoints generated will probably not be equal to the number requested, because most breakpoints will entail gene conversion tracts, which entail additional crossover breakpoints.</span></p>
<p class="p6">It is generally recommended that the parent individual be supplied to this method, but <span class="s1">parent</span> is <span class="s1">NULL</span> by default.<span class="Apple-converted-space">  </span>The individual supplied in <span class="s1">parent</span> is used for two purposes.<span class="Apple-converted-space">  </span>First, in sexual models that define separate recombination rate maps for males versus females, the sex of <span class="s1">parent</span> will be used to determine which map is used; in this case, a non-<span class="s1">NULL</span> value <i>must</i> be supplied for <span class="s1">parent</span>, since the choice of recombination rate map must be determined.<span class="Apple-converted-space">  </span>Second, in models that define <span class="s1">recombination()</span> callbacks, <span class="s1">parent</span> is used to determine the various pseudo-parameters that are passed to <span class="s1">recombination()</span> callbacks (<span class="s1">individual</span>, <span class="s1">haplosome1</span>, <span class="s1">haplosome2</span>, <span class="s1">subpop</span>), and the subpopulation to which <span class="s1">parent</span> belongs is used to select which <span class="s1">recombination()</span> callbacks are applicable; given the necessity of this information, <span class="s1">recombination()</span> callbacks will not be called as a side effect of this method if <span class="s1">parent</span> is <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>Apart from these two uses, <span class="s1">parent</span> is not used, and the caller does not guarantee that the generated breakpoints will actually be used to recombine the haplosomes of <span class="s1">parent</span> in particular.<span class="Apple-converted-space">  </span>If a <span class="s1">recombination()</span> callback is called, <span class="s1">haplosome1</span> for that callback will always be the first haplosome of <span class="s1">parent</span> for the chromosome; in other words, <span class="s1">drawBreakpoints()</span> will always treat the first haplosome of a homologous pair as the initial copy strand.<span class="Apple-converted-space">  </span>If the caller wishes to randomly choose an initial copy strand (which is usually desirable), they should do that themselves (note that the <span class="s1">addRecombinant()</span> and <span class="s1">addMultiRecombinant()</span> methods have a flag to facilitate this).</p>
<p class="p5">– (object&lt;GenomicElement&gt;)genomicElementForPosition(integer positions)</p>
<p class="p6">Returns a vector of <span class="s1">GenomicElement</span> objects corresponding to the given vector <span class="s1">positions</span>, which contains base positions along the chromosome.<span class="Apple-converted-space">  </span>If every position lies within a defined genomic element, the returned vector will have the same length as <span class="s1">positions</span>, and will correspond one-to-one with it.<span class="Apple-converted-space">  </span>However, if a position in <span class="s1">positions</span> is not within a genomic element, no <span class="s1">GenomicElement</span> object will be present for it in the returned vector, and so the returned vector will no longer have the same length as <span class="s1">positions</span>, and will no longer correspond one-to-one with it.<span class="Apple-converted-space">  </span>The method <span class="s1">hasGenomicElementForPosition()</span> can be used to detect this circumstance.</p>
<p class="p5">– (logical)hasGenomicElementForPosition(integer positions)</p>
<p class="p6">Returns a <span class="s1">logical</span> vector corresponding to the given vector <span class="s1">positions</span>, which contains base positions along the chromosome.<span class="Apple-converted-space">  </span>The returned vector will have the same length as <span class="s1">positions</span>, and will correspond one-to-one with it, containing <span class="s1">T</span> if the corresponding position lies inside a genomic element, or <span class="s1">F</span> if it does not.<span class="Apple-converted-space">  </span>The method <span class="s1">genomicElementForPosition()</span> can be used to look up the <span class="s1">GenomicElement</span> objects themselves.</p>
<p class="p5"><span class="s3">– (integer$)setAncestralNucleotides(is sequence)</span></p>
<p class="p6"><span class="s3">This method, which may be called only in nucleotide-based models, replaces the ancestral nucleotide sequence for the model.<span class="Apple-converted-space">  </span>The </span><span class="s4">sequence</span><span class="s3"> parameter is interpreted exactly as it is in the </span><span class="s4">initializeAncestralSequence()</span><span class="s3"> function; see that documentation for details.<span class="Apple-converted-space">  </span>The length of the ancestral sequence is returned.</span></p>
<p class="p6"><span class="s3">It is unusual to replace the ancestral sequence in a running simulation, since the nucleotide states of segregating and fixed mutations will depend upon the original ancestral sequence.<span class="Apple-converted-space">  </span>It can be useful when loading a new population state with </span><span class="s4">readHaplosomesFromMS()</span><span class="s3"> or </span><span class="s4">readHaplosomesFromVCF()</span><span class="s3">, such as when resetting the simulation state to an earlier state in a conditional simulation; however, that is more commonly done using </span><span class="s4">readFromPopulationFile()</span><span class="s3"> with a SLiM or </span><span class="s4">.trees</span><span class="s3"> file.</span></p>
<p class="p5"><span class="s3">– (void)setGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0])</span></p>
<p class="p6"><span class="s3">This method switches the recombination model to the “double-stranded break (DSB)” model (if it is not already set to that), and configures the details of the gene conversion tracts that will therefore be modeled.<span class="Apple-converted-space">  </span>The meanings and effects of the parameters exactly mirror the </span><span class="s4">initializeGeneConversion()</span><span class="s3"> function.</span></p>
<p class="p5"><span class="s3">– (void)setHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = "*"])</span></p>
<p class="p6"><span class="s3">In nucleotide-based models, set the mutation rate <i>multiplier</i> along the chromosome.<span class="Apple-converted-space">  </span>There are two ways to call this method.<span class="Apple-converted-space">  </span>If the optional </span><span class="s4">ends</span><span class="s3"> parameter is </span><span class="s4">NULL</span><span class="s3"> (the default), then </span><span class="s4">multipliers</span><span class="s3"> must be a singleton value that specifies a single multiplier to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s4">ends</span><span class="s3"> is supplied, then </span><span class="s4">multipliers</span><span class="s3"> and </span><span class="s4">ends</span><span class="s3"> must be the same length, and the values in </span><span class="s4">ends</span><span class="s3"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s4">multipliers</span><span class="s3"> and </span><span class="s4">ends</span><span class="s3"> taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s4">ends</span><span class="s3"> should extend to the end of the chromosome (as previously determined, during simulation initialization).<span class="Apple-converted-space">  </span>See the </span><span class="s4">initializeHotspotMap()</span><span class="s3"> function for further discussion of precisely how these multipliers and positions are interpreted.</span></p>
<p class="p6"><span class="s3">If the optional </span><span class="s4">sex</span><span class="s3"> parameter is </span><span class="s4">"*"</span><span class="s3"> (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s4">sex</span><span class="s3"> may be </span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3"> instead, in which case the supplied hotspot map is used only for that sex.<span class="Apple-converted-space">  </span>Note that whether sex-specific hotspot maps will be used is set by the way that the simulation is initially configured with </span><span class="s4">initializeHotspot()</span><span class="s3">, and cannot be changed with this method; so if the simulation was set up to use sex-specific hotspot maps then sex must be </span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3"> here, whereas if it was set up not to, then sex must be </span><span class="s4">"*"</span><span class="s3"> or unsupplied here.<span class="Apple-converted-space">  </span>If a simulation needs sex-specific hotspot maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.</span></p>
<p class="p6"><span class="s3">The hotspot map is normally constant in simulations, so be sure you know what you are doing.</span></p>
<p class="p3">– (void)setMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p4">Set the mutation rate per base position per <span class="s7">gamete</span>.<span class="Apple-converted-space">  </span>There are two ways to call this method.<span class="Apple-converted-space">  </span>If the optional <span class="s1">ends</span> parameter is <span class="s1">NULL</span> (the default), then <span class="s1">rates</span> must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, <span class="s1">ends</span> is supplied, then <span class="s1">rates</span> and <span class="s1">ends</span> must be the same length, and the values in <span class="s1">ends</span> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, <span class="s1">rates</span> and <span class="s1">ends</span> taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in <span class="s1">ends</span> should extend to the end of the chromosome (as previously determined, during simulation initialization).<span class="Apple-converted-space">  </span>See the <span class="s1">initializeMutationRate()</span> function for further discussion of precisely how these rates and positions are interpreted.</p>
<p class="p4">If the optional <span class="s1">sex</span> parameter is <span class="s1">"*"</span> (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations <span class="s1">sex</span> may be <span class="s1">"M"</span> or <span class="s1">"F"</span> instead, in which case the supplied mutation rate map is used only for that sex.<span class="Apple-converted-space">  </span>Note that whether sex-specific mutation rate maps will be used is set by the way that the simulation is initially configured with <span class="s1">initializeMutationRate()</span>, and cannot be changed with this method; so if the simulation was set up to use sex-specific mutation rate maps then sex must be <span class="s1">"M"</span> or <span class="s1">"F"</span> here, whereas if it was set up not to, then sex must be <span class="s1">"*"</span> or unsupplied here.<span class="Apple-converted-space">  </span>If a simulation needs sex-specific mutation rate maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.</p>
<p class="p4">The mutation rate intervals are normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p6"><span class="s3">In nucleotide-based models, </span><span class="s4">setMutationRate()</span><span class="s3"> may not be called.<span class="Apple-converted-space">  </span>If variation in the mutation rate along the chromosome is desired, </span><span class="s4">setHotspotMap()</span><span class="s3"> should be used.</span></p>
<p class="p3">– (void)setRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p4">Set the recombination rate per base position per <span class="s7">gamete</span>.<span class="Apple-converted-space">  </span><span class="s7">All rates must be in the interval [</span><span class="s8">0.0</span><span class="s7">, </span><span class="s8">0.5</span><span class="s7">].<span class="Apple-converted-space">  </span></span>There are two ways to call this method.<span class="Apple-converted-space">  </span>If the optional <span class="s1">ends</span> parameter is <span class="s1">NULL</span> (the default), then <span class="s1">rates</span> must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, <span class="s1">ends</span> is supplied, then <span class="s1">rates</span> and <span class="s1">ends</span> must be the same length, and the values in <span class="s1">ends</span> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, <span class="s1">rates</span> and <span class="s1">ends</span> taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in <span class="s1">ends</span> should extend to the end of the chromosome (as previously determined, during simulation initialization).<span class="Apple-converted-space">  </span>See the <span class="s1">initializeRecombinationRate()</span> function for further discussion of precisely how these rates and positions are interpreted.</p>
<p class="p4">If the optional <span class="s1">sex</span> parameter is <span class="s1">"*"</span> (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations <span class="s1">sex</span> may be <span class="s1">"M"</span> or <span class="s1">"F"</span> instead, in which case the supplied recombination map is used only for that sex.<span class="Apple-converted-space">  </span>Note that whether sex-specific recombination maps will be used is set by the way that the simulation is initially configured with <span class="s1">initializeRecombinationRate()</span>, and cannot be changed with this method; so if the simulation was set up to use sex-specific recombination maps then sex must be <span class="s1">"M"</span> or <span class="s1">"F"</span> here, whereas if it was set up not to, then sex must be <span class="s1">"*"</span> or unsupplied here.<span class="Apple-converted-space">  </span>If a simulation needs sex-specific recombination maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.</p>
<p class="p4">The recombination intervals are normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p1"><b>5.3<span class="Apple-converted-space">  </span>Class Community</b></p>
<p class="p2"><i>5.3.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Community</i></span><i> properties</i></p>
<p class="p5">allGenomicElementTypes =&gt; (object&lt;GenomicElementType&gt;)</p>
<p class="p6">All of the <span class="s1">GenomicElementType</span> objects defined in the simulation.<span class="Apple-converted-space">  </span>These are guaranteed to be in sorted order, by their <span class="s1">id</span> property.</p>
<p class="p5">allInteractionTypes =&gt; (object&lt;InteractionType&gt;)</p>
<p class="p6">All of the <span class="s1">InteractionType</span> objects defined in the simulation.<span class="Apple-converted-space">  </span>These are guaranteed to be in sorted order, by their <span class="s1">id</span> property.</p>
<p class="p5">allMutationTypes =&gt; (object&lt;MutationType&gt;)</p>
<p class="p6">All of the <span class="s1">MutationType</span> objects defined in the simulation.<span class="Apple-converted-space">  </span>These are guaranteed to be in sorted order, by their <span class="s1">id</span> property.</p>
<p class="p5">allScriptBlocks =&gt; (object&lt;SLiMEidosBlock&gt;)</p>
<p class="p6">All registered <span class="s1">SLiMEidosBlock</span> objects in the simulation.<span class="Apple-converted-space">  </span>These are guaranteed to be in sorted order, by their <span class="s1">id</span> property.</p>
<p class="p5">allSpecies =&gt; (object&lt;Species&gt;)</p>
<p class="p6">All of the <span class="s1">Species</span> objects defined in the simulation (in species declaration order).</p>
<p class="p5">allSubpopulations =&gt; (object&lt;Subpopulation&gt;)</p>
<p class="p6">All of the <span class="s1">Subpopulation</span> objects defined in the simulation.</p>
<p class="p5">cycleStage =&gt; (string$)</p>
<p class="p6">The current cycle stage, as a <span class="s1">string</span>.<span class="Apple-converted-space">  </span>The values of this property essentially mirror the cycle stages of WF and nonWF models.<span class="Apple-converted-space">  </span>Common values include <span class="s1">"first"</span> (during execution of <span class="s1">first()</span> events), <span class="s1">"early"</span> (during execution of <span class="s1">early()</span> events), <span class="s1">"reproduction"</span> (during offspring generation), <span class="s1">"fitness"</span> (during fitness evaluation), <span class="s1">"survival"</span> (while applying selection and mortality in nonWF models), and <span class="s1">"late"</span> (during execution of <span class="s1">late()</span> events).</p>
<p class="p6">Other possible values include <span class="s1">"begin"</span> (during internal setup before each cycle), <span class="s1">"tally"</span> (while tallying mutation reference counts and removing fixed mutations), <span class="s1">"swap"</span> (while swapping the offspring generation into the parental generation in WF models), <span class="s1">"end"</span> (during internal bookkeeping after each cycle), and <span class="s1">"console"</span> (during the in-between-ticks state in which commands in SLiMgui’s Eidos console are executed).<span class="Apple-converted-space">  </span>It would probably be a good idea not to use this latter set of values; they are probably not user-visible during ordinary model execution anyway.</p>
<p class="p6">During execution of <span class="s1">initialize()</span> callbacks, no <span class="s1">Community</span> object yet exists and so this property cannot be accessed.<span class="Apple-converted-space">  </span>To detect this state, use <span class="s1">exists("community")</span>; if that is <span class="s1">F</span>, <span class="s1">community</span> does not exist, and therefore your code is executing during <span class="s1">initialize()</span> callbacks (or outside of SLiM entirely, in some other Eidos-based context).</p>
<p class="p5">logFiles =&gt; (object&lt;LogFile&gt;)</p>
<p class="p6">The <span class="s1">LogFile</span> objects being used in the simulation.</p>
<p class="p3">modelType =&gt; (string$)</p>
<p class="p6"><span class="s3">The type of model being simulated, as specified in </span><span class="s4">initializeSLiMModelType()</span><span class="s3">.<span class="Apple-converted-space">  </span>This will be </span><span class="s4">"WF"</span><span class="s3"> for WF models (Wright-Fisher models, the default), or </span><span class="s4">"nonWF"</span><span class="s3"> for nonWF models (non-Wright-Fisher models).</span><span class="Apple-converted-space">  </span>This must be the same for all species in the community; it is therefore a property on <span class="s1">Community</span>, not <span class="s1">Species</span>.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to the simulation.</p>
<p class="p3">tick &lt;–&gt; (integer$)</p>
<p class="p4">The current tick number.</p>
<p class="p5">verbosity &lt;–&gt; (integer$)</p>
<p class="p6">The verbosity level, for SLiM’s logging of information about the simulation.<span class="Apple-converted-space">  </span>This is <span class="s1">1</span> by default, but can be changed at the command line with the <span class="s1">-l[ong]</span> option.<span class="Apple-converted-space">  </span>It is provided here so that scripts can consult it to govern the level of verbosity of their own output, or set the verbosity level for particular sections of their code.<span class="Apple-converted-space">  </span>A verbosity level of 0 suppresses most of SLiM’s optional output; 2 adds some extra output beyond SLiM’s standard output.</p>
<p class="p2"><i>5.3.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Community</i></span><i> methods</i></p>
<p class="p5">– (object&lt;LogFile&gt;$)createLogFile(string$ filePath, [Ns initialContents = NULL], [logical$ append = F], [logical$ compress = F], [string$ sep = ","], [Ni$ logInterval = NULL], [Ni$ flushInterval = NULL], [logical$ header = T])</p>
<p class="p6">Creates and returns a new <span class="s1">LogFile</span> object that logs data from the simulation (see the documentation for the <span class="s1">LogFile</span> class for details).<span class="Apple-converted-space">  </span>Logged data will be written to the file at <span class="s1">filePath</span>, overwriting any existing file at that path by default, or appending to it instead if <span class="s1">append</span> is <span class="s1">T</span> (successive rows of the log table will always be appended to the previously written content, of course).<span class="Apple-converted-space">  </span>Before the header line for the log is written out, any <span class="s1">string</span> elements in <span class="s1">initialContents</span> will be written first, separated by newlines, allowing for a user-defined file header.<span class="Apple-converted-space">  </span>If <span class="s1">compress</span> is <span class="s1">T</span>, the contents will be compressed with <span class="s1">zlib</span> as they are written, and the standard <span class="s1">.gz</span> extension for gzip-compressed files will be appended to the filename in <span class="s1">filePath</span> if it is not already present.</p>
<p class="p6">The <span class="s1">sep</span> parameter specifies the separator between data values within a row.<span class="Apple-converted-space">  </span>The default of <span class="s1">","</span> will generate a “comma-separated value” (CSV) file, while passing <span class="s1">sep="\t"</span> will use a tab separator instead to generate a “tab-separated value” (TSV) file.<span class="Apple-converted-space">  </span>Other values for <span class="s1">sep</span> may also be used, but are less standard.</p>
<p class="p6">LogTable supports periodic automatic logging of a new row of data, enabled by supplying a non-<span class="s1">NULL</span> value for <span class="s1">logInterval</span>.<span class="Apple-converted-space">  </span>In this case, a new row will be logged (as if <span class="s1">logRow()</span> were called on the <span class="s1">LogFile</span>) at the end of every <span class="s1">logInterval</span> ticks (just before the tick counter increments, in both WF and nonWF models), starting at the end of the tick in which the <span class="s1">LogFile</span> was created.<span class="Apple-converted-space">  </span>A <span class="s1">logInterval</span> of <span class="s1">1</span> will cause automatic logging at the end of every tick, whereas a <span class="s1">logInterval</span> of <span class="s1">NULL</span> disables automatic logging.<span class="Apple-converted-space">  </span>Automatic logging can always be disabled or reconfigured later with the <span class="s1">LogFile</span> method <span class="s1">setLogInterval()</span>, or logging can be triggered manually by calling <span class="s1">logRow()</span>.</p>
<p class="p6">When compression is enabled, <span class="s1">LogFile</span> flushes new data lazily by default, for performance reasons, buffering data for multiple rows before writing to disk.<span class="Apple-converted-space">  </span>Passing a non-<span class="s1">NULL</span> value for <span class="s1">flushInterval</span> requests a flush every <span class="s1">flushInterval</span> rows (with a value of <span class="s1">1</span> providing unbuffered operation).<span class="Apple-converted-space">  </span>Note that flushing very frequently will likely result in both lower performance and a larger final file size (in one simple test, <span class="s1">48943</span> bytes instead of <span class="s1">4280</span> bytes, or more than a 10× increase in size).<span class="Apple-converted-space">  </span>Alternatively, passing a very large value for <span class="s1">flushInterval</span> will effectively disable automatic flushing, except at the end of the simulation (but be aware that this may use a large amount of memory for large log files).<span class="Apple-converted-space">  </span>In any case, the log file will be created immediately, with its requested initial contents; the initial write is not buffered.<span class="Apple-converted-space">  </span>When compression is not enabled, the <span class="s1">flushInterval</span> setting is ignored.</p>
<p class="p6">The <span class="s1">header</span> parameter controls whether a header line is written out at the beginning of logging.<span class="Apple-converted-space">  </span>If it is <span class="s1">T</span> (the default), a header line is written out; if <span class="s1">F</span>, no header is written.<span class="Apple-converted-space">  </span>Suppressing the header output can be useful if you are using <span class="s1">LogFile</span> to append data to an existing file that already has a header line.</p>
<p class="p6">The <span class="s1">LogFile</span> documentation discusses how to configure and use <span class="s1">LogFile</span> to write out the data you are interested in from your simulation.</p>
<p class="p5">– (integer$)estimatedLastTick(void)</p>
<p class="p6">Returns SLiM’s current estimate of the last tick in which the model will execute.<span class="Apple-converted-space">  </span>Because script blocks can be added, removed, and rescheduled, and because the simulation may end prematurely (due to a call to <span class="s1">simulationFinished()</span>, for example), this is only an estimate, and may change over time.</p>
<p class="p3">– (void)deregisterScriptBlock(io&lt;SLiMEidosBlock&gt; scriptBlocks)</p>
<p class="p4">All <span class="s1">SLiMEidosBlock</span> objects specified by <span class="s1">scriptBlocks</span> (either with <span class="s1">SLiMEidosBlock</span> objects or with <span class="s1">integer</span> identifiers) will be scheduled for deregistration.<span class="Apple-converted-space">  </span>The deregistered blocks remain valid, and may even still be executed in the current stage of the current tick; the blocks are not actually deregistered and deallocated until sometime after the currently executing script block has completed.<span class="Apple-converted-space">  </span>To immediately prevent a script block from executing, even when it is scheduled to execute in the current stage of the current tick, use the <span class="s1">active</span> property of the script block.</p>
<p class="p5">– (object&lt;GenomicElementType&gt;)genomicElementTypesWithIDs(integer ids)</p>
<p class="p6">Find and return the <span class="s1">GenomicElementType</span> objects with <span class="s1">id</span> values matching the values in <span class="s1">ids</span>.<span class="Apple-converted-space">  </span>If no matching <span class="s1">GenomicElementType</span> object can be found with a given <span class="s1">id</span>, an error results.</p>
<p class="p5">– (object&lt;InteractionType&gt;)interactionTypesWithIDs(integer ids)</p>
<p class="p6">Find and return the <span class="s1">InteractionType</span> objects with <span class="s1">id</span> values matching the values in <span class="s1">ids</span>.<span class="Apple-converted-space">  </span>If no matching <span class="s1">InteractionType</span> object can be found with a given <span class="s1">id</span>, an error results.</p>
<p class="p5">– (object&lt;MutationType&gt;)mutationTypesWithIDs(integer ids)</p>
<p class="p6">Find and return the <span class="s1">MutationType</span> objects with <span class="s1">id</span> values matching the values in <span class="s1">ids</span>.<span class="Apple-converted-space">  </span>If no matching <span class="s1">MutationType</span> object can be found with a given <span class="s1">id</span>, an error results.</p>
<p class="p5"><span class="s3">– (void)outputUsage(void)</span></p>
<p class="p6">Output the current memory usage of the simulation to Eidos’s output stream.<span class="Apple-converted-space">  </span>The specifics of what is printed, and in what format, should not be relied upon as they may change from version to version of SLiM.<span class="Apple-converted-space">  </span>This method is primarily useful for understanding where the memory usage of a simulation predominantly resides, for debugging or optimization.<span class="Apple-converted-space">  </span>Note that it does not capture <i>all</i> memory usage by the process; rather, it summarizes the memory usage by SLiM and Eidos in directly allocated objects and buffers.<span class="Apple-converted-space">  </span>To get the same memory usage reported by <span class="s1">outputUsage()</span>, but as a <span class="s1">float$</span> value, use the <span class="s1">Community</span> method <span class="s1">usage()</span>.<span class="Apple-converted-space">  </span>To get the <i>total</i> memory usage of the running process (either current or peak), use the Eidos function <span class="s1">usage()</span>.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerEarlyEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL]<span class="s5">, [No&lt;Species&gt;$ ticksSpec = NULL]</span>)</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">early()</span> event in the current simulation, with optional <span class="s1">start</span> and <span class="s1">end</span> ticks<span class="s5"> (and, for multispecies models, optional ticks specifier </span><span class="s6">ticksSpec</span><span class="s5">)</span> limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered event is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p5">– (object&lt;SLiMEidosBlock&gt;$)registerFirstEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL], [No&lt;Species&gt;$ ticksSpec = NULL])</p>
<p class="p6">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">first()</span> event in the current simulation, with optional <span class="s1">start</span> and <span class="s1">end</span> ticks (and, for multispecies models, optional ticks specifier <span class="s1">ticksSpec</span>) limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered event is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerInteractionCallback(Nis$ id, string$ source, io&lt;InteractionType&gt;$ intType, [Nio&lt;Subpopulation&gt;$ subpop<span class="s9"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">interaction()</span> callback in the current simulation<span class="s5"> (global to the community)</span>, with a required interaction type <span class="s1">intType</span> (which may be an <span class="s1">integer</span> identifier), optional exerter subpopulation <span class="s1">subpop</span> (which may also be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations), and optional <span class="s1">start</span> and <span class="s1">end</span> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it will be eligible to execute the next time an <span class="s1">InteractionType</span> is evaluated.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerLateEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL]<span class="s5">, [No&lt;Species&gt;$ ticksSpec = NULL]</span>)</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">late()</span> event in the current simulation, with optional <span class="s1">start</span> and <span class="s1">end</span> ticks<span class="s5"> (and, for multispecies models, optional ticks specifier </span><span class="s6">ticksSpec</span><span class="s5">)</span> limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered event is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p5">– (object&lt;SLiMEidosBlock&gt;$)rescheduleScriptBlock(io&lt;SLiMEidosBlock&gt;$ block, [Ni$ start = NULL], [Ni$ end = NULL], [Ni ticks = NULL])</p>
<p class="p6">Reschedule the target script block given by <span class="s1">block</span> to execute in a specified set of ticks.<span class="Apple-converted-space">  </span>The <span class="s1">block</span> parameter may be either an <span class="s1">integer</span> representing the ID of the desired script block, or a <span class="s1">SLiMScriptBlock</span> specified directly.<span class="Apple-converted-space">  </span>The target script block, <span class="s1">block</span>, is returned.</p>
<p class="p6">The first way to specify the tick set is with <span class="s1">start</span> and <span class="s1">end</span> parameter values; <span class="s1">block</span> will then execute from <span class="s1">start</span> to <span class="s1">end</span>, inclusive.</p>
<p class="p6">The second way to specify the tick set is using the <span class="s1">ticks</span> parameter, specifying each tick in which the block should execute.<span class="Apple-converted-space">  </span>The vector supplied for <span class="s1">ticks</span> does not need to be in sorted order, but it must not contain any duplicates.</p>
<p class="p6">It can sometimes be better to handle script block scheduling in other ways.<span class="Apple-converted-space">  </span>If an <span class="s1">early()</span> event needs to execute every tenth tick over the whole duration of a long model run, for example, it might not be advisable to use a call like <span class="s1">community.rescheduleScriptBlock(s1, ticks=seq(10, 100000, 10))</span> for that purpose, since that would make things complicated for SLiM’s scheduler.<span class="Apple-converted-space">  </span>Instead, it might be preferable to add a test such as <span class="s1">if (community.tick % 10 != 0) return;</span> at the beginning of the event.<span class="Apple-converted-space">  </span>It is legal to reschedule a script block while the block is executing; a call like <span class="s1">community.rescheduleScriptBlock(self, community.tick + 10, community.tick + 10);</span> made inside a given block would therefore also cause the block to execute every tenth tick, although this sort of self-rescheduling code is probably harder to read, maintain, and debug.</p>
<p class="p6">Whichever way of specifying the tick set is used, <span class="s1">block</span> may continue to be executed during the current tick cycle stage even after it has been rescheduled, unless it is made inactive using its <span class="s1">active</span> property, and similarly, the block may not execute during the current tick cycle stage if it was not already scheduled to do so.<span class="Apple-converted-space">  </span>Rescheduling script blocks during the tick and tick cycle stage in which they are executing, or in which they are intended to execute, should be avoided.<span class="Apple-converted-space">  </span>Also, note that script blocks which are open-ended (i.e., with no specified end tick), are not used in determining whether the end of the simulation has been reached (because then the simulation would run forever).</p>
<p class="p6">Note that new script blocks can also be created and scheduled using the <span class="s1">register...()</span> methods of <span class="s1">Community</span> and <span class="s1">Species</span>; by using the same source as a template script block, the template can be duplicated and scheduled for different ticks, perhaps with modifications or variations.<span class="Apple-converted-space">  </span>In multispecies models, note that blocks may not run due to their <span class="s1">species</span> or <span class="s1">ticks</span> specifier, even in ticks in which they are scheduled to run.</p>
<p class="p5">– (object&lt;SLiMEidosBlock&gt;)scriptBlocksWithIDs(integer ids)</p>
<p class="p6">Find and return the <span class="s1">SLiMEidosBlock</span> objects with <span class="s1">id</span> values matching the values in <span class="s1">ids</span>.<span class="Apple-converted-space">  </span>If no matching <span class="s1">SLiMEidosBlock</span> object can be found with a given <span class="s1">id</span>, an error results.</p>
<p class="p3">– (void)simulationFinished(void)</p>
<p class="p4">Declare the current simulation finished.<span class="Apple-converted-space">  </span>Normally SLiM ends a simulation when, at the end of a tick, there are no script events or callbacks registered for any future tick (excluding scripts with no declared end tick).<span class="Apple-converted-space">  </span>If you wish to end a simulation before this condition is met, a call to <span class="s1">simulationFinished()</span> will cause the current simulation to end at the end of the current tick.<span class="Apple-converted-space">  </span>For example, a simulation might self-terminate if a test for a dynamic equilibrium condition is satisfied.<span class="Apple-converted-space">  </span>Note that the current tick will finish executing; if you want the simulation to stop immediately, you can use the Eidos method <span class="s1">stop()</span>, which raises an error condition.</p>
<p class="p5">– (object&lt;Species&gt;)speciesWithIDs(integer ids)</p>
<p class="p6">Find and return the <span class="s1">Species</span> objects with <span class="s1">id</span> values matching the values in <span class="s1">ids</span>.<span class="Apple-converted-space">  </span>If no matching <span class="s1">Species</span> object can be found with a given <span class="s1">id</span>, an error results.</p>
<p class="p5">– (object&lt;Subpopulation&gt;)subpopulationsWithIDs(integer ids)</p>
<p class="p6">Find and return the <span class="s1">Subpopulation</span> objects with <span class="s1">id</span> values matching the values in <span class="s1">ids</span>.<span class="Apple-converted-space">  </span>If no matching <span class="s1">Subpopulation</span> object can be found with a given <span class="s1">id</span>, an error results.</p>
<p class="p5">– (object&lt;Subpopulation&gt;)subpopulationsWithNames(string names)</p>
<p class="p6">Find and return the <span class="s1">Subpopulation</span> objects with <span class="s1">name</span> values matching the values in <span class="s1">names</span>.<span class="Apple-converted-space">  </span>If no matching <span class="s1">Subpopulation</span> object can be found with a given name, an error results.</p>
<p class="p5">– (float$)usage(void)</p>
<p class="p6">Return the current memory usage of the simulation.<span class="Apple-converted-space">  </span>The specifics of what is totalled up should not be relied upon as it may change from version to version of SLiM.<span class="Apple-converted-space">  </span>This method is primarily useful for understanding where the memory usage of a simulation predominantly resides, for debugging or optimization.<span class="Apple-converted-space">  </span>Note that it does not capture <i>all</i> memory usage by the process; rather, it summarizes the memory usage by SLiM and Eidos in directly allocated objects and buffers.<span class="Apple-converted-space">  </span>To see details of this internal memory usage, use the <span class="s1">Community</span> method <span class="s1">outputUsage()</span>.<span class="Apple-converted-space">  </span>To get the <i>total</i> memory usage of the running process (either current or peak), use the Eidos function <span class="s1">usage()</span>.</p>
<p class="p1"><b>5.4<span class="Apple-converted-space">  </span>Class Haplosome</b></p>
<p class="p2"><i>5.4.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Haplosome</i></span><i> properties</i></p>
<p class="p5">chromosome =&gt; (object&lt;Chromosome&gt;$)</p>
<p class="p6">The <span class="s1">Chromosome</span> object which this haplosome represents; for example, if this haplosome represents the X sex chromosome in a particular individual, then this property provides the <span class="s1">Chromosome</span> object that defines the genetic structure of the X sex chromosome in that individual’s species.</p>
<p class="p5">chromosomeSubposition =&gt; (integer$)</p>
<p class="p6">The position index of the haplosome, within the set of haplosomes associated with the <span class="s1">Chromosome</span> object which this haplosome represents.<span class="Apple-converted-space">  </span>For example, if an individual in a multi-chromosome model has two haplosomes that represent a given chromosome within its <span class="s1">haplosomes</span> vector, the first of those haplosomes will have a <span class="s1">chromosomeSubposition</span> value of <span class="s1">0</span>, the second will have a <span class="s1">chromosomeSubposition</span> value of <span class="s1">1</span>.<span class="Apple-converted-space">  </span>For an intrinsically diploid chromosome in individuals generated by a standard biparental cross, the first haplosome (at subposition <span class="s1">0</span>) came from its first parent (the female parent, in sexual models), and the second haplosome (at subposition <span class="s1">1</span>) came from its second parent (the male parent, in sexual models).</p>
<p class="p5"><span class="s3">haplosomePedigreeID =&gt; (integer$)</span></p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">haplosomePedigreeID</span> is a “semi-unique” non-negative identifier for each haplosome in a simulation, never re-used throughout the duration of the simulation run.<span class="Apple-converted-space">  </span>The <span class="s1">haplosomePedigreeID</span> of a given haplosome will be equal to either <span class="s1">(2*pedigreeID)</span> or <span class="s1">(2*pedigreeID + 1)</span> of the individual that the haplosome belongs to (the former for a first haplosome of the individual, the latter for a second haplosome of the individual if one exists); this invariant relationship is guaranteed.</p>
<p class="p6">This value is “semi-unique” in the sense that it is shared by <i>all</i> of the first haplosomes of an individual, or by <i>all</i> of the second haplosomes of an individual.<span class="Apple-converted-space">  </span>In a single-chromosome model, a given individual will have just one first haplosome, and perhaps (depending on the chromosome type) one second haplosome, and so the value of <span class="s1">haplosomePedigreeID</span> for each of those haplosomes will be truly unique.<span class="Apple-converted-space">  </span>In a multi-chromosome model, however, an individual has a first haplosome for each chromosome, and perhaps (depending on the chromosome types) a second haplosome for each chromosome.<span class="Apple-converted-space">  </span>In that case, the value of <span class="s1">haplosomePedigreeID</span> is unique in the sense that it is different for each individual, but it is <i>not</i> unique in the sense that it will be shared by other haplosomes within the same individual – shared by all the first haplosomes, or shared by all the second haplosomes.<span class="Apple-converted-space">  </span>This “semi-uniqueness” is intentional; it allows <span class="s1">haplosomePedigreeID</span> to be used as a “key” that associates the haplosomes of an individual across disparate datasets, such as across the different tree sequences for each chromosome that are produced by tree-sequence recording in a multi-chromosome model.<span class="Apple-converted-space">  </span>See sections 1.5.1 and 8.3 for further discussion of multi-chromosome models.</p>
<p class="p6">If pedigree tracking is not enabled, this property is unavailable.</p>
<p class="p5"><span class="s3">individual =&gt; (object&lt;Individual&gt;$)</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">Individual</span><span class="s3"> object to which this haplosome belongs.</span></p>
<p class="p3">isNullHaplosome =&gt; (logical$)</p>
<p class="p6"><span class="s1">T</span> if the haplosome is a “null” haplosome, <span class="s1">F</span> if it is an ordinary haplosome object.<span class="Apple-converted-space">  </span>Null haplosomes are used as placeholders when a real haplosome doesn’t exist in a particular slot, allowing SLiM’s code to operate in the same way across a wide variety of genomic configurations.<span class="Apple-converted-space">  </span>For example, when simulating chromosome type <span class="s1">"X"</span> (an X chromosome), the second haplosome for that chromosome in males will be a null haplosome, preserving a constant number of haplosomes for all individuals even though males have one X while females have two.<span class="Apple-converted-space">  </span>Null haplosomes should not be accessed or manipulated.</p>
<p class="p3">mutations =&gt; (object&lt;Mutation&gt;)</p>
<p class="p4">All of the <span class="s1">Mutation</span> objects present in this haplosome.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p6">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>Note that the <span class="s1">Haplosome</span> objects used by SLiM are new with every new individual, so the <span class="s1">tag</span> value of each new offspring haplosome generated in each tick will be initially undefined.</p>
<p class="p2"><i>5.4.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Haplosome</i></span><i> methods</i></p>
<p class="p3">+ (void)addMutations(object&lt;Mutation&gt; mutations)</p>
<p class="p6">Add the existing mutations in <span class="s1">mutations</span> to the target haplosomes, if they are not already present (if they are already present, they will be ignored), and if the addition is not prevented by the mutation stacking policy (see the <span class="s1">mutationStackPolicy</span> property of <span class="s1">MutationType</span>).<span class="Apple-converted-space">  </span>All target haplosomes and all mutations in <span class="s1">mutations</span> must be associated with the same <span class="s1">Chromosome</span> object; attempting to add a mutation to a haplosome associated with a different chromosome will raise an error.</p>
<p class="p6">Calling this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the <span class="s1">Species</span> method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6">Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the <span class="s1">age</span> of the individual is greater than <span class="s1">0</span>), to prevent the possibility of inconsistencies in the recorded tree sequence.</p>
<p class="p3">+ (object&lt;Mutation&gt;)addNewDrawnMutation(io&lt;MutationType&gt; mutationType, integer position, [Nio&lt;Subpopulation&gt; originSubpop = NULL]<span class="s7">, [Nis nucleotide = NULL]</span>)</p>
<p class="p6">Add new mutations to the target haplosomes with the specified <span class="s1">mutationType</span> (specified by the <span class="s1">MutationType</span> object or by <span class="s1">integer</span> identifier), <span class="s1">position</span>, <span class="s1">originTick</span> (which may be <span class="s1">NULL</span>, the default, to specify the current tick; otherwise, beginning in SLiM 3.5, it must be equal to the current tick anyway, as other uses of this property have been deprecated), and <span class="s1">originSubpop</span> (specified by the <span class="s1">Subpopulation</span> object or by <span class="s1">integer</span> identifier, or by <span class="s1">NULL</span>, the default, to specify the subpopulation to which the first target haplosome belongs).<span class="Apple-converted-space">  </span>If <span class="s1">originSubpop</span> is supplied as an <span class="s1">integer</span>, it is intentionally not checked for validity; you may use arbitrary values of <span class="s1">originSubpop</span> to “tag” the mutations that you create.<span class="Apple-converted-space">  </span>The selection coefficients of the mutations are drawn from their mutation types; <span class="s1">addNewMutation()</span> may be used instead if you wish to specify selection coefficients.<span class="Apple-converted-space">  </span>All of the target haplosomes must be associated with the same <span class="s1">Chromosome</span> object, since each new mutation is added to all of the target haplosomes.</p>
<p class="p6"><span class="s3">In non-nucleotide-based models, </span><span class="s4">mutationType</span><span class="s3"> will always be a non-nucleotide-based mutation type, and so </span><span class="s4">nucleotide</span><span class="s3"> must be </span><span class="s4">NULL</span><span class="s3"> (the default).<span class="Apple-converted-space">  </span>In a nucleotide-based model, </span><span class="s4">mutationType</span><span class="s3"> might still be non-nucleotide-based (in which case </span><span class="s4">nucleotide</span><span class="s3"> must still be </span><span class="s4">NULL</span><span class="s3">), or </span><span class="s4">mutationType</span><span class="s3"> might be nucleotide-based, in which case a non-</span><span class="s4">NULL</span><span class="s3"> value must be supplied for </span><span class="s4">nucleotide</span><span class="s3">, specifying the nucleotide(s) to be associated with the new mutation(s).<span class="Apple-converted-space">  </span>Nucleotides may be specified with string values (</span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">), or with integer values (A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3">).<span class="Apple-converted-space">  </span>If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.<span class="Apple-converted-space">  </span>No check is performed that a new mutation’s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model.</span></p>
<p class="p4">Beginning in SLiM 2.5 this method is vectorized, so all of these parameters may be singletons (in which case that single value is used for all mutations created by the call) or non-singleton vectors (in which case one element is used for each corresponding mutation created).<span class="Apple-converted-space">  </span>Non-singleton parameters must match in length, since their elements need to be matched up one-to-one.</p>
<p class="p4">The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the <span class="s1">mutationStackPolicy</span> property of <span class="s1">MutationType</span>).<span class="Apple-converted-space">  </span>However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the <span class="s1">position</span> parameter is specified in ascending order.<span class="Apple-converted-space">  </span>In other words, pre-sorting the parameters to this method into ascending order by position, using <span class="s1">order()</span> and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.</p>
<p class="p4">Beginning in SLiM 2.1, this is a class method, not an instance method.<span class="Apple-converted-space">  </span>This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation objects to all of the elements of the receiver.<span class="Apple-converted-space">  </span>Before SLiM 2.1, to add the same mutations to multiple haplosomes, it was necessary to call <span class="s1">addNewDrawnMutation()</span> on one of the haplosomes, and then add the returned <span class="s1">Mutation</span> object to all of the other haplosomes using <span class="s1">addMutations()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).<span class="Apple-converted-space">  </span>Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).</p>
<p class="p7">Before SLiM 4, this method also took a <span class="s1">originGeneration</span> parameter.<span class="Apple-converted-space">  </span>This was deprecated (the origin generation was then required to be equal to the current generation, for internal consistency), and was removed in SLiM 4.</p>
<p class="p4">Calling this will normally affect the fitness values calculated at the end of the current tick (but not sooner); if you want current fitness values to be affected, you can call the <span class="s1">Species</span> method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6">Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the <span class="s1">age</span> of the individual is greater than <span class="s1">0</span>), to prevent the possibility of inconsistencies in the recorded tree sequence.</p>
<p class="p3">+ (object&lt;Mutation&gt;)addNewMutation(io&lt;MutationType&gt; mutationType, numeric selectionCoeff, integer position, [Nio&lt;Subpopulation&gt; originSubpop = NULL]<span class="s7">, [Nis nucleotide = NULL]</span>)</p>
<p class="p6">Add new mutations to the target haplosomes with the specified <span class="s1">mutationType</span> (specified by the <span class="s1">MutationType</span> object or by <span class="s1">integer</span> identifier), <span class="s1">selectionCoeff</span>, <span class="s1">position</span>, <span class="s1">originTick</span> (which may be <span class="s1">NULL</span>, the default, to specify the current tick; otherwise, beginning in SLiM 3.5, it must be equal to the current tick anyway, as other uses of this property have been deprecated), and <span class="s1">originSubpop</span> (specified by the <span class="s1">Subpopulation</span> object or by <span class="s1">integer</span> identifier, or by <span class="s1">NULL</span>, the default, to specify the subpopulation to which the first target haplosome belongs).<span class="Apple-converted-space">  </span>If <span class="s1">originSubpop</span> is supplied as an <span class="s1">integer</span>, it is intentionally not checked for validity; you may use arbitrary values of <span class="s1">originSubpop</span> to “tag” the mutations that you create.<span class="Apple-converted-space">  </span>The <span class="s1">addNewDrawnMutation()</span> method may be used instead if you wish selection coefficients to be drawn from the mutation types of the mutations.<span class="Apple-converted-space">  </span>All of the target haplosomes must be associated with the same <span class="s1">Chromosome</span> object, since each new mutation is added to all of the target haplosomes.</p>
<p class="p6"><span class="s3">In non-nucleotide-based models, </span><span class="s4">mutationType</span><span class="s3"> will always be a non-nucleotide-based mutation type, and so </span><span class="s4">nucleotide</span><span class="s3"> must be </span><span class="s4">NULL</span><span class="s3"> (the default).<span class="Apple-converted-space">  </span>In a nucleotide-based model, </span><span class="s4">mutationType</span><span class="s3"> might still be non-nucleotide-based (in which case </span><span class="s4">nucleotide</span><span class="s3"> must still be </span><span class="s4">NULL</span><span class="s3">), or </span><span class="s4">mutationType</span><span class="s3"> might be nucleotide-based, in which case a non-</span><span class="s4">NULL</span><span class="s3"> value must be supplied for </span><span class="s4">nucleotide</span><span class="s3">, specifying the nucleotide(s) to be associated with the new mutation(s).<span class="Apple-converted-space">  </span>Nucleotides may be specified with string values (</span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">), or with integer values (A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3">).<span class="Apple-converted-space">  </span>If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.<span class="Apple-converted-space">  </span>No check is performed that a new mutation’s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model.</span></p>
<p class="p4">The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the <span class="s1">mutationStackPolicy</span> property of <span class="s1">MutationType</span>).<span class="Apple-converted-space">  </span>However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the <span class="s1">position</span> parameter is specified in ascending order.<span class="Apple-converted-space">  </span>In other words, pre-sorting the parameters to this method into ascending order by position, using <span class="s1">order()</span> and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.</p>
<p class="p4">Beginning in SLiM 2.1, this is a class method, not an instance method.<span class="Apple-converted-space">  </span>This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation object to all of the elements of the receiver.<span class="Apple-converted-space">  </span>Before SLiM 2.1, to add the same mutation to multiple haplosomes, it was necessary to call <span class="s1">addNewMutation()</span> on one of the haplosomes, and then add the returned <span class="s1">Mutation</span> object to all of the other haplosomes using <span class="s1">addMutations()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).<span class="Apple-converted-space">  </span>Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).</p>
<p class="p7">Before SLiM 4, this method also took a <span class="s1">originGeneration</span> parameter.<span class="Apple-converted-space">  </span>This was deprecated (the origin generation was then required to be equal to the current generation, for internal consistency), and was removed in SLiM 4.</p>
<p class="p4">Calling this will normally affect the fitness values calculated at the end of the current tick (but not sooner); if you want current fitness values to be affected, you can call the <span class="s1">Species</span> method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6">Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the <span class="s1">age</span> of the individual is greater than <span class="s1">0</span>), to prevent the possibility of inconsistencies in the recorded tree sequence.</p>
<p class="p3">–<span class="s9"> </span>(<span class="s7">Nlo&lt;Mutation&gt;$</span>)containsMarkerMutation(io&lt;MutationType&gt;$ mutType, integer$<span class="s9"> </span>position<span class="s7">, [logical$ returnMutation = F]</span>)</p>
<p class="p4">Returns <span class="s1">T</span> if the haplosome contains a mutation of type <span class="s1">mutType</span> at <span class="s1">position</span>, <span class="s1">F</span> otherwise<span class="s7"> (if </span><span class="s8">returnMutation</span><span class="s7"> has its default value of </span><span class="s8">F</span><span class="s7">; see below)</span>.<span class="Apple-converted-space">  </span>This method is, as its name suggests, intended for checking for “marker mutations”: mutations of a special mutation type that are not literally mutations in the usual sense, but instead are added in to particular haplosomes to mark them as possessing some property.<span class="Apple-converted-space">  </span>Marker mutations are not typically added by SLiM’s mutation-generating machinery; instead they are added explicitly with <span class="s1">addNewMutation()</span> or <span class="s1">addNewDrawnMutation()</span> at a known, constant position in the haplosome.<span class="Apple-converted-space">  </span>This method provides a check for whether a marker mutation of a given type exists in a particular haplosome; because the position to check is known in advance, that check can be done much faster than the equivalent check with <span class="s1">containsMutations()</span> or <span class="s1">countOfMutationsOfType()</span>, using a binary search of the haplosome.</p>
<p class="p6"><span class="s3">If </span><span class="s4">returnMutation</span><span class="s3"> is </span><span class="s4">T</span><span class="s3"> (an option added in SLiM 3), this method returns the actual mutation found, rather than just </span><span class="s4">T</span><span class="s3"> or </span><span class="s4">F</span><span class="s3">.<span class="Apple-converted-space">  </span>More specifically, the <i>first</i> mutation found of </span><span class="s4">mutType</span><span class="s3"> at </span><span class="s4">position</span><span class="s3"> will be returned; if more than one such mutation exists in the target haplosome, which one is returned is not defined.<span class="Apple-converted-space">  </span>If </span><span class="s4">returnMutation</span><span class="s3"> is T and no mutation of </span><span class="s4">mutType</span><span class="s3"> is found at </span><span class="s4">position</span><span class="s3">, </span><span class="s4">NULL</span><span class="s3"> will be returned.</span></p>
<p class="p3">– (logical)containsMutations(object&lt;Mutation&gt; mutations)</p>
<p class="p6">Returns a <span class="s1">logical</span> vector indicating whether each of the mutations in <span class="s1">mutations</span> is present in the target haplosome; each element in the returned vector indicates whether the corresponding mutation is present (<span class="s1">T</span>) or absent (<span class="s1">F</span>).<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p6">Note that the mutations must be associated with the same chromosome as the target haplosome, otherwise an error is raised.<span class="Apple-converted-space">  </span>The <span class="s1">containsMutations()</span> method of <span class="s1">Individual</span> does not have this restriction, since it checks for mutations across all of the haplosomes of the target individual.<span class="Apple-converted-space">  </span>This restriction is intended to find logic errors, since it seems to make little sense to check for a mutation in a haplosome for the wrong chromosome; but if this restriction proves inconvenient in common situations, it could be relaxed.</p>
<p class="p3">–<span class="s9"> </span>(integer$)countOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the number of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the haplosome.<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just a count, use <span class="s1">-mutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p5">+ (integer)mutationCountsInHaplosomes([No&lt;Mutation&gt; mutations = NULL])</p>
<p class="p6">Return an <span class="s1">integer</span> vector with the frequency counts of all of the <span class="s1">Mutation</span> objects passed in <span class="s1">mutations</span>, within the target <span class="s1">Haplosome</span> vector.<span class="Apple-converted-space">  </span>If the optional <span class="s1">mutations</span> argument is <span class="s1">NULL</span> (the default), frequency counts will be returned for all of the active <span class="s1">Mutation</span> objects in the species – the same <span class="s1">Mutation</span> objects, and in the same order, as would be returned by the <span class="s1">mutations</span> property of <span class="s1">sim</span>, in other words.</p>
<p class="p6">In multi-chromosome models, you might often wish to obtain counts only for mutations associated with one particular chromosome.<span class="Apple-converted-space">  </span>In that case, you would probably want to pass a vector of the mutations associated with that specific chromosome, as obtained from the <span class="s1">subsetMutations()</span> method of <span class="s1">Species</span>, rather than passing <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>(Passing <span class="s1">NULL</span> in that scenario would give you counts of <span class="s1">0</span> for all of the mutations associated with other chromosomes in the model.)</p>
<p class="p6">See the <span class="s1">+mutationFrequenciesInHaplosomes()</span> method to obtain <span class="s1">float</span> frequencies instead of <span class="s1">integer</span> counts.<span class="Apple-converted-space">  </span>See also the <span class="s1">Species</span> methods <span class="s1">mutationCounts()</span> and <span class="s1">mutationFrequencies()</span>, which might be more efficient for getting counts/frequencies for whole subpopulations or for the whole species.</p>
<p class="p5">+ (float)mutationFrequenciesInHaplosomes([No&lt;Mutation&gt; mutations = NULL])</p>
<p class="p6">Return a <span class="s1">float</span> vector with the frequencies of all of the <span class="s1">Mutation</span> objects passed in <span class="s1">mutations</span>, within the target <span class="s1">Haplosome</span> vector.<span class="Apple-converted-space">  </span>If the optional <span class="s1">mutations</span> argument is <span class="s1">NULL</span> (the default), frequencies will be returned for all of the active <span class="s1">Mutation</span> objects in the species – the same <span class="s1">Mutation</span> objects, and in the same order, as would be returned by the <span class="s1">mutations</span> property of <span class="s1">sim</span>, in other words.</p>
<p class="p6">In multi-chromosome models, the frequency of each mutation is assessed within the subset of target haplosomes that are associated with the same chromosome.<span class="Apple-converted-space">  </span>In other words, if a mutation is associated with chromosome 1, and the target haplosomes are associated with both chromosomes 1 and 2, the frequency of the mutation will be calculated only within the haplosomes for chromosome 1 (as you would expect).<span class="Apple-converted-space">  </span>However, you might often wish to obtain frequencies only for mutations associated with one particular chromosome.<span class="Apple-converted-space">  </span>In that case, you would probably want to pass a vector of the mutations associated with that specific chromosome, as obtained from the <span class="s1">subsetMutations()</span> method of <span class="s1">Species</span>, rather than passing <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>(Passing <span class="s1">NULL</span> in that scenario would give you frequencies of <span class="s1">0</span> for all of the mutations associated with other chromosomes in the model.)</p>
<p class="p6">See the <span class="s1">+mutationCountsInHaplosomes()</span> method to obtain <span class="s1">integer</span> counts instead of <span class="s1">float</span> frequencies.<span class="Apple-converted-space">  </span>See also the <span class="s1">Species</span> methods <span class="s1">mutationCounts()</span> and <span class="s1">mutationFrequencies()</span>, which might be more efficient for getting counts/frequencies for whole subpopulations or for the whole species.</p>
<p class="p3">–<span class="s9"> </span>(object&lt;Mutation&gt;)mutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns an <span class="s1">object</span> vector of all the mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the haplosome.<span class="Apple-converted-space">  </span>If you just need a count of the matching <span class="s1">Mutation</span> objects, rather than a vector of the matches, use <span class="s1">-countOfMutationsOfType()</span>; if you need just the positions of matching <span class="s1">Mutation</span> objects, use <span class="s1">-positionsOfMutationsOfType()</span>; and if you are aiming for a sum of the selection coefficients of matching <span class="s1">Mutation</span> objects, use <span class="s1">-sumOfMutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="s5"><span class="Apple-converted-space">  </span>See also </span><span class="s6">substitutionsOfType()</span><span class="s5">.</span></p>
<p class="p5"><span class="s3">– (is)nucleotides([Ni$ start = NULL], [Ni$ end = NULL], [string$ format = "string"])</span></p>
<p class="p6"><span class="s3">Returns the nucleotide sequence for the haplosome.<span class="Apple-converted-space">  </span>This is the current ancestral sequence, as would be returned by the </span><span class="s4">Chromosome</span><span class="s3"> method </span><span class="s4">ancestralNucleotides()</span><span class="s3">, with the nucleotides for any nucleotide-based mutations in the haplosome overlaid.<span class="Apple-converted-space">  </span>The range of the returned sequence may be constrained by a start position given in </span><span class="s4">start</span><span class="s3"> and/or an end position given in </span><span class="s4">end</span><span class="s3">; nucleotides will be returned from </span><span class="s4">start</span><span class="s3"> to </span><span class="s4">end</span><span class="s3">, inclusive.<span class="Apple-converted-space">  </span>The default value of </span><span class="s4">NULL</span><span class="s3"> for </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> represent the first and last base positions of the chromosome, respectively.</span></p>
<p class="p6"><span class="s3">The format of the returned sequence is controlled by the </span><span class="s4">format</span><span class="s3"> parameter.<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"string"</span><span class="s3"> will return the sequence as a singleton </span><span class="s4">string</span><span class="s3"> (e.g., </span><span class="s4">"TATA"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"char"</span><span class="s3"> will return a </span><span class="s4">string</span><span class="s3"> vector with one element per nucleotide (e.g., </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"integer"</span><span class="s3"> will return an </span><span class="s4">integer</span><span class="s3"> vector with values A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3"> (e.g., </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"codon"</span><span class="s3"> will return an </span><span class="s4">integer</span><span class="s3"> vector with values from </span><span class="s4">0</span><span class="s3"> to </span><span class="s4">63</span><span class="s3">, based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three); see the </span><span class="s4">ancestralNucleotides()</span><span class="s3"> documentation for details.<span class="Apple-converted-space">  </span>If the sequence returned is likely to be long, the </span><span class="s4">"string"</span><span class="s3"> format will be the most memory-efficient, and may also be the fastest (but may be harder to work with).</span></p>
<p class="p6"><span class="s3">Several helper functions are provided for working with sequences, such as </span><span class="s4">nucleotideCounts()</span><span class="s3"> to get the counts of A/C/G/T nucleotides in a sequence, </span><span class="s4">nucleotideFrequencies()</span><span class="s3"> to get the same information as frequencies, and </span><span class="s4">codonsToAminoAcids()</span><span class="s3"> to convert a codon sequence (such as provided by the codon format described above) to an amino acid sequence.</span></p>
<p class="p3">+ (void)outputHaplosomes([Ns$ filePath = NULL], [logical$ append = F]<span class="s5">, [logical$ objectTags = F]</span>)</p>
<p class="p6">Output the target haplosomes in SLiM’s native format.<span class="Apple-converted-space">  </span>This low-level output method may be used to output any sample of <span class="s1">Haplosome</span> objects associated with a single chromosome.<span class="Apple-converted-space">  </span>The Eidos function <span class="s1">sample()</span> may be useful for constructing custom samples, as may the SLiM class <span class="s1">Individual</span>.<span class="Apple-converted-space">  </span>For output of a sample from a single <span class="s1">Subpopulation</span>, the <span class="s1">outputSample()</span> method of <span class="s1">Subpopulation</span> may be more straightforward to use.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output is directed to SLiM’s standard output.<span class="Apple-converted-space">  </span>Otherwise, the output is sent to the file specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.</p>
<p class="p6">The <span class="s1">objectTags</span> parameter may be used to request that tag values for objects be written out.<span class="Apple-converted-space">  </span>This option is turned off (<span class="s1">F</span>) by default, for brevity; if it turned on (<span class="s1">T</span>), the <span class="s1">tag</span> property values of all haplosomes and mutations in the output will be written.<span class="Apple-converted-space">  </span>If there is other state that you wish you persist, such as tags on objects of other classes, values attached to objects with <span class="s1">setValue()</span>, and so forth, you should persist that state in separate files using calls such as <span class="s1">writeFile()</span>.</p>
<p class="p4">See <span class="s1">output</span><span class="s6">HaplosomesTo</span><span class="s1">MS()</span> and <span class="s1">output</span><span class="s6">HaplosomesTo</span><span class="s1">VCF()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p3">+ (void)output<span class="s5">HaplosomesTo</span>MS([Ns$ filePath = NULL], [logical$ append = F]<span class="s7">, [logical$ filterMonomorphic = F]</span>)</p>
<p class="p6">Output the target haplosomes in MS format.<span class="Apple-converted-space">  </span>This low-level output method may be used to output any sample of <span class="s1">Haplosome</span> objects associated with a single chromosome.<span class="Apple-converted-space">  </span>The Eidos function <span class="s1">sample()</span> may be useful for constructing custom samples, as may the SLiM class <span class="s1">Individual</span>.<span class="Apple-converted-space">  </span>For output of a sample from a single <span class="s1">Subpopulation</span>, the <span class="s1">outputMSSample()</span> of <span class="s1">Subpopulation</span> may be more straightforward to use.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output is directed to SLiM’s standard output.<span class="Apple-converted-space">  </span>Otherwise, the output is sent to the file specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.<span class="Apple-converted-space">  </span>Positions in the output will span the interval [0,1].</p>
<p class="p6"><span class="s3">If </span><span class="s4">filterMonomorphic</span><span class="s3"> is </span><span class="s4">F</span><span class="s3"> (the default), all mutations that are present in the sample will be included in the output.<span class="Apple-converted-space">  </span>This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in <i>every</i> sampled haplosome, and are thus apparently fixed).<span class="Apple-converted-space">  </span>These may be filtered out with </span><span class="s4">filterMonomorphic = T</span><span class="s3"> if desired; note that this option means that some mutations that do exist in the sampled haplosomes might not be included in the output, simply because they exist in every sampled haplosome.</span></p>
<p class="p4">See <span class="s1">outputHaplosomes()</span> and <span class="s1">output</span><span class="s6">HaplosomesTo</span><span class="s1">VCF()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p5"><span class="s5">+ (void)output</span>HaplosomesTo<span class="s5">VCF([Ns$ filePath = NULL], [logical$ outputMultiallelics = T], [logical$ append = F]</span><span class="s3">, [logical$ simplifyNucleotides = F], [logical$ outputNonnucleotides = T]</span>, [logical$ groupAsIndividuals = T]<span class="s5">)</span></p>
<p class="p6">Output the target haplosomes in VCF format.<span class="Apple-converted-space">  </span>This low-level output method may be used to output any sample of <span class="s1">Haplosome</span> objects associated with a single chromosome.<span class="Apple-converted-space">  </span>The Eidos function <span class="s1">sample()</span> may be useful for constructing custom samples, as may the SLiM class <span class="s1">Individual</span>.<span class="Apple-converted-space">  </span>For output of a sample from a single <span class="s1">Subpopulation</span>, the <span class="s1">outputVCFSample()</span> method of <span class="s1">Subpopulation</span> may be more straightforward to use.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output is directed to SLiM’s standard output.<span class="Apple-converted-space">  </span>Otherwise, the output is sent to the file specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.</p>
<p class="p6">The parameters <span class="s1">outputMultiallelics</span>, <span class="s1">simplifyNucleotides</span>, and <span class="s1">outputNonnucleotides</span> affect the format of the output produced.</p>
<p class="p6">With <span class="s1">groupAsIndividuals</span> being <span class="s1">T</span> (the default), the target haplosome vector should be structured as if it represents all of the haplosomes for some set of individuals, for a single focal chromosome.<span class="Apple-converted-space">  </span>All haplosomes for the focal chromosome should be present, including null haplosomes.<span class="Apple-converted-space">  </span>It should provide all of the haplosomes for the first individual (for the chosen chromosome); then for the second individual; and so forth.<span class="Apple-converted-space">  </span>The haplosomes in the target haplosome vector do not, in fact, need to belong to individuals in SLiM following this pattern; they just need to specify well-formed individuals in the VCF output.<span class="Apple-converted-space">  </span>For an intrinsically haploid chromosome, the target haplosome for a given output individual is used to generate a haploid call (<span class="s1">0</span> or <span class="s1">1</span>) for that individual; if the haplosome is a null haplosome, the call will be <span class="s1">~</span> (an ASCII tilde). For example, calls for (non-null) Y haplosomes in males will be emitted as <span class="s1">0</span> or <span class="s1">1</span>, whereas calls for the (null) Y haplosomes in females will be emitted as <span class="s1">~</span>.<span class="Apple-converted-space">  </span>For an intrinsically diploid chromosome, the pair of target haplosomes for a given individual is used to generate a call for that individual, but null haplosomes are allowed (in the patterns expected by SLiM given the chromosome type).<span class="Apple-converted-space">  </span>For example, a pair of non-null haplosomes for an X chromosome will be emitted as a diploid call (such as <span class="s1">1|0</span>) for a female (XX), but if the second haplosome of the pair is a null haplosome, the pair will be emitted as a haploid call (<span class="s1">0</span> or <span class="s1">1</span>) for a male (X).<span class="Apple-converted-space">  </span>If the first haplosome of the pair were a null haplosome for an X chromosome, an error would be raised, since that is not an allowed pattern in SLiM (as discussed in the documentation for the <span class="s1">Chromosome</span> class).<span class="Apple-converted-space">  </span>For a diploid autosome of type <span class="s1">"A"</span>, however, any pattern is legal, but the VCF format cannot distinguish between a non-null haplosome first and a null haplosome second, versus a null haplosome first and a non-null haplosome second; both will be emitted as a haploid call (<span class="s1">0</span> or <span class="s1">1</span>).<span class="Apple-converted-space">  </span>For a diploid autosome of type <span class="s1">"A"</span>, if both haplosomes are null the call will be <span class="s1">~</span>.<span class="Apple-converted-space">  </span>The VCF specification does not actually seem to discuss sex chromosomes, but this design is intended to follow standard usage.</p>
<p class="p6">With <span class="s1">groupAsIndividuals</span> being <span class="s1">F</span>, the focal chromosome is treated as being intrinsically haploid whether it is or not; each haplosome will be called as a haploid sample whether the chromosome type is diploid or haploid.<span class="Apple-converted-space">  </span>This provides more detailed and accurate information; the exact state of each haplosome will be represented with either <span class="s1">0</span>, <span class="s1">1</span>, or (for null haplosomes) <span class="s1">~</span>, rather than the state of a pair of haplosomes being represented as a single call in a way that can sometimes be ambiguous, as discussed above.<span class="Apple-converted-space">  </span>However, the resulting output might confuse some VCF parsers that expect diploid calls for individuals, and it will not be as obvious which calls in the output belong to a given diploid individual.</p>
<p class="p6">See <span class="s1">outputHaplosomesToMS()</span> and <span class="s1">outputHaplosomes()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p3">– (integer)positionsOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the positions of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the haplosome.<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just positions, use <span class="s1">-mutationsOfType()</span>.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p5"><span class="s3">+ (</span><span class="s5">object</span><span class="s3">&lt;Mutation&gt;)readHaplosomesFromMS(string$ filePath, io&lt;MutationType&gt;$ mutationType)</span></p>
<p class="p6">Read new mutations from the MS format file at <span class="s1">filePath</span> and add them to the target haplosomes.<span class="Apple-converted-space">  </span>The number of target haplosomes must match the number of haplosomes represented in the MS file, and all target haplosomes must be associated with the same chromosome, and must not be null haplosomes.<span class="Apple-converted-space">  </span>The target haplosomes correspond, in order, to the call lines in the MS file.<span class="Apple-converted-space">  </span>To read into all of the non-null haplosomes in a given subpopulation <span class="s1">pN</span> in a single-chromosome model, simply call <span class="s1">pN.haplosomesNonNull.</span><span class="s4">readHaplosomesFromMS</span><span class="s1">()</span>, assuming the subpopulation’s size matches that of the MS file.<span class="Apple-converted-space">  </span>A vector containing all of the mutations created by <span class="s4">readHaplosomesFromMS</span><span class="s1">()</span> is returned.</p>
<p class="p6">Each mutation is created at the position specified in the file, using the mutation type given by <span class="s1">mutationType</span>.<span class="Apple-converted-space">  </span>Positions are expected to be in [0,1], and are scaled to the length of the chromosome by multiplying by the last valid base position of the chromosome (i.e., one less than the chromosome length).<span class="Apple-converted-space">  </span>Selection coefficients are drawn from the mutation type.<span class="Apple-converted-space">  </span>The population of origin for each mutation is set to <span class="s1">-1</span>, and the tick of origin is set to the current tick.<span class="Apple-converted-space">  </span>In a nucleotide-based model, if <span class="s1">mutationType</span> is nucleotide-based, a random nucleotide different from the ancestral nucleotide at the position will be chosen with equal probability.</p>
<p class="p5"><span class="s3">+ (</span><span class="s5">object</span><span class="s3">&lt;Mutation&gt;)readHaplosomesFromVCF(string$ filePath, [Nio&lt;MutationType&gt;$ mutationType = NULL])</span></p>
<p class="p6">Read new mutations from the VCF format file at <span class="s1">filePath</span> and add them to the target haplosomes.<span class="Apple-converted-space">  </span>The number of target haplosomes must match the number of haplosomes represented in the VCF file (i.e., two times the number of diploid samples plus one times the number of haploid samples).<span class="Apple-converted-space">  </span>To read into all of the haplosomes in a given subpopulation <span class="s1">pN</span> in a single-chromosome model, simply call <span class="s1">pN.haplosomes.readHaplosomesFromVCF()</span>, assuming the subpopulation’s size matches that of the VCF file taking ploidy into account.<span class="Apple-converted-space">  </span>A vector containing all of the mutations created by <span class="s1">readHaplosomesFromVCF()</span> is returned.</p>
<p class="p6">This method and the <span class="s1">readIndividualsFromVCF()</span> method of <span class="s1">Individual</span> provide two alternative ways of reading VCF data, focused in the perspective of either haplosomes (this method) or individuals (the <span class="s1">Individual</span> method).<span class="Apple-converted-space">  </span>See the documentation of <span class="s1">readIndividualsFromVCF()</span> for discussion of the pros and cons of each approach; that discussion will not be duplicated here.</p>
<p class="p6">SLiM’s VCF parsing is quite primitive.<span class="Apple-converted-space">  </span>The header is parsed only inasmuch as SLiM looks to see whether SLiM-specific VCF fields are defined or not; the rest of the header information is ignored.<span class="Apple-converted-space">  </span>Call lines are assumed to follow the format:</p>
<p class="p8">#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT i0...iN</p>
<p class="p6">The <span class="s1">CHROM</span> field is largely ignored, but <span class="s1">readHaplosomesFromVCF()</span> does check that its value is identical across all call lines, to prevent the genetic data for more than one chromosome from being glommed together nonsensically; the input VCF file must contain data for just a single chromosome.<span class="Apple-converted-space">  </span>In single-chromosome models the <span class="s1">CHROM</span> field is not otherwise checked or validated.<span class="Apple-converted-space">  </span>In multi-chromosome models, <span class="s1">readHaplosomesFromVCF()</span> imposes some additional restrictions.<span class="Apple-converted-space">  </span>First, all haplosomes in the target vector must be associated with the same single focal chromosome.<span class="Apple-converted-space">  </span>Second, the <span class="s1">CHROM</span> field for every call line in the VCF file must match the <span class="s1">symbol</span> property of that focal chromosome; the VCF file must indicate that it specifically matches the focal chromosome associated with the target haplosomes.<span class="Apple-converted-space">  </span>These restrictions boil down to the fact that <span class="s1">readHaplosomesFromVCF()</span> only reads data for a single chromosome.<span class="Apple-converted-space">  </span>If you wish to read multi-chromosome VCF data into a multi-chromosome SLiM model, the <span class="s1">readIndividualsFromVCF()</span> method provided by the <span class="s1">Individual</span> class supports that functionality (because it can work at the level of individuals, rather than haplosomes, making it possible to match calls to the corresponding haplosomes in a reasonable way).<span class="Apple-converted-space">  </span>Alternatively, you can call <span class="s1">readHaplosomesFromVCF()</span> multiple times to read data for different chromosomes one by one.</p>
<p class="p6">The <span class="s1">ID</span>, <span class="s1">QUAL</span>, <span class="s1">FILTER</span>, and <span class="s1">FORMAT</span> fields are ignored, and information in the genotype fields beyond the <span class="s1">GT</span> genotype subfield are also ignored.<span class="Apple-converted-space">  </span>SLiM’s own VCF annotations are honored; in particular, mutations will be created using the given values of <span class="s1">MID</span>, <span class="s1">S</span>, <span class="s1">PO</span>, <span class="s1">TO</span>, and <span class="s1">MT</span> if those subfields are present, and <span class="s1">DOM</span>, if it is present, must match the dominance coefficient of the mutation type.<span class="Apple-converted-space">  </span>The parameter <span class="s1">mutationType</span> (a <span class="s1">MutationType</span> object or id) will be used for any mutations that have no supplied mutation type id in the <span class="s1">MT</span> subfield; if <span class="s1">mutationType</span> would be used but is <span class="s1">NULL</span> an error will result.<span class="Apple-converted-space">  </span>Mutation IDs supplied in <span class="s1">MID</span> will be used if no mutation IDs have been used in the simulation so far; if any have been used, it is difficult for SLiM to guarantee that there are no conflicts, so a warning will be emitted and the <span class="s1">MID</span> values will be ignored.<span class="Apple-converted-space">  </span>If selection coefficients are not supplied with the <span class="s1">S</span> subfield, they will be drawn from the mutation type used for the mutation.<span class="Apple-converted-space">  </span>If a population of origin is not supplied with the <span class="s1">PO</span> subfield, <span class="s1">-1</span> will be used.<span class="Apple-converted-space">  </span>If a tick of origin is not supplied with the <span class="s1">TO</span> subfield (or a generation of origin <span class="s1">GO</span> field, which was the SLiM convention before SLiM 4), the current tick will be used.</p>
<p class="p6"><span class="s1">REF</span> and <span class="s1">ALT</span> must always be comprised of simple nucleotides (<span class="s1">A</span>/<span class="s1">C</span>/<span class="s1">G</span>/<span class="s1">T</span>) rather than values representing indels or other complex states.<span class="Apple-converted-space">  </span>Beyond this, the handling of the <span class="s1">REF</span> and <span class="s1">ALT</span> fields depends upon several factors.<span class="Apple-converted-space">  </span>In non-nucleotide-based models, we have the first case: (1) These fields are ignored, although they are still checked for conformance.<span class="Apple-converted-space">  </span>In nucleotide-based models, when a header definition for SLiM’s <span class="s1">NONNUC</span> tag is present (as when nucleotide-based output is generated by SLiM) there are two further possibilities, given as (2) and (3) here: (2) If a <span class="s1">NONNUC</span> field is present in the <span class="s1">INFO</span> field the call line is taken to represent a non-nucleotide-based mutation, and <span class="s1">REF</span> and <span class="s1">ALT</span> are again ignored; in this case the mutation type used must be non-nucleotide-based.<span class="Apple-converted-space">  </span>(3) If a <span class="s1">NONNUC</span> field is <i>not</i> present the call line is taken to represent a nucleotide-based mutation; in this case, the mutation type used must be nucleotide-based, and the specified reference nucleotide must match the existing ancestral nucleotide at the given position.<span class="Apple-converted-space">  </span>Finally, in nucleotide-based models, when a header definition for SLiM’s <span class="s1">NONNUC</span> tag is <i>not</i> present (as when loading a non-SLiM-generated VCF file), there is a remaining possibility: (4) The mutation type used will govern the way nucleotides are handled.<span class="Apple-converted-space">  </span>In this case, if the mutation type used for a mutation is nucleotide-based, the nucleotide provided in the VCF file for that allele will be used, whereas if the mutation type is non-nucleotide-based, the nucleotide provided will be ignored.</p>
<p class="p6">If multiple alleles using the same nucleotide at the same position are specified in the VCF file, a separate mutation will be created for each, mirroring SLiM’s behavior with independent mutational lineages when writing VCF.<span class="Apple-converted-space">  </span>The <span class="s1">MULTIALLELIC</span> flag is ignored by <span class="s1">readHaplosomesFromVCF()</span>; call lines for mutations at the same base position in the same haplosome will result in stacked mutations whether or not <span class="s1">MULTIALLELIC</span> is present.</p>
<p class="p6">The target haplosomes correspond, in order, to the haploid or diploid calls provided for <span class="s1">i0</span>…<span class="s1">iN</span> (the sample IDs) in the VCF file.<span class="Apple-converted-space">  </span>Null haplosomes in the target vector will be skipped, and will not be used to correspond to any of the calls for <span class="s1">i0</span>…<span class="s1">iN</span>; however, care should be taken in this case that the haplosomes in the VCF file correspond to the target haplosomes in the manner desired.</p>
<p class="p6">A call of <span class="s1">~</span> (an ASCII tilde character) for an individual <span class="s1">i0</span>…<span class="s1">iN</span> is taken to indicate that that individual possesses no genetic information for the chromosome; it lacks that chromosome entirely.<span class="Apple-converted-space">  </span>For example, if the VCF file represents Y-chromosome data, female individuals should have calls of <span class="s1">~</span>.<span class="Apple-converted-space">  </span>This is treated differently than a call of <span class="s1">0</span><span class="Apple-converted-space">  </span>or <span class="s1">0|0</span>; a call of <span class="s1">0</span> matches that call to a non-null target haplosome (but does not add the called mutation to that haplosome), and a call of <span class="s1">0|0</span> matches two non-null target haplosomes (but does not add the called mutation to either), whereas a call of <span class="s1">~</span> is simply skipped, without matching to any haplosome in the target vector, mirroring the fact that <span class="s1">readHaplosomesFromVCF()</span> skips over null haplosomes in the target haplosome vector.<span class="Apple-converted-space">  </span>(When reading Y-chromosome data, a female’s null Y haplosome could be omitted from the target haplosome vector, or it could be present since it would be skipped anyway – as stated above, all null haplosomes are skipped.)<span class="Apple-converted-space">  </span>Note that these semantics using <span class="s1">~</span> are non-standard; the VCF standard does not seem to say anything about how sex chromosomes should be represented (or anything about other types of chromosomes that might be absent from some individuals), so the usage of <span class="s1">~</span> was invented for SLiM.<span class="Apple-converted-space">  </span>This is an area where standardization is very much needed.</p>
<p class="p5"><span class="s3">+ (void)removeMutations([No&lt;Mutation&gt; mutations = NULL], [logical$ substitute = F])</span></p>
<p class="p6">Remove the mutations in <span class="s1">mutations</span> from the target haplosomes, if they are present (if they are not present, they will be ignored).<span class="Apple-converted-space">  </span>If <span class="s1">NULL</span> is passed for <span class="s1">mutations</span> (which is the default), then all mutations will be removed from the target haplosomes; in this case, <span class="s1">substitute</span> must be <span class="s1">F</span> (a specific vector of mutations to be substituted is required).<span class="Apple-converted-space">  </span>Note that the <span class="s1">Mutation</span> objects removed remain valid, and will still be in the simulation’s mutation registry (i.e., will be returned by the <span class="s1">Species</span> property <span class="s1">mutations</span>), until the next tick.<span class="Apple-converted-space">  </span>All target haplosomes and all mutations in <span class="s1">mutations</span> must be associated with the same <span class="s1">Chromosome</span> object; attempting to remove a mutation from a haplosome associated with a different chromosome will raise an error.</p>
<p class="p6"><span class="s3">Removing mutations will normally affect the fitness values calculated at the end of the current tick; if you want current fitness values to be affected, you can call the </span><span class="s4">Species</span><span class="s3"> method </span><span class="s4">recalculateFitness()</span><span class="s3"> – but see the documentation of that method for caveats.</span></p>
<p class="p6"><span class="s3">The optional parameter </span><span class="s4">substitute</span><span class="s3"> was added in SLiM 2.2, with a default of </span><span class="s4">F</span><span class="s3"> for backward compatibility.<span class="Apple-converted-space">  </span>If </span><span class="s4">substitute</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">, </span><span class="s4">Substitution</span><span class="s3"> objects will be created for all of the removed mutations so that they are recorded in the simulation as having fixed, just as if they had reached fixation and been removed by SLiM’s own internal machinery.<span class="Apple-converted-space">  </span>This will occur regardless of whether the mutations have in fact fixed, regardless of the </span><span class="s4">convertToSubstitution</span><span class="s3"> property of the relevant mutation types, and regardless of whether all copies of the mutations have even been removed from the simulation (making it possible to create </span><span class="s4">Substitution</span><span class="s3"> objects for mutations that are still segregating).<span class="Apple-converted-space">  </span>It is up to the caller to perform whatever checks are necessary to preserve the integrity of the simulation’s records.<span class="Apple-converted-space">  </span>Typically </span><span class="s4">substitute</span><span class="s3"> will only be set to </span><span class="s4">T</span><span class="s3"> in the context of calls like </span><span class="s4">sim.subpopulations.haplosomes.removeMutations(muts, T)</span><span class="s3">, such that the substituted mutations are guaranteed to be entirely removed from circulation.<span class="Apple-converted-space">  </span>As mentioned above, </span><span class="s4">substitute</span><span class="s3"> may not be </span><span class="s4">T</span><span class="s3"> if </span><span class="s4">mutations</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3">.</span></p>
<p class="p3">–<span class="s9"> </span>(float$)sumOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the sum of the selection coefficients of all mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the haplosome.<span class="Apple-converted-space">  </span>This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, <span class="s1">sumOfMutationsOfType()</span> will provide the sum of the additive effects of the QTLs for the given mutation type.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="Apple-converted-space">  </span>Note that this method also exists on <span class="s1">Individual</span>, for cases in which the sum across both haplosomes of an individual is desired.</p>
<p class="p1"><b>5.5<span class="Apple-converted-space">  </span>Class GenomicElement</b></p>
<p class="p2"><i>5.5.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>GenomicElement</i></span><i> properties</i></p>
<p class="p3">endPosition =&gt; (integer$)</p>
<p class="p4">The last position in the chromosome contained by this genomic element.</p>
<p class="p3">genomicElementType =&gt; (object&lt;GenomicElementType&gt;$)</p>
<p class="p4">The <span class="s1">GenomicElementType</span> object that defines the behavior of this genomic element.</p>
<p class="p3">startPosition =&gt; (integer$)</p>
<p class="p4">The first position in the chromosome contained by this genomic element.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p2"><i>5.5.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>GenomicElement</i></span><i> methods</i></p>
<p class="p3">– (void)setGenomicElementType(io&lt;GenomicElementType&gt;$ genomicElementType)</p>
<p class="p4">Set the genomic element type used for a genomic element.<span class="Apple-converted-space">  </span>The genomicElementType parameter should supply the new genomic element type for the element, either as a <span class="s1">GenomicElementType</span> object or as an <span class="s1">integer</span> identifier.<span class="Apple-converted-space">  </span>The genomic element type for a genomic element is normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p1"><b>5.6<span class="Apple-converted-space">  </span>Class GenomicElementType</b></p>
<p class="p2"><i>5.6.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>GenomicElementType</i></span><i> properties</i></p>
<p class="p3">color &lt;–&gt; (string$)</p>
<p class="p4">The color used to display genomic elements of this type in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">color</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default color scheme is used; this is the default for new <span class="s1">GenomicElementType</span> objects.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this genomic element type; for genomic element type <span class="s1">g3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">mutationFractions =&gt; (float)</p>
<p class="p4">For each <span class="s1">MutationType</span> represented in this genomic element type, this property has the corresponding fraction of all mutations that will be drawn from that <span class="s1">MutationType</span><span class="s2">.</span></p>
<p class="p5"><span class="s3">mutationMatrix =&gt; (float)</span></p>
<p class="p6"><span class="s3">The nucleotide mutation matrix used for this genomic element type, set up by </span><span class="s4">initializeGenomicElementType()</span><span class="s3"> and </span><span class="s4">setMutationMatrix()</span><span class="s3">.<span class="Apple-converted-space">  </span>This property is only defined in nucleotide-based models; it is unavailable otherwise.</span></p>
<p class="p3">mutationTypes =&gt; (object&lt;MutationType&gt;)</p>
<p class="p4">The <span class="s1">MutationType</span> instances used by this genomic element type.</p>
<p class="p3">species =&gt; (object&lt;Species&gt;$)</p>
<p class="p6"><span class="s3">The species to which the target object belongs.</span></p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to genomic element types.</p>
<p class="p9"><span class="s10"><i>5.6.2<span class="Apple-converted-space">  </span></i></span><i>GenomicElementType</i><span class="s10"><i> methods</i></span></p>
<p class="p3">– (void)setMutationFractions(io&lt;MutationType&gt; mutationTypes, numeric proportions)</p>
<p class="p4">Set the mutation type fractions contributing to a genomic element type.<span class="Apple-converted-space">  </span>The <span class="s1">mutationTypes</span> vector should supply the mutation types used by the genomic element (either as <span class="s1">MutationType</span> objects or as <span class="s1">integer</span> identifiers), and the <span class="s1">proportions</span> vector should be of equal length, specifying the relative proportion of mutations that will be drawn from each corresponding type.<span class="Apple-converted-space">  </span>This is normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p5"><span class="s3">– (void)setMutationMatrix(float mutationMatrix)</span></p>
<p class="p6"><span class="s3">Sets a new nucleotide mutation matrix for the genomic element type.<span class="Apple-converted-space">  </span>This replaces the mutation matrix originally set by </span><span class="s4">initializeGenomicElementType()</span><span class="s3">.<span class="Apple-converted-space">  </span>This method may only be called in nucleotide-based models.</span></p>
<p class="p1"><b>5.7<span class="Apple-converted-space">  </span>Class Individual</b></p>
<p class="p2"><i>5.7.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Individual</i></span><i> properties</i></p>
<p class="p3">age <span class="s7">&lt;–&gt;</span> (integer$)</p>
<p class="p6">The age of the individual, measured in cycles.<span class="Apple-converted-space">  </span>A newly generated offspring individual will have an age of <span class="s1">0</span> in the same tick in which it was created.<span class="Apple-converted-space">  </span>The age of every individual is incremented by one at the same point that its species cycle counter is incremented, at the end of the tick cycle, <i>if and only if</i> its species was active in that tick.<span class="Apple-converted-space">  </span>The age of individuals may be changed; usually this only makes sense when setting up the initial state of a model, however.</p>
<p class="p3">color &lt;–&gt; (string$)</p>
<p class="p6">The color used to display the individual in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span> (see the Eidos manual).<span class="Apple-converted-space">  </span>If <span class="s1">color</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default (fitness-based) color scheme is used; this is the default for new <span class="s1">Individual</span> objects.<span class="Apple-converted-space">  </span>Note that named colors will be converted to RGB internally, so the value of this property will always be a hexadecimal RGB color string (or <span class="s1">""</span>).</p>
<p class="p5"><span class="s3">fitnessScaling &lt;–&gt; (float$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">float</span><span class="s3"> scaling factor applied to the individual’s fitness (i.e., the fitness value computed for the individual will be multiplied by this value).<span class="Apple-converted-space">  </span>This provides a simple, fast way to modify the fitness of an individual; conceptually it is similar to returning a fitness effect for the individual from a </span><span class="s4">fitnessEffect()</span><span class="s3"> callback, but without the complexity and performance overhead of implementing such a callback.<span class="Apple-converted-space">  </span>To scale the fitness of all individuals in a subpopulation by the same factor, see the </span><span class="s4">fitnessScaling</span><span class="s3"> property of </span><span class="s4">Subpopulation</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The value of </span><span class="s4">fitnessScaling</span><span class="s3"> is reset to </span><span class="s4">1.0</span><span class="s3"> every tick, so that any scaling factor set lasts for only a single tick.<span class="Apple-converted-space">  </span>This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.</span></p>
<p class="p5">haploidGenome1 =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">A vector of all <span class="s1">Haplosome</span> objects associated with this individual that are attributed to its first parent (the female parent, in sexual models).<span class="Apple-converted-space">  </span>This method assumes the individual was generated by the typical method for each chromosome type, as explained below; it does not trace back the true ancestry of each haplosome.<span class="Apple-converted-space">  </span>The semantics of this are more obvious for some chromosome types than others, depending on the inheritance pattern of the chromosome as described in <span class="s1">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>For chromosomes with two associated haplosomes (types <span class="s1">"A"</span>, <span class="s1">"X"</span>, <span class="s1">"Z"</span>, <span class="s1">"H-"</span>, and <span class="s1">"-Y"</span>), the first haplosome is assumed to be from the first parent, and is thus included, whereas the second haplosome is assumed to be from the second parent and is thus not included.<span class="Apple-converted-space">  </span>For chromosomes with one associated haplosome that is inherited from the female/first parent in one way or another (types <span class="s1">"W"</span>, <span class="s1">"HF"</span>, and <span class="s1">"FL"</span>), that haplosome is always included.<span class="Apple-converted-space">  </span>For type <span class="s1">"H"</span>, the single haplosome is assumed to have come from the first parent (since clonal inheritance is the common case), and so is included.<span class="Apple-converted-space">  </span>Other chromosome types (<span class="s1">"Y"</span>, <span class="s1">"HM"</span>, <span class="s1">"ML"</span>) are never included.<span class="Apple-converted-space">  </span>See also the <span class="s1">haploidGenome1NonNull</span> property and the <span class="s1">haplosomesForChromosomes()</span> method.</p>
<p class="p5">haploidGenome1NonNull =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">This provides the same vector of haplosomes as the <span class="s1">haploidGenome1</span> property, except that null haplosomes are not included in this property.<span class="Apple-converted-space">  </span>This is a convenience shorthand, sometimes useful in models that involve null haplosomes.<span class="Apple-converted-space">  </span>See also the <span class="s1">haplosomesForChromosomes()</span> method.</p>
<p class="p5">haploidGenome2 =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">A vector of all <span class="s1">Haplosome</span> objects associated with this individual that are attributed to its second parent (the male parent, in sexual models).<span class="Apple-converted-space">  </span>This method assumes the individual was generated by the typical method for each chromosome type, as explained below; it does not trace back the true ancestry of each haplosome.<span class="Apple-converted-space">  </span>The semantics of this are more obvious for some chromosome types than others, depending on the inheritance pattern of the chromosome as described in <span class="s1">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>For chromosomes with two associated haplosomes (types <span class="s1">"A"</span>, <span class="s1">"X"</span>, <span class="s1">"Z"</span>, <span class="s1">"H-"</span>, and<span class="s1">"-Y"</span>), the second haplosome is assumed to be from the second parent, and is thus included, whereas the first haplosome is assumed to be from the first parent and is thus not included.<span class="Apple-converted-space">  </span>For chromosomes with one associated haplosome that is inherited from the male/second parent in one way or another (types <span class="s1">"Y"</span>, <span class="s1">"HM"</span>, and <span class="s1">"ML"</span>), that haplosome is always included.<span class="Apple-converted-space">  </span>For type <span class="s1">"H"</span>, the single haplosome is assumed to have come from the first parent (since clonal inheritance is the common case), and so is not included.<span class="Apple-converted-space">  </span>Other chromosome types (<span class="s1">"W"</span>, <span class="s1">"HF"</span>, <span class="s1">"FL"</span>) are never included.<span class="Apple-converted-space">  </span>See also the <span class="s1">haploidGenome2NonNull</span> property and the <span class="s1">haplosomesForChromosomes()</span> method.</p>
<p class="p5">haploidGenome2NonNull =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">This provides the same vector of haplosomes as the <span class="s1">haploidGenome2</span> property, except that null haplosomes are not included in this property.<span class="Apple-converted-space">  </span>This is a convenience shorthand, sometimes useful in models that involve null haplosomes.<span class="Apple-converted-space">  </span>See also the <span class="s1">haplosomesForChromosomes()</span> method.</p>
<p class="p5">haplosomes =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">A vector of all <span class="s1">Haplosome</span> objects associated with this individual, in the order in which the chromosomes were defined for the species.<span class="Apple-converted-space">  </span>See also the <span class="s1">haplosomesNonNull</span>, <span class="s1">haploidGenome1</span>, <span class="s1">haploidGenome1NonNull</span>, <span class="s1">haploidGenome2</span>, and <span class="s1">haploidGenome2NonNull</span> properties and the <span class="s1">haplosomesForChromosomes()</span> method.</p>
<p class="p5">haplosomesNonNull =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">A vector of all <span class="s1">Haplosome</span> objects associated with this individual, in the order in which the chromosomes were defined for the species (as with the <span class="s1">haplosomes</span> property), but excluding any null haplosomes from the returned vector.<span class="Apple-converted-space">  </span>This is a convenience shorthand, sometimes useful in models that involve null haplosomes.</p>
<p class="p3">index =&gt; (integer$)</p>
<p class="p4">The index of the individual in the <span class="s1">individuals</span> vector of its <span class="s1">Subpopulation</span><span class="s2">.</span></p>
<p class="p3">meanParentAge =&gt; (float$)</p>
<p class="p6">The average age of the parents of this individual, measured in cycles.<span class="Apple-converted-space">  </span>Parentless individuals will have a <span class="s1">meanParentAge</span> of <span class="s1">0.0</span>.<span class="Apple-converted-space">  </span>The mean parent age is determined when a new offspring is generated, from the <span class="s1">age</span> property of the parent or parents involved in generating the offspring.<span class="Apple-converted-space">  </span>For <span class="s1">addRecombinant()</span> and <span class="s1">addMultiRecombinant()</span> that is somewhat complex; see those methods for details.</p>
<p class="p5"><span class="s3">migrant =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">Set to </span><span class="s6">T</span><span class="s3"> if the individual is a recent migrant, </span><span class="s6">F</span><span class="s3"> otherwise.<span class="Apple-converted-space">  </span>The definition of “recent” depends upon the model type (WF or nonWF).</span></p>
<p class="p6"><span class="s3">In WF models, this flag is set at the point when a new child is generated if it is a migrant (i.e., if its source subpopulation is not the same as its subpopulation), and remains valid, with the same value, for the rest of the individual’s lifetime.</span></p>
<p class="p6"><span class="s3">In nonWF models, this flag is </span><span class="s6">F</span><span class="s3"> for all new individuals, is set to </span><span class="s6">F</span><span class="s3"> in all individuals at the end of the reproduction tick cycle stage, and is set to </span><span class="s6">T</span><span class="s3"> on all individuals moved to a new subpopulation by</span><span class="s6"> takeMigrants()</span><span class="s3"> or a </span><span class="s6">survival()</span><span class="s3"> callback; the </span><span class="s6">T</span><span class="s3"> value set by </span><span class="s6">takeMigrants()</span><span class="s3"> or </span><span class="s6">survival()</span><span class="s3"> will remain until it is reset at the end of the next reproduction tick cycle stage.</span></p>
<p class="p3">pedigreeID =&gt; (integer$)</p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">pedigreeID</span> is a unique non-negative identifier for each individual in a simulation, never re-used throughout the duration of the simulation run.<span class="Apple-converted-space">  </span>If pedigree tracking is not enabled, this property is unavailable.</p>
<p class="p3">pedigreeParentIDs =&gt; (integer)</p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">pedigreeParentIDs</span> contains the values of <span class="s1">pedigreeID</span> that were possessed by the parents of an individual; it is thus a vector of two values.<span class="Apple-converted-space">  </span>If pedigree tracking is not enabled, this property is unavailable.<span class="Apple-converted-space">  </span>Parental values may be <span class="s1">-1</span> if insufficient ticks have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).</p>
<p class="p3">pedigreeGrandparentIDs =&gt; (integer)</p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">pedigreeGrandparentIDs</span> contains the values of <span class="s1">pedigreeID</span> that were possessed by the grandparents of an individual; it is thus a vector of four values.<span class="Apple-converted-space">  </span>If pedigree tracking is not enabled, this property is unavailable.<span class="Apple-converted-space">  </span>Grandparental values may be <span class="s1">-1</span> if insufficient ticks have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).</p>
<p class="p5">reproductiveOutput =&gt; (integer$)</p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">reproductiveOutput</span> contains the number of offspring for which this individual has been a parent.<span class="Apple-converted-space">  </span>If pedigree tracking is not enabled, this property is unavailable.<span class="Apple-converted-space">  </span>If an individual is a parent by cloning or selfing, or as <i>both</i> parents for a biparental mating, this value is incremented by two.<span class="Apple-converted-space">  </span>Involvement of an individual as a parent for an <span class="s1">addRecombinant()</span> or <span class="s1">addMultiRecombinant()</span> call does not change this property’s value, since the reproductive contribution in that case is unclear; one must conduct separate bookkeeping for that case if necessary, or use tree-sequence recording to infer it from the inheritance record.</p>
<p class="p10"><span class="s11">See also the </span>Subpopulation<span class="s11"> property </span>lifetimeReproductiveOutput<span class="s11">.</span></p>
<p class="p3">sex =&gt; (string$)</p>
<p class="p4">The sex of the individual.<span class="Apple-converted-space">  </span>This will be <span class="s1">"H"</span> if sex is not enabled in the simulation (i.e., for hermaphrodites), otherwise <span class="s1">"F"</span> or <span class="s1">"M"</span> as appropriate.</p>
<p class="p3">spatialPosition =&gt; (float)</p>
<p class="p4">The spatial position of the individual.<span class="Apple-converted-space">  </span>The length of the <span class="s1">spatialPosition</span> property (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>If the spatial dimensionality is zero (as it is by default), it is an error to access this property.<span class="Apple-converted-space">  </span>The elements of this property are identical to the values of the <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">z</span> properties (if those properties are encompassed by the spatial dimensionality of the simulation).<span class="Apple-converted-space">  </span>In other words, if the declared dimensionality is <span class="s1">"xy"</span><span class="s2">,</span> the <span class="s1">individual.spatialPosition</span> property is equivalent to <span class="s1">c(individual.x, individual.y)</span>; <span class="s1">individual.z</span> is not used since it is not encompassed by the simulation’s dimensionality.</p>
<p class="p3">subpopulation =&gt; (object&lt;Subpopulation&gt;$)</p>
<p class="p4">The <span class="s1">Subpopulation</span> object to which the individual belongs.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value (as opposed to <span class="s1">tagF</span>, which is of type <span class="s1">float</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to individuals.<span class="Apple-converted-space">  </span><span class="s5">Note that the </span><span class="s6">Individual</span><span class="s5"> objects used by SLiM are new for every new offspring, so the </span><span class="s6">tag</span><span class="s5"> value of each new offspring generated in each tick will be initially undefined.</span></p>
<p class="p3">tagF &lt;–&gt; (float$)</p>
<p class="p4">A user-defined <span class="s1">float</span> value (as opposed to <span class="s1">tag</span>, which is of type <span class="s1">integer</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tagF</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tagF</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to individuals.</p>
<p class="p4">Note that at present, although many classes in SLiM have an <span class="s1">integer</span>-type <span class="s1">tag</span> property, only <span class="s1">Individual</span> has a <span class="s1">float</span>-type <span class="s1">tagF</span> property, because attaching model state to individuals seems to be particularly common and useful.<span class="Apple-converted-space">  </span>If a <span class="s1">tagF</span> property would be helpful on another class, it would be easy to add.</p>
<p class="p4">See the description of the <span class="s1">tag</span> property above for additional comments.</p>
<p class="p5">tagL0 &lt;–&gt; (logical$)</p>
<p class="p6">A user-defined <span class="s1">logical</span> value (see also <span class="s1">tag</span> and <span class="s1">tagF</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL0</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL0</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods (provided by the <span class="s1">Dictionary</span> class; see the Eidos manual), for another way of attaching state to individuals.</p>
<p class="p5">tagL1 &lt;–&gt; (logical$)</p>
<p class="p6">A user-defined <span class="s1">logical</span> value (see also <span class="s1">tag</span> and <span class="s1">tagF</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL1</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL1</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods (provided by the <span class="s1">Dictionary</span> class; see the Eidos manual), for another way of attaching state to individuals.</p>
<p class="p5">tagL2 &lt;–&gt; (logical$)</p>
<p class="p6">A user-defined <span class="s1">logical</span> value (see also <span class="s1">tag</span> and <span class="s1">tagF</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL2</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL2</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods (provided by the <span class="s1">Dictionary</span> class; see the Eidos manual), for another way of attaching state to individuals.</p>
<p class="p5">tagL3 &lt;–&gt; (logical$)</p>
<p class="p6">A user-defined <span class="s1">logical</span> value (see also <span class="s1">tag</span> and <span class="s1">tagF</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL3</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL3</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods (provided by the <span class="s1">Dictionary</span> class; see the Eidos manual), for another way of attaching state to individuals.</p>
<p class="p5">tagL4 &lt;–&gt; (logical$)</p>
<p class="p6">A user-defined <span class="s1">logical</span> value (see also <span class="s1">tag</span> and <span class="s1">tagF</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL4</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tagL4</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods (provided by the <span class="s1">Dictionary</span> class; see the Eidos manual), for another way of attaching state to individuals.</p>
<p class="p3">uniqueMutations =&gt; (object&lt;Mutation&gt;)</p>
<p class="p6">All of the <span class="s1">Mutation</span> objects present in this individual.<span class="Apple-converted-space">  </span>Mutations present in homologous haplosomes will occur only once in this property, and the mutations for a given chromosome will be given in sorted order by <span class="s1">position</span>, so in single-chromosome simulations this property is similar to <span class="s1">sortBy(unique(individual.haplosomes.mutations), "position")</span>.<span class="Apple-converted-space">  </span>(Even with a single chromosome it is not identical to that call, since if multiple mutations exist at the exact same position, they might be sorted differently by this method than they would be by <span class="s1">sortBy()</span>.)<span class="Apple-converted-space">  </span>This method is provided primarily for speed; it executes much faster than the Eidos equivalent above.<span class="Apple-converted-space">  </span>Indeed, it is faster than just <span class="s1">individual.haplosomes.mutations</span>, and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.<span class="Apple-converted-space">  </span>For more flexibility, see the method <span class="s1">mutationsFromHaplosomes()</span>.</p>
<p class="p5">x &lt;–&gt; (float$)</p>
<p class="p6">A user-defined <span class="s1">float</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">x</span> is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">x</span> is not used by SLiM unless the optional “continuous space” facility is enabled with the <span class="s1">dimensionality</span> parameter to <span class="s1">initializeSLiMOptions()</span>, in which case <span class="s1">x</span> will be understood to represent the <i>x</i> coordinate of the individual in space.<span class="Apple-converted-space">  </span>If continuous space is not enabled, you may use <span class="s1">x</span> as an additional tag value of type <span class="s1">float</span>.</p>
<p class="p5">xy =&gt; (float)</p>
<p class="p6">This property provides joint read-only access to the <span class="s1">x</span> and <span class="s1">y</span> properties; they are returned as a two-element <span class="s1">float</span> vector.<span class="Apple-converted-space">  </span>This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.<span class="Apple-converted-space">  </span>See the documentation for the separate properties <span class="s1">x</span> and <span class="s1">y</span> for further comments.</p>
<p class="p5">xyz =&gt; (float)</p>
<p class="p6">This property provides joint read-only access to the <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">z</span> properties; they are returned as a three-element <span class="s1">float</span> vector.<span class="Apple-converted-space">  </span>This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.<span class="Apple-converted-space">  </span>See the documentation for the separate properties <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">z</span> for further comments.</p>
<p class="p5">xz =&gt; (float)</p>
<p class="p6">This property provides joint read-only access to the <span class="s1">x</span> and <span class="s1">z</span> properties; they are returned as a two-element <span class="s1">float</span> vector.<span class="Apple-converted-space">  </span>This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.<span class="Apple-converted-space">  </span>See the documentation for the separate properties <span class="s1">x</span> and <span class="s1">z</span> for further comments.</p>
<p class="p5">y &lt;–&gt; (float$)</p>
<p class="p6">A user-defined <span class="s1">float</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">y</span> is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">y</span> is not used by SLiM unless the optional “continuous space” facility is enabled with the <span class="s1">dimensionality</span> parameter to <span class="s1">initializeSLiMOptions()</span>, in which case <span class="s1">y</span> will be understood to represent the <i>y</i> coordinate of the individual in space (if the dimensionality is <span class="s1">"xy"</span> or <span class="s1">"xyz"</span>).<span class="Apple-converted-space">  </span>If continuous space is not enabled, or the dimensionality is not <span class="s1">"xy"</span> or <span class="s1">"xyz"</span>, you may use <span class="s1">y</span> as an additional tag value of type <span class="s1">float</span>.</p>
<p class="p5">yz =&gt; (float)</p>
<p class="p6">This property provides joint read-only access to the <span class="s1">y</span> and <span class="s1">z</span> properties; they are returned as a two-element <span class="s1">float</span> vector.<span class="Apple-converted-space">  </span>This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.<span class="Apple-converted-space">  </span>See the documentation for the separate properties <span class="s1">y</span> and <span class="s1">z</span> for further comments.</p>
<p class="p5">z &lt;–&gt; (float$)</p>
<p class="p6">A user-defined <span class="s1">float</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">z</span> is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">z</span> is not used by SLiM unless the optional “continuous space” facility is enabled with the <span class="s1">dimensionality</span> parameter to <span class="s1">initializeSLiMOptions()</span>, in which case <span class="s1">z</span> will be understood to represent the <i>z</i> coordinate of the individual in space (if the dimensionality is <span class="s1">"xyz"</span>).<span class="Apple-converted-space">  </span>If continuous space is not enabled, or the dimensionality is not <span class="s1">"xyz"</span>, you may use <span class="s1">z</span> as an additional tag value of type <span class="s1">float</span>.</p>
<p class="p2"><i>5.7.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Individual</i></span><i> methods</i></p>
<p class="p3">– (logical)containsMutations(object&lt;Mutation&gt; mutations)</p>
<p class="p6">Returns a <span class="s1">logical</span> vector indicating whether each of the mutations in <span class="s1">mutations</span> is present in the individual (in any of its haplosomes); each element in the returned vector indicates whether the corresponding mutation is present (<span class="s1">T</span>) or absent (<span class="s1">F</span>).<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">–<span class="s9"> </span>(integer$)countOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p6">Returns the number of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the individual (in all of its haplosomes; a mutation that is present in both homologous haplosomes counts twice).<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just a count, you should probably use <span class="s1">mutationsFromHaplosomes()</span>.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p5">– (object&lt;Haplosome&gt;)haplosomesForChromosomes([Niso&lt;Chromosome&gt; chromosomes = NULL], [Ni$ index = NULL], [logical$ includeNulls = T])</p>
<p class="p6">Returns a vector containing the haplosomes of the target individual that correspond to the chromosomes passed in <span class="s1">chromosomes</span> (following the order of the <span class="s1">chromosomes</span> property of <span class="s1">Individual</span>).<span class="Apple-converted-space">  </span>Chromosomes can be specified by id (<span class="s1">integer</span>), by symbol (<span class="s1">string</span>) or by the <span class="s1">Chromosome</span> objects themselves; if <span class="s1">NULL</span> is passed (the default), all chromosomes defined for the species are used, in the order in which they were defined.</p>
<p class="p6">For chromosomes that are intrinsically diploid (types <span class="s1">"A"</span>, <span class="s1">"X"</span>, and <span class="s1">"Z"</span>, as well as the <span class="s1">"H-"</span> and <span class="s1">"-Y"</span> backward-compatibility chromosome types), <span class="s1">index</span> can be <span class="s1">0</span> or <span class="s1">1</span>, requesting only the first or second haplosome, respectively, for that chromosome; for other chromosome types, <span class="s1">index</span> is ignored.<span class="Apple-converted-space">  </span>If <span class="s1">includeNulls</span> is <span class="s1">T</span> (the default), any null haplosomes corresponding to the specified chromosomes are included in the result; if it is <span class="s1">F</span>, null haplosomes are excluded.<span class="Apple-converted-space">  </span>See also the properties <span class="s1">haplosomes</span>, <span class="s1">haplosomesNonNull</span>, <span class="s1">haploidGenome1</span>, <span class="s1">haploidGenome1NonNull</span>, <span class="s1">haploidGenome2</span>, and <span class="s1">haploidGenome2NonNull</span>.</p>
<p class="p5">– (object&lt;Mutation&gt;)mutationsFromHaplosomes(string$ category, [Nio&lt;MutationType&gt;$ mutType = NULL], [Niso&lt;Chromosome&gt; chromosomes = NULL])</p>
<p class="p6">Returns a vector of mutations from the haplosomes of the target individual.<span class="Apple-converted-space">  </span>Several options are provided that filter which mutations are returned.</p>
<p class="p6">The <span class="s1">category</span> parameter must be one of five supported values: <span class="s1">"unique"</span>, <span class="s1">"homozygous"</span>, <span class="s1">"heterozygous"</span>, <span class="s1">"hemizygous"</span>, or <span class="s1">"all"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">category</span> is <span class="s1">"unique"</span>, a given mutation will be returned only once, whether it is present homozygously or heterozygously (or hemizygously, for that matter); this mode of operation is similar to the <span class="s1">uniqueMutations</span> property, but provides more control due to the other options provided by this method.<span class="Apple-converted-space">  </span>If <span class="s1">category</span> is <span class="s1">"homozygous"</span>, a given mutation will be returned only if it is present homozygously (in both of the homologous haplosomes for a given chromosome).<span class="Apple-converted-space">  </span>If <span class="s1">category</span> is <span class="s1">"heterozygous"</span>, a given mutation will be returned only if it is present heterozygously (in only one of the two homologous non-null haplosomes for a given chromosome).<span class="Apple-converted-space">  </span>If <span class="s1">category</span> is <span class="s1">"hemizygous"</span>, a given mutation will be returned only if it is present hemizygously (in one haplosome for an intrinsically diploid chromosome, when the other haplosome is a null haplosome).<span class="Apple-converted-space">  </span>If <span class="s1">category</span> is <span class="s1">"all"</span>, a given mutation will be returned each time that it occurs in the haplosomes of the individual; in other words, it will be present in the returned vector <i>twice</i> if it is homozygous, <i>once</i> if it is heterozygous or hemizygous.<span class="Apple-converted-space">  </span>Mutations in the single haplosome of an intrinsically haploid chromosome will be returned for <span class="s1">category</span> values of <span class="s1">"unique"</span>, <span class="s1">"homozygous"</span>, and <span class="s1">"all"</span>.</p>
<p class="p6">The <span class="s1">mutType</span> parameter may be <span class="s1">NULL</span>, or may specify a mutation type by its <span class="s1">integer</span> id or with the <span class="s1">MutationType</span> object itself.<span class="Apple-converted-space">  </span>If <span class="s1">mutType</span> is <span class="s1">NULL</span> (the default), mutations of every mutation type are returned; no filtering by mutation type is done.<span class="Apple-converted-space">  </span>Otherwise, only mutations of the specified mutation type will be returned.</p>
<p class="p6">The <span class="s1">chromosomes</span> parameter may be <span class="s1">NULL</span>, or may provide a vector of chromosomes specified by their <span class="s1">integer</span> id, <span class="s1">string</span> symbol, or with the <span class="s1">Chromosome</span> object itself.<span class="Apple-converted-space">  </span>If <span class="s1">chromosomes</span> is <span class="s1">NULL</span> (the default), mutations associated with every chromosome are returned; no filtering by chromosome is done.<span class="Apple-converted-space">  </span>Otherwise, only mutations associated with the specified chromosomes will be returned.</p>
<p class="p6">The returned vector will contain tranches of mutations, one tranche per chromosome, in the order that the chromosomes were specified (if <span class="s1">chromosomes</span> is non-<span class="s1">NULL</span>) or the order the chromosomes were defined in the model (if <span class="s1">chromosomes</span> is <span class="s1">NULL</span>).<span class="Apple-converted-space">  </span>Within a given tranche, the mutations for that chromosome will be returned in sorted order by <span class="s1">position</span>.<span class="Apple-converted-space">  </span>(If more than one mutation associated with a given chromosome exists at the same position, the order in which those mutations are returned is undefined.)</p>
<p class="p6">This method replaces the deprecated method <span class="s1">uniqueMutationsOfType()</span>, while providing additional useful options.<span class="Apple-converted-space">  </span>It is particularly useful for efficient, vectorized assessment of the homozygous versus heterozygous state of the mutations contained by an individual, which is otherwise difficult to assess efficiently.</p>
<p class="p5">+ (void)outputIndividuals([Ns$ filePath = NULL], [logical$ append = F], [Niso&lt;Chromosome&gt;$ chromosome = NULL], [logical$ spatialPositions = T], [logical$ ages = T], [logical$ ancestralNucleotides = F], [logical$ pedigreeIDs = F], [logical$ objectTags = F])</p>
<p class="p6">Output the state of the target vector of individuals in SLiM's own format.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.<span class="Apple-converted-space">  </span>This method is quite similar to the <span class="s1">Species</span> method <span class="s1">outputFull()</span>, but (1) it can produce output for any vector of individuals, not always for the entire population; (2) it does not support output in a binary format; (3) it can produce output regarding the genetics for all chromosomes or for just one focal chromosome; and (4) there is no corresponding read method, as r<span class="s1">eadFromPopulationFile()</span> can read the data saved by <span class="s1">outputFull()</span>.</p>
<p class="p6">The <span class="s1">chromosome</span> parameter specifies a focal chromosome for which the genetics of the target individuals will be output.<span class="Apple-converted-space">  </span>If <span class="s1">chromosome</span> is <span class="s1">NULL</span>, all chromosomes will be output; otherwise, <span class="s1">chromosome</span> may specify the focal chromosome with an <span class="s1">integer</span> chromosome id, a <span class="s1">string</span> chromosome symbol, or a <span class="s1">Chromosome</span> object.</p>
<p class="p6">The <span class="s1">spatialPositions</span> parameter may be used to control the output of the spatial positions of individuals in species for which continuous space has been enabled using the <span class="s1">dimensionality</span> option of <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>If <span class="s1">spatialPositions</span> is <span class="s1">F</span>, the output will not contain spatial positions.<span class="Apple-converted-space">  </span>If <span class="s1">spatialPositions</span> is <span class="s1">T</span>, spatial position information will be output if it is available.<span class="Apple-converted-space">  </span>If the species does not have continuous space enabled, the <span class="s1">spatialPositions</span> parameter will be ignored.</p>
<p class="p6">The <span class="s1">ages</span> parameter may be used to control the output of the ages of individuals in nonWF simulations.<span class="Apple-converted-space">  </span>If <span class="s1">ages</span> is <span class="s1">F</span>, the output will not contain ages.<span class="Apple-converted-space">  </span>If <span class="s1">ages</span> is <span class="s1">T</span>, ages will be output for nonWF models.<span class="Apple-converted-space">  </span>In WF simulations, the <span class="s1">ages</span> parameter will be ignored.</p>
<p class="p6">The <span class="s1">ancestralNucleotides</span> parameter may be used to control the output of the ancestral nucleotide sequence in nucleotide-based models.<span class="Apple-converted-space">  </span>If <span class="s1">ancestralNucleotides</span> is <span class="s1">F</span>, the output will not contain ancestral nucleotide information.<span class="Apple-converted-space">  </span>This option is provided because the ancestral sequence may be quite large, for models with a long chromosome.<span class="Apple-converted-space">  </span>If the model is not nucleotide-based (as enabled with the <span class="s1">nucleotideBased</span> parameter to <span class="s1">initializeSLiMOptions()</span>), the <span class="s1">ancestralNucleotides</span> parameter will be ignored.<span class="Apple-converted-space">  </span>Note that in nucleotide-based models the output format will <i>always</i> include the nucleotides associated with any nucleotide-based mutations; the <span class="s1">ancestralNucleotides</span> flag governs only the ancestral sequence.</p>
<p class="p6">The <span class="s1">pedigreeIDs</span> parameter may be used to request that pedigree IDs be written out.<span class="Apple-converted-space">  </span>This option is turned off (<span class="s1">F</span>) by default, for brevity.<span class="Apple-converted-space">  </span>This option may only be used if SLiM’s optional pedigree tracking has been enabled with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>.</p>
<p class="p6">Finally, the <span class="s1">objectTags</span> parameter may be used to request that tag values for objects be written out.<span class="Apple-converted-space">  </span>This option is turned off (<span class="s1">F</span>) by default, for brevity; if it turned on (<span class="s1">T</span>), the values of all tags for all objects of supported classes (<span class="s1">Chromosome</span>, <span class="s1">Individual</span>, <span class="s1">Haplosome</span>, <span class="s1">Mutation</span>) will be written.<span class="Apple-converted-space">  </span>For individuals, the <span class="s1">tag</span>, <span class="s1">tagF</span>, <span class="s1">tagL0</span>, <span class="s1">tagL1</span>, <span class="s1">tagL2</span>, <span class="s1">tagL3</span>, and <span class="s1">tagL4</span> properties will be written; for chromosomes, haplosomes, and mutations, the <span class="s1">tag</span> property will be written.<span class="Apple-converted-space">  </span>If there is other state that you wish you persist, such as tags on objects of other classes, values attached to objects with <span class="s1">setValue()</span>, and so forth, you should persist that state in separate files using calls such as <span class="s1">writeFile()</span>.</p>
<p class="p6">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p5">+ (void)outputIndividualsToVCF([Ns$ filePath = NULL], [logical$ append = F], [Niso&lt;Chromosome&gt;$ chromosome = NULL], [logical$ outputMultiallelics = T], [logical$ simplifyNucleotides = F], [logical$ outputNonnucleotides = T])</p>
<p class="p6">Output the state of the target vector of individuals in VCF format.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.<span class="Apple-converted-space">  </span>This method is quite similar to the <span class="s1">Subpopulation</span> method <span class="s1">outputVCFSample()</span>, but (1) it can produce output for any vector of individuals, rather than sampling from a single population; (2) it can produce output regarding the genetics for all chromosomes or for just one focal chromosome, whereas <span class="s1">outputVCFSample()</span> can only output data for a single chromosome; and (3) because it can output genetic information for more than one chromosome, the <span class="s1">groupAsIndividuals</span> option provided by <span class="s1">outputVCFSample()</span> is not available for <span class="s1">outputIndividualsToVCF()</span>; each VCF sample has to correspond directly to one individual.</p>
<p class="p6">The <span class="s1">chromosome</span> parameter specifies a focal chromosome for which the genetics of the target individuals will be output.<span class="Apple-converted-space">  </span>If <span class="s1">chromosome</span> is <span class="s1">NULL</span>, all chromosomes will be output (distinguished in the VCF output by the chromosome symbol output in the <span class="s1">CHROM</span> column); otherwise, <span class="s1">chromosome</span> may specify the focal chromosome with an <span class="s1">integer</span> chromosome id, a <span class="s1">string</span> chromosome symbol, or a <span class="s1">Chromosome</span> object.</p>
<p class="p6">The parameters <span class="s1">outputMultiallelics</span>, <span class="s1">simplifyNucleotides</span>, and <span class="s1">outputNonnucleotides</span> affect the format of the output produced.</p>
<p class="p6">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p5">+ (object&lt;Mutation&gt;)readIndividualsFromVCF(string$ filePath, [Nio&lt;MutationType&gt;$ mutationType = NULL])</p>
<p class="p6">Read new mutations from the VCF format file at <span class="s1">filePath</span> and add them to the target individuals.<span class="Apple-converted-space">  </span>The number of target individuals must match the number of samples represented in the VCF file; each sample will be associated with a corresponding target individual, in the order that the samples and the target individuals are provided.<span class="Apple-converted-space">  </span>To read into all of the individuals in a given subpopulation <span class="s1">pN</span>, simply call <span class="s1">pN.individuals.readIndividualsFromVCF()</span>, assuming the subpopulation’s size matches the number of samples in the VCF file.<span class="Apple-converted-space">  </span>A vector containing all of the mutations created by <span class="s1">readIndividualsFromVCF()</span> is returned (not necessarily in the order of the corresponding VCF call lines).</p>
<p class="p6">This method and the <span class="s1">readHaplosomesFromVCF()</span> method of <span class="s1">Haplosome</span> provide two alternative ways of reading VCF data, focused on the perspective of either individuals (this method) or haplosomes (the <span class="s1">Haplosome</span> method).<span class="Apple-converted-space">  </span>As described above, this method draws a correspondence between VCF samples and individuals, whereas the <span class="s1">Haplosome</span> method draws a correspondence between VCF calls and haplosomes.<span class="Apple-converted-space">  </span>For example, if a VCF call line contained a series of calls like “<span class="s1">1|1 0|1 1 0 1|0</span>” this method would see that as calls for five individuals, three of which are diploid for the chromosome being called, and two of which are haploid.<span class="Apple-converted-space">  </span>That would make sense if, for example, the chromosome being called is an X chromosome; the diploid individuals would be females, the haploid individuals would be males.<span class="Apple-converted-space">  </span>The vector of target individuals would need to contain two females, then two males, and then a female, so that the structure of the calls matched the haplosome structure of the individuals, or an error would result.<span class="Apple-converted-space">  </span>The <span class="s1">readHaplosomesFromVCF()</span> method of <span class="s1">Haplosome</span>, on the other hand, would see that same series of calls as corresponding to eight haplosomes, and would assign each call to the corresponding non-null target haplosome, without regard to whether the VCF’s grouping into diploid and haploid calls corresponded to any coherent structure of individuals in the SLiM model.<span class="Apple-converted-space">  </span>Each approach has advantages and disadvantages.<span class="Apple-converted-space">  </span>This method provides much more error-checking and safety when your intention is to read individual-level data from VCF; it can check that the ploidy in the VCF data matches the ploidy of each target individual, and that diploid calls like <span class="s1">1|1</span> get assigned to the two haplosomes of a single individual correctly.<span class="Apple-converted-space">  </span>The <span class="s1">readHaplosomesFromVCF()</span> method of <span class="s1">Haplosome</span> does not perform such checks, and can push VCF data into any arbitrary set of haplosomes, so it provides more power and flexibility, but less error-checking and less intelligence.</p>
<p class="p6">Because this method works at the level of individuals, it can read VCF data associated with multiple chromosomes into a multi-chromosome SLiM model and place mutations into the correct haplosomes of each individual based upon the <span class="s1">CHROM</span> column of the VCF file (which <span class="s1">readHaplosomesFromVCF()</span> cannot do).<span class="Apple-converted-space">  </span>For this to work, the values in the <span class="s1">CHROM</span> column of the call lines must correspond exactly to chromosome symbols in the SLiM model, as provided to <span class="s1">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>The call lines in the input file may be in any order (they do not have to be sorted by <span class="s1">CHROM</span> value, or any other such requirement).<span class="Apple-converted-space">  </span>The vector of mutations returned will contain all of the mutations created; when reading multi-chromosome data, that returned vector will therefore contain a mix of mutations with different associated chromosomes.<span class="Apple-converted-space">  </span>Alternatively, it would work equally well to make a separate call to <span class="s1">readIndividualsFromVCF()</span> for each chromosome, providing each call with a separate VCF file that contains only the mutations associated with one chromosome; in that case, each call would return only the mutations added to the chromosome associated with that call, which might be more convenient if post-processing of the returned mutations is necessary.</p>
<p class="p6">As in <span class="s1">readHaplosomesFromVCF()</span>, a call of <span class="s1">~</span> represents the fact that an individual has no genetic information for the chromosome being called; for example, a call line for a mutation on a Y chromosome should have haploid calls for male individuals (they have or do not have the called mutation), and calls of <span class="s1">~</span> for female individuals (they have no Y haplosome at all).<span class="Apple-converted-space">  </span>This convention was invented for SLiM, since the VCF standard does not seem to say anything about how sex chromosomes should be represented (or anything about other types of chromosomes that might be absent from some individuals).</p>
<p class="p6">The <span class="s1">readHaplosomesFromVCF()</span> method’s documentation provides many important details on how SLiM treats various VCF fields during input; those details will not be repeated here, for brevity.</p>
<p class="p5">– (float)relatedness(object&lt;Individual&gt; individuals, [Niso&lt;Chromosome&gt;$ chromosome = NULL])</p>
<p class="p6">Returns a vector containing the degrees of relatedness between the receiver and each of the individuals in <span class="s1">individuals</span>.<span class="Apple-converted-space">  </span>The relatedness between <span class="s1">A</span> and <span class="s1">B</span> is always <span class="s1">1.0</span> if <span class="s1">A</span> and <span class="s1">B</span> are actually the same individual; this facility works even if SLiM’s optional pedigree tracking is not enabled (in which case all other relatedness values will be <span class="s1">0.0</span>).<span class="Apple-converted-space">  </span>Otherwise, if pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, this method will use the pedigree information to construct a relatedness estimate.<span class="Apple-converted-space">  </span>The relatedness is calculated based upon the type of the chromosome specified by <span class="s1">chromosome</span> (as an <span class="s1">integer</span> id, a <span class="s1">string</span> symbol, or a <span class="s1">Chromosome</span> object); if <span class="s1">chromosome</span> is <span class="s1">NULL</span>, it is assumed to be the single chromosome present in the model, or if more than one chromosome is present, an error results and the chromosome must be explicitly given.</p>
<p class="p6">More specifically, this method uses all available pedigree information from the grandparental and parental pedigree records of <span class="s1">A</span> and <span class="s1">B</span> to compute an estimate of the degree of consanguinity between <span class="s1">A</span> and <span class="s1">B</span>.<span class="Apple-converted-space">  </span>When considering a diploid autosome, siblings have a relatedness of <span class="s1">0.5</span>, as do parents to their children and vice versa; cousins have a relatedness of <span class="s1">0.125</span>; and so forth.<span class="Apple-converted-space">  </span>If, according to the pedigree information available, <span class="s1">A</span> and <span class="s1">B</span> have no blood relationship, the value returned is <span class="s1">0.0</span>.<span class="Apple-converted-space">  </span>Note that the value returned by <span class="s1">relatedness()</span> is what is called the “coefficient of relationship” between the two individuals (Wright, 1922; <a href="https://doi.org/10.1086/279872"><span class="s12">https://doi.org/10.1086/279872</span></a>), and ranges from <span class="s1">0.0</span> to <span class="s1">1.0</span>.</p>
<p class="p6">There is another commonly used metric of relatedness, called the “kinship coefficient”, that reflects the probability of identity by descent between two individuals <span class="s1">A</span> and <span class="s1">B</span>.<span class="Apple-converted-space">  </span>In general, it is approximately equal to one-half of the coefficient of relationship; if an approximate estimate of the kinship coefficient is acceptable, especially in models in which individuals are expected to be outbred, you can simply divide <span class="s1">relatedness()</span> by two.<span class="Apple-converted-space">  </span>However, it should be noted that Wright’s coefficient of relationship is <i>not</i> a measure of the probability of identity by descent, and so it is not exactly double the kinship coefficient; they actually measure different things.<span class="Apple-converted-space">  </span>More precisely, the relationship between them is <span class="s2"><i>r</i> = 2<i>φ</i>/sqrt((1+<i>f</i></span><span class="s13"><sub>A</sub></span><span class="s2">)(1+<i>f</i></span><span class="s13"><sub>B</sub></span><span class="s2">))</span>, where <span class="s2"><i>r</i></span> is Wright’s coefficient of relatedness, <span class="s2"><i>φ</i></span> is the kinship coefficient, and <span class="s2"><i>f</i></span><span class="s13"><sub>A</sub></span> and <span class="s2"><i>f</i></span><span class="s13"><sub>B</sub></span> are the inbreeding coefficients of <span class="s1">A</span> and <span class="s1">B</span> respectively.</p>
<p class="p6">Note that this relatedness is simply pedigree-based relatedness, and does not necessarily correspond to genetic relatedness, because of the effects of factors like assortment and recombination.<span class="Apple-converted-space">  </span>If a metric of actual genetic relatedness is desired, tree-sequence recording can be used after simulation is complete, to compute the exact genetic relatedness between individuals based upon the complete ancestry tree (a topic which is beyond the scope of this manual).<span class="Apple-converted-space">  </span>Actual genetic relatedness cannot presently be calculated during a simulation run; the information is implicitly contained in the recorded tree-sequence tables, but calculating it is too computationally expensive to be reasonable.</p>
<p class="p6">This method assumes that the grandparents (or the parents, if grandparental information is not available) are themselves unrelated and that they are not inbred; this assumption is necessary because we have no information about their parentage, since SLiM’s pedigree tracking information only goes back two generations.<span class="Apple-converted-space">  </span>Be aware that in a model where inbreeding or selfing occurs at all (including “incidental selfing”, where a hermaphroditic individual happens to choose itself as a mate), some level of “background relatedness” will be present and this assumption will be violated.<span class="Apple-converted-space">  </span>In such circumstances, <span class="s1">relatedness()</span> will therefore tend to underestimate the degree of relatedness between individuals, and the greater the degree of inbreeding, the greater the underestimation will be.<span class="Apple-converted-space">  </span>If inbreeding is allowed in a model – and particularly if it is common – the results of <span class="s1">relatedness()</span> should therefore not be taken as an estimate of <i>absolute</i> relatedness, but can still be useful as an estimate of <i>relative</i> relatedness (indicating that, say, A appears from the information available to be more closely related to B than it is to C).</p>
<p class="p6">See also <span class="s1">sharedParentCount()</span> for a different metric of relatedness.</p>
<p class="p5"><span class="s3">+ (void)setSpatialPosition(float position)</span></p>
<p class="p6"><span class="s3">Sets the spatial position of the individual (as accessed through the </span><span class="s4">spatialPosition</span><span class="s3"> property).<span class="Apple-converted-space">  </span>The length of </span><span class="s4">position</span><span class="s3"> (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.<span class="Apple-converted-space">  </span>If the spatial dimensionality is zero (as it is by default), it is an error to call this method.<span class="Apple-converted-space">  </span>The elements of </span><span class="s4">position</span><span class="s3"> are set into the values of the </span><span class="s4">x</span><span class="s3">, </span><span class="s4">y</span><span class="s3">, and </span><span class="s4">z</span><span class="s3"> properties (if those properties are encompassed by the spatial dimensionality of the simulation).<span class="Apple-converted-space">  </span>In other words, if the declared dimensionality is </span><span class="s4">"xy"</span><span class="s3">, calling </span><span class="s4">individual.setSpatialPosition(c(1.0, 0.5))</span><span class="s3"> property is equivalent to </span><span class="s4">individual.x = 1.0; individual.y = 0.5</span><span class="s3">; </span><span class="s4">individual.z</span><span class="s3"> is not set (even if a third value is supplied in </span><span class="s4">position</span><span class="s3">) since it is not encompassed by the simulation’s dimensionality in this example.</span></p>
<p class="p6"><span class="s3">Note that this is an Eidos class method, somewhat unusually, which allows it to work in a special way when called on a vector of individuals.<span class="Apple-converted-space">  </span>When the target vector of individuals is non-singleton, this method can do one of two things.<span class="Apple-converted-space">  </span>If </span><span class="s4">position</span><span class="s3"> contains just a single point (i.e., is equal in length to the spatial dimensionality of the model), the spatial position of all of the target individuals will be set to the given point.<span class="Apple-converted-space">  </span>Alternatively, if </span><span class="s4">position</span><span class="s3"> contains one point per target individual (i.e., is equal in length to the number of individuals multiplied by the spatial dimensionality of the model), the spatial position of each target individual will be set to the corresponding point from </span><span class="s4">position</span><span class="s3"> (where the point data is concatenated, not interleaved, just as it would be returned by accessing the </span><span class="s4">spatialPosition</span><span class="s3"> property on the vector of target individuals).<span class="Apple-converted-space">  </span>Calling this method with a </span><span class="s4">position</span><span class="s3"> vector of any other length is an error.</span></p>
<p class="p5">– (integer)sharedParentCount(object&lt;Individual&gt; individuals)</p>
<p class="p6">Returns a vector containing the number of parents shared between the receiver and each of the individuals in <span class="s1">individuals</span>.<span class="Apple-converted-space">  </span>The number of shared parents between <span class="s1">A</span> and <span class="s1">B</span> is always <span class="s1">2</span> if <span class="s1">A</span> and <span class="s1">B</span> are actually the same individual; this facility works even if SLiM’s optional pedigree tracking is not enabled (in which case all other relatedness values will be <span class="s1">0</span>).<span class="Apple-converted-space">  </span>Otherwise, if pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, this method will use the pedigree information to construct a relatedness estimate.</p>
<p class="p6">More specifically, this method uses the parental pedigree IDs from the pedigree records of a pair of individuals to count the number of shared parents between them, such that full siblings (with all of the same parents) have a count of <span class="s1">2</span>, and half siblings (with half of the same parents) have a count of <span class="s1">1</span>.<span class="Apple-converted-space">  </span>If possible parents of the two individuals are <span class="s1">A</span>, <span class="s1">B</span>, <span class="s1">C</span>, and <span class="s1">D</span>, then the shared parent count is as follows, for some illustrative examples.<span class="Apple-converted-space">  </span>The first column showing the two parents of the first individual, the second column showing the two parents of the second individual; note that the two parents of an individual can be the same due to cloning or selfing:</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AB</span> <span class="s1">CD</span> <span class="s14">→</span> <span class="s1">0</span> (no shared parents)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AB</span> <span class="s1">CC</span> <span class="s14">→</span> <span class="s1">0</span> (no shared parents)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AB</span> <span class="s1">AC</span> <span class="s14">→</span> <span class="s1">1</span> (half siblings)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AB</span> <span class="s1">AA</span> <span class="s14">→</span> <span class="s1">1</span> (half siblings)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AA</span> <span class="s1">AB</span> <span class="s14">→</span> <span class="s1">1</span> (half siblings)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AB</span> <span class="s1">AB</span> <span class="s14">→</span> <span class="s1">2</span> (full siblings)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AB</span> <span class="s1">BA</span> <span class="s14">→</span> <span class="s1">2</span> (full siblings)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s1">AA</span> <span class="s1">AA</span> <span class="s14">→</span> <span class="s1">2</span> (full siblings)</p>
<p class="p6">This method does not estimate consanguinity.<span class="Apple-converted-space">  </span>For example, if one individual is itself a parent of the other individual, that is irrelevant for this method.<span class="Apple-converted-space">  </span>Similarly, in simulations of sex chromosomes, the sexes of the parents are irrelevant, even if no genetic material would have been inherited from a given parent.<span class="Apple-converted-space">  </span>See <span class="s1">relatedness()</span> for an assessment of pedigree-based relatedness that does estimate the consanguinity of individuals.<span class="Apple-converted-space">  </span>The <span class="s1">sharedParentCount()</span> method is preferable if your exact question is simply whether individuals are full siblings, half siblings, or non-siblings; in other cases, <span class="s1">relatedness()</span> is probably more useful.</p>
<p class="p3">–<span class="s9"> </span>(float$)sumOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the sum of the selection coefficients of all mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the haplosomes of the individual.<span class="Apple-converted-space">  </span>This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, <span class="s1">sumOfMutationsOfType()</span> will provide the sum of the additive effects of the QTLs for the given mutation type.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="Apple-converted-space">  </span>Note that this method also exists on <span class="s1">Haplosome</span>, for cases in which the sum for just one haplosome is desired.</p>
<p class="p3">–<span class="s9"> </span>(object&lt;Mutation&gt;)uniqueMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p6"><b>This method has been deprecated, and may be removed in a future release of SLiM.</b><span class="Apple-converted-space">  </span>Its functionality was replaced by <span class="s1">mutationsFromHaplosomes()</span> in SLiM 5.0.</p>
<p class="p6">Returns an <span class="s1">object</span> vector of all the mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the individual.<span class="Apple-converted-space">  </span>Mutations present in both homologous haplosomes will occur only once in the result of this method, and the mutations for a given chromosomes will be given in sorted order by <span class="s1">position</span>, so in single-chromosome simulations this method is similar to <span class="s1">sortBy(unique(individual.haplosomes.mutationsOfType(mutType)), "position")</span>.<span class="Apple-converted-space">  </span>(Even with a single chromosome it is not identical to that call, since if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by <span class="s1">sortBy()</span>.)<span class="Apple-converted-space">  </span>If you just need a count of the matching <span class="s1">Mutation</span> objects, rather than a vector of the matches, use <span class="s1">-countOfMutationsOfType()</span>.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="Apple-converted-space">  </span>Indeed, it is faster than just <span class="s1">individual.haplosomes.mutationsOfType(mutType)</span>, and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.</p>
<p class="p1"><b>5.8<span class="Apple-converted-space">  </span>Class InteractionType</b></p>
<p class="p2"><i>5.8.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>InteractionType</i></span><i> properties</i></p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this interaction type; for interaction type <span class="s1">i3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">maxDistance &lt;–&gt; (float$)</p>
<p class="p4">The maximum distance over which this interaction will be evaluated.<span class="Apple-converted-space">  </span>For inter-individual distances greater than <span class="s1">maxDistance</span><span class="s2">,</span> the interaction strength will be zero.</p>
<p class="p3">reciprocal =&gt; (logical$)</p>
<p class="p4">The reciprocality of the interaction, as specified in <span class="s1">initializeInteractionType()</span>.<span class="Apple-converted-space">  </span>This will be <span class="s1">T</span> for reciprocal interactions (those for which the interaction strength of B upon A is equal to the interaction strength of A upon B), and <span class="s1">F</span> otherwise.</p>
<p class="p3">sexSegregation =&gt; (string$)</p>
<p class="p6">The sex-segregation of the interaction, as specified in <span class="s1">initializeInteractionType()</span> or with <span class="s1">setConstraints()</span>.<span class="Apple-converted-space">  </span>For non-sexual simulations, this will be <span class="s1">"**"</span>.<span class="Apple-converted-space">  </span>For sexual simulations, this <span class="s1">string</span> value indicates the sex of individuals feeling the interaction, and the sex of individuals exerting the interaction; see <span class="s1">initializeInteractionType()</span> for details.</p>
<p class="p3">spatiality =&gt; (string$)</p>
<p class="p4">The spatial dimensions used by the interaction, as specified in <span class="s1">initializeInteractionType()</span>.<span class="Apple-converted-space">  </span>This will be <span class="s1">""</span> (the empty string) for non-spatial interactions, or <span class="s1">"x"</span>, <span class="s1">"y"</span>, <span class="s1">"z"</span>, <span class="s1">"xy"</span>, <span class="s1">"xz"</span>, <span class="s1">"yz"</span>, or <span class="s1">"xyz"</span>, for interactions using those spatial dimensions respectively.<span class="Apple-converted-space">  </span>The specified dimensions are used to calculate the distances between individuals for this interaction.<span class="Apple-converted-space">  </span>The value of this property is always the same as the value given to <span class="s1">initializeInteractionType()</span><span class="s2">.</span></p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to interaction types.</p>
<p class="p2"><i>5.8.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>InteractionType</i></span><i> methods</i></p>
<p class="p5">– (float)clippedIntegral(No&lt;Individual&gt; receivers)</p>
<p class="p6">Returns a vector containing the integral of the interaction function as experienced by each of the individuals in <span class="s1">receivers</span>.<span class="Apple-converted-space">  </span>For each given individual, the interaction function is clipped to the edges of the spatial bounds of the subpopulation that individual inhabits; the individual’s spatial position must be within bounds or an error is raised.<span class="Apple-converted-space">  </span>A periodic boundary will, correctly, not clip the interaction function.<span class="Apple-converted-space">  </span>The interaction function is also clipped to the interaction’s maximum distance; that distance must be less than half of the extent of the spatial bounds in each dimension (so that, for a given dimension, the interaction function is clipped by the spatial bounds on only one side), otherwise an error is raised.<span class="Apple-converted-space">  </span>Note that receiver constraints are not applied; an individual might not actually receive any interactions because of those constraints, but it is still considered to have the same interaction function integral.<span class="Apple-converted-space">  </span>If <span class="s1">receivers</span> is <span class="s1">NULL</span>, the maximal integral is returned, as would be experienced by an individual farther than the maximum distance from any edge.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver subpopulation, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">The computed value of the integral is not exact; it is calculated by an approximate numerical method designed to be fast, but the error should be fairly small (typically less than 1% from the true value).<span class="Apple-converted-space">  </span>A large amount of computation will occur the first time this method is called (perhaps taking more than a second, depending upon hardware), but subsequent calls should be very fast.<span class="Apple-converted-space">  </span>This method does not invoke <span class="s1">interaction()</span> callbacks; the calculated integrals are only for the interaction function itself, and so will not be accurate if <span class="s1">interaction()</span> callbacks modify the relationship between distance and interaction strength.<span class="Apple-converted-space">  </span>For this reason, the overhead of the first call will <i>not</i> reoccur when individuals move or when the interaction is re-evaluated; for typical models, the initial overhead will be incurred only once.<span class="Apple-converted-space">  </span>The initial overhead will reoccur, however, if the interaction function itself, or the maximum interaction distance, are changed; frequent change of those parameters may render the performance of this method unacceptable.</p>
<p class="p6">The integral values returned by <span class="s1">clippedIntegral()</span> can be useful for computing interaction metrics that are scaled by the amount of “interaction field” (to coin a term) that is present for a given individual, producing metrics of interaction <i>density</i>.<span class="Apple-converted-space">  </span>Notably, the <span class="s1">localPopulationDensity()</span> method automatically incorporates the mechanics of <span class="s1">clippedIntegral()</span> into the calculations it performs; see that method’s documentation for further discussion of this concept.<span class="Apple-converted-space">  </span>This approach can also be useful with the <span class="s1">interactingNeighborCount()</span> method, provided that the interaction function is of type <span class="s1">"f"</span> (since the neighbor count does not depend upon interaction strength).</p>
<p class="p5">– (float)distance(object&lt;Individual&gt;$ receiver, [No&lt;Individual&gt; exerters = NULL])</p>
<p class="p6">Returns a vector containing distances between <span class="s1">receiver</span> and the individuals in <span class="s1">exerters</span>.<span class="Apple-converted-space">  </span>If <span class="s1">exerters</span> is <span class="s1">NULL</span> (the default), then a vector of the distances from <span class="s1">receiver</span> to all individuals in its subpopulation (including itself) is returned; this case may be handled differently internally, for greater speed, so supplying <span class="s1">NULL</span> is preferable to supplying the vector of all individuals in the subpopulation explicitly.<span class="Apple-converted-space">  </span>Otherwise, all individuals in <span class="s1">exerters</span> must belong to a single subpopulation (but not necessarily the same subpopulation as <span class="s1">receiver</span>).<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">Importantly, distances are calculated according to the spatiality of the <span class="s1">InteractionType</span> (as declared in <span class="s1">initializeInteractionType()</span>), not the dimensionality of the model as a whole (as declared in <span class="s1">initializeSLiMOptions()</span>).<span class="Apple-converted-space">  </span>The distances returned are therefore the distances that would be used to calculate interaction strengths.<span class="Apple-converted-space">  </span>However, <span class="s1">distance()</span> will return finite distances for all pairs of individuals, even if the individuals are non-interacting due to the maximum interaction distance or the interaction constraints; the <span class="s1">distance()</span> between an individual and itself will thus be <span class="s1">0</span>.<span class="Apple-converted-space">  </span>See <span class="s1">interactionDistance()</span> for an alternative distance definition.</p>
<p class="p5">– (float)distanceFromPoint(float point, object&lt;Individual&gt; exerters)</p>
<p class="p6">Returns a vector containing distances between the point given by the spatial coordinates in <span class="s1">point</span>, which may be thought of as the “receiver”, and individuals in <span class="s1">exerters</span>.<span class="Apple-converted-space">  </span>The <span class="s1">point</span> vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if the interaction type’s spatiality is <span class="s1">"xz"</span>, for example, then <span class="s1">point[0]</span> is assumed to be an <i>x</i> value, and <span class="s1">point[1]</span> is assumed to be a <i>z</i> value, and <span class="s1">point</span> must be exactly two elements in length.<span class="Apple-converted-space">  </span>Be careful; this means that in general it is not safe to pass an individual’s <span class="s1">spatialPosition</span> property for <span class="s1">point</span>, for example (although it is safe if the spatiality of the interaction matches the dimensionality of the simulation); other properties on <span class="s1">Individual</span> exist for getting the individual’s coordinates in a particular spatiality, such as the <span class="s1">xz</span> property for this example.<span class="Apple-converted-space">  </span>A coordinate for a periodic spatial dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic bounds are meaningless (<span class="s1">pointPeriodic()</span> may be used to ensure this); coordinates for non-periodic spatial dimensions are not restricted.</p>
<p class="p6">All individuals in <span class="s1">exerters</span> must belong to a single subpopulation; the <span class="s1">evaluate()</span> method must have been previously called for that subpopulation, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">Importantly, distances are calculated according to the spatiality of the <span class="s1">InteractionType</span> (as declared in <span class="s1">initializeInteractionType()</span>) not the dimensionality of the model as a whole (as declared in <span class="s1">initializeSLiMOptions()</span>).<span class="Apple-converted-space">  </span>The distances are therefore interaction distances: the distances that are used to calculate interaction strengths.<span class="Apple-converted-space">  </span>However, the maximum interaction distance and interaction constraints are not used.</p>
<p class="p6">This method replaces the <span class="s1">distanceToPoint()</span> method that existed prior to SLiM 4.</p>
<p class="p5">– (object)drawByStrength(object&lt;Individual&gt; receiver, [integer$ count = 1], [No&lt;Subpopulation&gt;$ exerterSubpop = NULL], [logical$ returnDict = F])</p>
<p class="p6">Returns an <span class="s1">object&lt;Individual&gt;</span> vector containing up to <span class="s1">count</span> individuals drawn from <span class="s1">exerterSubpop</span>, or if that is <span class="s1">NULL</span> (the default), then from the subpopulation of <span class="s1">receiver</span>, which must be singleton in the default mode of operation (but see below).<span class="Apple-converted-space">  </span>The probability of drawing particular individuals is proportional to the strength of interaction they exert upon <span class="s1">receiver</span> (which is zero for <span class="s1">receiver</span> itself).<span class="Apple-converted-space">  </span>All exerters must belong to a single subpopulation (but not necessarily the same subpopulation as <span class="s1">receiver</span>).<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.</p>
<p class="p6">This method may be used with either spatial or non-spatial interactions, but will be more efficient with spatial interactions that set a short maximum interaction distance.<span class="Apple-converted-space">  </span>Draws are done with replacement, so the same individual may be drawn more than once; sometimes using <span class="s1">unique()</span> on the result of this call is therefore desirable.<span class="Apple-converted-space">  </span>If more than one draw will be needed, it is much more efficient to use a single call to <span class="s1">drawByStrength()</span>, rather than drawing individuals one at a time.<span class="Apple-converted-space">  </span>Note that if no individuals exert a non-zero interaction strength upon <span class="s1">receiver</span>, the vector returned will be zero-length; it is important to consider this possibility.</p>
<p class="p6">Beginning in SLiM 4.1, this method has a vectorized mode of operation in which the <span class="s1">receiver</span> parameter may be non-singleton.<span class="Apple-converted-space">  </span>To switch the method to this mode, pass <span class="s1">T</span> for <span class="s1">returnDict</span>, rather than the default of <span class="s1">F</span> (the operation of which is described above).<span class="Apple-converted-space">  </span>In this mode, the return value is a <span class="s1">Dictionary</span> object instead of a vector of <span class="s1">Individual</span> objects.<span class="Apple-converted-space">  </span>This dictionary uses <span class="s1">integer</span> keys that range from <span class="s1">0</span> to <span class="s1">N-1</span>, where <span class="s1">N</span> is the number of individuals passed in <span class="s1">receiver</span>; these keys thus correspond directly to the indices of the individuals in <span class="s1">receiver</span>, and there is one entry in the dictionary for each receiver.<span class="Apple-converted-space">  </span>The value in the dictionary, for a given <span class="s1">integer</span> key, is an <span class="s1">object&lt;Individual&gt;</span> vector with the individuals drawn for the corresponding receiver, exactly as described above for the non-vectorized case.<span class="Apple-converted-space">  </span>The results for each receiver can therefore be obtained from the returned dictionary with <span class="s1">getValue()</span>, passing the index of the receiver.<span class="Apple-converted-space">  </span>The speed of this mode of operation will probably be similar to the speed of making <span class="s1">N</span> separate non-vectorized calls to <span class="s1">drawByStrength()</span>, when running single-threaded.<span class="Apple-converted-space">  </span>When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.<span class="Apple-converted-space">  </span>In this mode of operation, all receivers must belong to the same subpopulation.</p>
<p class="p3">– (void)evaluate(io&lt;Subpopulation&gt; subpops)</p>
<p class="p6">Snapshots model state in preparation for the use of the interaction, for the receiver and exerter subpopulations specified by <span class="s1">subpops</span>.<span class="Apple-converted-space">  </span>The subpopulations may be supplied either as <span class="s1">integer</span> IDs, or as <span class="s1">Subpopulation</span> objects.<span class="Apple-converted-space">  </span>This method will discard all previously cached data for the subpopulation(s), and will cache the current spatial positions of all individuals they contain (so that the spatial positions of those individuals may then change without disturbing the state of the interaction at the moment of evaluation).<span class="Apple-converted-space">  </span>It will also cache which individuals in the subpopulation are eligible to act as exerters, according to the configured exerter constraints, but it will <i>not</i> cache such eligibility information for receiver constraints (which are applied at the time a spatial query is made).<span class="Apple-converted-space">  </span>Particular interaction distances and strengths are not computed by <span class="s1">evaluate()</span>, and <span class="s1">interaction()</span> callbacks will not be called in response to this method; that work is deferred until required to satisfy a query (at which point the tick and cycle counters may have advanced, so be careful with the tick ranges used in defining <span class="s1">interaction()</span> callbacks).</p>
<p class="p6">You must explicitly call <span class="s1">evaluate()</span> at an appropriate time in the tick cycle before the interaction is used, but after any relevant changes have been made to the population.<span class="Apple-converted-space">  </span>SLiM will invalidate any existing interactions after any portion of the tick cycle in which new individuals have been born or existing individuals have died.<span class="Apple-converted-space">  </span>In a WF model, this occurs just before <span class="s1">late()</span> events execute (see the WF tick cycle diagram), so <span class="s1">late()</span> events are often the appropriate place to put <span class="s1">evaluate()</span> calls, but <span class="s1">first()</span> or <span class="s1">early()</span> events can work too if the interaction is not needed until that point in the tick cycle anyway. In nonWF models, on the other hand, new offspring are produced just before <span class="s1">early()</span> events and then individuals die just before <span class="s1">late()</span> events (see the nonWF tick cycle diagram), so interactions will be invalidated twice during each tick cycle.<span class="Apple-converted-space">  </span>This means that in a nonWF model, an interaction that influences reproduction should usually be evaluated in a <span class="s1">first()</span> event, while an interaction that influences fitness or mortality should usually be evaluated in an <span class="s1">early()</span> event (and an interaction that affects both may need to be evaluated at both times).</p>
<p class="p6">If an interaction is never evaluated for a given subpopulation, it is guaranteed that there will be essentially no memory or computational overhead associated with the interaction for that subpopulation.<span class="Apple-converted-space">  </span>Furthermore, attempting to query an interaction for a receiver or exerter in a subpopulation that has not been evaluated is guaranteed to raise an error.</p>
<p class="p5">– (integer)interactingNeighborCount(object&lt;Individual&gt; receivers, [No&lt;Subpopulation&gt;$ exerterSubpop = NULL])</p>
<p class="p6">Returns the number of interacting individuals for each individual in <span class="s1">receivers</span>, within the maximum interaction distance according to the distance metric of the <span class="s1">InteractionType</span>, from among the exerters in <span class="s1">exerterSubpop</span> (or, if that is <span class="s1">NULL</span>, then from among all individuals in the receiver’s subpopulation).<span class="Apple-converted-space">  </span>More specifically, this method counts the number of individuals which can exert an interaction upon each receiver (which does not include the receiver itself).<span class="Apple-converted-space">  </span>All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.</p>
<p class="p6">This method is similar to <span class="s1">nearestInteractingNeighbors()</span> (when passed a large count so as to guarantee that all interacting individuals are returned), but this method returns only a count of the interacting individuals, not a vector containing the individuals.</p>
<p class="p6">Note that this method uses interaction eligibility as a criterion; it will not count neighbors that do not exert an interaction upon a given receiver (due to the configured receiver or exerter constraints).<span class="Apple-converted-space">  </span>(It also does not count a receiver as a neighbor of itself.)<span class="Apple-converted-space">  </span>If a count of all neighbors is desired, rather than just interacting neighbors, use <span class="s1">neighborCount()</span>.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p5"><span class="s3">– (float)interactionDistance(object&lt;Individual&gt;$ receiver, [No&lt;Individual&gt; exerters = NULL])</span></p>
<p class="p6">Returns a vector containing interaction-dependent distances between <span class="s1">receiver</span> and individuals in <span class="s1">exerters</span>.<span class="Apple-converted-space">  </span>If <span class="s1">exerters</span> is <span class="s1">NULL</span> (the default), then a vector of the interaction-dependent distances from <span class="s1">receiver</span> to all individuals in its subpopulation (including <span class="s1">receiver</span> itself) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.<span class="Apple-converted-space">  </span>Otherwise, all individuals in <span class="s1">exerters</span> must belong to a single subpopulation (but not necessarily the same subpopulation as <span class="s1">receiver</span>).<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">Importantly, distances are calculated according to the spatiality of the <span class="s1">InteractionType</span> (as declared in <span class="s1">initializeInteractionType()</span>), not the dimensionality of the model as a whole (as declared in <span class="s1">initializeSLiMOptions()</span>).<span class="Apple-converted-space">  </span>The distances returned are therefore the distances that would be used to calculate interaction strengths.<span class="Apple-converted-space">  </span>In addition, <span class="s1">interactionDistance()</span> will return <span class="s1">INF</span> as the distance between <span class="s1">receiver</span> and any individual which does not exert an interaction upon <span class="s1">receiver</span>; the <span class="s1">interactionDistance()</span> between an individual and itself will thus be <span class="s1">INF</span>, and likewise for pairs excluded from interacting by receiver constraints, exerter constraints, or the maximum interaction distance of the interaction type.<span class="Apple-converted-space">  </span>See <span class="s1">distance()</span> for an alternative distance definition.</p>
<p class="p5">– (float)localPopulationDensity(object&lt;Individual&gt; receivers, [No&lt;Subpopulation&gt;$ exerterSubpop = NULL])</p>
<p class="p6">Returns a vector of the local population density present at the location of each individual in <span class="s1">receivers</span>, which does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.<span class="Apple-converted-space">  </span>However, all receivers must be in the same subpopulation.<span class="Apple-converted-space">  </span>The local population density is computed from exerters in <span class="s1">exerterSubpop</span>, or if that is <span class="s1">NULL</span> (the default), then from the receiver’s subpopulation.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.</p>
<p class="p6">Population density is estimated using interaction strengths, effectively doing a kernel density estimate using the interaction function as the kernel.<span class="Apple-converted-space">  </span>What is returned is computed as the total interaction strength present at a given point, divided by the integral of the interaction function around that point after clipping by the spatial bounds of the exerter subpopulation (what one might think of as the amount of “interaction field” around the point).<span class="Apple-converted-space">  </span>This provides an estimate of local population density, in units of individuals per unit area, as a weighted average over the area covered by the interaction function, where the weight of each exerter in the average is the value of the interaction function at that exerter’s position.<span class="Apple-converted-space">  </span>This can also be thought of as a measure of the amount of interaction happening per unit of interaction field in the space surrounding the point.</p>
<p class="p6">To calculate the clipped integral of the interaction function, this method uses the same numerical estimator used by the <span class="s1">clippedIntegral()</span> method of <span class="s1">InteractionType</span>, and all of the caveats described for that method apply here also; notably, all individuals must be within spatial bounds, the maximum interaction distance must be less than half the spatial extent of the subpopulation, and <span class="s1">interaction()</span> callbacks are not used (and so, for this method, are not allowed to be active).<span class="Apple-converted-space">  </span>See the documentation for <span class="s1">clippedIntegral()</span> for further discussion of the details of these calculations.</p>
<p class="p6">To calculate the total interaction strength around the position of a receiver, this method uses the same machinery as the <span class="s1">totalOfNeighborStrengths()</span> method of <span class="s1">InteractionType</span>, <i>except</i> that – in contrast to other <span class="s1">InteractionType</span> methods – the interaction strength exerted by the receiver itself is included in the total (if the exerter subpopulation is the receiver’s own subpopulation).<span class="Apple-converted-space">  </span>This is because population density at the location of an individual includes the individual itself.<span class="Apple-converted-space">  </span>If this is not desirable, the <span class="s1">totalOfNeighborStrengths()</span> method should probably be used.</p>
<p class="p6">To see the point of this method, consider a receiver located near the edge of the spatial bounds of its subpopulation.<span class="Apple-converted-space">  </span>Some portion of the interaction function that surrounds that receiver falls outside the spatial bounds of its subpopulation, and will therefore never contain an interacting exerter.<span class="Apple-converted-space">  </span>If, for example, interaction strengths are used as a measure of competition, this receiver will therefore have an advantage, because it will never feel any competition from the portion of its range that falls outside spatial bounds.<span class="Apple-converted-space">  </span>However, that portion of its range is presumably also not available to the receiver itself, for foraging or hunting, in which case this advantage is not biologically realistic, but is instead just an undesirable “edge effect” artifact.<span class="Apple-converted-space">  </span>Dividing by the integral of the interaction function, clipped to the spatial bounds, provides a way to compensate for this edge effect.<span class="Apple-converted-space">  </span>A nice side effect of using local population densities instead of total interaction strengths is that the maximum interaction strength passed to <span class="s1">setInteractionFunction()</span> no longer matters; it cancels out when the total interaction strength is divided by the receiver’s clipped integral.<span class="Apple-converted-space">  </span>However, the <i>shape</i> of the interaction function does still matter; it determines the relative weights used for exerters at different distances from the position of the receiver.</p>
<p class="p5">– (object)nearestInteractingNeighbors(object&lt;Individual&gt; receiver, [integer$ count = 1], [No&lt;Subpopulation&gt;$ exerterSubpop = NULL], [logical$ returnDict = F])</p>
<p class="p6">Returns an <span class="s1">object&lt;Individual&gt;</span> vector containing up to <span class="s1">count</span> interacting individuals that are spatially closest to <span class="s1">receiver</span>, according to the distance metric of the <span class="s1">InteractionType</span>, from among the exerters in <span class="s1">exerterSubpop</span> (or, if that is <span class="s1">NULL</span>, then from among all individuals in the receiver’s subpopulation).<span class="Apple-converted-space">  </span>More specifically, this method returns only individuals which can exert an interaction upon <span class="s1">receiver</span>, which must be singleton in the default mode of operation (but see below).<span class="Apple-converted-space">  </span>To obtain all of the interacting individuals within the maximum interaction distance of <span class="s1">receiver</span>, simply pass a value for <span class="s1">count</span> that is greater than or equal to the size of the exerter subpopulation.<span class="Apple-converted-space">  </span>Note that if fewer than <span class="s1">count</span> interacting individuals are within the maximum interaction distance, the vector returned may be shorter than <span class="s1">count</span>, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.<span class="Apple-converted-space">  </span>If only the number of interacting individuals is needed, use <span class="s1">interactingNeighborCount()</span> instead.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">Note that this method uses interaction eligibility as a criterion; it will not return neighbors that cannot exert an interaction upon the receiver (due to the configured receiver or exerter constraints).<span class="Apple-converted-space">  </span>(It will also never return the receiver as a neighbor of itself.)<span class="Apple-converted-space">  </span>To find all neighbors of a receiver, whether they can interact with it or not, use <span class="s1">nearestNeighbors()</span>.</p>
<p class="p6">Beginning in SLiM 4.1, this method has a vectorized mode of operation in which the <span class="s1">receiver</span> parameter may be non-singleton.<span class="Apple-converted-space">  </span>To switch the method to this mode, pass <span class="s1">T</span> for <span class="s1">returnDict</span>, rather than the default of <span class="s1">F</span> (the operation of which is described above).<span class="Apple-converted-space">  </span>In this mode, the return value is a <span class="s1">Dictionary</span> object instead of a vector of <span class="s1">Individual</span> objects.<span class="Apple-converted-space">  </span>This dictionary uses <span class="s1">integer</span> keys that range from <span class="s1">0</span> to <span class="s1">N-1</span>, where <span class="s1">N</span> is the number of individuals passed in <span class="s1">receiver</span>; these keys thus correspond directly to the indices of the individuals in <span class="s1">receiver</span>, and there is one entry in the dictionary for each receiver.<span class="Apple-converted-space">  </span>The value in the dictionary, for a given <span class="s1">integer</span> key, is an <span class="s1">object&lt;Individual&gt;</span> vector with the interacting neighbors found for the corresponding receiver, exactly as described above for the non-vectorized case.<span class="Apple-converted-space">  </span>The results for each receiver can therefore be obtained from the returned dictionary with <span class="s1">getValue()</span>, passing the index of the receiver.<span class="Apple-converted-space">  </span>The speed of this mode of operation will probably be similar to the speed of making <span class="s1">N</span> separate non-vectorized calls to <span class="s1">nearestInteractingNeighbors()</span>, when running single-threaded.<span class="Apple-converted-space">  </span>When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.<span class="Apple-converted-space">  </span>In this mode of operation, all receivers must belong to the same subpopulation.</p>
<p class="p5">– (object)nearestNeighbors(object&lt;Individual&gt; receiver, [integer$ count = 1], [No&lt;Subpopulation&gt;$ exerterSubpop = NULL], [logical$ returnDict = F])</p>
<p class="p6">Returns an <span class="s1">object&lt;Individual&gt;</span> vector containing up to <span class="s1">count</span> individuals that are spatially closest to <span class="s1">receiver</span>, according to the distance metric of the <span class="s1">InteractionType</span>, from among the exerters in <span class="s1">exerterSubpop</span> (or, if that is <span class="s1">NULL</span>, then from among all individuals in the receiver’s subpopulation).<span class="Apple-converted-space">  </span>In the default mode of operation, <span class="s1">receiver</span> must be singleton (but see below).<span class="Apple-converted-space">  </span>To obtain all of the individuals within the maximum interaction distance of <span class="s1">receiver</span>, simply pass a value for <span class="s1">count</span> that is greater than or equal to the size of <span class="s1">individual</span>’s subpopulation.<span class="Apple-converted-space">  </span>Note that if fewer than <span class="s1">count</span> individuals are within the maximum interaction distance, the vector returned may be shorter than <span class="s1">count</span>, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">Note that this method does not use interaction eligibility as a criterion; it will return neighbors that could not interact with the receiver due to the configured receiver or exerter constraints.<span class="Apple-converted-space">  </span>(It will never return the receiver as a neighbor of itself, however.)<span class="Apple-converted-space">  </span>To find only neighbors that are eligible to exert an interaction upon the receiver, use <span class="s1">nearestInteractingNeighbors()</span>.</p>
<p class="p6">Beginning in SLiM 4.1, this method has a vectorized mode of operation in which the <span class="s1">receiver</span> parameter may be non-singleton.<span class="Apple-converted-space">  </span>To switch the method to this mode, pass <span class="s1">T</span> for <span class="s1">returnDict</span>, rather than the default of <span class="s1">F</span> (the operation of which is described above).<span class="Apple-converted-space">  </span>In this mode, the return value is a <span class="s1">Dictionary</span> object instead of a vector of <span class="s1">Individual</span> objects.<span class="Apple-converted-space">  </span>This dictionary uses <span class="s1">integer</span> keys that range from <span class="s1">0</span> to <span class="s1">N-1</span>, where <span class="s1">N</span> is the number of individuals passed in <span class="s1">receiver</span>; these keys thus correspond directly to the indices of the individuals in <span class="s1">receiver</span>, and there is one entry in the dictionary for each receiver.<span class="Apple-converted-space">  </span>The value in the dictionary, for a given <span class="s1">integer</span> key, is an <span class="s1">object&lt;Individual&gt;</span> vector with the neighbors found for the corresponding receiver, exactly as described above for the non-vectorized case.<span class="Apple-converted-space">  </span>The results for each receiver can therefore be obtained from the returned dictionary with <span class="s1">getValue()</span>, passing the index of the receiver.<span class="Apple-converted-space">  </span>The speed of this mode of operation will probably be similar to the speed of making <span class="s1">N</span> separate non-vectorized calls to <span class="s1">nearestNeighbors()</span>, when running single-threaded.<span class="Apple-converted-space">  </span>When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.<span class="Apple-converted-space">  </span>In this mode of operation, all receivers must belong to the same subpopulation.</p>
<p class="p5">– (object&lt;Individual&gt;)nearestNeighborsOfPoint(float point, io&lt;Subpopulation&gt;$ exerterSubpop, [integer$ count = 1])</p>
<p class="p6">Returns up to <span class="s1">count</span> individuals in <span class="s1">exerterSubpop</span> that are spatially closest to the point given by the spatial coordinates in <span class="s1">point</span>, which may be thought of as the “receiver”, according to the distance metric of the <span class="s1">InteractionType</span>.<span class="Apple-converted-space">  </span>The <span class="s1">point</span> vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if the interaction type’s spatiality is <span class="s1">"xz"</span>, for example, then <span class="s1">point[0]</span> is assumed to be an <i>x</i> value, and <span class="s1">point[1]</span> is assumed to be a <i>z</i> value, and <span class="s1">point</span> must be exactly two elements in length.<span class="Apple-converted-space">  </span>Be careful; this means that in general it is not safe to pass an individual’s <span class="s1">spatialPosition</span> property for <span class="s1">point</span>, for example (although it is safe if the spatiality of the interaction matches the dimensionality of the simulation); other properties on <span class="s1">Individual</span> exist for getting the individual’s coordinates in a particular spatiality, such as the <span class="s1">xz</span> property for this example.<span class="Apple-converted-space">  </span>A coordinate for a periodic spatial dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic bounds are meaningless (<span class="s1">pointPeriodic()</span> may be used to ensure this); coordinates for non-periodic spatial dimensions are not restricted.</p>
<p class="p6">The subpopulation may be supplied either as an <span class="s1">integer</span> ID, or as a <span class="s1">Subpopulation</span> object.<span class="Apple-converted-space">  </span>To obtain all of the individuals within the maximum interaction distance of <span class="s1">point</span>, simply pass a value for <span class="s1">count</span> that is greater than or equal to the size of <span class="s1">exerterSubpop</span>.<span class="Apple-converted-space">  </span>Note that if fewer than <span class="s1">count</span> individuals are within the maximum interaction distance, the vector returned may be shorter than <span class="s1">count</span>, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for <span class="s1">exerterSubpop</span>, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p5">– (integer)neighborCount(object&lt;Individual&gt; receivers, [No&lt;Subpopulation&gt;$ exerterSubpop = NULL])</p>
<p class="p6">Returns the number of neighbors for each individual in <span class="s1">receivers</span>, within the maximum interaction distance according to the distance metric of the <span class="s1">InteractionType</span>, from among the individuals in <span class="s1">exerterSubpop</span> (or, if that is <span class="s1">NULL</span>, then from among all individuals in the receiver’s subpopulation).<span class="Apple-converted-space">  </span>All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.</p>
<p class="p6">This method is similar to <span class="s1">nearestNeighbors()</span> (when passed a large count so as to guarantee that all neighbors are returned), but this method returns only a count of the individuals, not a vector containing the individuals.</p>
<p class="p6">Note that this method does not use interaction eligibility as a criterion; it will count neighbors that cannot exert an interaction upon a receiver (due to the configured receiver or exerter constraints).<span class="Apple-converted-space">  </span>(It still does not count a receiver as a neighbor of itself, however.)<span class="Apple-converted-space">  </span>If a count of only interacting neighbors is desired, use <span class="s1">interactingNeighborCount()</span>.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p5">– (integer$)neighborCountOfPoint(float point, io&lt;Subpopulation&gt;$ exerterSubpop)</p>
<p class="p6">Returns the number of individuals in <span class="s1">exerterSubpop</span> that are within the maximum interaction distance of the point given by the spatial coordinates in <span class="s1">point</span>, which may be thought of as the “receiver”, according to the distance metric of the <span class="s1">InteractionType</span>.<span class="Apple-converted-space">  </span>The <span class="s1">point</span> vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if the interaction type’s spatiality is <span class="s1">"xz"</span>, for example, then <span class="s1">point[0]</span> is assumed to be an <i>x</i> value, and <span class="s1">point[1]</span> is assumed to be a <i>z</i> value, and <span class="s1">point</span> must be exactly two elements in length.<span class="Apple-converted-space">  </span>Be careful; this means that in general it is not safe to pass an individual’s <span class="s1">spatialPosition</span> property for <span class="s1">point</span>, for example (although it is safe if the spatiality of the interaction matches the dimensionality of the simulation); other properties on <span class="s1">Individual</span> exist for getting the individual’s coordinates in a particular spatiality, such as the <span class="s1">xz</span> property for this example.<span class="Apple-converted-space">  </span>A coordinate for a periodic spatial dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic bounds are meaningless (<span class="s1">pointPeriodic()</span> may be used to ensure this); coordinates for non-periodic spatial dimensions are not restricted.</p>
<p class="p6">The subpopulation may be supplied either as an <span class="s1">integer</span> ID, or as a <span class="s1">Subpopulation</span> object.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for <span class="s1">exerterSubpop</span>, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">This method is similar to <span class="s1">nearestNeighborsOfPoint()</span> (when passed a large count so as to guarantee that all neighbors are returned), but this method returns only a count of the individuals, not a vector containing the individuals.</p>
<p class="p5">– (void)setConstraints(string$ who, [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL], [Nl$ tagL0 = NULL], [Nl$ tagL1 = NULL], [Nl$ tagL2 = NULL], [Nl$ tagL3 = NULL], [Nl$ tagL4 = NULL])</p>
<p class="p6">Sets constraints upon which individuals can be receivers and/or exerters, making the target <span class="s1">InteractionType</span> measure interactions between only subsets of the population.<span class="Apple-converted-space">  </span>The parameter <span class="s1">who</span> specifies upon whom the specified constraints apply; it may be <span class="s1">"exerter"</span> to set constraints upon exerters, <span class="s1">"receiver"</span> to set constraints upon receivers, or <span class="s1">"both"</span> to set constraints upon both.<span class="Apple-converted-space">  </span>If <span class="s1">"both"</span> is used, the <i>same</i> constraints are set for both exerters and receivers; <i>different</i> constraints can be set for exerters versus receivers by making a separate call to <span class="s1">setConstraints()</span> for each.<span class="Apple-converted-space">  </span>Constraints only affect queries that involve the concept of interaction; for example, they will affect the result of <span class="s1">nearestInteractingNeighbors()</span>, but not the result of <span class="s1">nearestNeighbors()</span>.<span class="Apple-converted-space">  </span>The constraints specified by a given call to <span class="s1">setConstraints()</span> override all previously set constraints for the category specified (receivers, exerters, or both).</p>
<p class="p6">There is a general policy for the remaining arguments: they are <span class="s1">NULL</span> by default, and if <span class="s1">NULL</span> is used, it specifies “no constraint” for that property (removing any currently existing constraint for that property).<span class="Apple-converted-space">  </span>The <span class="s1">sex</span> parameter constrains the sex of individuals; it may be <span class="s1">"M"</span> or <span class="s1">“F"</span> (or <span class="s1">"*"</span> as another way of specifying no constraint, for historical reasons).<span class="Apple-converted-space">  </span>If <span class="s1">sex</span> is <span class="s1">"M"</span> or <span class="s1">"F"</span>, the individuals to which the constraint is applied (potential receivers/exerters) must belong to a sexual species.<span class="Apple-converted-space">  </span>The <span class="s1">tag</span> parameter constrains the <span class="s1">tag</span> property of individuals; if this set, the individuals to which the constraint is applied must have defined <span class="s1">tag</span> values.<span class="Apple-converted-space">  </span>The <span class="s1">minAge</span> and <span class="s1">maxAge</span> properties constrain the <span class="s1">age</span> property of individuals to the given minimum and/or maximum values; these constraints can only be used in nonWF models.<span class="Apple-converted-space">  </span>The <span class="s1">migrant</span> property constraints the <span class="s1">migrant</span> property of individuals (<span class="s1">T</span> constrains to only migrants, <span class="s1">F</span> to only non-migrants).<span class="Apple-converted-space">  </span>Finally, the <span class="s1">tagL0</span>, <span class="s1">tagL1</span>, <span class="s1">tagL2</span>, <span class="s1">tagL3</span>, and <span class="s1">tagL4</span> properties constrain the corresponding <span class="s1">logical</span> properties of individuals, requiring them to be either <span class="s1">T</span> or <span class="s1">F</span> as specified; the individuals to which these constraints are applied must have defined values for the constrained property or properties.<span class="Apple-converted-space">  </span>Again, <span class="s1">NULL</span> should be supplied (as it is by default) for any property which you do not wish to constrain.</p>
<p class="p6">These constraints may be used in any combination, as desired.<span class="Apple-converted-space">  </span>For example, calling <span class="s1">setConstraints("receivers", sex="M", minAge=5, tagL0=T)</span> constrains the interaction type’s operation so that receivers must be males, with an <span class="s1">age</span> of at least <span class="s1">5</span>, with a <span class="s1">tagL0</span> property value of <span class="s1">T</span>.<span class="Apple-converted-space">  </span>For that configuration the potential receivers used with the interaction type must be sexual (since <span class="s1">sex</span> is specified), must be in a nonWF model (since <span class="s1">minAge</span> is specified), and must have a defined value for their <span class="s1">tagL0</span> property (since that property is constrained).<span class="Apple-converted-space">  </span>Note that the <span class="s1">sexSegregation</span> parameter to <span class="s1">initializeInteractionType()</span> is a shortcut which does the same thing as the corresponding calls to <span class="s1">setConstraints()</span>.</p>
<p class="p6">Exerter constraints are applied at <span class="s1">evaluate()</span> time, whereas receiver constraints are applied at query time; see the <span class="s1">InteractionType</span> class documentation for further discussion.<span class="Apple-converted-space">  </span>The interaction constraints for an interaction type are normally a constant in simulations; in any case, they cannot be changed when an interaction has already been evaluated, so either they should be set prior to evaluation, or <span class="s1">unevaluate()</span> should be called first.</p>
<p class="p3">– (void)setInteractionFunction(string$ functionType, ...)</p>
<p class="p6">Set the function used to translate spatial distances into interaction strengths for an interaction type.<span class="Apple-converted-space">  </span>The <span class="s1">functionType</span> may be <span class="s1">"f"</span>, in which case the ellipsis <span class="s1">...</span> should supply a <span class="s1">numeric$</span> fixed interaction strength; <span class="s1">"l"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> maximum strength for a linear function; <span class="s1">"e"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> maximum strength and a <span class="s1">numeric$</span> lambda (rate) parameter for a negative exponential function; <span class="s1">"n"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> maximum strength and a <span class="s1">numeric$</span> sigma (standard deviation) parameter for a Gaussian function; <span class="s1">"c"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> maximum strength and a <span class="s1">numeric$</span> scale parameter for a Cauchy distribution function; or <span class="s1">"t"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> maximum strength, a <span class="s1">numeric$</span> degrees of freedom, and a <span class="s1">numeric$</span> scale parameter for a <i>t</i>-distribution function.<span class="Apple-converted-space">  </span>See the InteractionType class documentation for discussions of these interaction functions.<span class="Apple-converted-space">  </span>Non-spatial interactions must use function type <span class="s1">"f"</span>, since no distance values are available in that case.</p>
<p class="p6">The interaction function for an interaction type is normally a constant in simulations; in any case, it cannot be changed when an interaction has already been evaluated, so either it should be set prior to evaluation, or <span class="s1">unevaluate()</span> should be called first.</p>
<p class="p5">– (float)strength(object&lt;Individual&gt;$ receiver, [No&lt;Individual&gt; exerters = NULL])</p>
<p class="p6">Returns a vector containing the interaction strengths exerted upon <span class="s1">receiver</span> by the individuals in <span class="s1">exerters</span>.<span class="Apple-converted-space">  </span>If <span class="s1">exerters</span> is <span class="s1">NULL</span> (the default), then a vector of the interaction strengths exerted by all individuals in the subpopulation of <span class="s1">receiver</span> (including <span class="s1">receiver</span> itself, with a strength of <span class="s1">0.0</span>) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.<span class="Apple-converted-space">  </span>Otherwise, all individuals in <span class="s1">exerters</span> must belong to a single subpopulation (but not necessarily the same subpopulation as <span class="s1">receiver</span>).<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.</p>
<p class="p6">If the strengths of interactions exerted by a single individual upon multiple individuals are needed instead (the inverse of what this method provides), multiple calls to this method will be necessary, one per pairwise interaction queried; the interaction engine is not optimized for the inverse case, and so it will likely be quite slow to compute.<span class="Apple-converted-space">  </span>If the interaction is reciprocal and has the same receiver and exerter constraints, the opposite query should provide identical results in a single efficient call (because then the interactions exerted are equal to the interactions received); otherwise, the best approach might be to define a second interaction type representing the inverse interaction that you wish to be able to query efficiently.</p>
<p class="p5">– (lo&lt;Individual&gt;)testConstraints(object&lt;Individual&gt; individuals, string$ constraints, [logical$ returnIndividuals = F])</p>
<p class="p6">Tests the individuals in the parameter <span class="s1">individuals</span> against the interaction constraints specified by <span class="s1">constraints</span>.<span class="Apple-converted-space">  </span>The value of <span class="s1">constraints</span> may be <span class="s1">"receiver"</span> to use the receiver constraints, or <span class="s1">"exerter"</span> to use the exerter constraints.<span class="Apple-converted-space">  </span>If <span class="s1">returnIndividuals</span> is <span class="s1">F</span> (the default), a <span class="s1">logical</span> vector will be returned, with <span class="s1">T</span> values indicating that the corresponding individual satisfied the constraints, <span class="s1">F</span> values indicating that it did not.<span class="Apple-converted-space">  </span>If <span class="s1">returnIndividuals</span> is <span class="s1">T</span>, an <span class="s1">object</span> vector of class <span class="s1">Individual</span> will be returned containing only those elements of <span class="s1">individuals</span> that satisfied the constraints (in the same order as <span class="s1">individuals</span>).<span class="Apple-converted-space">  </span>Note that unlike most queries, the <span class="s1">InteractionType</span> does not need to have been evaluated before calling this method, and the individuals passed in need not belong to a single population or even a single species.</p>
<p class="p6">This method can be useful for narrowing a vector of individuals down to just those that satisfy constraints.<span class="Apple-converted-space">  </span>Outside the context of <span class="s1">InteractionType</span>, similar functionality is provided by the <span class="s1">Subpopulation</span> method <span class="s1">subsetIndividuals()</span>.<span class="Apple-converted-space">  </span>Note that the use of <span class="s1">testConstraints()</span> is somewhat rare; usually, queries are evaluated across a vector of individuals, each of which might or might not satisfy the defined constraints.<span class="Apple-converted-space">  </span>Individuals that do not satisfy constraints do not participate in interactions, so their interaction strength with other individuals will simply be zero.</p>
<p class="p6">See the <span class="s1">setConstraints()</span> method to set up constraints, as well as the <span class="s1">sexSegregation</span> parameter to <span class="s1">initializeInteractionType()</span>.<span class="Apple-converted-space">  </span>Note that if the constraints tested involve <span class="s1">tag</span> values (including <span class="s1">tagL0</span> / <span class="s1">tagL1</span> / <span class="s1">tagL2</span> / <span class="s1">tagL3</span> / <span class="s1">tagL4</span>), the corresponding property or properties of the tested individuals must be defined (i.e., must have been set to a value), or an error will result because the constraints cannot be applied.</p>
<p class="p5">– (float)totalOfNeighborStrengths(object&lt;Individual&gt; receivers, [No&lt;Subpopulation&gt;$ exerterSubpop = NULL])</p>
<p class="p6">Returns a vector of the total interaction strength felt by each individual in <span class="s1">receivers</span> by the exerters in <span class="s1">exerterSubpop</span> (or, if that is <span class="s1">NULL</span>, then by all individuals in the receiver’s subpopulation).<span class="Apple-converted-space">  </span>The <span class="s1">receivers</span> parameter does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.<span class="Apple-converted-space">  </span>All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.<span class="Apple-converted-space">  </span>The <span class="s1">evaluate()</span> method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.</p>
<p class="p6">For one individual, this is essentially the same as calling <span class="s1">nearestInteractingNeighbors()</span> with a large <span class="s1">count</span> so as to obtain the complete vector of all interacting neighbors, calling <span class="s1">strength()</span> for each of those interactions to get each interaction strength, and adding those interaction strengths together with <span class="s1">sum()</span>.<span class="Apple-converted-space">  </span>This method is much faster than that implementation, however, since all of that work is done as a single operation.<span class="Apple-converted-space">  </span>Also, <span class="s1">totalOfNeighborStrengths()</span> can total up interactions for more than one receiver in a single vectorized call.</p>
<p class="p6">Similarly, for one individual this is essentially the same as calling <span class="s1">strength()</span> to get the interaction strengths between a receiver and all individuals in the exerter subpopulation, and then calling <span class="s1">sum()</span>.<span class="Apple-converted-space">  </span>Again, this method should be much faster, since this algorithm looks only at neighbors, whereas calling <span class="s1">strength()</span> directly assesses interaction strengths with all other individuals.<span class="Apple-converted-space">  </span>This will make a particularly large difference when the subpopulation size is large and the maximum distance of the <span class="s1">InteractionType</span> is small.</p>
<p class="p6">See <span class="s1">localPopulationDensity()</span> for a related method that calculates the total interaction strength divided by the amount of “interaction field” present for an individual (i.e., the integral of the interaction function clipped to the spatial bounds of the subpopulation) to provide an estimate of the “interaction density” felt by an individual.</p>
<p class="p3">– (void)unevaluate(void)</p>
<p class="p6">Discards all evaluation of this interaction, for all subpopulations.<span class="Apple-converted-space">  </span>The state of the <span class="s1">InteractionType</span> is reset to a state prior to evaluation.<span class="Apple-converted-space">  </span>This can be useful if the model state has changed in such a way that the evaluation already conducted is no longer valid.<span class="Apple-converted-space">  </span>For example, if the maximum distance, the interaction function, or the receiver or exerter constraints of the <span class="s1">InteractionType</span> need to be changed with immediate effect, or if the data used by an <span class="s1">interaction()</span> callback has changed in such a way that previously calculated interaction strengths are no longer correct, <span class="s1">unevaluate()</span> allows the interaction to begin again from scratch.</p>
<p class="p6"><span class="s3">In WF models, all interactions are automatically reset to an unevaluated state at the moment when the new offspring generation becomes the parental generation (at step 4 in the tick cycle).</span></p>
<p class="p6"><span class="s3">In nonWF models, all interactions are automatically reset to an unevaluated state twice per tick: immediately after </span><span class="s4">reproduction()</span><span class="s3"> callbacks have completed (after step 1 in the tick cycle), and immediately before viability/survival selection (before step 4 in the tick cycle).</span></p>
<p class="p6"><span class="s3">Given this automatic invalidation, most simulations have no reason to call </span><span class="s4">unevaluate()</span><span class="s3">.</span></p>
<p class="p11"><b>5.9<span class="Apple-converted-space">  </span>Class LogFile</b></p>
<p class="p12"><i>5.9.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>LogFile</i></span><i> properties</i></p>
<p class="p5">filePath =&gt; (string$)</p>
<p class="p6">The path of the log file being written to.<span class="Apple-converted-space">  </span>This may be changed with <span class="s1">setFilePath()</span>.</p>
<p class="p5">logInterval =&gt; (integer$)</p>
<p class="p6">The interval for automatic logging; a new row of data will be logged every <span class="s1">logInterval</span> ticks.<span class="Apple-converted-space">  </span>This may be set with the <span class="s1">logInterval</span> parameter to <span class="s1">createLogFile()</span> and changed with <span class="s1">setLogInterval()</span>.<span class="Apple-converted-space">  </span>If automatic logging has been disabled, this property will be <span class="s1">0</span>.</p>
<p class="p5">precision &lt;–&gt; (integer$)</p>
<p class="p6">The precision of <span class="s1">float</span> output.<span class="Apple-converted-space">  </span>To be exact, <span class="s1">precision</span> specifies the preferred number of significant digits that will be output for <span class="s1">float</span> values.<span class="Apple-converted-space">  </span>The default is <span class="s1">6</span>; values in [<span class="s1">1</span>,<span class="s1">22</span>] are legal, but <span class="s1">17</span> is probably the largest value that makes sense given the limits of double-precision floating point.</p>
<p class="p5">tag &lt;–&gt; (integer$)</p>
<p class="p6">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p12"><i>5.9.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>LogFile</i></span><i> methods</i></p>
<p class="p5">– (void)addCustomColumn(string$ columnName, string$ source, [* context = NULL])</p>
<p class="p6">Adds a new data column with its name provided by <span class="s1">columnName</span>.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>The value for the column, when a given row is generated, will be produced by the code supplied in <span class="s1">source</span>, which is expected to return either <span class="s1">NULL</span> (which will write out <span class="s1">NA</span>), or a singleton value of any non-object type.</p>
<p class="p6">The <span class="s1">context</span> parameter will be set up as a pseudo-parameter, named <span class="s1">context</span>, when <span class="s1">source</span> is called, allowing the same source code to be used to generate values for multiple data columns; you might, for example, pass the <span class="s1">id</span> of the particular <span class="s1">Subpopulation</span> object that you wish <span class="s1">source</span> to use for its calculations, and <span class="s1">source</span> could then use the <span class="s1">Community</span> method <span class="s1">subpopulationsWithIDs()</span> to look up the subpopulation from the <span class="s1">id</span> value provided in <span class="s1">context</span>.</p>
<p class="p6">Note that the <span class="s1">Subpopulation</span> object itself cannot be passed in <span class="s1">context</span>, because class <span class="s1">Subpopulation</span> is not under retain-release memory management in SLiM, meaning essentially that subpopulation objects can cease to exist unpredictably (because they go extinct, for example).<span class="Apple-converted-space">  </span>A reference to such an object cannot be kept long-term by your script (including by <span class="s1">LogFile</span>), because if the object ceases to exist, the reference would become invalid and a crash would result.<span class="Apple-converted-space">  </span>Passing such an object – one not under retain-release – to <span class="s1">addCustomColumn()</span> will therefore raise an error, to safeguard against that possible crash.<span class="Apple-converted-space">  </span>The workaround for this limitation is to find a way to look up the desired object, such as the suggestion above of using the subpopulation’s <span class="s1">id</span> to look it up.</p>
<p class="p6">The use of <span class="s1">context</span> is optional; if the default value of <span class="s1">NULL</span> is used, then <span class="s1">context</span> will be <span class="s1">NULL</span> when <span class="s1">source</span> is called.</p>
<p class="p6">See <span class="s1">addMeanSDColumns()</span> for a useful variant.</p>
<p class="p5">– (void)addCycle([No&lt;Species&gt;$ species = NULL])</p>
<p class="p6">Adds a new data column that provides the cycle counter for <span class="s1">species</span> (the same as the value of the <span class="s1">cycle</span> property of that species).<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>In single-species models, <span class="s1">species</span> may be <span class="s1">NULL</span> to indicate that single species.<span class="Apple-converted-space">  </span>The column will simply be named <span class="s1">cycle</span> in single-species models; an underscore and the name of the species will be appended in multispecies models.</p>
<p class="p5">– (void)addCycleStage(void)</p>
<p class="p6">Adds a new data column that provides the cycle stage, named <span class="s1">cycle_stage</span>.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>The stage is provided as a <span class="s1">string</span>, and will typically be <span class="s1">"first"</span>, <span class="s1">"early"</span>, <span class="s1">"late"</span>, or <span class="s1">"end"</span> (the latter used for the point in time at which end-of-tick automatic logging occurs).<span class="Apple-converted-space">  </span>Other possible values are discussed in the documentation for the <span class="s1">cycleStage</span> property of <span class="s1">Community</span>, which this column reflects.</p>
<p class="p5">– (void)addKeysAndValuesFrom(object&lt;Dictionary&gt;$ source)</p>
<p class="p6">This <span class="s1">Dictionary</span> method has an override in <span class="s1">LogFile</span> to make it illegal to call, since <span class="s1">LogFile</span> manages its <span class="s1">Dictionary</span> entries.</p>
<p class="p5">– (void)addMeanSDColumns(string$ columnName, string$ source, [* context = NULL])</p>
<p class="p6">Adds two new data columns with names of <span class="s1">columnName_mean</span> and <span class="s1">columnName_sd</span>.<span class="Apple-converted-space">  </span>The new columns will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>When a given row is generated, the code supplied in <span class="s1">source</span> is expected to return either a zero-length vector of any type including <span class="s1">NULL</span> (which will write out <span class="s1">NA</span> to both columns), or a non-zero-length vector of <span class="s1">integer</span> or <span class="s1">float</span> values.<span class="Apple-converted-space">  </span>In the latter case, the result vector will be summarized in the two columns by its mean and standard deviation respectively.<span class="Apple-converted-space">  </span>If the result vector has exactly one value, the standard deviation will be written as <span class="s1">NA</span>.</p>
<p class="p6">The <span class="s1">context</span> parameter is set up as a pseudo-parameter when <span class="s1">source</span> is called, as described in <span class="s1">addCustomColumn()</span>.<span class="Apple-converted-space">  </span>See the documentation for that method for further discussion of <span class="s1">context</span>, including limitations on its use.</p>
<p class="p5">– (void)addPopulationSexRatio([No&lt;Species&gt;$ species = NULL])</p>
<p class="p6">Adds a new data column that provides the population sex ratio M:(M+F) for <span class="s1">species</span>.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>In single-species models, <span class="s1">species</span> may be <span class="s1">NULL</span> to indicate that single species.<span class="Apple-converted-space">  </span>The column will simply be named <span class="s1">sex_ratio</span> in single-species models; an underscore and the name of the species will be appended in multispecies models.<span class="Apple-converted-space">  </span>If the species is hermaphroditic, <span class="s1">NA</span> will be written.</p>
<p class="p5">– (void)addPopulationSize([No&lt;Species&gt;$ species = NULL])</p>
<p class="p6">Adds a new data column that provides the total population size for <span class="s1">species</span>.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>In single-species models, <span class="s1">species</span> may be <span class="s1">NULL</span> to indicate that single species.<span class="Apple-converted-space">  </span>The column will simply be named <span class="s1">num_individuals</span> in single-species models; an underscore and the name of the species will be appended in multispecies models.</p>
<p class="p5">– (void)addSubpopulationSexRatio(io&lt;Subpopulation&gt;$ subpop)</p>
<p class="p6">Adds a new data column that provides the sex ratio M:(M+F) of the subpopulation <span class="s1">subpop</span>, named <span class="s1">pX_sex_ratio</span>.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>If the subpopulation exists but has a size of zero, <span class="s1">NA</span> will be written.</p>
<p class="p5">– (void)addSubpopulationSize(io&lt;Subpopulation&gt;$ subpop)</p>
<p class="p6">Adds a new data column that provides the size of the subpopulation <span class="s1">subpop</span>, named <span class="s1">pX_num_individuals</span>.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>If the subpopulation exists but has a size of zero, <span class="s1">0</span> will be written.</p>
<p class="p5">– (void)addSuppliedColumn(string$ columnName)</p>
<p class="p6">Adds a new data column with its name provided by <span class="s1">columnName</span>.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.<span class="Apple-converted-space">  </span>The value for the column is initially undefined, and will be written as <span class="s1">NA</span>.<span class="Apple-converted-space">  </span>A different value may (optionally) be provided by calling <span class="s1">setSuppliedValue()</span> with a value for <span class="s1">columnName</span>.<span class="Apple-converted-space">  </span>That value will be used for the column the next time a row is generated (whether automatically or by a call to <span class="s1">logRow()</span>), and the column’s value will subsequently be undefined again.<span class="Apple-converted-space">  </span>In other words, for any given logged row the default of <span class="s1">NA</span> may be kept, or a different value may be supplied.<span class="Apple-converted-space">  </span>This allows the value for the column to be set at any point during the tick cycle, which can be convenient if the column’s value depends upon transient state that is no longer available at the time the row is logged.</p>
<p class="p5">– (void)addTick(void)</p>
<p class="p6">Adds a new data column, named <span class="s1">tick</span>, that provides the tick number for the simulation.<span class="Apple-converted-space">  </span>The new column will be logged each time that a row is generated, either by automatic logging or by a call to <span class="s1">logRow()</span>.</p>
<p class="p5">– (void)clearKeysAndValues(void)</p>
<p class="p6">This <span class="s1">Dictionary</span> method has an override in <span class="s1">LogFile</span> to make it illegal to call, since <span class="s1">LogFile</span> manages its <span class="s1">Dictionary</span> entries.</p>
<p class="p5">– (void)flush(void)</p>
<p class="p6">Flushes all buffered data to the output file, synchronously.<span class="Apple-converted-space">  </span>This will make the contents of the file on disk be up-to-date with the running simulation.<span class="Apple-converted-space">  </span>Flushing frequently may entail a small performance penalty.<span class="Apple-converted-space">  </span>More importantly, if <span class="s1">.gz</span> compression has been requested with <span class="s1">compress=T</span> the size of the resulting file will be larger – potentially much larger – if <span class="s1">flush()</span> is called frequently.<span class="Apple-converted-space">  </span>Note that automatic periodic flushing can be requested with the <span class="s1">flushInterval</span> parameter to <span class="s1">createLogFile()</span>.</p>
<p class="p5">– (void)logRow(void)</p>
<p class="p6">This logs a new row of data, by evaluating all of the generators added to the <span class="s1">LogFile</span> with <span class="s1">add...()</span> calls.<span class="Apple-converted-space">  </span>Note that the new row may be buffered, and thus may not be written out to disk immediately; see <span class="s1">flush()</span>.<span class="Apple-converted-space">  </span>This method may be used instead of, or in conjunction with, automatic logging.</p>
<p class="p6">You can get the <span class="s1">LogFile</span> instance, in order to call <span class="s1">logRow()</span> on it, from <span class="s1">community.logFiles</span>, or you can remember it in a global constant with <span class="s1">defineConstant()</span>.</p>
<p class="p5">– (void)setLogInterval([Ni$ logInterval = NULL])</p>
<p class="p6">Sets the automatic logging interval.<span class="Apple-converted-space">  </span>A <span class="s1">logInterval</span> of <span class="s1">NULL</span> stops automatic logging immediately.<span class="Apple-converted-space">  </span>Other values request that a new row should be logged (as if <span class="s1">logRow()</span> were called) at the end of every <span class="s1">logInterval</span> ticks (just before the tick count increment, in both WF and nonWF models), starting at the end of the tick in which <span class="s1">setLogInterval()</span> was called.</p>
<p class="p5">– (void)setFilePath(string$ filePath, [Ns initialContents = NULL], [logical$ append = F], [Nl$ compress = NULL], [Ns$ sep = NULL], [Nl$ header = NULL])</p>
<p class="p6">Redirects the <span class="s1">LogFile</span> to write new rows to a new <span class="s1">filePath</span>.<span class="Apple-converted-space">  </span>Any rows that have been buffered but not flushed will be written to the previous file first, as if <span class="s1">flush()</span> had been called.<span class="Apple-converted-space">  </span>With this call, new <span class="s1">initialContents</span> may be supplied, which will either replace any existing file or will be appended to it, depending upon the value of <span class="s1">append</span>.<span class="Apple-converted-space">  </span>New values may be supplied for <span class="s1">compress</span>, <span class="s1">sep</span>, and <span class="s1">header</span>; the meaning of these parameters is identical to their meaning in <span class="s1">createLogFile()</span>, except that a value of <span class="s1">NULL</span> for these means “do not change this setting from its previous value”.<span class="Apple-converted-space">  </span>In effect, then, this method lets you start a completely new log file at a new path, without having to create and configure a new <span class="s1">LogFile</span> object.<span class="Apple-converted-space">  </span>The new file will be created (or appended) synchronously, with the specified initial contents.</p>
<p class="p5">– (void)setSuppliedValue(string$ columnName, +$ value)</p>
<p class="p6">Registers a value, passed in <span class="s1">value</span>, to be used for the supplied column named <span class="s1">columnName</span> when a row is next logged.<span class="Apple-converted-space">  </span>This column must have been added with <span class="s1">addSuppliedColumn()</span>.<span class="Apple-converted-space">  </span>A value of <span class="s1">NULL</span> may be passed to log <span class="s1">NA</span>, but logging <span class="s1">NA</span> is the default behavior for supplied columns in any case.<span class="Apple-converted-space">  </span>Otherwise, the value must be a singleton, and its type should match the values previously supplied for the column (otherwise the log file may be difficult to parse, since the values within the column will not be of one consistent type).<span class="Apple-converted-space">  </span>See <span class="s1">addSuppliedColumn()</span> for further details.</p>
<p class="p5">– (void)setValue(is$ key, * value)</p>
<p class="p6">This <span class="s1">Dictionary</span> method has an override in <span class="s1">LogFile</span> to make it illegal to call, since <span class="s1">LogFile</span> manages its <span class="s1">Dictionary</span> entries.</p>
<p class="p5">– (logical$)willAutolog(void)</p>
<p class="p6">Returns <span class="s1">T</span> if the log file is configured to log a new row automatically at the end of the current tick; otherwise, returns <span class="s1">F</span>.<span class="Apple-converted-space">  </span>This is useful for calculating a value that will be logged only in ticks when the value is needed.</p>
<p class="p1"><b>5.10<span class="Apple-converted-space">  </span>Class Mutation</b></p>
<p class="p2"><i>5.10.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Mutation</i></span><i> properties</i></p>
<p class="p5">chromosome =&gt; (object&lt;Chromosome&gt;$)</p>
<p class="p6">The <span class="s1">Chromosome</span> object with which the mutation is associated.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this mutation.<span class="Apple-converted-space">  </span>Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run.<span class="Apple-converted-space">  </span>These identifiers are not re-used during a run, except that if a population file is loaded from disk, the loaded mutations will receive their original identifier values as saved in the population file.</p>
<p class="p5">isFixed =&gt; (logical$)</p>
<p class="p6"><span class="s1">T</span> if the mutation has fixed (in the SLiM sense of having been converted to a <span class="s1">Substitution</span> object), <span class="s1">F</span> otherwise.<span class="Apple-converted-space">  </span>Since fixed/substituted mutations are removed from the simulation, you will only see this flag be <span class="s1">T</span> if you have held onto a mutation beyond its usual lifetime.</p>
<p class="p5">isSegregating =&gt; (logical$)</p>
<p class="p6"><span class="s1">T</span> if the mutation is segregating (in the SLiM sense of not having been either lost or converted to a <span class="s1">Substitution</span> object), <span class="s1">F</span> otherwise.<span class="Apple-converted-space">  </span>Since both lost and fixed/substituted mutations are removed from the simulation, you will only see this flag be <span class="s1">F</span> if you have held onto a mutation beyond its usual lifetime.<span class="Apple-converted-space">  </span>Note that if <span class="s1">isSegregating</span> is <span class="s1">F</span>, <span class="s1">isFixed</span> will let you determine whether the mutation is no longer segregating because it was lost, or because it fixed.</p>
<p class="p3">mutationType =&gt; (object&lt;MutationType&gt;$)</p>
<p class="p4">The <span class="s1">MutationType</span> from which this mutation was drawn.</p>
<p class="p5"><span class="s3">nucleotide &lt;–&gt; (string$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">string</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">.<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p5"><span class="s3">nucleotideValue &lt;–&gt; (integer$)</span></p>
<p class="p6"><span class="s3">An </span><span class="s4">integer</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">0</span><span class="s3"> (A), </span><span class="s4">1</span><span class="s3"> (C), </span><span class="s4">2</span><span class="s3"> (G), or </span><span class="s4">3</span><span class="s3"> (T).<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p3">originTick =&gt; (integer$)</p>
<p class="p4">The tick in which this mutation arose.</p>
<p class="p3">position =&gt; (integer$)</p>
<p class="p4">The position in the chromosome of this mutation.</p>
<p class="p3">selectionCoeff =&gt; (float$)</p>
<p class="p6"><span class="s5">The selection coefficient of the mutation, drawn from the distribution of fitness effects of its </span><span class="s6">MutationType</span><span class="s15">.</span><span class="s3"><span class="Apple-converted-space">  </span>If a mutation has a </span><span class="s4">selectionCoeff</span><span class="s3"> of <i>s</i>, the multiplicative fitness effect of the mutation in a homozygote is 1+<i>s</i>; in a heterozygote it is 1+<i>hs</i>, where <i>h</i> is the dominance coefficient kept by the mutation type.</span></p>
<p class="p4">Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.<span class="Apple-converted-space">  </span>This means that if you set a mutation <span class="s1">mut</span>’s selection coefficient to some number <span class="s1">x</span>, <span class="s1">mut.selectionCoeff==x</span> may be <span class="s1">F</span> due to floating-point rounding error.<span class="Apple-converted-space">  </span>Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.<span class="Apple-converted-space">  </span>Instead, it is recommended to use the <span class="s1">id</span> or <span class="s1">tag</span> properties to identify particular mutations.</p>
<p class="p3">subpopID &lt;–&gt; (integer$)</p>
<p class="p4">The identifier of the subpopulation in which this mutation arose.<span class="Apple-converted-space">  </span>This property can be used to track the ancestry of mutations through their subpopulation of origin.</p>
<p class="p4">If you don’t care which subpopulation a mutation originated in, the <span class="s1">subpopID</span> may be used as an arbitrary <span class="s1">integer</span> “tag” value for any purpose you wish; SLiM does not do anything with the value of <span class="s1">subpopID</span> except propagate it to <span class="s1">Substitution</span> objects and report it in output.<span class="Apple-converted-space">  </span>(It must still be <span class="s1">&gt;= 0</span>, however, since SLiM object identifiers are limited to nonnegative integers).</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p2"><i>5.10.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Mutation</i></span><i> methods</i></p>
<p class="p3">– (void)setMutationType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Set the mutation type of the mutation to <span class="s1">mutType</span> (which may be specified as either an <span class="s1">integer</span> identifier or a <span class="s1">MutationType</span> object).<span class="Apple-converted-space">  </span>This implicitly changes the dominance coefficient of the mutation to that of the new mutation type, since the dominance coefficient is a property of the mutation type.<span class="Apple-converted-space">  </span>On the other hand, the selection coefficient of the mutation is not changed, since it is a property of the mutation object itself; it can be changed explicitly using the <span class="s1">setSelectionCoeff()</span> method if so desired.</p>
<p class="p4">The mutation type of a mutation is normally a constant in simulations, so be sure you know what you are doing.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the <span class="s1">Species</span> method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6"><span class="s3">In nucleotide-based models, a restriction applies: nucleotide-based mutations may not be changed to a non-nucleotide-based mutation type, and non-nucleotide-based mutations may not be changed to a nucleotide-based mutation type.</span></p>
<p class="p3">– (void)setSelectionCoeff(float$ selectionCoeff)</p>
<p class="p4">Set the selection coefficient of the mutation to <span class="s1">selectionCoeff</span>.<span class="Apple-converted-space">  </span>The selection coefficient will be changed for all individuals that possess the mutation, since they all share a single <span class="s1">Mutation</span> object (note that the dominance coefficient will remain unchanged, as it is determined by the mutation type).</p>
<p class="p4">This is normally a constant in simulations, so be sure you know what you are doing; often setting up a <span class="s1">mutationEffect()</span> callback is preferable, in order to modify the selection coefficient in a more limited and controlled fashion.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the <span class="s1">Species</span> method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p1"><b>5.11<span class="Apple-converted-space">  </span>Class MutationType</b></p>
<p class="p2"><i>5.11.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>MutationType</i></span><i> properties</i></p>
<p class="p3">color &lt;–&gt; (string$)</p>
<p class="p4">The color used to display mutations of this type in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">color</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default (selection-coefficient–based) color scheme is used; this is the default for new <span class="s1">MutationType</span> objects.</p>
<p class="p3">colorSubstitution &lt;–&gt; (string$)</p>
<p class="p4">The color used to display substitutions of this type in SLiMgui (see the discussion for the <span class="s1">colorSubstitution</span> property of the <span class="s1">Chromosome</span> class for details).<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">colorSubstitution</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default (selection-coefficient–based) color scheme is used; this is the default for new <span class="s1">MutationType</span> objects.</p>
<p class="p3">convertToSubstitution &lt;–&gt; (logical$)</p>
<p class="p6"><span class="s3">This property governs whether mutations of this mutation type will be converted to </span><span class="s4">Substitution</span><span class="s3"> objects when they reach fixation.</span></p>
<p class="p6"><span class="s3">In WF models this property is </span><span class="s4">T</span><span class="s3"> by default, since conversion to </span><span class="s4">Substitution</span><span class="s3"> objects provides large speed benefits; it should be set to </span><span class="s4">F</span><span class="s3"> only if necessary, and only on the mutation types for which it is necessary.<span class="Apple-converted-space">  </span>This might be needed, for example, if you are using a </span><span class="s4">mutationEffect()</span><span class="s3"> callback to implement an epistatic relationship between mutations; a mutation epistatically influencing the fitness of other mutations through a </span><span class="s4">mutationEffect()</span><span class="s3"> callback would need to continue having that influence even after reaching fixation, but if the simulation were to replace the fixed mutation with a </span><span class="s4">Substitution</span><span class="s3"> object the mutation would no longer be considered in fitness calculations (unless the callback explicitly consulted the list of </span><span class="s4">Substitution</span><span class="s3"> objects kept by the simulation).<span class="Apple-converted-space">  </span>Other script-defined behaviors in </span><span class="s4">mutationEffect()</span><span class="s3">, </span><span class="s4">interaction()</span><span class="s3">, </span><span class="s4">mateChoice()</span><span class="s3">, </span><span class="s4">modifyChild()</span><span class="s3">, and </span><span class="s4">recombination()</span><span class="s3"> callbacks might also necessitate the disabling of substitution for a given mutation type; this is an important consideration to keep in mind.</span></p>
<p class="p6"><span class="s3">In contrast, for nonWF models this property is </span><span class="s4">F</span><span class="s3"> by default, because even mutations with no epistatis or other indirect fitness effects will continue to influence the survival probabilities of individuals.<span class="Apple-converted-space">  </span>For nonWF models, only neutral mutation types with no epistasis or other side effects can safely be converted to substitutions upon fixation.<span class="Apple-converted-space">  </span>When such a pure-neutral mutation type is defined in a nonWF model, this property should be set to </span><span class="s4">T</span><span class="s3"> to tell SLiM that substitution is allowed; this may have very large positive effects on performance, so it is important to remember when modeling background neutral mutations.</span></p>
<p class="p6"><span class="s3">SLiM consults this flag at the end of each tick when deciding whether to substitute each fixed mutation.<span class="Apple-converted-space">  </span>If this flag is </span><span class="s4">T</span><span class="s3">, all eligible fixed mutations will be converted at the end of the current tick, even if they were previously left unconverted because of the previous value of the flag.<span class="Apple-converted-space">  </span>Setting this flag to </span><span class="s4">F</span><span class="s3"> will prevent future substitutions, but will not cause any existing </span><span class="s4">Substitution</span><span class="s3"> objects to be converted back into </span><span class="s4">Mutation</span><span class="s3"> objects.</span></p>
<p class="p3">distributionParams =&gt; (fs)</p>
<p class="p4">The parameters that configure the chosen distribution of fitness effects.<span class="Apple-converted-space">  </span>This will be of type <span class="s1">string</span> for DFE type <span class="s1">"s"</span>, and type <span class="s1">float</span> for all other DFE types.</p>
<p class="p3">distributionType =&gt; (string$)</p>
<p class="p4">The type of distribution of fitness effects; one of <span class="s1">"f"</span>, <span class="s1">"g"</span><span class="s2">,</span> <span class="s1">"e"</span><span class="s2">,</span> <span class="s1">"n"</span><span class="s2">,</span> <span class="s1">"w"</span><span class="s2">,</span> or <span class="s1">"s"</span><span class="s2">:</span></p>
<p class="p13"><span class="s1">"f"</span> – A <b>f</b>ixed fitness effect.<span class="Apple-converted-space">  </span>This DFE type has a single parameter, the selection coefficient <i>s</i> to be used by all mutations of the mutation type.</p>
<p class="p13"><span class="s1">"g"</span> – A <b>g</b>amma-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by two parameters, a shape parameter and a mean value.<span class="Apple-converted-space">  </span>The gamma distribution from which mutations are drawn is given by the probability density function <span class="s16"><i>P</i>(<i>s</i> | </span><span class="s17"><i>α</i></span><span class="s16">,</span><span class="s17"><i>β</i></span><span class="s16">) </span><span class="s17">= [Γ(<i>α</i></span><span class="s16">)</span><span class="s17"><i>βα</i></span><span class="s16">]<sup>−1</sup>exp(−<i>s</i>/</span><span class="s17"><i>β</i></span><span class="s16">)</span>, where <span class="s17"><i>α</i></span> is the shape parameter, and the specified mean for the distribution is equal to <span class="s17"><i>αβ</i></span>.<span class="Apple-converted-space">  </span>Note that this parameterization is the same as for the Eidos function <span class="s1">rgamma()</span>.<span class="Apple-converted-space">  </span>A gamma distribution is often used to model deleterious mutations at functional sites.</p>
<p class="p13"><span class="s1">"e"</span> – An <b>e</b>xponentially-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by a single parameter, the mean of the distribution.<span class="Apple-converted-space">  </span>The exponential distribution from which mutations are drawn is given by the probability density function <span class="s16"><i>P</i>(<i>s</i> | </span><span class="s17"><i>β</i></span><span class="s16">) = </span><span class="s17"><i>β</i></span><span class="s16"><sup>−1</sup>exp(−<i>s</i>/</span><span class="s17"><i>β</i></span><span class="s16">)</span>, where <span class="s17"><i>β</i></span> is the specified mean for the distribution.<span class="Apple-converted-space">  </span>This parameterization is the same as for the Eidos function <span class="s1">rexp()</span>.<span class="Apple-converted-space">  </span>An exponential distribution is often used to model beneficial mutations.</p>
<p class="p13"><span class="s1">"n"</span> – A <b>n</b>ormally-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by two parameters, a mean and a standard deviation.<span class="Apple-converted-space">  </span>The normal distribution from which mutations are drawn is given by the probability density function <span class="s16"><i>P</i>(<i>s</i> | </span><span class="s17"><i>μ</i></span><span class="s16">,</span><span class="s17"><i>σ</i></span><span class="s16">) = (2</span><span class="s17">π<i>σ</i></span><span class="s16"><sup>2</sup>)<sup>−1/2</sup>exp(−(<i>s</i>−</span><span class="s17"><i>μ</i></span><span class="s16">)<sup>2</sup>/2</span><span class="s17"><i>σ</i></span><span class="s16"><sup>2</sup>)</span>, where <span class="s17"><i>μ</i></span> is the mean and <span class="s17"><i>σ</i></span> is the standard deviation.<span class="Apple-converted-space">  </span>This parameterization is the same as for the Eidos function <span class="s1">rnorm()</span>.<span class="Apple-converted-space">  </span>A normal distribution is often used to model mutations that can be either beneficial or deleterious, since both tails of the distribution are unbounded.</p>
<p class="p14"><span class="s1">"p"</span> – A La<b>p</b>lace-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by two parameters, a mean and a scale.<span class="Apple-converted-space">  </span>The Laplace distribution from which mutations are drawn is given by the probability density function <span class="s16"><i>P</i>(<i>s</i> | <i>μ</i>,<i>b</i>) = exp(−|<i>s</i>−<i>μ</i>|/<i>b</i>)/2<i>b</i></span>, where <span class="s16"><i>μ</i></span> is the mean and <span class="s16"><i>b</i></span> is the scale parameter.<span class="Apple-converted-space">  </span>A Laplace distribution is sometimes used to model a mix of both deleterious and beneficial mutations.</p>
<p class="p13"><span class="s1">"w"</span> – A <b>W</b>eibull-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by a scale parameter and a shape parameter.<span class="Apple-converted-space">  </span>The Weibull distribution from which mutations are drawn is given by the probability density function <span class="s16"><i>P</i>(<i>s</i> | </span><span class="s17"><i>λ</i></span><span class="s16">,<i>k</i>) = (<i>k</i>/</span><span class="s17"><i>λ</i></span><span class="s16"><i><sup>k</sup></i>)<i>s<sup>k</sup></i><sup>−1</sup>exp(−(<i>s</i>/</span><span class="s17"><i>λ</i></span><span class="s16">)<i><sup>k</sup></i>)</span>, where <span class="s17"><i>λ</i></span> is the scale parameter and <span class="s16"><i>k</i></span> is the shape parameter.<span class="Apple-converted-space">  </span>This parameterization is the same as for the Eidos function <span class="s1">rweibull()</span>.<span class="Apple-converted-space">  </span>A Weibull distribution is often used to model mutations following extreme-value theory.</p>
<p class="p13"><span class="s1">"s"</span> – A <b>s</b>cript-based fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by a script parameter of type <span class="s1">string</span>, specifying an Eidos script to be executed to produce each new selection coefficient.<span class="Apple-converted-space">  </span>For example, the script <span class="s1">"return rbinom(1);"</span> could be used to generate selection coefficients drawn from a binomial distribution, using the Eidos function <span class="s1">rbinom()</span>, even though that mutational distribution is not supported by SLiM directly.<span class="Apple-converted-space">  </span>The script must return a singleton float or integer.</p>
<p class="p13">Note that these distributions can in principle produce selection coefficients smaller than <span class="s1">-1.0. </span>In that case<span class="s16">,</span> the mutations will be evaluated as “lethal” by SLiM, and the relative fitness of the individual will be set to <span class="s1">0.0</span><span class="s16">.</span></p>
<p class="p3">dominanceCoeff &lt;–&gt; (float$)</p>
<p class="p4">The dominance coefficient used for mutations of this type when heterozygous.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the <span class="s1">Species</span> method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p4">Note that the dominance coefficient is not bounded.<span class="Apple-converted-space">  </span>A dominance coefficient greater than <span class="s1">1.0</span> may be used to achieve an overdominance effect.<span class="Apple-converted-space">  </span>By making the selection coefficient very small and the dominance coefficient very large, an overdominance scenario in which both homozygotes have the same fitness may be approximated, to a nearly arbitrary degree of precision.</p>
<p class="p4">Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.<span class="Apple-converted-space">  </span>This means that if you set a mutation type <span class="s1">muttype</span>’s dominance coefficient to some number <span class="s1">x</span>, <span class="s1">muttype.dominanceCoeff==x</span> may be <span class="s1">F</span> due to floating-point rounding error.<span class="Apple-converted-space">  </span>Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.<span class="Apple-converted-space">  </span>Instead, it is recommended to use the <span class="s1">id</span> or <span class="s1">tag</span> properties to identify particular mutation types.</p>
<p class="p5">hemizygousDominanceCoeff &lt;–&gt; (float$)</p>
<p class="p6">The dominance coefficient used for mutations of this type when they occur opposite a null haplosome (as can occur in sex-chromosome models and models involving a mix of haploids and diploids).<span class="Apple-converted-space">  </span>This defaults to <span class="s1">1.0</span>, and is used only in models where null haplosomes are present; the <span class="s1">dominanceCoeff</span> property is the dominance coefficient used in most circumstances.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the <span class="s1">Species</span> method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6">As with the <span class="s1">dominanceCoeff</span> property, this is stored internally using a single-precision float; see the documentation for <span class="s1">dominanceCoeff</span> for discussion.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this mutation type; for mutation type <span class="s1">m3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">mutationStackGroup &lt;–&gt; (integer$)</p>
<p class="p4">The group into which this mutation type belongs for purposes of mutation stacking policy.<span class="Apple-converted-space">  </span>This is equal to the mutation type’s <span class="s1">id</span> by default.<span class="Apple-converted-space">  </span>See <span class="s1">mutationStackPolicy</span>, below, for discussion.</p>
<p class="p6"><span class="s3">In nucleotide-based models, the stacking group for nucleotide-based mutation types is always </span><span class="s4">-1</span><span class="s3">, and cannot be changed.<span class="Apple-converted-space">  </span>Non-nucleotide-based mutation types may also be set to share the </span><span class="s4">-1</span><span class="s3"> stacking group, if they should participate in the same stacking policy as nucleotide-based mutations, but that would be quite unusual.</span></p>
<p class="p3">mutationStackPolicy &lt;–&gt; (string$)</p>
<p class="p4">This property and the <span class="s1">mutationStackGroup</span> property together govern whether mutations of this mutation type’s stacking group can “stack” – can occupy the same position in a single individual.<span class="Apple-converted-space">  </span>A set of mutation types with the same value for <span class="s1">mutationStackGroup</span> is called a “stacking group”, and all mutation types in a given stacking group must have the same <span class="s1">mutationStackPolicy</span> value, which defines the stacking behavior of all mutations of the mutation types in the stacking group.<span class="Apple-converted-space">  </span>In other words, one stacking group might allow its mutations to stack, while another stacking group might not, but the policy within each stacking group must be unambiguous.</p>
<p class="p6"><span class="s3">This property is </span><span class="s4">"s"</span><span class="s3"> by default, indicating that mutations in this stacking group should be allowed to stack without restriction.<span class="Apple-converted-space">  </span>If the policy is set to </span><span class="s4">"f"</span><span class="s3">, the <i>first</i> mutation of stacking group at a given site is retained; further mutations of this stacking group at the same site are discarded with no effect.<span class="Apple-converted-space">  </span>This can be useful for modeling one-way changes; once a gene is disabled by a premature stop codon, for example, you might wish to assume, for simplicity, that further mutations cannot alter that fact.<span class="Apple-converted-space">  </span>If the policy is set to </span><span class="s4">"l"</span><span class="s3">, the <i>last</i> mutation of this stacking group at a given site is retained; earlier mutation of this stacking group at the same site are discarded.<span class="Apple-converted-space">  </span>This can be useful for modeling an “infinite-alleles” scenario in which every new mutation at a site generates a completely new allele, rather than retaining the previous mutations at the site.</span></p>
<p class="p4">The mutation stacking policy applies only within the given mutation type’s stacking group; mutations of different stacking groups are always allowed to stack in SLiM.<span class="Apple-converted-space">  </span>The policy applies to all mutations added to the model after the policy is set, whether those mutations are introduced by calls such as <span class="s1">addMutation()</span>, <span class="s1">addNewMutation()</span>, or <span class="s1">addNewDrawnMutation()</span>, or are added by SLiM’s own mutation-generation machinery.<span class="Apple-converted-space">  </span>However, no attempt is made to enforce the policy for mutations already existing at the time the policy is set; typically, therefore, the policy is set in an <span class="s1">initialize()</span> callback so that it applies throughout the simulation.<span class="Apple-converted-space">  </span>The policy is also not enforced upon the mutations loaded from a file with <span class="s1">readFromPopulationFile()</span>; such mutations were governed by whatever stacking policy was in effect when the population file was generated.</p>
<p class="p6"><span class="s3">In nucleotide-based models, the stacking policy for nucleotide-based mutation types is always </span><span class="s4">"l"</span><span class="s3">, and cannot be changed.<span class="Apple-converted-space">  </span>This ensures that new nucleotide mutations always replace the previous nucleotide at a site, and that more than one nucleotide mutation is never present at the same position in a single haplosome.</span></p>
<p class="p5"><span class="s3">nucleotideBased =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">If the mutation type was created with </span><span class="s4">initializeMutationType()</span><span class="s3">, it is not nucleotide-based, and this property is </span><span class="s4">F</span><span class="s3">.<span class="Apple-converted-space">  </span>If it was created with </span><span class="s4">initializeMutationTypeNuc()</span><span class="s3">, it is nucleotide-based, and this property is </span><span class="s4">T</span><span class="s3">.<span class="Apple-converted-space">  </span>See those methods for further discussion.</span></p>
<p class="p3">species =&gt; (object&lt;Species&gt;$)</p>
<p class="p6"><span class="s3">The species to which the target object belongs.</span></p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to mutation types.</p>
<p class="p2"><i>5.11.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>MutationType</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (float)drawSelectionCoefficient([integer$ n = 1])</span></p>
<p class="p6"><span class="s3">Draws and returns a vector of </span><span class="s4">n</span><span class="s3"> selection coefficients using the currently defined distribution of fitness effects (DFE) for the target mutation type.<span class="Apple-converted-space">  </span>If the DFE is type </span><span class="s4">"s"</span><span class="s3">, this method will result in synchronous execution of the DFE’s script.</span></p>
<p class="p3">– (void)setDistribution(string$ distributionType, ...)</p>
<p class="p6">Set the distribution of fitness effects for a mutation type.<span class="Apple-converted-space">  </span>The <span class="s1">distributionType</span> may be <span class="s1">"f"</span>, in which case the ellipsis <span class="s1">...</span> should supply a <span class="s1">numeric$</span> fixed selection coefficient; <span class="s1">"e"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> mean selection coefficient for the exponential distribution; <span class="s1">"g"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> mean selection coefficient and a <span class="s1">numeric$</span> alpha shape parameter for a gamma distribution; <span class="s1">"n"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> mean selection coefficient and a <span class="s1">numeric$</span> sigma (standard deviation) parameter for a normal distribution; <span class="s1">"p"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> mean selection coefficient and a <span class="s1">numeric$</span> scale parameter for a Laplace distribution; <span class="s1">"w"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> <span class="s2">λ</span> scale parameter and a <span class="s1">numeric$</span> k shape parameter for a Weibull distribution; or <span class="s1">"s"</span>, in which case the ellipsis should supply a <span class="s1">string$</span> Eidos script parameter.<span class="Apple-converted-space">  </span>The DFE for a mutation type is normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p11"><b>5.12<span class="Apple-converted-space">  </span>Class Plot</b></p>
<p class="p12"><i>5.12.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Plot</i></span><i> properties</i></p>
<p class="p5">title =&gt; (string$)</p>
<p class="p6">The title of the plot, as originally passed to <span class="s1">createPlot()</span>.<span class="Apple-converted-space">  </span>See also the <span class="s1">plotWithTitle()</span> method of <span class="s1">SLiMgui</span>.</p>
<p class="p12"><i>5.12.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Plot</i></span><i> methods</i></p>
<p class="p5">– (void)abline([Nif a = NULL], [Nif b = NULL], [Nif h = NULL], [Nif v = NULL], [string color = "red"], [numeric lwd = 1.0], [float alpha = 1.0])</p>
<p class="p6">Adds one or more straight lines to the plot.<span class="Apple-converted-space">  </span>There are three supported modes of operation for this method.<span class="Apple-converted-space">  </span>In the first mode, the lines are specified by <span class="s1">a</span> and <span class="s1">b</span>, representing the intercepts and slopes of the lines, respectively; in this case, <span class="s1">a</span> and <span class="s1">b</span> may be the same length, or one of them may be a singleton to provide a single value used for all of the lines specified by the other.<span class="Apple-converted-space">  </span>In the second mode, the lines are specified by <span class="s1">h</span>, representing the <i>y</i>-values of horizontal lines.<span class="Apple-converted-space">  </span>In the third mode, the lines are specified by <span class="s1">v</span>, representing the <i>x</i>-values of vertical lines.<span class="Apple-converted-space">  </span>These modes are mutually exclusive and cannot be mixed within one call to <span class="s1">abline()</span>.<span class="Apple-converted-space">  </span>The new lines will be plotted on top of any previously added data.</p>
<p class="p6">The lines will be drawn in colors, line widths, and alpha (opacity) values specified by <span class="s1">color</span>, <span class="s1">lwd</span>, and <span class="s1">alpha</span>, each of which may be either a singleton (to provide one value used for all lines) or a vector equal in length to the number of lines plotted (to provide one value per line).<span class="Apple-converted-space">  </span>Alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.</p>
<p class="p6">See also <span class="s1">lines()</span> and <span class="s1">segments()</span> for more common approaches to line plotting.<span class="Apple-converted-space">  </span>The <span class="s1">abline()</span> method is different, and more specialized; the lines plotted by it span the full extent of the plot area, and their coordinates are not considered when dynamically resizing the axes of the plot (i.e., when <span class="s1">createPlot()</span> is not passed explicit, non-<span class="s1">NULL</span> values for <span class="s1">xrange</span> or <span class="s1">yrange</span>).<span class="Apple-converted-space">  </span>This is typically useful for plotting things such as expected values and fit lines.</p>
<p class="p5">– (void)addLegend([Ns$ position = NULL], [Ni$ inset = NULL], [Nif$ labelSize = NULL], [Nif$ lineHeight = NULL], [Nif$ graphicsWidth = NULL], [Nif$ exteriorMargin = NULL], [Nif$ interiorMargin = NULL])</p>
<p class="p6">Adds a legend to the plot.<span class="Apple-converted-space">  </span>The legend will be displayed within the plot at the location specified by position, which must be <span class="s1">"topRight"</span>, <span class="s1">"topLeft"</span>, <span class="s1">"bottomRight"</span>, or <span class="s1">"bottomLeft"</span>, or <span class="s1">NULL</span> (the default) requesting that SLiMgui choose the position.<span class="Apple-converted-space">  </span>The position of the legend will be inset from the chosen corner by a margin <span class="s1">inset</span>, measured in pixels; the default of <span class="s1">NULL</span> allows SLiMgui to choose the inset.</p>
<p class="p6">The internal layout of the legend is a bit complex, and can be controlled by five parameters; in all cases, the default value of <span class="s1">NULL</span> requests that SLiMgui provide a reasonable default.<span class="Apple-converted-space">  </span>The <span class="s1">labelSize</span> parameter specifies the font size used for the text labels for each legend entry (measured in “points”, the standard metric of font sizes).<span class="Apple-converted-space">  </span>The <span class="s1">lineHeight</span> parameter specifies the vertical size, in pixels, of one entry line.<span class="Apple-converted-space">  </span>The <span class="s1">graphicsWidth</span> parameter species the width, in pixels, of the column used to display the “graphics” (whether a line segment, a point symbol, a swatch, or a combination of those) associated with each entry.<span class="Apple-converted-space">  </span>The <span class="s1">exteriorMargin</span> parameter specifies the width/height of margins, in pixels, outside of the entries (between the entries and the legend’s frame).<span class="Apple-converted-space">  </span>Finally, the <span class="s1">interiorMargin</span> parameter specifies the width/height of margins, in pixels, vertically between entries, and also between the “graphics” column and the label.<span class="Apple-converted-space">  </span>It is easy to produce a legend that looks terrible, using these layout metrics; SLiMgui does only minimal sanity-checking of their values, to provide maximal flexibility.</p>
<p class="p6">The legend is initially empty; entries for it can be added with <span class="s1">legendLineEntry()</span>, <span class="s1">legendPointEntry()</span>, and <span class="s1">legendSwatchEntry()</span>.</p>
<p class="p5">– (void)axis(integer$ side, [Nif at = NULL], [ls labels = T])</p>
<p class="p6">Configures an axis of the plot.<span class="Apple-converted-space">  </span>The <span class="s1">side</span> parameter controls which axis is being configured; at present, it may be <span class="s1">1</span> for the <i>x</i>-axis (at the bottom of the plot), or <span class="s1">2</span> for the <i>y</i>-axis (at the left of the plot).</p>
<p class="p6">The positions of tick marks (and of any associated labels) are controlled by <span class="s1">at</span>; if <span class="s1">at</span> is <span class="s1">NULL</span> (the default) these positions will be computed automatically based upon the range of the data in the plot, otherwise <span class="s1">at</span> must be a vector of <span class="s1">numeric</span> positions.<span class="Apple-converted-space">  </span>Note that the coordinate system of the plot is controlled not by this method, but by the <span class="s1">xrange</span> and <span class="s1">yrange</span> parameters of <span class="s1">createPlot()</span>; <span class="s1">at</span> controls only the positions of axis ticks <i>within</i> that coordinate system.</p>
<p class="p6">The <span class="s1">labels</span> parameter controls the text labels displayed for ticks; it may be <span class="s1">T</span> (the default) to label ticks with their numeric positions, <span class="s1">F</span> to suppress all tick labels, or a vector of type <span class="s1">string</span>, equal in length to <span class="s1">at</span>, providing the label for each position in <span class="s1">at</span>.<span class="Apple-converted-space">  </span>Label values may be the empty string, <span class="s1">""</span>, if a label at a given position is not desired, and if <span class="s1">labels</span> is <span class="s1">T</span>, some ticks may not receive a label for readability.</p>
<p class="p5">– (void)image(object$ image, numeric$ x1, numeric$ y1, numeric$ x2, numeric$ y2, [logical$ flipped = F], [float$ alpha = 1.0])</p>
<p class="p6">Adds image data given by <span class="s1">image</span> to the plot.<span class="Apple-converted-space">  </span>The data will be plotted as a raster (bitmap, pixel) image in the rectangle specified by <span class="s1">x1</span>, <span class="s1">y1</span>, <span class="s1">x2</span>, and <span class="s1">y2</span>, which must be sorted such that <span class="s1">x1 &lt;= x2</span> and <span class="s1">y1 &lt;= y2</span>.<span class="Apple-converted-space">  </span>When <span class="s1">flipped</span> is <span class="s1">F</span> (the default), the plotted image is shown in a default orientation that is typically best given the source of the image; if <span class="s1">flipped</span> is <span class="s1">T</span> the image’s orientation is flipped vertically relative to that default.<span class="Apple-converted-space">  </span>The plotted image will use opacity <span class="s1">alpha</span>; alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.<span class="Apple-converted-space">  </span>The new image data will be plotted on top of any previously added data.</p>
<p class="p6">The image data may be specified in one of two ways.<span class="Apple-converted-space">  </span>First, <span class="s1">image</span> may be a singleton <span class="s1">Image</span> object.<span class="Apple-converted-space">  </span>In this case, the image is simply plotted inside the rectangle specified by <span class="s1">x1</span>/<span class="s1">y1</span>/<span class="s1">x2</span>/<span class="s1">y2</span>, fully displaying all of its pixels (in contrast to how the grid values of a spatial map area displayed, as described below).<span class="Apple-converted-space">  </span>The image may be either RGB or grayscale.</p>
<p class="p6">Second, <span class="s1">image</span> may be a singleton <span class="s1">SpatialMap</span> object.<span class="Apple-converted-space">  </span>In this case, the grid values of the spatial map are plotted aligned to the corners of the rectangle specified by <span class="s1">x1</span>/<span class="s1">y1</span>/<span class="s1">x2</span>/<span class="s1">y2</span>, as the map would be used by SLiM; the edge and corner grid points of the map are therefore only partially displayed.<span class="Apple-converted-space">  </span>(If desired, the <span class="s1">gridValues()</span> or <span class="s1">mapImage()</span> methods of <span class="s1">SpatialMap</span> could be used to convert the map to a matrix or <span class="s1">Image</span> representation that could be plotted differently.)<span class="Apple-converted-space">  </span>The spatial map’s display uses the color scheme that was specified for the map.<span class="Apple-converted-space">  </span>The map’s values are not interpolated, regardless of the map’s <span class="s1">interpolate</span> property; only the raw grid data of the spatial map is displayed.<span class="Apple-converted-space">  </span>(If interpolated display is desired, the <span class="s1">interpolate()</span> method of <span class="s1">SpatialMap</span> can be used to increase the grid resolution of the map prior to display.)</p>
<p class="p6">This method caches the image data being plotted so that plotting the same <span class="s1">SpatialMap</span> or <span class="s1">Image</span> object multiple times is more efficient.<span class="Apple-converted-space">  </span>See the <span class="s1">matrix()</span> method of <span class="s1">Plot</span> for an alternative way of plotting raster data that may be more suitable in some situations, but that is less efficient because it does not provide such caching.</p>
<p class="p5">– (void)legendLineEntry(string$ label, [string$ color = "red"], [numeric$ lwd = 1.0])</p>
<p class="p6">Adds a legend entry with text <span class="s1">label</span> to the plot.<span class="Apple-converted-space">  </span>The entry will be displayed as a line segment drawn in color <span class="s1">color</span>, using line width <span class="s1">lwd</span>, mirroring the appearance produced by <span class="s1">lines()</span> for the same parameters.<span class="Apple-converted-space">  </span>If one or more other legend entries already exist with the same label, the new entry will be drawn on top of the previously set entries for that label (allowing legend entries that display both a line and a point, for example).</p>
<p class="p5">– (void)legendPointEntry(string$ label, [integer$ symbol = 0], [string$ color = "red"], [string$ border = "black"], [numeric$ lwd = 1.0], [numeric$ size = 1.0])</p>
<p class="p6">Adds a legend entry with text <span class="s1">label</span> to the plot.<span class="Apple-converted-space">  </span>The entry will be displayed as a point symbol specified by <span class="s1">symbol</span>, <span class="s1">color</span>, <span class="s1">border</span>, <span class="s1">lwd</span>, and <span class="s1">size</span>, mirroring the appearance produced by <span class="s1">points()</span> for the same parameters; see <span class="s1">points()</span> for further details.<span class="Apple-converted-space">  </span>If one or more other legend entries already exist with the same label, the new entry will be drawn on top of the previously set entries for that label (allowing legend entries that display both a line and a point, for example).</p>
<p class="p5">– (void)legendSwatchEntry(string$ label, [string$ color = "red"])</p>
<p class="p6">Adds a legend entry with text <span class="s1">label</span> to the plot.<span class="Apple-converted-space">  </span>The entry will be displayed as a swatch drawn in color <span class="s1">color</span>.<span class="Apple-converted-space">  </span>If one or more other legend entries already exist with the same label, the new entry will be drawn on top of the previously set entries for that label (allowing legend entries that display both a line and a point, for example).</p>
<p class="p5">– (void)legendTitleEntry(string$ label)</p>
<p class="p6">Adds a legend entry with text <span class="s1">label</span> to the plot.<span class="Apple-converted-space">  </span>The entry will be displayed as a title, left-aligned with no graphical representation (no line, point, or swatch).<span class="Apple-converted-space">  </span>A label of <span class="s1">""</span>, the empty string, is allowed and will produce a blank line in the legend (for spacing).<span class="Apple-converted-space">  </span>Note that title entries always produce their own separate line in the legend; they do not participate in the overdrawing scheme used for other types of legend entries.</p>
<p class="p5">– (void)lines(numeric x, numeric y, [string$ color = "red"], [numeric$ lwd = 1.0], [float$ alpha = 1.0])</p>
<p class="p6">Adds line data given by <span class="s1">x</span> and <span class="s1">y</span> to the plot.<span class="Apple-converted-space">  </span>The data will be plotted as a series of connected line segments, following the (<i>x</i>, <i>y</i>) positions given; note that the <span class="s1">x</span> and <span class="s1">y</span> vectors must be the same length.<span class="Apple-converted-space">  </span>The new line data will be plotted on top of any previously added data.</p>
<p class="p6">The lines will be drawn in color <span class="s1">color</span>, using line width <span class="s1">lwd</span>, with opacity <span class="s1">alpha</span>.<span class="Apple-converted-space">  </span>Alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.<span class="Apple-converted-space">  </span>Unlike <span class="s1">points()</span> and <span class="s1">text()</span>, the parameters <span class="s1">color</span>, <span class="s1">lwd</span>, and <span class="s1">alpha</span> must be singletons, since each point (except the two ends) is shared by two line segments; if you wish to vary the color/width/opacity for each line segment, separate calls to <span class="s1">lines()</span> are necessary, or the <span class="s1">segments()</span> method may be useful. <span class="Apple-converted-space">  </span>See also <span class="s1">abline()</span> and <span class="s1">segments()</span>.</p>
<p class="p5">– (void)matrix(numeric matrix, numeric$ x1, numeric$ y1, numeric$ x2, numeric$ y2, [logical$ flipped = F], [Nif valueRange = NULL], [Ns$ colors = NULL], [float$ alpha = 1.0])</p>
<p class="p6">Adds image data given by <span class="s1">matrix</span> to the plot.<span class="Apple-converted-space">  </span>The image data must be specified as a <span class="s1">numeric</span> (i.e., <span class="s1">integer</span> or <span class="s1">float</span>) matrix, as for example produced by the <span class="s1">matrix()</span> function in Eidos.<span class="Apple-converted-space">  </span>The data will be plotted as a raster (bitmap, pixel) image in the rectangle specified by <span class="s1">x1</span>, <span class="s1">y1</span>, <span class="s1">x2</span>, and <span class="s1">y2</span>, which must be sorted such that <span class="s1">x1 &lt;= x2</span> and <span class="s1">y1 &lt;= y2</span>.<span class="Apple-converted-space">  </span>When <span class="s1">flipped</span> is <span class="s1">F</span> (the default), the plotted image is shown in a default orientation that matches the orientation of the matrix (with row <span class="s1">0</span> topmost); if <span class="s1">flipped</span> is <span class="s1">T</span> the image’s orientation is flipped vertically relative to that default (with row <span class="s1">0</span> bottommost).</p>
<p class="p6">Prior to display, the values in the matrix will be rescaled according to the parameter <span class="s1">valueRange</span>.<span class="Apple-converted-space">  </span>If <span class="s1">valueRange</span> is <span class="s1">NULL</span> (the default), the values will be left unscaled; this is equivalent to passing <span class="s1">c(0,1)</span> for <span class="s1">valueRange</span>.<span class="Apple-converted-space">  </span>Otherwise, <span class="s1">valueRange</span> should be a <span class="s1">numeric</span> vector containing two elements that define the range of values that will be rescaled to span the interval [0, 1] – the range to which the color scheme will then be applied.<span class="Apple-converted-space">  </span>After rescaling the given range to [<span class="s1">0</span>, <span class="s1">1</span>], the resulting values are clamped to the range [<span class="s1">0</span>, <span class="s1">1</span>].<span class="Apple-converted-space">  </span>It is legal for <span class="s1">valueRange[0]</span> to be greater than <span class="s1">valueRange[1]</span>; in this case, the rescaling operation will, in effect, reverse the direction of the color scheme by reversing the ranks of the reordered values.</p>
<p class="p6">The rescaled and clamped values are then colored according to the color scheme named by <span class="s1">colors</span>, which should be one of the named schemes supported by the Eidos function <span class="s1">colors()</span>: <span class="s1">"cm"</span>, <span class="s1">"heat"</span>, <span class="s1">"terrain"</span>, <span class="s1">"parula"</span>, <span class="s1">"hot"</span>, <span class="s1">"jet"</span>, <span class="s1">"turbo"</span>, <span class="s1">"gray"</span>, <span class="s1">"magma"</span>, <span class="s1">"inferno"</span>, <span class="s1">"plasma"</span>, <span class="s1">"viridis"</span>, or <span class="s1">"cividis"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">colors</span> is <span class="s1">NULL</span> (the default), the color scheme used is the reverse of the <span class="s1">"gray"</span> color scheme, shading from black for <span class="s1">0</span> up to white for <span class="s1">1</span>.<span class="Apple-converted-space">  </span>In all cases, the color scheme is applied across the range [<span class="s1">0</span>, <span class="s1">1</span>] for the rescaled and clamped values.</p>
<p class="p6">The plotted image will use opacity <span class="s1">alpha</span>; alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.<span class="Apple-converted-space">  </span>The new image data will be plotted on top of any previously added data.</p>
<p class="p6">See the <span class="s1">image()</span> method of <span class="s1">Plot</span> for an alternative way of plotting raster data from <span class="s1">SpatialMap</span> and <span class="s1">Image</span> objects that may be more suitable in some situations.</p>
<p class="p5">– (void)mtext(numeric x, numeric y, string labels, [string color = "black"], [numeric size = 10.0], [Nif adj = NULL], [float alpha = 1.0], [numeric angle = 0.0])</p>
<p class="p6">Adds marginal text data given by <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">labels</span> to the plot.<span class="Apple-converted-space">  </span>The string values in <span class="s1">labels</span> will be plotted at the (<i>x</i>, <i>y</i>) positions given; note that <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">labels</span> must all be the same length.<span class="Apple-converted-space">  </span>This method differs from the <span class="s1">text()</span> method in two respects.<span class="Apple-converted-space">  </span>The first – the reason that this method draws “marginal” text – is that the text drawn is not clipped to the plot area, allowing text to be drawn in the axis and border areas outside the plot itself.<span class="Apple-converted-space">  </span>The second is that the <span class="s1">x</span> and <span class="s1">y</span> coordinates are interpreted differently than other <span class="s1">Plot</span> methods; rather than being in the coordinate system of the plot, they are in a coordinate system in which the plot area spans [0,1] on both axes.<span class="Apple-converted-space">  </span>This is intended to make positioning text outside of the plot area not depend upon the axis ranges of the plot; those axis ranges might vary, but the positions at which <span class="s1">mtext()</span> draws, relative to the plot area, will remain fixed.<span class="Apple-converted-space">  </span>The new marginal text data will be plotted on top of any previously added data.</p>
<p class="p6">The text will be drawn in color <span class="s1">color</span>, at the font size given by <span class="s1">size</span> (measured in “points”, the standard metric of font sizes); the font family and style cannot be controlled at this time.<span class="Apple-converted-space">  </span>Opacity values may be supplied with <span class="s1">alpha</span>; alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.<span class="Apple-converted-space">  </span>The angle at which the text is drawn can be specified with <span class="s1">angle</span>; angles are measured in degrees, clockwise.<span class="Apple-converted-space">  </span>All of these parameters (<span class="s1">color</span>, <span class="s1">size</span>, <span class="s1">alpha</span>, and <span class="s1">angle</span>) may either be a singleton value applied to all points, or a vector with one value per corresponding point.</p>
<p class="p6">The exact position of the text, relative to each point (<i>x</i>, <i>y</i>), is adjusted by the optional parameter <span class="s1">adj</span>.<span class="Apple-converted-space">  </span>The value of <span class="s1">adj</span>, if specified, must be a vector of length <span class="s1">2</span>, where <span class="s1">adj[0]</span> adjusts the <i>x</i> position and <span class="s1">adj[1]</span> adjusts the <i>y</i> position of the text.<span class="Apple-converted-space">  </span>Relative to a given <i>x</i> position, a value of <span class="s1">0.0</span> aligns the left edge of the text to it; a value of <span class="s1">0.5</span> aligns the center of the text to it; and a value of <span class="s1">1.0</span> aligns the right edge of the text to it.<span class="Apple-converted-space">  </span>Similarly, relative to a given <i>y</i> position, a value of <span class="s1">0.0</span> aligns the bottom edge of the text to it; a value of <span class="s1">0.5</span> aligns the center of the text to it; and a value of <span class="s1">1.0</span> aligns the top edge of the text to it.<span class="Apple-converted-space">  </span>Intermediate values will produce intermediate alignments, and values of <span class="s1">adj</span> outside of [<span class="s1">0.0</span>, <span class="s1">1.0</span>] are also allowed.<span class="Apple-converted-space">  </span>The default value of <span class="s1">adj</span>, <span class="s1">NULL</span>, is equivalent to <span class="s1">c(0.5, 0.5)</span>, aligning the center of the text to (<i>x</i>, <i>y</i>) both horizontally and vertically.</p>
<p class="p5">– (void)points(numeric x, numeric y, [integer symbol = 0], [string color = "red"], [string border = "black"], [numeric lwd = 1.0], [numeric size = 1.0], [float alpha = 1.0])</p>
<p class="p6">Adds point data given by <span class="s1">x</span> and <span class="s1">y</span> to the plot.<span class="Apple-converted-space">  </span>The data will be plotted as a set of point symbols, centered at the (<i>x</i>, <i>y</i>) positions given; note that the <span class="s1">x</span> and <span class="s1">y</span> vectors must be the same length.<span class="Apple-converted-space">  </span>The new point data will be plotted on top of any previously added data.</p>
<p class="p6">The symbol plotted for each point depends upon the value of <span class="s1">symbol</span>.<span class="Apple-converted-space">  </span>In general, symbols will be drawn in color <span class="s1">color</span>, with a line width <span class="s1">lwd</span> used for lines (if any) in the symbol, and an overall size scaled by <span class="s1">size</span>.<span class="Apple-converted-space">  </span>Symbols <span class="s1">21</span>–<span class="s1">25</span> involve both a filled shape and a border line around that shape; for those symbols, the border line will use the color provided by <span class="s1">border</span>, while the filled shape will use color <span class="s1">color</span>.<span class="Apple-converted-space">  </span>Opacity values may be supplied with <span class="s1">alpha</span>; alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.<span class="Apple-converted-space">  </span>All of these parameters (<span class="s1">symbol</span>, <span class="s1">color</span>, <span class="s1">border</span>, <span class="s1">lwd</span>, <span class="s1">size</span>, and <span class="s1">alpha</span>) may either be a singleton value applied to all points, or a vector with one value per corresponding point.</p>
<p class="p5">– (void)rects(numeric x1, numeric y1, numeric x2, numeric y2, [string color = "red"], [string border = "black"], [numeric lwd = 1.0], [float alpha = 1.0])</p>
<p class="p6">Adds rectangle data given by <span class="s1">x1</span>, <span class="s1">y1</span>, <span class="s1">x2</span>, and <span class="s1">y2</span> to the plot; note that these four vectors must all be the same length.<span class="Apple-converted-space">  </span>The data will be plotted as a series of rectangles, defined by each (<i>x1</i>, <i>y1</i>, <i>x2</i>, <i>y2</i>) quadret providing the left, right, top and bottom of each rectangle.<span class="Apple-converted-space">  </span>The coordinates of each rectangle do not need to be sorted; in other words, it is not required that <span class="s1">x1[i] &lt;= x2[i]</span>, or that <span class="s1">y1[i] &lt;= y2[i]</span>, and different sorting orders for the coordinates of a given rectangle will draw identically.<span class="Apple-converted-space">  </span>The fill of a each rectangle is contained within its coordinates, but the frame of each rectangle is composed of lines of some width, drawn between the vertices of the rectangle, and will therefore extend beyond the coordinates of the rectangle by one-half of the line width; if this is not desired, inset the rectangle coordinates by one-half of the line width to compensate.<span class="Apple-converted-space">  </span>The new rectangle data will be plotted on top of any previously added data.</p>
<p class="p6">The rectangles will be drawn in fill colors <span class="s1">color</span>, with border colors <span class="s1">border</span>, using line widths <span class="s1">lwd</span>, with opacities <span class="s1">alpha</span> applied to both the fill and the border.<span class="Apple-converted-space">  </span>The <span class="s1">color</span>, <span class="s1">border</span>, <span class="s1">lwd</span>, and <span class="s1">alpha</span> parameters may each be either a singleton value (applying to all rectangles) or a vector with one value per rectangle.<span class="Apple-converted-space">  </span>Alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.<span class="Apple-converted-space">  </span>If a filled rectangle with no border is desired, a <span class="s1">border</span> value of <span class="s1">"none"</span> can be used; similarly, if a framed rectangle with no fill is desired, a <span class="s1">color</span> value of <span class="s1">"none"</span> can be used.<span class="Apple-converted-space">  </span>Note that that <span class="s1">"none"</span> a special color value supported only by <span class="s1">rects()</span>; it is not part of the standard set of named colors in Eidos.</p>
<p class="p5">– (void)segments(numeric x1, numeric y1, numeric x2, numeric y2, [string color = "red"], [numeric lwd = 1.0], [float alpha = 1.0])</p>
<p class="p6">Adds line segment data given by <span class="s1">x1</span>, <span class="s1">y1</span>, <span class="s1">x2</span>, and <span class="s1">y2</span> to the plot; note that these four vectors must all be the same length.<span class="Apple-converted-space">  </span>The data will be plotted as a series of unconnected line segments, from each (<i>x1</i>, <i>y1</i>) position to the corresponding (<i>x2</i>, <i>y2</i>) position.<span class="Apple-converted-space">  </span>The new line segment data will be plotted on top of any previously added data.</p>
<p class="p6">The line segments will be drawn in colors <span class="s1">color</span>, using line widths <span class="s1">lwd</span>, with opacities <span class="s1">alpha</span>.<span class="Apple-converted-space">  </span>The <span class="s1">color</span>, <span class="s1">lwd</span>, and <span class="s1">alpha</span> parameters may each be either a singleton value (applying to all line segments) or a vector with one value per line segment.<span class="Apple-converted-space">  </span>Alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque. <span class="Apple-converted-space">  </span>See also <span class="s1">lines()</span> and <span class="s1">abline()</span>.</p>
<p class="p5">– (void)setBorderless([numeric$ marginLeft = 0.0], [numeric$ marginTop = 0.0], [numeric$ marginRight = 0.0], [numeric$ marginBottom = 0.0])</p>
<p class="p6">Reconfigures the plot to be borderless – to not display axes, ticks, or the labels for axes and ticks.<span class="Apple-converted-space">  </span>Since those elements are not present, the plot area in borderless plots essentially fills the window’s available area, except for being inset by the margins given in <span class="s1">marginLeft</span>, <span class="s1">marginTop</span>, <span class="s1">marginRight</span>, and <span class="s1">marginBottom</span>, which are specified in pixels.<span class="Apple-converted-space">  </span>The axis ranges are not extended in the usual manner; if the range of the <i>x</i> axis is specified as <span class="s1">c(0,1)</span>, for example, then that is the range actually used for the <i>x</i> axis.<span class="Apple-converted-space">  </span>(This is similar to R’s <span class="s1">"xaxs"</span> and <span class="s1">"yaxs"</span> being specified as <span class="s1">"i"</span>, rather than the usual behavior specified by the default of <span class="s1">"r"</span>.)<span class="Apple-converted-space">  </span>If you want the plotted data to have “breathing room” around it, you should therefore specify non-zero margins.</p>
<p class="p6">Note that the <span class="s1">fullBox</span> parameter of <span class="s1">createPlot()</span> is still honored; for borderless plots, the box is drawn at the outer edge of the margin area.<span class="Apple-converted-space">  </span>If you don’t want the box to overdraw any of the data area of the plot (within the extents of the axes), you should specify each margin value as <span class="s1">1</span> (or greater), to provide a pixel of margin space within which the box will be drawn without impinging upon the plotted data.</p>
<p class="p5">– (void)text(numeric x, numeric y, string labels, [string color = "black"], [numeric size = 10.0], [Nif adj = NULL], [float alpha = 1.0], [numeric angle = 0.0])</p>
<p class="p6">Adds text data given by <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">labels</span> to the plot.<span class="Apple-converted-space">  </span>The string values in <span class="s1">labels</span> will be plotted at the (<i>x</i>, <i>y</i>) positions given; note that <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">labels</span> must all be the same length.<span class="Apple-converted-space">  </span>The new text data will be plotted on top of any previously added data.</p>
<p class="p6">The text will be drawn in color <span class="s1">color</span>, at the font size given by <span class="s1">size</span> (measured in “points”, the standard metric of font sizes); the font family and style cannot be controlled at this time.<span class="Apple-converted-space">  </span>Opacity values may be supplied with <span class="s1">alpha</span>; alpha values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], where <span class="s1">0.0</span> is fully transparent and <span class="s1">1.0</span> is fully opaque.<span class="Apple-converted-space">  </span>The angle at which the text is drawn can be specified with <span class="s1">angle</span>; angles are measured in degrees, clockwise.<span class="Apple-converted-space">  </span>All of these parameters (<span class="s1">color</span>, <span class="s1">size</span>, <span class="s1">alpha</span>, and <span class="s1">angle</span>) may either be a singleton value applied to all points, or a vector with one value per corresponding point.</p>
<p class="p6">The exact position of the text, relative to each point (<i>x</i>, <i>y</i>), is adjusted by the optional parameter <span class="s1">adj</span>.<span class="Apple-converted-space">  </span>The value of <span class="s1">adj</span>, if specified, must be a vector of length <span class="s1">2</span>, where <span class="s1">adj[0]</span> adjusts the <i>x</i> position and <span class="s1">adj[1]</span> adjusts the <i>y</i> position of the text.<span class="Apple-converted-space">  </span>Relative to a given <i>x</i> position, a value of <span class="s1">0.0</span> aligns the left edge of the text to it; a value of <span class="s1">0.5</span> aligns the center of the text to it; and a value of <span class="s1">1.0</span> aligns the right edge of the text to it.<span class="Apple-converted-space">  </span>Similarly, relative to a given <i>y</i> position, a value of <span class="s1">0.0</span> aligns the bottom edge of the text to it; a value of <span class="s1">0.5</span> aligns the center of the text to it; and a value of <span class="s1">1.0</span> aligns the top edge of the text to it.<span class="Apple-converted-space">  </span>Intermediate values will produce intermediate alignments, and values of <span class="s1">adj</span> outside of [<span class="s1">0.0</span>, <span class="s1">1.0</span>] are also allowed.<span class="Apple-converted-space">  </span>The default value of <span class="s1">adj</span>, <span class="s1">NULL</span>, is equivalent to <span class="s1">c(0.5, 0.5)</span>, aligning the center of the text to (<i>x</i>, <i>y</i>) both horizontally and vertically.</p>
<p class="p6">See also the <span class="s1">mtext()</span> method, for drawing text outside of the plot area.</p>
<p class="p5">– (void)write(string$ filePath)</p>
<p class="p6">Writes the plot to the given filesystem path <span class="s1">filePath</span> as a PDF file.<span class="Apple-converted-space">  </span>It is suggested, but not required, that <span class="s1">filePath</span> should end in a <span class="s1">.pdf</span> or <span class="s1">.PDF</span> filename extension.<span class="Apple-converted-space">  </span>If the file cannot be written, an error will result.</p>
<p class="p1"><b>5.13<span class="Apple-converted-space">  </span>Class SLiMEidosBlock</b></p>
<p class="p2"><i>5.13.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMEidosBlock</i></span><i> properties</i></p>
<p class="p3">active &lt;–&gt; (integer$)</p>
<p class="p6">If this evaluates to <span class="s1">logical</span> <span class="s1">F</span> (i.e., is equal to <span class="s1">0</span>), the script block is inactive and will not be called.<span class="Apple-converted-space">  </span>The value of <span class="s1">active</span> for all registered script blocks is reset to <span class="s1">-1</span> at the beginning of each tick, prior to script events being called, thus activating all blocks (except callbacks associated with a species that is not active in that tick, which are deactivated as part of the deactivation of the species).<span class="Apple-converted-space">  </span>Any <span class="s1">integer</span> value other than <span class="s1">-1</span> may be used instead of <span class="s1">-1</span> to represent that a block is active; for example, <span class="s1">active</span> may be used as a counter to make a block execute a fixed number of times in each tick.<span class="Apple-converted-space">  </span>This value is not cached by SLiM; if it is changed, the new value takes effect immediately.<span class="Apple-converted-space">  </span>For example, a callback might be activated and inactivated repeatedly during a single tick.</p>
<p class="p3">end =&gt; (integer$)</p>
<p class="p4">The last tick in which the script block is active.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this script block; for script <span class="s1">s3</span>, for example, this is <span class="s1">3</span>.<span class="Apple-converted-space">  </span>A script block for which no <span class="s1">id</span> was given will have an <span class="s1">id</span> of <span class="s1">-1</span><span class="s2">.</span></p>
<p class="p3">source =&gt; (string$)</p>
<p class="p4">The source code string of the script block.</p>
<p class="p5">speciesSpec =&gt; (object&lt;Species&gt;)</p>
<p class="p6">The <span class="s1">species</span> specifier for the script block.<span class="Apple-converted-space">  </span>The species specifier for a callback block indicates the callback’s associated species; the callback is called to modify the default behavior for that species.<span class="Apple-converted-space">  </span>If the script block has no <span class="s1">species</span> specifier, this property’s value is a zero-length <span class="s1">object</span> vector of class <span class="s1">Species</span>.<span class="Apple-converted-space">  </span>This property is read-only; normally it is set by preceding the definition of a callback with a <span class="s1">species</span> specifier, of the form <span class="s1">species &lt;species-name&gt;</span>.</p>
<p class="p3">start =&gt; (integer$)</p>
<p class="p4">The first tick in which the script block is active.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p5">ticksSpec =&gt; (object&lt;Species&gt;)</p>
<p class="p6">The <span class="s1">ticks</span> specifier for the script block.<span class="Apple-converted-space">  </span>The <span class="s1">ticks</span> specifier for an event block indicates the event’s associated species; the event executes only in ticks when that species is active.<span class="Apple-converted-space">  </span>If the script block has no <span class="s1">ticks</span> specifier, this property’s value is a zero-length <span class="s1">object</span> vector of class <span class="s1">Species</span>.<span class="Apple-converted-space">  </span>This property is read-only; normally it is set by preceding the definition of an event with a <span class="s1">ticks</span> specifier, of the form <span class="s1">ticks &lt;species-name&gt;</span>.</p>
<p class="p3">type =&gt; (string$)</p>
<p class="p6">The type of the script block; this will be <span class="s1">"first"</span>, <span class="s1">"early"</span>, or <span class="s1">"late"</span> for the three types of Eidos events, or <span class="s1">"initialize"</span>, <span class="s1">"fitnessEffect"</span>, <span class="s1">"interaction"</span>, <span class="s1">"mateChoice"</span>, <span class="s1">"modifyChild"</span>, <span class="s1">"mutation"</span>, <span class="s1">"mutationEffect"</span>, <span class="s1">"recombination"</span>, <span class="s1">"reproduction"</span>, or <span class="s1">"survival"</span> for the respective types of Eidos callbacks.</p>
<p class="p2"><i>5.13.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMEidosBlock</i></span><i> methods</i></p>
<p class="p15"><br></p>
<p class="p1"><b>5.14<span class="Apple-converted-space">  </span>Class SLiMgui</b></p>
<p class="p2"><i>5.14.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMgui</i></span><i> properties</i></p>
<p class="p5"><span class="s3">pid =&gt; (integer$)</span></p>
<p class="p6"><span class="s3">The Un*x process identifier (commonly called the “pid”) of the running SLiMgui application.<span class="Apple-converted-space">  </span>This can be useful for scripts that wish to use system calls to influence the SLiMgui application.</span></p>
<p class="p2"><i>5.14.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMgui</i></span><i> methods</i></p>
<p class="p5">– (No&lt;Plot&gt;$)createPlot(string$ title, [Nif xrange = NULL], [Nif yrange = NULL], [string$ xlab = "x"], [string$ ylab = "y"], [Nif$ width = NULL], [Nif$ height = NULL], [logical$ horizontalGrid = F], [logical$ verticalGrid = F], [logical$ fullBox = T], [numeric$ axisLabelSize = 15], [numeric$ tickLabelSize = 10])</p>
<p class="p6">Creates and returns a new custom plot referred to by <span class="s1">title</span>, or restarts and returns the existing plot with that title; if the plot cannot be created (notably, when running under SLiMguiLegacy rather than SLiMgui), <span class="s1">NULL</span> is returned.<span class="Apple-converted-space">  </span>The range for the <i>x</i> and <i>y</i> axes of the plot can optionally be provided in <span class="s1">xrange</span> and <span class="s1">yrange</span>, as vectors of length <span class="s1">2</span> containing the minimum and maximum values for the corresponding axis; the default of <span class="s1">NULL</span> for these parameters requests that the axis ranges be determined heuristically based upon the data subsequently added to the plot.<span class="Apple-converted-space">  </span>Labels for the <i>x</i> and <i>y</i> axes can be provided in <span class="s1">xlab</span> and <span class="s1">ylab</span>; if no axis label is desired, the empty string <span class="s1">""</span> may be passed.<span class="Apple-converted-space">  </span>The width and height of the window itself can optionally be set with <span class="s1">width</span> and <span class="s1">height</span>, in units of pixels (perhaps 70–100 pixels per inch, depending on your screen’s pixel density); the default of <span class="s1">NULL</span> for these parameters requests SLiMgui’s default plot window size.<span class="Apple-converted-space">  </span>The display of horizontal grid lines, vertical grid lines, and a full box around the plot area can be controlled with <span class="s1">horizontalGrid</span>, <span class="s1">verticalGrid</span>, and <span class="s1">fullBox</span> respectively, and the size (in points) of axis and tick labels can be controlled with <span class="s1">axisLabelSize</span> and <span class="s1">tickLabelSize</span> respectively.</p>
<p class="p6">Once the plot has been created, data can be added to it using <span class="s1">Plot</span> methods such as <span class="s1">lines()</span>, <span class="s1">points()</span>, and <span class="s1">text()</span>.<span class="Apple-converted-space">  </span>As with other plot windows in SLiMgui, the “action button” can be used to access plot configuration options, and to copy or save the final plot as a raster image or a PDF file.</p>
<p class="p5">– (Nfs)logFileData(object&lt;LogFile&gt;$ logFile, is$ column)</p>
<p class="p6">Returns a vector containing data from the <span class="s1">LogFile</span> object <span class="s1">logFile</span>, taken from a specified column (identified in <span class="s1">column</span> either by the column’s name or by its zero-based index).<span class="Apple-converted-space">  </span>If the data are all numeric, they will be returned as a <span class="s1">float</span> vector.<span class="Apple-converted-space">  </span>Otherwise – if the data are non-numeric – they will be returned as a <span class="s1">string</span> vector.<span class="Apple-converted-space">  </span>If the specified column does not exist in the log file, <span class="s1">NULL</span> will be returned.</p>
<p class="p6">This functionality is provided as a method on the <span class="s1">SLiMgui</span> class, rather than on <span class="s1">LogFile</span>, because in SLiMgui logged data is kept in memory anyway, for display in the debugging output viewer window.<span class="Apple-converted-space">  </span>When running at the command line logged data is not kept in memory, and thus is not available.</p>
<p class="p5"><span class="s3">– (void)openDocument(string$ filePath)</span></p>
<p class="p6">Open the document at <span class="s1">filePath</span> in SLiMgui, if possible.<span class="Apple-converted-space">  </span>Supported document types include SLiM model files (typically with a <span class="s1">.slim</span> path extension), text files (typically with a <span class="s1">.txt</span> path extension, and opened as untitled model files), and PNG, JPG/JPEG, BMP, and GIF image file formats (typically <span class="s1">.png</span> / <span class="s1">.jpg</span> / <span class="s1">.jpeg</span> / <span class="s1">.bmp</span> / <span class="s1">.gif</span>, respectively).<span class="Apple-converted-space">  </span>(Note that in SLiMguiLegacy, PDF files (<span class="s1">.pdf</span>) are supported but these other image file formats are not.)<span class="Apple-converted-space">  </span>This method can be particularly useful for opening images created by the simulation itself, often by sublaunching a plotting process in R or another environment.</p>
<p class="p5"><span class="s3">– (void)pauseExecution(void)</span></p>
<p class="p6"><span class="s3">Pauses a model that is playing in SLiMgui.<span class="Apple-converted-space">  </span>This is essentially equivalent to clicking the “Play” button to stop the execution of the model.<span class="Apple-converted-space">  </span>Execution can be resumed by the user, by clicking the “Play” button again; unlike calling </span><span class="s4">stop()</span><span class="s3"> or </span><span class="s4">simulationFinished()</span><span class="s3">, the simulation is not terminated.<span class="Apple-converted-space">  </span>This method can be useful for debugging or exploratory purposes, to pause the model at a point of interest.<span class="Apple-converted-space">  </span>Execution is paused at the end of the currently executing tick, not mid-tick.</span></p>
<p class="p6"><span class="s3">If the model is being profiled, or is executing forward to a tick number entered in the tick field, </span><span class="s4">pauseExecution()</span><span class="s3"> will do nothing; by design, </span><span class="s4">pauseExecution()</span><span class="s3"> only pauses execution when SLiMgui is doing a simple “Play” of the model.</span></p>
<p class="p5">– (No&lt;Plot&gt;$)plotWithTitle(string$ title)</p>
<p class="p6">Returns an existing plot that was created by <span class="s1">createPlot()</span> with <span class="s1">title</span>; if such a plot does not exist, <span class="s1">NULL</span> is returned.<span class="Apple-converted-space">  </span>Note that other SLiMgui plots cannot be accessed through this method; only plots created by <span class="s1">createPlot()</span> are available in Eidos.</p>
<p class="p11"><b>5.15<span class="Apple-converted-space">  </span>Class SpatialMap</b></p>
<p class="p5">(object&lt;SpatialMap&gt;$)SpatialMap(string$ name, object&lt;SpatialMap&gt;$ map)</p>
<p class="p6">Creates a new <span class="s1">SpatialMap</span> object that is a copy of <span class="s1">map</span>, named <span class="s1">name</span>.</p>
<p class="p12"><i>5.15.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>SpatialMap</i></span><i> properties</i></p>
<p class="p5">gridDimensions =&gt; (integer)</p>
<p class="p6">The dimensions of the spatial map’s grid of values, in the order of the components of the map’s spatiality.<span class="Apple-converted-space">  </span>For example, a map with spatiality <span class="s1">"xz"</span> and a grid of values that is <span class="s1">500</span> in the <span class="s1">"x"</span> dimension by <span class="s1">300</span> in the <span class="s1">"z"</span> dimension would return <span class="s1">c(500, 300)</span> for this property.</p>
<p class="p5">interpolate &lt;–&gt; (logical$)</p>
<p class="p6">Whether interpolation between grid values is enabled (<span class="s1">T</span>) or disabled (<span class="s1">F</span>).<span class="Apple-converted-space">  </span>The initial value of this property is set by <span class="s1">defineSpatialMap()</span>, but it can be changed.<span class="Apple-converted-space">  </span>The interpolation performed is linear; for cubic interpolation, use the <span class="s1">interpolate()</span> method.</p>
<p class="p5">name =&gt; (string$)</p>
<p class="p6">The name of the spatial map, usually as provided to <span class="s1">defineSpatialMap()</span>.<span class="Apple-converted-space">  </span>The names of spatial maps must be unique within any given subpopulation, but the same name may be reused for different spatial maps in different subpopulations.<span class="Apple-converted-space">  </span>The name is used to identify a map for methods such as <span class="s1">spatialMapValue()</span>, and is also used for display in SLiMgui.</p>
<p class="p5">spatialBounds =&gt; (float)</p>
<p class="p6">The spatial bounds to which the spatial map is aligned.<span class="Apple-converted-space">  </span>These bounds come from the subpopulation that originally created the map, with the <span class="s1">defineSpatialMap()</span> method, and cannot be subsequently changed.<span class="Apple-converted-space">  </span>All subpopulations that use a given spatial map must match that map’s spatial bounds, so that the map does not stretch or shrink relative to its initial configuration.<span class="Apple-converted-space">  </span>The components of the spatial bounds of a map correspond to the components of the map’s spatiality; for example, a map with spatiality <span class="s1">"xz"</span> will have bounds (<span class="s1">x0</span>, <span class="s1">z0</span>, <span class="s1">x1</span>, <span class="s1">z1</span>); bounds for <span class="s1">"y"</span> are not included, since that dimension is not used by the spatial map.</p>
<p class="p5">spatiality =&gt; (string$)</p>
<p class="p6">The spatiality of the map: the subset of the model’s dimensions that are used by the spatial map.<span class="Apple-converted-space">  </span>The spatiality of a map is configured by <span class="s1">defineSpatialMap()</span> and cannot subsequently be changed.<span class="Apple-converted-space">  </span>For example, a 3D model (with dimensionality <span class="s1">"xyz"</span>) might define a 2D spatial map with spatiality <span class="s1">"xz"</span>, providing spatial values that do not depend upon the <span class="s1">"y"</span> dimension.<span class="Apple-converted-space">  </span>Often, however, the spatiality of a map will match the dimensionality of the model.</p>
<p class="p5">tag &lt;–&gt; (integer$)</p>
<p class="p6">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods (provided by the <span class="s1">Dictionary</span> class; see the Eidos manual), for another way of attaching state to spatial maps.</p>
<p class="p12"><i>5.15.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>SpatialMap</i></span><i> methods</i></p>
<p class="p5">– (object&lt;SpatialMap&gt;$)add(ifo&lt;SpatialMap&gt; x)</p>
<p class="p6">Adds <span class="s1">x</span> to the spatial map.<span class="Apple-converted-space">  </span>One possibility is that <span class="s1">x</span> is a singleton <span class="s1">integer</span> or <span class="s1">float</span> value; in this case, <span class="s1">x</span> is added to each grid value of the target spatial map.<span class="Apple-converted-space">  </span>Another possibility is that <span class="s1">x</span> is an <span class="s1">integer</span> or <span class="s1">float</span> vector/matrix/array of the same dimensions as the target spatial map’s grid; in this case, each value of <span class="s1">x</span> is added to the corresponding grid value of the target spatial map.<span class="Apple-converted-space">  </span>The third possibility is that <span class="s1">x</span> is itself a (singleton) spatial map; in this case, each grid value of <span class="s1">x</span> is added to the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)blend(ifo&lt;SpatialMap&gt; x, float$ xFraction)</p>
<p class="p6">Blends <span class="s1">x</span> into the spatial map, giving <span class="s1">x</span> a weight of <span class="s1">xFraction</span> and the existing values in the target spatial map a weight of <span class="s1">1 - xFraction</span>, such that the resulting values in the target spatial map are then given by <span class="s1">x * xFraction + target * (1 - xFraction)</span>.<span class="Apple-converted-space">  </span>The value of <span class="s1">xFraction</span> must be in [0.0, 1.0].</p>
<p class="p6">One possibility is that <span class="s1">x</span> is a singleton <span class="s1">integer</span> or <span class="s1">float</span> value; in this case, <span class="s1">x</span> is blended with each grid value of the target spatial map.<span class="Apple-converted-space">  </span>Another possibility is that <span class="s1">x</span> is an <span class="s1">integer</span> or <span class="s1">float</span> vector/matrix/array of the same dimensions as the target spatial map’s grid; in this case, each value of <span class="s1">x</span> is blended with the corresponding grid value of the target spatial map.<span class="Apple-converted-space">  </span>The third possibility is that <span class="s1">x</span> is itself a (singleton) spatial map; in this case, each grid value of <span class="s1">x</span> is blended with the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p5">– (void)changeColors([Nif valueRange = NULL], [Ns colors = NULL])</p>
<p class="p6">Changes the color scheme for the target spatial map.<span class="Apple-converted-space">  </span>The meaning of <span class="s1">valueRange</span> and <span class="s1">colors</span> are identical to their meaning in <span class="s1">defineSpatialMap()</span>, but are also described here.</p>
<p class="p6">The <span class="s1">valueRange</span> and <span class="s1">colors</span> parameters travel together; either both are <span class="s1">NULL</span>, or both are specified.<span class="Apple-converted-space">  </span>They control how map values will be transformed into colors, by SLiMgui and by the <span class="s1">mapColor()</span> method.<span class="Apple-converted-space">  </span>The <span class="s1">valueRange</span> parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.<span class="Apple-converted-space">  </span>The <span class="s1">colors</span> parameter then establishes the corresponding colors for values within the interval defined by <span class="s1">valueRange</span>: values less than or equal to <span class="s1">valueRange[0]</span> will map to <span class="s1">colors[0]</span>, values greater than or equal to <span class="s1">valueRange[1]</span> will map to the last <span class="s1">colors</span> value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.<span class="Apple-converted-space">  </span>This is much simpler than it sounds in this description; see the recipes for an illustration of its use.</p>
<p class="p6">If <span class="s1">valueRange</span> and <span class="s1">colors</span> are both <span class="s1">NULL</span>, a default grayscale color scheme will be used in SLiMgui, but an error will result if <span class="s1">mapColor()</span> is called.</p>
<p class="p5">– (void)changeValues(ifo&lt;SpatialMap&gt; x)</p>
<p class="p6">Changes the grid values used for the target spatial map.<span class="Apple-converted-space">  </span>The parameter <span class="s1">x</span> should be either a <span class="s1">SpatialMap</span> object from which values are taken directly, or a vector, matrix, or array of numeric values as described in the documentation for <span class="s1">defineSpatialMap()</span>.<span class="Apple-converted-space">  </span>Other characteristics of the spatial map, such as its color mapping (if defined), its spatial bounds, and its spatiality, will remain unchanged.<span class="Apple-converted-space">  </span>The grid resolution of the spatial map is allowed to change with this method.<span class="Apple-converted-space">  </span>This method is useful for changing the values of a spatial map over time, such as to implement changes to the landscape’s characteristics due to seasonality, climate change, processes such as fire or urbanization, and so forth.<span class="Apple-converted-space">  </span>As with the original map values provided to <span class="s1">defineSpatialMap()</span>, it is often useful to read map values from a PNG image file using the Eidos class <span class="s1">Image</span>.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)divide(ifo&lt;SpatialMap&gt; x)</p>
<p class="p6">Divides the spatial map by <span class="s1">x</span>.<span class="Apple-converted-space">  </span>One possibility is that <span class="s1">x</span> is a singleton <span class="s1">integer</span> or <span class="s1">float</span> value; in this case, each grid value of the target spatial map is divided by <span class="s1">x</span>.<span class="Apple-converted-space">  </span>Another possibility is that <span class="s1">x</span> is an <span class="s1">integer</span> or <span class="s1">float</span> vector/matrix/array of the same dimensions as the target spatial map’s grid; in this case, each grid value of the target spatial map is divided by the corresponding value of <span class="s1">x</span>.<span class="Apple-converted-space">  </span>The third possibility is that <span class="s1">x</span> is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is divided by the corresponding grid value of <span class="s1">x</span> (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)exp(void)</p>
<p class="p6">Exponentiates the values of the spatial map.<span class="Apple-converted-space">  </span>More precisely, each grid value <i>x</i> of the target spatial map is exponentiated – replaced by the value <i>e</i><span class="s18"><i><sup>x</sup></i></span>.<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p5">– (float)gridValues(void)</p>
<p class="p6">Returns the values for the spatial map’s grid as a vector (for a 1D map), a matrix (for a 2D map), or an array (for a 3D map).<span class="Apple-converted-space">  </span>The form and orientation of the returned values is such that it could be used to create a new spatial map, with <span class="s1">defineSpatialMap()</span>, which would be identical to the original.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)interpolate(integer$ factor, [string$ method = "linear"])</p>
<p class="p6">Increases the resolution of the spatial map by <span class="s1">factor</span>, changing the dimensions of the spatial map’s grid of values (while leaving its spatial bounds unchanged), by interpolating new values between the existing values.<span class="Apple-converted-space">  </span>The parameter <span class="s1">factor</span> must be an integer in [<span class="s1">2</span>, <span class="s1">10001</span>], somewhat arbitrarily.<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p6">For a 1D spatial map, <span class="s1">factor-1</span> new values will be inserted between every pair of values in the original value grid.<span class="Apple-converted-space">  </span>A <span class="s1">factor</span> of <span class="s1">2</span> would therefore insert one new value between each pair of existing values, thereby increasing the map’s resolution by a factor of two.<span class="Apple-converted-space">  </span>Note that if the spatial map’s original grid dimension was <i>N</i>, the new grid dimension with a <span class="s1">factor</span> of <i>k</i> would be <i>k</i>(<i>N</i>−1)+1, not <i>kN</i>, because new values are inserted only <i>between</i> existing values.<span class="Apple-converted-space">  </span>For 2D and 3D spatial maps, essentially the same process is conducted along each axis of the map’s spatiality, increasing the resolution of the map by <span class="s1">factor</span> in every dimension.</p>
<p class="p6">If <span class="s1">method</span> is <span class="s1">"linear"</span> (the default), linear (or bilinear or trilinear, for 2D/3D maps) interpolation will be used to interpolate the values for the new grid points.<span class="Apple-converted-space">  </span>Alternatively, if <span class="s1">method</span> is <span class="s1">"nearest"</span>, the nearest value in the old grid will be used for new grid points; with this method, it is recommended that <span class="s1">factor</span> be odd, not even, to avoid artifacts due to rounding of coordinates midway between the original grid positions.<span class="Apple-converted-space">  </span>If method is <span class="s1">"cubic"</span>, cubic (or bicubic, for 2D maps) will be used; this generally produces smoother interpolation with fewer artifacts than <span class="s1">"linear"</span>, but it is not supported for 3D maps.<span class="Apple-converted-space">  </span>The choice of interpolation method used here is independent of the map’s <span class="s1">interpolate</span> property.<span class="Apple-converted-space">  </span>Note that while the <span class="s1">"nearest"</span> and <span class="s1">"linear"</span> interpolation methods will leave the range of values in the map unchanged, <span class="s1">"cubic"</span> interpolation may produce interpolated values that are outside the original range of values (by design).<span class="Apple-converted-space">  </span>Periodic boundaries are currently supported only for <span class="s1">"nearest"</span>, <span class="s1">"linear"</span>, and 1D <span class="s1">"cubic"</span> interpolation.</p>
<p class="p5">– (string)mapColor(numeric value)</p>
<p class="p6">Uses the spatial map’s color-translation machinery (as defined by the <span class="s1">valueRange</span> and <span class="s1">colors</span> parameters to <span class="s1">defineSpatialMap()</span>) to translate each element of <span class="s1">value</span> into a corresponding color string.<span class="Apple-converted-space">  </span>If the spatial map does not have color-translation capabilities, an error will result.<span class="Apple-converted-space">  </span>See the documentation for <span class="s1">defineSpatialMap()</span> for information regarding the details of color translation.<span class="Apple-converted-space">  </span>See the Eidos manual for further information on color strings.</p>
<p class="p5">– (object&lt;Image&gt;$)mapImage([Ni$ width = NULL], [Ni$ height = NULL], [logical$ centers = F], [logical$ color = T])</p>
<p class="p6">Returns an <span class="s1">Image</span> object sampled from the spatial map.<span class="Apple-converted-space">  </span>The image will be <span class="s1">width</span> pixels wide and <span class="s1">height</span> pixels tall; the intrinsic size of the spatial map itself will be used if one of these parameters is <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>The image will be oriented in the same way as it is displayed in SLiMgui (which conceptually entails a transformation from matrix coordinates, which store values by column, to standard image coordinates, which store values by row; see the Eidos manual’s documentation of <span class="s1">Image</span> for details).<span class="Apple-converted-space">  </span>This method may only be called for 2D spatial maps at present.</p>
<p class="p6">The sampling of the spatial map can be done in one of two ways, as controlled by the <span class="s1">centers</span> parameter.<span class="Apple-converted-space">  </span>If <span class="s1">centers</span> is <span class="s1">T</span>, a (<span class="s1">width+1</span>) × (<span class="s1">height+1</span>) grid of lines that delineates <span class="s1">width</span> × <span class="s1">height</span> rectangular pixels will be overlaid on top of the spatial map, and values will be sampled from the spatial map at the <i>center</i> of each of these pixels.<span class="Apple-converted-space">  </span>If <span class="s1">centers</span> is <span class="s1">F</span> (the default), a <span class="s1">width</span> × <span class="s1">height</span> grid of lines will be overlaid on top of the spatial map, and values will be sampled from the spatial map at the <i>vertices</i> of the grid.<span class="Apple-converted-space">  </span>If interpolation is not enabled for the spatial map, these two options will both recover the original matrix of values used to define the spatial map (assuming, here and below, that <span class="s1">width</span> and <span class="s1">height</span> are <span class="s1">NULL</span>).<span class="Apple-converted-space">  </span>If interpolation is enabled for the spatial map, however, <span class="s1">centers == F</span> will recover the original values, but will not capture the “typical” value of each pixel in the image; <span class="s1">centers == T</span>, on the other hand, will not recover the original values, but will capture the “typical” value of each pixel in the image (i.e., the value at the center of each pixel, as produced by interpolation).</p>
<p class="p6">If <span class="s1">color</span> is <span class="s1">T</span> (the default), the <span class="s1">valueRange</span> and <span class="s1">colors</span> parameters supplied to <span class="s1">defineSpatialMap()</span> will be used to translate map values to RGB color values as described in the documentation of that method, providing the same appearance as in SLiMgui; of course those parameters must have been supplied, otherwise an error will result.<span class="Apple-converted-space">  </span>If <span class="s1">color</span> is <span class="s1">F</span>, on the other hand, a grayscale image will be produced that directly reflects the map values without color translation.<span class="Apple-converted-space">  </span>In this case, this method needs to translate map values, which can have any <span class="s1">float</span> value, into grayscale pixel values that are integers in [<span class="s1">0</span>, <span class="s1">255</span>].<span class="Apple-converted-space">  </span>To do so, the map values are multiplied by <span class="s1">255.0</span>, clamped to [<span class="s1">0.0</span>, <span class="s1">255.0</span>], and then rounded to the nearest integer.<span class="Apple-converted-space">  </span>This translation scheme essentially assumes that map values are in [0, 1]; for spatial maps that were defined using the <span class="s1">floatK</span> channel of a grayscale PNG image, this should recover the original image’s pixel values.<span class="Apple-converted-space">  </span>(If a different translation scheme is desired, <span class="s1">color=T</span> with the desired <span class="s1">valueRange</span> and <span class="s1">colors</span> should be used.)</p>
<p class="p5">– (float)mapValue(float point)</p>
<p class="p6">Uses the spatial map’s mapping machinery (as defined by the <span class="s1">gridSize</span>, <span class="s1">values</span>, and <span class="s1">interpolate</span> parameters to <span class="s1">defineSpatialMap()</span>) to translate the coordinates of <span class="s1">point</span> into a corresponding map value.<span class="Apple-converted-space">  </span>The length of <span class="s1">point</span> must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality <span class="s1">"xz"</span>, <span class="s1">point</span> must be of length <span class="s1">2</span>, specifying the <i>x</i> and <i>z</i> coordinates of the point to be evaluated.<span class="Apple-converted-space">  </span>Interpolation will automatically be used if it was enabled for the spatial map.<span class="Apple-converted-space">  </span>Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use <span class="s1">pointPeriodic()</span> to wrap the point coordinates first if desired.<span class="Apple-converted-space">  </span>See the documentation for <span class="s1">defineSpatialMap()</span> for information regarding the details of value mapping.</p>
<p class="p6">The <span class="s1">point</span> parameter may also contain more than one point to be looked up.<span class="Apple-converted-space">  </span>In this case, the length of <span class="s1">point</span> must be an exact multiple of the spatiality of the spatial map; for a spatial map with spatiality <span class="s1">"xz"</span>, for example, the length of <span class="s1">point</span> must be an exact multiple of <span class="s1">2</span>, and successive pairs of elements from point (elements <span class="s1">0</span> and <span class="s1">1</span>, then elements <span class="s1">2</span> and <span class="s1">3</span>, etc.) will be taken as the <i>x</i> and <i>z</i> coordinates of the points to be evaluated.<span class="Apple-converted-space">  </span>This allows <span class="s1">mapValue()</span> to be used in a vectorized fashion.</p>
<p class="p6">The <span class="s1">spatialMapValue()</span> method of <span class="s1">Subpopulation</span> provides essentially the same functionality as this method; it may be more convenient to use, for some usage cases, and it checks that the spatial map is actually added to the subpopulation in question, providing an additional consistency check.<span class="Apple-converted-space">  </span>However, either method may be used.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)multiply(ifo&lt;SpatialMap&gt; x)</p>
<p class="p6">Multiplies the spatial map by <span class="s1">x</span>.<span class="Apple-converted-space">  </span>One possibility is that <span class="s1">x</span> is a singleton <span class="s1">integer</span> or <span class="s1">float</span> value; in this case, each grid value of the target spatial map is multiplied by <span class="s1">x</span>.<span class="Apple-converted-space">  </span>Another possibility is that <span class="s1">x</span> is an <span class="s1">integer</span> or <span class="s1">float</span> vector/matrix/array of the same dimensions as the target spatial map’s grid; in this case, each grid value of the target spatial map is multiplied by the corresponding value of <span class="s1">x</span>.<span class="Apple-converted-space">  </span>The third possibility is that <span class="s1">x</span> is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is multiplied by the corresponding grid value of <span class="s1">x</span> (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)power(ifo&lt;SpatialMap&gt; x)</p>
<p class="p6">Raises the spatial map to the power <span class="s1">x</span>.<span class="Apple-converted-space">  </span>One possibility is that <span class="s1">x</span> is a singleton <span class="s1">integer</span> or <span class="s1">float</span> value; in this case, each grid value of the target spatial map is raised to the power <span class="s1">x</span>.<span class="Apple-converted-space">  </span>Another possibility is that <span class="s1">x</span> is an <span class="s1">integer</span> or <span class="s1">float</span> vector/matrix/array of the same dimensions as the target spatial map’s grid; in this case, each grid value of the target spatial map is raised to the power of the corresponding value of <span class="s1">x</span>.<span class="Apple-converted-space">  </span>The third possibility is that <span class="s1">x</span> is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is raised to power of the corresponding grid value of <span class="s1">x</span> (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p5">– (float)range(void)</p>
<p class="p6">Returns the range of values contained in the spatial map.<span class="Apple-converted-space">  </span>The result is a <span class="s1">float</span> vector of length <span class="s1">2</span>; the first element is the minimum map value, and the second element is the maximum map value.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)rescale([numeric$ min = 0.0], [numeric$ max = 1.0])</p>
<p class="p6">Rescales the values of the spatial map to the range [<span class="s1">min</span>, <span class="s1">max</span>].<span class="Apple-converted-space">  </span>By default, the rescaling is to the range [<span class="s1">0.0</span>, <span class="s1">1.0</span>].<span class="Apple-converted-space">  </span>It is required that <span class="s1">min</span> be less than <span class="s1">max</span>, and that both be finite.<span class="Apple-converted-space">  </span>Note that the final range may not be exactly [<span class="s1">min</span>, <span class="s1">max</span>] due to numerical error.<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p5">– (float)sampleImprovedNearbyPoint(float point, float$ maxDistance, string$ functionType, ...)</p>
<p class="p6">This variant of <span class="s1">sampleNearbyPoint()</span> samples a Metropolis–Hastings move on the spatial map.<span class="Apple-converted-space">  </span>See <span class="s1">sampleNearbyPoint()</span> for discussion of the basic idea.<span class="Apple-converted-space">  </span>This method proposes a nearby point drawn from the given kernel.<span class="Apple-converted-space">  </span>If the drawn point has a larger map value than the original point, the new point is returned.<span class="Apple-converted-space">  </span>If the drawn point has a smaller map value than the original point, it is returned with a probability equal to the ratio between its map value and the original map value, otherwise the original point is returned.<span class="Apple-converted-space">  </span>The distribution of points that move (or not) to new locations governed by this method will converge upon the map itself, in a similar manner to how MCMC converges upon the posterior distribution (assuming no other forces, such as birth or death, influence the distribution of individuals).<span class="Apple-converted-space">  </span>Movement governed by this method is “improved” in the sense that points will tend to remain where they are unless the new sampled point is an improvement for them – a higher map value.<span class="Apple-converted-space">  </span>Note that unlike <span class="s1">sampleNearbyPoint()</span>, this method requires that all map values are non-negative.</p>
<p class="p6">The parameter <span class="s1">point</span> may contain any number of points; the returned vector will contain corresponding points sampled as described above.<span class="Apple-converted-space">  </span>Each supplied point must provide coordinates precisely as specified by the spatiality of the target map; for example, if the target map’s spatiality is <span class="s1">"xz"</span> (in an <span class="s1">"xyz"</span> species), each point must contain two elements, providing the <i>x</i> and <i>z</i> coordinate.<span class="Apple-converted-space">  </span>Be careful; this means that in general it is not safe to pass an individual’s <span class="s1">spatialPosition</span> property for <span class="s1">point</span>, for example (although it is safe if the spatiality of the map matches the dimensionality of the simulation); other properties on <span class="s1">Individual</span> exist for getting the individual’s coordinates in a particular spatiality, such as the <span class="s1">xz</span> property for this example.<span class="Apple-converted-space">  </span>Supplied points are not required to be within bounds, but since nearby points are sampled from the given kernel and must be within bounds, an infinite loop might result if a supplied point is substantially outside bounds.</p>
<p class="p6">The kernel is specified with a kernel type, <span class="s1">functionType</span>, followed by zero or more ellipsis arguments; see <span class="s1">smooth()</span> for further information.<span class="Apple-converted-space">  </span>For this method, at present only kernel types <span class="s1">"f"</span>, <span class="s1">"l"</span>, <span class="s1">"e"</span>, <span class="s1">"n"</span>, and <span class="s1">"t"</span> are supported, and type <span class="s1">"t"</span> is not presently supported for 3D kernels.<span class="Apple-converted-space">  </span>The parameters that define the kernel’s shape – the ellipsis arguments that follow <span class="s1">functionType</span> – may each, independently, be either a singleton or a vector with length equal to the number of points, providing a separate value for each point being processed.<span class="Apple-converted-space">  </span>In this way, all of the nearby points can be drawn from the same kernel, or each from a separately defined kernel.<span class="Apple-converted-space">  </span>Since <span class="s1">maxDistance</span> and <span class="s1">functionType</span> are required to be singletons, however, their values cannot vary from point to point in the present design.</p>
<p class="p6">See also the <span class="s1">Subpopulation</span> method <span class="s1">deviatePositionsWithMap()</span>, which is conceptually similar to this method.</p>
<p class="p5">– (float)sampleNearbyPoint(float point, float$ maxDistance, string$ functionType, ...)</p>
<p class="p6">For a spatial point supplied in <span class="s1">point</span>, returns a nearby point sampled from a kernel weighted by the spatial map’s values.<span class="Apple-converted-space">  </span>Only points within the maximum distance of the kernel, <span class="s1">maxDistance</span>, will be chosen, and the probability that a given point is chosen will be proportional to the density of the kernel at that point multiplied by the value of the map at that point (interpolated, if interpolation is enabled for the map).<span class="Apple-converted-space">  </span>Negative values of the map will be treated as zero.<span class="Apple-converted-space">  </span>The point returned will be within spatial bounds, respecting periodic boundaries if in effect (so there is no need to call <span class="s1">pointPeriodic()</span> on the result).</p>
<p class="p6">The parameter <span class="s1">point</span> may contain any number of points; the returned vector will contain corresponding points sampled as described above.<span class="Apple-converted-space">  </span>Each supplied point must provide coordinates precisely as specified by the spatiality of the target map; for example, if the target map’s spatiality is <span class="s1">"xz"</span> (in an <span class="s1">"xyz"</span> species), each point must contain two elements, providing the <i>x</i> and <i>z</i> coordinate.<span class="Apple-converted-space">  </span>Be careful; this means that in general it is not safe to pass an individual’s <span class="s1">spatialPosition</span> property for <span class="s1">point</span>, for example (although it is safe if the spatiality of the map matches the dimensionality of the simulation); other properties on <span class="s1">Individual</span> exist for getting the individual’s coordinates in a particular spatiality, such as the <span class="s1">xz</span> property for this example.<span class="Apple-converted-space">  </span>Supplied points are not required to be within bounds, but since nearby points are sampled from the given kernel and must be within bounds, an infinite loop might result if a supplied point is substantially outside bounds.</p>
<p class="p6">The kernel is specified with a kernel type, <span class="s1">functionType</span>, followed by zero or more ellipsis arguments; see <span class="s1">smooth()</span> for further information.<span class="Apple-converted-space">  </span>For this method, at present only kernel types <span class="s1">"f"</span>, <span class="s1">"l"</span>, <span class="s1">"e"</span>, <span class="s1">"n"</span>, and <span class="s1">"t"</span> are supported, and type <span class="s1">"t"</span> is not presently supported for 3D kernels.<span class="Apple-converted-space">  </span>The parameters that define the kernel’s shape – the ellipsis arguments that follow <span class="s1">functionType</span> – may each, independently, be either a singleton or a vector with length equal to the number of points, providing a separate value for each point being processed.<span class="Apple-converted-space">  </span>In this way, all of the nearby points can be drawn from the same kernel, or each from a separately defined kernel.<span class="Apple-converted-space">  </span>Since <span class="s1">maxDistance</span> and <span class="s1">functionType</span> are required to be singletons, however, their values cannot vary from point to point in the present design.</p>
<p class="p6">This method can be used to find points in the vicinity of individuals that are favorable – possessing more resources, or better environmental conditions, etc.<span class="Apple-converted-space">  </span>It can also be used to guide the dispersal or foraging behavior of individuals.<span class="Apple-converted-space">  </span>See <span class="s1">sampleImprovedNearbyPoint()</span> for a variant that may be useful for directed movement across a landscape.<span class="Apple-converted-space">  </span>Note that the algorithm for <span class="s1">sampleNearbyPoint()</span> works by rejection sampling, and so will be very inefficient if the maximum value of the map (anywhere, across the entire map) is much larger than the typical value of the map where individuals are.<span class="Apple-converted-space">  </span>The algorithm for <span class="s1">sampleImprovedNearbyPoint()</span> is different, and does not exhibit this performance issue.</p>
<p class="p6">See also the <span class="s1">Subpopulation</span> method <span class="s1">deviatePositionsWithMap()</span>, which is conceptually similar to this method.</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)smooth(float$ maxDistance, string$ functionType, ...)</p>
<p class="p6">Smooths (or blurs, one could say) the values of the spatial map by convolution with a kernel.<span class="Apple-converted-space">  </span>The kernel is specified with a maximum distance <span class="s1">maxDistance</span> (beyond which the kernel cuts off to a value of zero), a kernel type <span class="s1">functionType</span> that should be <span class="s1">"f"</span>, <span class="s1">"l"</span>, <span class="s1">"e"</span>, <span class="s1">"n"</span>, <span class="s1">"c"</span>, or <span class="s1">"t"</span>, and additional parameters in the ellipsis <span class="s1">...</span> that depend upon the kernel type and further specify its shape.<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p6">The kernel specification is similar to that for the <span class="s1">setInteractionType()</span> method of <span class="s1">InteractionType</span>, but omits the maximum value of the kernel.<span class="Apple-converted-space">  </span>Specifically, <span class="s1">functionType</span> may be <span class="s1">"f"</span>, in which case no ellipsis arguments should be supplied; <span class="s1">"l"</span>, similarly with no ellipsis arguments; <span class="s1">"e"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> lambda (rate) parameter for a negative exponential function; <span class="s1">"n"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> sigma (standard deviation) parameter for a Gaussian function; <span class="s1">"c"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> scale parameter for a Cauchy distribution function; or <span class="s1">"t"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> degrees of freedom and a <span class="s1">numeric$</span> scale parameter for a <i>t</i>-distribution function.<span class="Apple-converted-space">  </span>See the <span class="s1">InteractionType</span> class documentation for discussions of these kernel types.</p>
<p class="p6">Distance metrics specified to this method, such as <span class="s1">maxDistance</span> and the additional kernel shape parameters, are measured in the distance scale of the spatial map – the same distance scale in which the spatial bounds of the map are specified.<span class="Apple-converted-space">  </span>The operation is performed upon the grid values of the spatial map; distances are internally translated into the scale of the value grid.<span class="Apple-converted-space">  </span>For non-periodic boundaries, clipping at the edge of the spatial map is done; in a 2D map with no periodic boundaries, for example, the weights of edge and corner grid values are adjusted for their partial (one-half and one-quarter) coverage.<span class="Apple-converted-space">  </span>For periodic boundaries, the smoothing operation will automatically wrap around based upon the assumption that the grid values at the two connected edges of the periodic boundary have identical values (which they should, since by definition they represent the same position in space).</p>
<p class="p6">The density scale of the kernel has no effect and will be normalized; this is the reason that <span class="s1">smooth()</span>, unlike <span class="s1">InteractionType</span>, does not require specification of the maximum value of the kernel.<span class="Apple-converted-space">  </span>This normalization prevents the kernel from increasing or decreasing the average spatial map value (apart from possible edge effects).</p>
<p class="p5">– (object&lt;SpatialMap&gt;$)subtract(ifo&lt;SpatialMap&gt; x)</p>
<p class="p6">Subtracts <span class="s1">x</span> from the spatial map.<span class="Apple-converted-space">  </span>One possibility is that <span class="s1">x</span> is a singleton <span class="s1">integer</span> or <span class="s1">float</span> value; in this case, <span class="s1">x</span> is subtracted from each grid value of the target spatial map.<span class="Apple-converted-space">  </span>Another possibility is that <span class="s1">x</span> is an <span class="s1">integer</span> or <span class="s1">float</span> vector/matrix/array of the same dimensions as the target spatial map’s grid; in this case, each value of <span class="s1">x</span> is subtracted from the corresponding grid value of the target spatial map.<span class="Apple-converted-space">  </span>The third possibility is that <span class="s1">x</span> is itself a (singleton) spatial map; in this case, each grid value of <span class="s1">x</span> is subtracted from the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).<span class="Apple-converted-space">  </span>The target spatial map is returned, to allow easy chaining of operations.</p>
<p class="p1"><b>5.16<span class="Apple-converted-space">  </span>Class Species</b></p>
<p class="p2"><i>5.16.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Species</i></span><i> properties</i></p>
<p class="p5">avatar =&gt; (string$)</p>
<p class="p6">The avatar string used to represent this species in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Avatars are typically one-character strings, often using an emoji that symbolizes the species.<span class="Apple-converted-space">  </span>This property is read-only; its value should be set with the <span class="s1">avatar</span> parameter of <span class="s1">initializeSpecies()</span>.</p>
<p class="p5">chromosome =&gt; (object&lt;Chromosome&gt;$)</p>
<p class="p6">The <span class="s1">Chromosome</span> object used by the species.<span class="Apple-converted-space">  </span>This property may only be accessed in a single-chromosome model; if there are multiple chromosomes (or none), the <span class="s1">chromosomes</span> property must be used instead.</p>
<p class="p5">chromosomes =&gt; (object&lt;Chromosome&gt;)</p>
<p class="p6">The <span class="s1">Chromosome</span> objects used by the species, in the order in which they were defined.<span class="Apple-converted-space">  </span>See also the <span class="s1">sexChromosomes</span> property.</p>
<p class="p5">color =&gt; (string$)</p>
<p class="p6">The color used to display information about this species in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span> (see the Eidos manual).<span class="Apple-converted-space">  </span>This property is read-only; its value should be set with the <span class="s1">color</span> parameter of <span class="s1">initializeSpecies()</span>.</p>
<p class="p5">cycle &lt;–&gt; (integer$)</p>
<p class="p6">The current cycle count for this species.<span class="Apple-converted-space">  </span>This counter begins at 1, and increments at the end of every tick in which the species is active.<span class="Apple-converted-space">  </span>In models with non-overlapping generations, particularly WF models, this can be thought of as a generation counter.</p>
<p class="p5">description &lt;–&gt; (string$)</p>
<p class="p6">A human-readable <span class="s1">string</span> description for the species.<span class="Apple-converted-space">  </span>By default, this is the empty string, <span class="s1">""</span>; however, it may be set to whatever you wish.</p>
<p class="p3">dimensionality =&gt; (string$)</p>
<p class="p4">The spatial dimensionality of the simulation for this species, as specified in <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>This will be <span class="s1">""</span> (the empty string) for non-spatial simulations (the default), or <span class="s1">"x"</span>, <span class="s1">"xy"</span>, or <span class="s1">"xyz"</span>, for simulations using those spatial dimensions respectively.</p>
<p class="p3">genomicElementTypes =&gt; (object&lt;GenomicElementType&gt;)</p>
<p class="p6"><span class="s5">The </span><span class="s6">GenomicElementType</span><span class="s5"> objects being used in the species.</span><span class="Apple-converted-space">  </span>These are guaranteed to be in sorted order, by their <span class="s1">id</span> property.</p>
<p class="p5">id =&gt; (integer$)</p>
<p class="p6">The identifier for this species.<span class="Apple-converted-space">  </span>Species identifiers are determined by their declaration order in the script; the first declared species is given an <span class="s1">id</span> of <span class="s1">0</span>, the second is given an <span class="s1">id</span> of <span class="s1">1</span>, and so forth.</p>
<p class="p3">mutationTypes =&gt; (object&lt;MutationType&gt;)</p>
<p class="p6"><span class="s5">The </span><span class="s6">MutationType</span><span class="s5"> objects being used in the species.</span><span class="Apple-converted-space">  </span>These are guaranteed to be in sorted order, by their <span class="s1">id</span> property.</p>
<p class="p3">mutations =&gt; (object&lt;Mutation&gt;)</p>
<p class="p4">The <span class="s1">Mutation</span> objects that are currently active in the species.</p>
<p class="p5">name =&gt; (string$)</p>
<p class="p6">A human-readable <span class="s1">string</span> name for the subpopulation.<span class="Apple-converted-space">  </span>This is always the declared name of the species, as given in the explicit species declaration in script, and cannot be changed.<span class="Apple-converted-space">  </span>The <span class="s1">name</span> of a species may appear as a label in SLiMgui, and it can be useful in generating output, debugging, and other purposes.<span class="Apple-converted-space">  </span>See also the description property, which can be changed by the user and used for any purpose.</p>
<p class="p5"><span class="s3">nucleotideBased =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">If </span><span class="s4">T</span><span class="s3">, the model for this species is nucleotide-based; if </span><span class="s4">F</span><span class="s3">, it is not.<span class="Apple-converted-space">  </span>See the discussion of the </span><span class="s4">nucleotideBased</span><span class="s3"> parameter to </span><span class="s4">initializeSLiMOptions()</span><span class="s3"> for discussion.</span></p>
<p class="p3">periodicity =&gt; (string$)</p>
<p class="p6"><span class="s3">The spatial periodicity of the simulation for this species, as specified in </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.<span class="Apple-converted-space">  </span>This will be </span><span class="s4">""</span><span class="s3"> (the empty string) for non-spatial simulations and simulations with no periodic spatial dimensions (the default).<span class="Apple-converted-space">  </span>Otherwise, it will be a string representing the subset of spatial dimensions that have been declared to be periodic, as specified to </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p3">scriptBlocks =&gt; (object&lt;SLiMEidosBlock&gt;)</p>
<p class="p6">All registered <span class="s1">SLiMEidosBlock</span> objects in the simulation that have been declared with this species as their <span class="s1">species</span> specifier (<i>not</i> <span class="s1">ticks</span> specifier).<span class="Apple-converted-space">  </span>These will always be callback blocks; callbacks are species-specific, while other types of blocks are not.</p>
<p class="p5">sexChromosomes =&gt; (object&lt;Chromosome&gt;)</p>
<p class="p6">The <span class="s1">Chromosome</span> objects used by the species that represent sex chromosomes, in the order in which they were defined.<span class="Apple-converted-space">  </span>Sex chromosomes are specifically those of type <span class="s1">"X"</span>, <span class="s1">"Y"</span>, <span class="s1">"W"</span>, <span class="s1">"Z"</span>, and <span class="s1">"-Y"</span>.<span class="Apple-converted-space">  </span>See also the <span class="s1">chromosomes</span> property, and the <span class="s1">isSexChromosome</span> property of <span class="s1">Chromosome</span>.</p>
<p class="p3">sexEnabled =&gt; (logical$)</p>
<p class="p4">If <span class="s1">T</span>, sex is enabled for this species; if <span class="s1">F</span>, individuals are hermaphroditic.</p>
<p class="p3">subpopulations =&gt; (object&lt;Subpopulation&gt;)</p>
<p class="p6"><span class="s5">The </span><span class="s6">Subpopulation</span><span class="s5"> instances currently defined in the species.</span><span class="Apple-converted-space">  </span>These are guaranteed to be in sorted order, by their <span class="s1">id</span> property.</p>
<p class="p3">substitutions =&gt; (object&lt;Substitution&gt;)</p>
<p class="p4">A vector of <span class="s1">Substitution</span> objects, representing all mutations that have been fixed in this species.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to the simulation.</p>
<p class="p2"><i>5.16.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Species</i></span><i> methods</i></p>
<p class="p5">– (object&lt;Dictionary&gt;$)addPatternForClone(iso&lt;Chromosome&gt;$ chromosome, No&lt;Dictionary&gt;$ pattern, object&lt;Individual&gt;$ parent, [Ns$ sex = NULL])</p>
<p class="p6">Adds an inheritance dictionary for the specified chromosome to the pattern dictionary <span class="s1">pattern</span>, representing producing a clone of <span class="s1">parent</span>, with sex optionally specified by <span class="s1">sex</span>.<span class="Apple-converted-space">  </span>The parameter <span class="s1">chromosome</span> can provide a chromosome <span class="s1">id</span> (an <span class="s1">integer</span>), a chromosome <span class="s1">symbol</span> (a <span class="s1">string</span>), or a <span class="s1">Chromosome</span> object.<span class="Apple-converted-space">  </span>The resulting pattern dictionary is intended for use with the <span class="s1">Subpopulation</span> method <span class="s1">addMultiRecombinant()</span>; see that method for background on the use of pattern dictionaries.</p>
<p class="p6">The parameter <span class="s1">pattern</span> must be a <span class="s1">Dictionary</span> (or a subclass of <span class="s1">Dictionary</span>), or <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is <span class="s1">NULL</span>, a new singleton object of class <span class="s1">Dictionary</span> will be created, set up, and returned; otherwise, the returned object is the same object passed in as <span class="s1">pattern</span>.<span class="Apple-converted-space">  </span>The inheritance dictionary generated by <span class="s1">addPatternForClone()</span> will be added to <span class="s1">pattern</span> as the value for a particular key.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is already configured to use <span class="s1">string</span> keys, the key used will be the <span class="s1">symbol</span> property of the chromosome; otherwise, including if <span class="s1">pattern</span> is <span class="s1">NULL</span>, the key used will be the <span class="s1">id</span> property of the chromosome.<span class="Apple-converted-space">  </span>If the key in question already exists in <span class="s1">pattern</span>, its value will be replaced.</p>
<p class="p6">The precise inheritance pattern generated by this method depends upon the chromosome’s type; see <span class="s1">initializeChromosome()</span> for a description of the different chromosome types and the ways in which they are inherited.<span class="Apple-converted-space">  </span>The pattern will be the same as would be used by the <span class="s1">addCloned()</span> method for the chromosome.<span class="Apple-converted-space">  </span>If <span class="s1">sex</span> is <span class="s1">NULL</span>, the sex of the offspring is assumed to be the same as the parent; in non-sexual models, <span class="s1">NULL</span> must be passed.<span class="Apple-converted-space">  </span>If the sex of the offspring will be different from the parent, <span class="s1">"M"</span> or <span class="s1">"F"</span> should be passed; if changing the sex from parent to offspring presents any genetic problems (if the chromosome is a sex chromosome, for example), an error will be raised, but if the chromosome does not depend upon sex, the change of sex will be allowed.<span class="Apple-converted-space">  </span>Note that the generated inheritance dictionary does not encode the offspring sex; the <span class="s1">sex</span> parameter is simply used to determine and validate the inheritance pattern for the specified chromosome.<span class="Apple-converted-space">  </span>The final pattern dictionary passed to <span class="s1">addMultiRecombinant()</span> will be validated against the <span class="s1">sex</span> parameter given to that method.</p>
<p class="p6">It is typically not necessary to call <span class="s1">addPatternForClone()</span>, since <span class="s1">addMultiRecombinant()</span> will usually automatically infer the correct inheritance pattern from its parental individual <span class="s1">parent1</span> if an inheritance dictionary for the chromosome is not supplied in <span class="s1">pattern</span>.<span class="Apple-converted-space">  </span>This method is needed primarily for edge cases, such as if <span class="s1">addMultiRecombinant()</span> is being used to generate a biparental cross, but a particular chromosome should be cloned from just one of the parents in a manner that the biparental cross would not do automatically.</p>
<p class="p5">– (object&lt;Dictionary&gt;$)addPatternForCross(iso&lt;Chromosome&gt;$ chromosome, No&lt;Dictionary&gt;$ pattern, object&lt;Individual&gt;$ parent1, object&lt;Individual&gt;$ parent2, [Ns$ sex = NULL])</p>
<p class="p6">Adds an inheritance dictionary for the specified chromosome to the pattern dictionary <span class="s1">pattern</span>, representing a biparental cross between <span class="s1">parent1</span> and <span class="s1">parent2</span> to generate an offspring, with sex optionally specified by <span class="s1">sex</span>.<span class="Apple-converted-space">  </span>The parameter <span class="s1">chromosome</span> can provide a chromosome <span class="s1">id</span> (an <span class="s1">integer</span>), a chromosome <span class="s1">symbol</span> (a <span class="s1">string</span>), or a <span class="s1">Chromosome</span> object.<span class="Apple-converted-space">  </span>The resulting pattern dictionary is intended for use with the <span class="s1">Subpopulation</span> method <span class="s1">addMultiRecombinant()</span>; see that method for background on the use of pattern dictionaries.</p>
<p class="p6">The parameter <span class="s1">pattern</span> must be a <span class="s1">Dictionary</span> (or a subclass of <span class="s1">Dictionary</span>), or <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is <span class="s1">NULL</span>, a new singleton object of class <span class="s1">Dictionary</span> will be created, set up, and returned; otherwise, the returned object is the same object passed in as <span class="s1">pattern</span>.<span class="Apple-converted-space">  </span>The inheritance dictionary generated by <span class="s1">addPatternForCross()</span> will be added to <span class="s1">pattern</span> as the value for a particular key.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is already configured to use <span class="s1">string</span> keys, the key used will be the <span class="s1">symbol</span> property of the chromosome; otherwise, including if <span class="s1">pattern</span> is <span class="s1">NULL</span>, the key used will be the <span class="s1">id</span> property of the chromosome.<span class="Apple-converted-space">  </span>If the key in question already exists in <span class="s1">pattern</span>, its value will be replaced.</p>
<p class="p6">The precise inheritance pattern generated by this method depends upon the chromosome’s type; see <span class="s1">initializeChromosome()</span> for a description of the different chromosome types and the ways in which they are inherited.<span class="Apple-converted-space">  </span>The pattern will be the same as would be used by the <span class="s1">addCrossed()</span> method for the chromosome.<span class="Apple-converted-space">  </span>In some cases, the value of <span class="s1">sex</span> is unimportant and may be left as <span class="s1">NULL</span>; a <span class="s1">NULL</span> value for <span class="s1">sex</span> essentially asserts that the sex of the offspring is unimportant to the inheritance pattern for the chromosome with the given parents.<span class="Apple-converted-space">  </span>If that assertion is untrue – if the sex needs to be known, for example to know how a sex chromosome should be inherited – an error will be raised.<span class="Apple-converted-space">  </span>When the sex needs to be known, <span class="s1">"M"</span> or <span class="s1">"F"</span> must be passed so that the correct inheritance pattern can be generated.<span class="Apple-converted-space">  </span>In non-sexual models, <span class="s1">NULL</span> must be passed.<span class="Apple-converted-space">  </span>Note that the generated inheritance dictionary does not encode the offspring sex; the <span class="s1">sex</span> parameter is simply used to determine and validate the inheritance pattern for the specified chromosome.<span class="Apple-converted-space">  </span>The final pattern dictionary passed to <span class="s1">addMultiRecombinant()</span> will be validated against the <span class="s1">sex</span> parameter given to that method.</p>
<p class="p6">It is typically not necessary to call <span class="s1">addPatternForCross()</span>, since <span class="s1">addMultiRecombinant()</span> will usually automatically infer the correct inheritance pattern from its parental individuals <span class="s1">parent1</span> and <span class="s1">parent2</span> if an inheritance dictionary for the chromosome is not supplied in <span class="s1">pattern</span>.<span class="Apple-converted-space">  </span>This method is needed primarily for edge cases, such as if <span class="s1">addMultiRecombinant()</span> is being used to generate a clonal offspring, but a particular chromosome should be produced with recombination.</p>
<p class="p5">– (object&lt;Dictionary&gt;$)addPatternForNull(iso&lt;Chromosome&gt;$ chromosome, No&lt;Dictionary&gt;$ pattern, [Ns$ sex = NULL])</p>
<p class="p6">Adds an inheritance dictionary for the specified chromosome to the pattern dictionary <span class="s1">pattern</span>, representing a non-inheritance event producing null haplosomes, with sex optionally specified by <span class="s1">sex</span>.<span class="Apple-converted-space">  </span>The parameter <span class="s1">chromosome</span> can provide a chromosome <span class="s1">id</span> (an <span class="s1">integer</span>), a chromosome <span class="s1">symbol</span> (a <span class="s1">string</span>), or a <span class="s1">Chromosome</span> object.<span class="Apple-converted-space">  </span>The resulting pattern dictionary is intended for use with the <span class="s1">Subpopulation</span> method <span class="s1">addMultiRecombinant()</span>; see that method for background on the use of pattern dictionaries.</p>
<p class="p6">The parameter <span class="s1">pattern</span> must be a <span class="s1">Dictionary</span> (or a subclass of <span class="s1">Dictionary</span>), or <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is <span class="s1">NULL</span>, a new singleton object of class <span class="s1">Dictionary</span> will be created, set up, and returned; otherwise, the returned object is the same object passed in as <span class="s1">pattern</span>.<span class="Apple-converted-space">  </span>The inheritance dictionary generated by <span class="s1">addPatternForNull()</span> will be added to <span class="s1">pattern</span> as the value for a particular key.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is already configured to use <span class="s1">string</span> keys, the key used will be the <span class="s1">symbol</span> property of the chromosome; otherwise, including if <span class="s1">pattern</span> is <span class="s1">NULL</span>, the key used will be the <span class="s1">id</span> property of the chromosome.<span class="Apple-converted-space">  </span>If the key in question already exists in <span class="s1">pattern</span>, its value will be replaced.</p>
<p class="p6">For all chromosome types, this method will simply produce a null haplosome or haplosomes for the specified chromosome.<span class="Apple-converted-space">  </span>If the chromosome does not allow a null haplosome, an error will be raised.<span class="Apple-converted-space">  </span>In some cases, the value of <span class="s1">sex</span> is unimportant and may be left as <span class="s1">NULL</span>; a <span class="s1">NULL</span> value for <span class="s1">sex</span> essentially asserts that the chromosome allows null haplosomes for any sex.<span class="Apple-converted-space">  </span>If that assertion is untrue – if the sex needs to be known, for example to know whether a null haplosome is allowed for a sex chromosome – an error will be raised.<span class="Apple-converted-space">  </span>When the sex needs to be known, <span class="s1">"M"</span> or <span class="s1">"F"</span> must be passed so that <span class="s1">addPatternForNull()</span> is satisfied that a legal pattern for the chromosome will be generated.<span class="Apple-converted-space">  </span>In non-sexual models, <span class="s1">NULL</span> must be passed.<span class="Apple-converted-space">  </span>Note that the generated inheritance dictionary does not encode the offspring sex; the <span class="s1">sex</span> parameter is simply used to determine and validate the inheritance pattern for the specified chromosome.<span class="Apple-converted-space">  </span>The final pattern dictionary passed to <span class="s1">addMultiRecombinant()</span> will be validated against the <span class="s1">sex</span> parameter given to that method.</p>
<p class="p6">If only one of the two haplosomes for a diploid chromosome should be a null haplosome, and <span class="s1">addPatternForCrossed()</span> and <span class="s1">addPatternForCloned()</span> would not produce the desired pattern, use <span class="s1">addPatternForRecombinant()</span>, which provides complete control.</p>
<p class="p5">– (object&lt;Dictionary&gt;$)addPatternForRecombinant(iso&lt;Chromosome&gt;$ chromosome, No&lt;Dictionary&gt;$ pattern, No&lt;Haplosome&gt;$ strand1, No&lt;Haplosome&gt;$ strand2, Ni breaks1, No&lt;Haplosome&gt;$ strand3, No&lt;Haplosome&gt;$ strand4, Ni breaks2, [Ns$ sex = NULL], [logical$ randomizeStrands = T])</p>
<p class="p6">Adds an inheritance dictionary for the specified chromosome to the pattern dictionary <span class="s1">pattern</span>, representing inheritance by cloning, recombination, or both, to generate an offspring from up to four parental haplosomes, with sex optionally specified by <span class="s1">sex</span>.<span class="Apple-converted-space">  </span>The parameter <span class="s1">chromosome</span> can provide a chromosome <span class="s1">id</span> (an <span class="s1">integer</span>), a chromosome <span class="s1">symbol</span> (a <span class="s1">string</span>), or a <span class="s1">Chromosome</span> object.<span class="Apple-converted-space">  </span>The resulting pattern dictionary is intended for use with the <span class="s1">Subpopulation</span> method <span class="s1">addMultiRecombinant()</span>; see that method for background on the use of pattern dictionaries.</p>
<p class="p6">The parameter <span class="s1">pattern</span> must be a <span class="s1">Dictionary</span> (or a subclass of <span class="s1">Dictionary</span>), or <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is <span class="s1">NULL</span>, a new singleton object of class <span class="s1">Dictionary</span> will be created, set up, and returned; otherwise, the returned object is the same object passed in as <span class="s1">pattern</span>.<span class="Apple-converted-space">  </span>The inheritance dictionary generated by <span class="s1">addPatternForRecombinant()</span> will be added to <span class="s1">pattern</span> as the value for a particular key.<span class="Apple-converted-space">  </span>If <span class="s1">pattern</span> is already configured to use <span class="s1">string</span> keys, the key used will be the <span class="s1">symbol</span> property of the chromosome; otherwise, including if <span class="s1">pattern</span> is <span class="s1">NULL</span>, the key used will be the <span class="s1">id</span> property of the chromosome.<span class="Apple-converted-space">  </span>If the key in question already exists in <span class="s1">pattern</span>, its value will be replaced.</p>
<p class="p6">When passed the resulting pattern dictionary, the <span class="s1">addMultiRecombinant()</span> method will produce the first offspring haplosome using the <span class="s1">Haplosome</span> objects <span class="s1">strand1</span> and <span class="s1">strand2</span> with the vector of recombination breakpoints <span class="s1">breaks1</span>, and likewise will produce the second offspring haplosome using <span class="s1">strand3</span>, <span class="s1">strand4</span>, and <span class="s1">breaks2</span>.<span class="Apple-converted-space">  </span>If both parental strands for an offspring haplosome are <span class="s1">NULL</span>, the breaks vector must be <span class="s1">NULL</span> or empty, and a null haplosome will be produced.<span class="Apple-converted-space">  </span>If the first parental strand is non-<span class="s1">NULL</span> and the second is <span class="s1">NULL</span> for an offspring haplosome, the breaks vector must again be <span class="s1">NULL</span> or empty, and the first strand will be cloned with mutation.<span class="Apple-converted-space">  </span>If both parental strands for an offspring haplosome are non-<span class="s1">NULL</span>, recombination between the strands will be done using the supplied breaks vector; in this case, if the breaks vector is <span class="s1">NULL</span> then <span class="s1">addMultiRecombinant()</span> will automatically generate breakpoints for the recombination.<span class="Apple-converted-space">  </span>All of these semantics are discussed further in the documentation for <span class="s1">addMultiRecombinant()</span>; this method is just a helper for that method.<span class="Apple-converted-space">  </span>The documentation for <span class="s1">addRecombinant()</span> may also be helpful for understanding the concepts here, since it is the conceptual foundation upon which the very complex architecture of the <span class="s1">addMultiRecombinant()</span> method is built.</p>
<p class="p6">Unlike <span class="s1">addPatternForClone()</span> and <span class="s1">addPatternForCrossed()</span>, which must infer the inheritance pattern given the chromosome type and the offspring sex, <span class="s1">addPatternForRecombinant()</span> is given the inheritance pattern, and must simply confirm that it is valid.<span class="Apple-converted-space">  </span>If <span class="s1">sex</span> is <span class="s1">NULL</span> (the default), this validation only needs to check that the inheritance pattern is possible, for some sex.<span class="Apple-converted-space">  </span>For example, if the chromosome type is <span class="s1">"X"</span> then the inheritance pattern must produce a non-null first haplosome, and the second haplosome can be null (for a male, X–) or non-null (for a female, XX); other inheritance patterns would fail validation.<span class="Apple-converted-space">  </span>When the sex is known, <span class="s1">"M"</span> or <span class="s1">"F"</span> may optionally be passed to validate against that sex; X– would then fail validation if a female is specified, for example.<span class="Apple-converted-space">  </span>In non-sexual models, <span class="s1">NULL</span> must be passed.<span class="Apple-converted-space">  </span>Note that the generated inheritance dictionary does not encode the offspring sex; the <span class="s1">sex</span> parameter is simply used for validation.<span class="Apple-converted-space">  </span>The final pattern dictionary passed to <span class="s1">addMultiRecombinant()</span> will be validated against the <span class="s1">sex</span> parameter given to that method.</p>
<p class="p6">The <span class="s1">randomizeStrands</span> parameter indicates whether or not the order of recombining parental strands should be randomized in the inheritance dictionary.<span class="Apple-converted-space">  </span>If <span class="s1">randomizeStrands</span> is <span class="s1">T</span>, then if <span class="s1">strand1</span> and <span class="s1">strand2</span> are both non-<span class="s1">NULL</span>, their order will be randomized; and similarly for <span class="s1">strand3</span> and <span class="s1">strand4</span>.<span class="Apple-converted-space">  </span>If <span class="s1">randomizeStrands</span> is <span class="s1">F</span>, no randomization will be done in the inheritance dictionary – but strand order randomization may still be done by <span class="s1">addMultiRecombinant()</span> if <span class="s1">T</span> is passed for its own <span class="s1">randomizeStrands</span> parameter.<span class="Apple-converted-space">  </span>Randomizing the strand order is usually desirable, to avoid an inheritance bias due to a lack of randomization in the initial copy strand.<span class="Apple-converted-space">  </span>Whether you wish to randomize strand order in <span class="s1">addPatternForRecombinant()</span> or in <span class="s1">addMultiRecombinant()</span> is up to you; it is harmless to do it in both places, apart from a small performance penalty, but there is no benefit.</p>
<p class="p6">Of the family of <span class="s1">addPatternFor...()</span> methods, <span class="s1">addPatternForRecombinant()</span> is the most commonly used.<span class="Apple-converted-space">  </span>Typically, <span class="s1">addMultiRecombinant()</span> can automatically infer the correct inheritance pattern for crossing or cloning (as described in its documentation), but for more complex inheritance patterns, using <span class="s1">addPatternForRecombinant()</span> is necessary (unless you want to build the pattern dictionary yourself).</p>
<p class="p3">– (object&lt;Subpopulation&gt;$)addSubpop(is$ subpopID, integer$ size, [float$ sexRatio = 0.5]<span class="s5">, [logical$ haploid = F]</span>)</p>
<p class="p6">Add a new subpopulation with id <span class="s1">subpopID</span> and <span class="s1">size</span> individuals.<span class="Apple-converted-space">  </span>The <span class="s1">subpopID</span> parameter may be either an <span class="s1">integer</span> giving the ID of the new subpopulation, or a <span class="s1">string</span> giving the name of the new subpopulation (such as <span class="s1">"p5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>Only if sex is enabled for the species, the initial sex ratio may optionally be specified as <span class="s1">sexRatio</span> (as the male fraction, M:M+F); if it is not specified, a default of <span class="s1">0.5</span> is used.<span class="Apple-converted-space">  </span>The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.<span class="Apple-converted-space">  </span>Subpopulations added by this method will initially consist of individuals with empty haplosomes.<span class="Apple-converted-space">  </span>In order to model subpopulations that split from an already existing subpopulation, use <span class="s1">addSubpopSplit()</span>.</p>
<p class="p6">The <span class="s1">haploid</span> parameter defaults to <span class="s1">F</span>, indicating that the generated individuals should adopt their natural ploidy; in particular, type <span class="s1">"A"</span> chromosomes should be represented in each individual by two empty haplosomes.<span class="Apple-converted-space">  </span>The <span class="s1">haploid</span> parameter may instead be <span class="s1">T</span>; in this case, for all chromosomes of type <span class="s1">"A"</span> (and only that type), the second haplosome of each new individual will be a null haplosome, rather than an empty haplosome.<span class="Apple-converted-space">  </span>This could be useful in a model of haplodiploidy, for example, to generate initial individuals that are haploid for the autosomal chromosomes of the species.<span class="Apple-converted-space">  </span>For even greater control in nonWF models, you can call <span class="s1">addSubpop()</span> with an initial size of <span class="s1">0</span> and then stock the population with new individuals created however you wish in the next tick’s <span class="s1">reproduction()</span> callback, such as with the <span class="s1">addEmpty()</span> method, providing separate control over the configuration of each individual.</p>
<p class="p3">– (object&lt;Subpopulation&gt;$)addSubpopSplit(is$ subpopID, integer$ size, io&lt;Subpopulation&gt;$ sourceSubpop, [float$ sexRatio = 0.5])</p>
<p class="p6">Split off a new subpopulation with id <span class="s1">subpopID</span> and <span class="s1">size</span> individuals derived from subpopulation <span class="s1">sourceSubpop</span>.<span class="Apple-converted-space">  </span>The <span class="s1">subpopID</span> parameter may be either an <span class="s1">integer</span> giving the ID of the new subpopulation, or a <span class="s1">string</span> giving the name of the new subpopulation (such as <span class="s1">"p5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>The <span class="s1">sourceSubpop</span> parameter may specify the source subpopulation either as a <span class="s1">Subpopulation</span> object or by <span class="s1">integer</span> identifier.<span class="Apple-converted-space">  </span>Only if sex is enabled for the species, the initial sex ratio may optionally be specified as <span class="s1">sexRatio</span> (as the male fraction, M:M+F); if it is not specified, a default of <span class="s1">0.5</span> is used.<span class="Apple-converted-space">  </span>The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p6">Subpopulations added by this method will consist of individuals that are clonal copies of individuals from the source subpopulation, randomly chosen with probabilities proportional to fitness.<span class="Apple-converted-space">  </span>The fitness of all of these initial individuals is considered to be 1.0, to avoid a doubled round of selection in the initial tick, given that fitness values were already used to choose the individuals to clone.<span class="Apple-converted-space">  </span>Once this initial set of individuals has mated to produce offspring, the model is effectively of parental individuals in the source subpopulation mating randomly according to fitness, as usual in SLiM, with juveniles migrating to the newly added subpopulation.<span class="Apple-converted-space">  </span>Effectively, then, then new subpopulation is created empty, and is filled by migrating juveniles from the source subpopulation, in accordance with SLiM’s usual model of juvenile migration.</p>
<p class="p5">– (object&lt;Chromosome&gt;)chromosomesOfType(string$ type)</p>
<p class="p6">Returns a vector of <span class="s1">Chromosome</span> objects of the chromosome type supplied in <span class="s1">type</span>, in the order if which they were defined.<span class="Apple-converted-space">  </span>If <span class="s1">type</span> does not correspond to a chromosome type accepted by <span class="s1">initializeChromosome()</span>, an error will be raised.<span class="Apple-converted-space">  </span>See also <span class="s1">chromosomesWithIDs()</span> and <span class="s1">chromosomesWithSymbols()</span>.</p>
<p class="p5">– (object&lt;Chromosome&gt;)chromosomesWithIDs(integer ids)</p>
<p class="p6">Returns a vector of <span class="s1">Chromosome</span> objects corresponding to the chromosome ids supplied in <span class="s1">ids</span>, in the same order.<span class="Apple-converted-space">  </span>If any chromosome id in <span class="s1">ids</span> does not correspond to a chromosome in the target species, an error will be raised.<span class="Apple-converted-space">  </span>See also <span class="s1">chromosomesOfType()</span> and <span class="s1">chromosomesWithSymbols()</span>.</p>
<p class="p5">– (object&lt;Chromosome&gt;)chromosomesWithSymbols(string symbols)</p>
<p class="p6">Returns a vector of <span class="s1">Chromosome</span> objects corresponding to the chromosome symbols supplied in <span class="s1">symbols</span>, in the same order.<span class="Apple-converted-space">  </span>If any chromosome symbol in <span class="s1">symbols</span> does not correspond to a chromosome in the target species, an error will be raised.<span class="Apple-converted-space">  </span>See also <span class="s1">chromosomesOfType()</span> and <span class="s1">chromosomesWithIDs()</span>.</p>
<p class="p3"><span class="s5">– </span>(integer$)countOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the number of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations that are currently active in the species.<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just a count, use <span class="s1">-mutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is often used to determine whether an introduced mutation is still active (as opposed to being either lost or fixed).<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p5">– (object&lt;Individual&gt;)individualsWithPedigreeIDs(integer pedigreeIDs, [Nio&lt;Subpopulation&gt; subpops = NULL])</p>
<p class="p6">Looks up individuals by pedigree ID, optionally within specific subpopulations.<span class="Apple-converted-space">  </span>Pedigree tracking must be turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span> to use this method, otherwise an error will result.<span class="Apple-converted-space">  </span>This method is vectorized; more than one pedigree id may be passed in <span class="s1">pedigreeID</span>, in which case the returned vector will contain all of the individuals for which a match was found (in the same order in which they were supplied).<span class="Apple-converted-space">  </span>If a given id is not found, the returned vector will contain no entry for that id (so the length of the returned vector may not match the length of <span class="s1">pedigreeIDs</span>).<span class="Apple-converted-space">  </span>If none of the given ids were found, the returned vector will be <span class="s1">object&lt;Individual&gt;(0)</span>, an empty <span class="s1">object</span> vector of class <span class="s1">Individual</span>.<span class="Apple-converted-space">  </span>If you have more than one pedigree ID to look up, calling this method just once, in vectorized fashion, may be much faster than calling it once for each ID, due to internal optimizations.</p>
<p class="p6">To find individuals within all subpopulations, pass the default of <span class="s1">NULL</span> for <span class="s1">subpops</span>.<span class="Apple-converted-space">  </span>If you are interested only in matches within a specific subpopulation, pass that subpopulation for <span class="s1">subpops</span>; that will make the search faster.<span class="Apple-converted-space">  </span>Similarly, if you know that a particular subpopulation is the most likely to contain matches, you should supply that subpopulation first in the <span class="s1">subpops</span> vector so that it will be searched first; the supplied subpopulations are searched in order.<span class="Apple-converted-space">  </span>Subpopulations may be supplied either as <span class="s1">integer</span> IDs, or as <span class="s1">Subpopulation</span> objects.</p>
<p class="p5">– (void)killIndividuals(object&lt;Individual&gt; individuals)</p>
<p class="p6">Immediately kills the individuals in <span class="s1">individuals</span>.<span class="Apple-converted-space">  </span>This removes them from their subpopulation and gives them an <span class="s1">index</span> value of <span class="s1">-1</span>.<span class="Apple-converted-space">  </span>The <span class="s1">Individual</span> objects are not freed immediately, since references to them could still exist in local Eidos variables; instead, the individuals are kept in a temporary “graveyard” until they can be freed safely.<span class="Apple-converted-space">  </span>It therefore continues to be safe to use them and their haplosomes, except that accessing their <span class="s1">subpopulation</span> property will raise an error since they no longer have a subpopulation.</p>
<p class="p6">Note that the indices and order of individuals and haplosomes in all source subpopulations will change unpredictably as a side effect of this method.<span class="Apple-converted-space">  </span>All evaluated interactions are invalidated as a side effect of calling this method.</p>
<p class="p6">Note that this method is only for use in nonWF models, in which mortality is managed manually by the model script.<span class="Apple-converted-space">  </span>In WF models, mortality is managed automatically by the SLiM core when the new offspring generation becomes the parental generation and the previous parental generation dies; mortality does not otherwise occur in WF models.<span class="Apple-converted-space">  </span>In nonWF models, mortality normally occurs during the survival stage of the tick cycle, based upon the fitness values calculated by SLiM, and <span class="s1">survival()</span> callbacks can influence the outcome of that survival stage.<span class="Apple-converted-space">  </span>Calls to <span class="s1">killIndividuals()</span>, on the other hand, can be made at any time during <span class="s1">first()</span>, <span class="s1">early()</span>, or <span class="s1">late()</span> events, and the result cannot be modified by <span class="s1">survival()</span> callbacks; the given individuals are simply immediately killed.<span class="Apple-converted-space">  </span>This method therefore provides an alternative, and relatively rarely used, mortality mechanism that is disconnected from fitness.</p>
<p class="p3">– (integer)mutationCounts(Nio&lt;Subpopulation&gt; subpops, [No&lt;Mutation&gt; mutations = NULL])</p>
<p class="p4">Return an <span class="s1">integer</span> vector with the frequency counts of all of the <span class="s1">Mutation</span> objects passed in <span class="s1">mutations</span>, within the <span class="s1">Subpopulation</span> objects in <span class="s1">subpops</span>.<span class="Apple-converted-space">  </span>The <span class="s1">subpops</span> argument is required, but you may pass <span class="s1">NULL</span> to get population-wide frequency counts.<span class="s5"><span class="Apple-converted-space">  </span>Subpopulations may be supplied either as </span><span class="s6">integer</span><span class="s5"> IDs, or as </span><span class="s6">Subpopulation</span><span class="s5"> objects.</span><span class="Apple-converted-space">  </span>If the optional <span class="s1">mutations</span> argument is <span class="s1">NULL</span> (the default), frequency counts will be returned for all of the active <span class="s1">Mutation</span> objects in the species – the same <span class="s1">Mutation</span> objects, and in the same order, as would be returned by the <span class="s1">mutations</span> property of <span class="s1">sim</span>, in other words.</p>
<p class="p16"><span class="s11">See the </span>-mutationFrequencies()<span class="s11"> method to obtain </span>float<span class="s11"> frequencies instead of </span>integer<span class="s11"> counts.</span><span class="s19"><span class="Apple-converted-space">  </span>See also the </span>Haplosome<span class="s19"> methods </span><span class="s5">mutationCountsIn</span>Haplosome<span class="s5">s()</span><span class="s19"> and </span><span class="s5">mutationFrequenciesIn</span>Haplosome<span class="s5">s()</span><span class="s19">.</span></p>
<p class="p3">– (float)mutationFrequencies(Nio&lt;Subpopulation&gt; subpops, [No&lt;Mutation&gt; mutations = NULL])</p>
<p class="p4">Return a <span class="s1">float</span> vector with the frequencies of all of the <span class="s1">Mutation</span> objects passed in <span class="s1">mutations</span>, within the <span class="s1">Subpopulation</span> objects in <span class="s1">subpops</span>.<span class="Apple-converted-space">  </span>The <span class="s1">subpops</span> argument is required, but you may pass <span class="s1">NULL</span> to get population-wide frequencies.<span class="s5"><span class="Apple-converted-space">  </span>Subpopulations may be supplied either as </span><span class="s6">integer</span><span class="s5"> IDs, or as </span><span class="s6">Subpopulation</span><span class="s5"> objects.</span><span class="Apple-converted-space">  </span>If the optional <span class="s1">mutations</span> argument is <span class="s1">NULL</span> (the default), frequencies will be returned for all of the active <span class="s1">Mutation</span> objects in the species – the same <span class="s1">Mutation</span> objects, and in the same order, as would be returned by the <span class="s1">mutations</span> property of <span class="s1">sim</span>, in other words.</p>
<p class="p16"><span class="s11">See the </span>-mutationCounts()<span class="s11"> method to obtain </span>integer<span class="s11"> counts instead of </span>float<span class="s11"> frequencies.</span><span class="s19"><span class="Apple-converted-space">  </span>See also the </span>Haplosome<span class="s19"> methods </span><span class="s5">mutationCountsIn</span>Haplosome<span class="s5">s()</span><span class="s19"> and </span><span class="s5">mutationFrequenciesIn</span>Haplosome<span class="s5">s()</span><span class="s19">.</span></p>
<p class="p3">–<span class="s9"> </span>(object&lt;Mutation&gt;)mutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns an <span class="s1">object</span> vector of all the mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations that are currently active in the species.<span class="Apple-converted-space">  </span>If you just need a count of the matching <span class="s1">Mutation</span> objects, rather than a vector of the matches, use <span class="s1">-countOfMutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is often used to look up an introduced mutation at a later point in the simulation, since there is no way to keep persistent references to objects in SLiM.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">– (void)outputFixedMutations([Ns$ filePath = NULL], [logical$ append = F]<span class="s5">, [logical$ objectTags = F]</span>)</p>
<p class="p4">Output all fixed mutations – all <span class="s1">Substitution</span> objects, in other words – in a SLiM native format.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span><span class="Apple-converted-space">  </span>Mutations which have fixed but have not been turned into <span class="s1">Substitution</span> objects – typically because <span class="s1">convertToSubstitution</span> has been set to <span class="s1">F</span> for their mutation type – are not output; they are still considered to be segregating mutations by SLiM.</p>
<p class="p6"><span class="s3">In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations.</span></p>
<p class="p6">In SLiM 5.0 and later, in models with multiple chromosome the output includes the symbol of the chromosome associated with each mutation.</p>
<p class="p6">Beginning with SLiM 5.0, the <span class="s1">objectTags</span> parameter may be used to request that tag values for substitutions be written out.</p>
<p class="p4">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p5"><span class="s5">– (void)outputFull([Ns$ filePath = NULL], [logical$ binary = F], [logical$ append = F], [logical$ spatialPositions = T]</span><span class="s3">, [logical$ ages = T], [logical$ ancestralNucleotides = T]</span>, [logical$ pedigreeIDs = F], [logical$ objectTags = F], [logical$ substitutions = F]<span class="s5">)</span></p>
<p class="p4">Output the state of the entire population.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span><span class="Apple-converted-space">  </span>When writing to a file, a <span class="s1">logical</span> flag, <span class="s1">binary</span>, may be supplied as well.<span class="Apple-converted-space">  </span>If <span class="s1">binary</span> is <span class="s1">T</span>, the population state will be written as a binary file instead of a text file (binary data cannot be written to the standard output stream).<span class="Apple-converted-space">  </span>The binary file is usually smaller, and in any case will be read much faster than the corresponding text file would be read.<span class="Apple-converted-space">  </span>Binary files are not guaranteed to be portable between platforms; in other words, a binary file written on one machine may not be readable on a different machine (but in practice it usually will be, unless the platforms being used are fairly unusual).<span class="Apple-converted-space">  </span>If <span class="s1">binary</span> is <span class="s1">F</span> (the default), a text file will be written.</p>
<p class="p4">Beginning with SLiM 2.3, the <span class="s1">spatialPositions</span> parameter may be used to control the output of the spatial positions of individuals in species for which continuous space has been enabled using the <span class="s1">dimensionality</span> option of <span class="s1">initializeSLiMOptions()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>If <span class="s1">spatialPositions</span> is <span class="s1">F</span>, the output will not contain spatial positions, and will be identical to the output generated by SLiM 2.1 and later.<span class="Apple-converted-space">  </span>If <span class="s1">spatialPositions</span> is <span class="s1">T</span>, spatial position information will be output if it is available.<span class="Apple-converted-space">  </span>If the species does not have continuous space enabled, the <span class="s1">spatialPositions</span> parameter will be ignored.<span class="Apple-converted-space">  </span>Positional information may be output for all output destinations – the Eidos output stream, a text file, or a binary file.</p>
<p class="p6"><span class="s3">Beginning with SLiM 3.0, the </span><span class="s4">ages</span><span class="s3"> parameter may be used to control the output of the ages of individuals in nonWF simulations.<span class="Apple-converted-space">  </span>If </span><span class="s4">ages</span><span class="s3"> is </span><span class="s4">F</span><span class="s3">, the output will not contain ages, preserving backward compatibility with the output format of SLiM 2.1 and later.<span class="Apple-converted-space">  </span>If </span><span class="s4">ages</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">, ages will be output for nonWF models.<span class="Apple-converted-space">  </span>In WF simulations, the </span><span class="s4">ages</span><span class="s3"> parameter will be ignored.</span></p>
<p class="p6"><span class="s3">Beginning with SLiM 3.3, the </span><span class="s4">ancestralNucleotides</span><span class="s3"> parameter may be used to control the output of the ancestral nucleotide sequence in nucleotide-based models.<span class="Apple-converted-space">  </span>If </span><span class="s4">ancestralNucleotides</span><span class="s3"> is </span><span class="s4">F</span><span class="s3">, the output will not contain ancestral nucleotide information, and so the ancestral sequence will not be restored correctly if the saved file is loaded with </span><span class="s4">readPopulationFile()</span><span class="s3">.<span class="Apple-converted-space">  </span>This option is provided because the ancestral sequence may be quite large, for models with a long chromosome (e.g., 1 GB if the chromosome is 10</span><span class="s20"><sup>9</sup></span><span class="s3"> bases long, when saved in text format, or 0.25 GB when saved in binary format).<span class="Apple-converted-space">  </span>If the model is not nucleotide-based (as enabled with the </span><span class="s4">nucleotideBased</span><span class="s3"> parameter to </span><span class="s4">initializeSLiMOptions()</span><span class="s3">), the </span><span class="s4">ancestralNucleotides</span><span class="s3"> parameter will be ignored.<span class="Apple-converted-space">  </span>Note that in nucleotide-based models the output format will <i>always</i> include the nucleotides associated with any nucleotide-based mutations; the </span><span class="s4">ancestralNucleotides</span><span class="s3"> flag governs only the ancestral sequence.</span></p>
<p class="p6">Beginning with SLiM 3.5, the <span class="s1">pedigreeIDs</span> parameter may be used to request that pedigree IDs be written out (and read in by <span class="s1">readFromPopulationFile()</span>, subsequently).<span class="Apple-converted-space">  </span>This option is turned off (<span class="s1">F</span>) by default, for brevity.<span class="Apple-converted-space">  </span>This option may only be used if SLiM’s optional pedigree tracking has been enabled with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>.</p>
<p class="p6">Beginning with SLiM 5.0, the <span class="s1">objectTags</span> parameter may be used to request that tag values for objects be written out.<span class="Apple-converted-space">  </span>This option is turned off (<span class="s1">F</span>) by default, for brevity; if it turned on (<span class="s1">T</span>), the values of all tags for all objects of supported classes (<span class="s1">Chromosome</span>, <span class="s1">Subpopulation</span>, <span class="s1">Individual</span>, <span class="s1">Haplosome</span>, <span class="s1">Mutation</span>, <span class="s1">Substitution</span>) will be written.<span class="Apple-converted-space">  </span>For individuals, the <span class="s1">tag</span>, <span class="s1">tagF</span>, <span class="s1">tagL0</span>, <span class="s1">tagL1</span>, <span class="s1">tagL2</span>, <span class="s1">tagL3</span>, and <span class="s1">tagL4</span> properties will be written; for chromosomes, subpopulations, haplosomes, and mutations, the <span class="s1">tag</span> property will be written.<span class="Apple-converted-space">  </span>The saved tag information can be read in by <span class="s1">readFromPopulationFile()</span>, but only if the output is in binary format (<span class="s1">binary=T</span>).<span class="Apple-converted-space">  </span>Note that if there is other state that you wish you persist, such as tags on objects of other classes, values attached to objects with <span class="s1">setValue()</span>, and so forth, you should persist that state in separate files using calls such as <span class="s1">writeFile()</span>.</p>
<p class="p6">Beginning with SLiM 5.0, the <span class="s1">substitutions</span> parameter may be used to request that information about <span class="s1">Substitution</span> objects in the simulation be written out.<span class="Apple-converted-space">  </span>This option is turned off (<span class="s1">F</span>) by default, for brevity.<span class="Apple-converted-space">  </span>The saved substitution information can be read in by <span class="s1">readFromPopulationFile()</span>, but only if the output is in binary format (<span class="s1">binary=T</span>).</p>
<p class="p4">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p3">– (void)outputMutations(object&lt;Mutation&gt; mutations, [Ns$ filePath = NULL], [logical$ append = F]<span class="s5">, [logical$ objectTags = F]</span>)</p>
<p class="p6"><span class="s5">Output all of the given mutations.<span class="Apple-converted-space">  </span>This can be used to output all mutations of a given mutation type, for example.<span class="Apple-converted-space">  </span></span><span class="s3">If the optional parameter </span><span class="s4">filePath</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by </span><span class="s4">filePath</span><span class="s3">, overwriting that file if </span><span class="s4">append</span><span class="s3"> if </span><span class="s4">F</span><span class="s3">, or appending to the end of it if </span><span class="s4">append</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations.</span></p>
<p class="p6">In SLiM 5 and later, in models with multiple chromosome the output includes the symbol of the chromosome associated with each mutation.</p>
<p class="p6">Beginning with SLiM 5.0, the <span class="s1">objectTags</span> parameter may be used to request that tag values for mutations be written out.</p>
<p class="p4">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p3">– (integer$)readFromPopulationFile(string$ filePath<span class="s5">, [No&lt;Dictionary&gt;$ subpopMap = NULL]</span>)</p>
<p class="p6">Read from a population file, whether in text or binary format as previously specified to <span class="s1">outputFull()</span>, and return the tick counter value represented by the file’s contents (i.e., the tick at which the file was generated).<span class="Apple-converted-space">  </span>Although this is most commonly used to set up initial populations (often in an Eidos event set to run in tick <span class="s1">1</span>, immediately after simulation initialization), it may be called in any <span class="s1">early()</span> or <span class="s1">late()</span> event; the current state of all populations in the target species will be wiped and replaced by the state in the file at <span class="s1">filePath</span>.<span class="Apple-converted-space">  </span>All Eidos variables that are of type <span class="s1">object</span> and have element class <span class="s1">Subpopulation</span>, <span class="s1">Haplosome</span>, <span class="s1">Mutation</span>, <span class="s1">Individual</span>, or <span class="s1">Substitution</span> will be removed as a side effect of this method if they contain any element that belongs to the target species, because those objects will no longer exist in the SLiM simulation; if you want to preserve any of that state, you should output it or save it to a file prior to this call.<span class="Apple-converted-space">  </span>New symbols (<span class="s1">p1</span>, <span class="s1">p2</span>, etc.) will be defined to refer to the new <span class="s1">Subpopulation</span> objects loaded from the file.<span class="Apple-converted-space">  </span>Note that fitness values are not calculated as a side effect of this call (because the simulation will often need to evaluate interactions or modify other state prior to doing so).</p>
<p class="p6"><span class="s3">In SLiM 2.3 and later when using the WF model, calling </span><span class="s4">readFromPopulationFile()</span><span class="s3"> from any context other than a </span><span class="s4">late()</span><span class="s3"> event causes a warning; calling from a </span><span class="s4">late()</span><span class="s3"> event is almost always correct in WF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the tick cycle without the need to force their recalculation (see comments on </span><span class="s4">recalculateFitness()</span><span class="s3">).</span></p>
<p class="p6"><span class="s3">In SLiM 3.0 when using the nonWF model, calling </span><span class="s4">readFromPopulationFile()</span><span class="s3"> from any context other than an </span><span class="s4">early()</span><span class="s3"> event causes a warning; calling from an </span><span class="s4">early()</span><span class="s3"> event is almost always correct in nonWF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the tick cycle without the need to force their recalculation (see comments on </span><span class="s4">recalculateFitness()</span><span class="s3">).</span></p>
<p class="p6">This method changes the tick and cycle counters to the tick and cycle read from the file.<span class="Apple-converted-space">  </span>If you do not want these counters to be changed, you can change them back after reading, by setting <span class="s1">community.tick</span> and <span class="s1">sim.cycle</span> to whatever values you wish.<span class="Apple-converted-space">  </span>Note that restoring a saved past state and running forward again will not yield the same simulation results, because the random number generator’s state will not be the same; if you wish to ensure reproducibility from a given time point, <span class="s1">setSeed()</span> can be used to establish a new seed value.</p>
<p class="p6">Any changes made to the structure of the species (mutation types, genomic element types, etc.) will not be wiped and re-established by <span class="s1">readFromPopulationFile()</span>; this method loads only the population’s state, not the species configuration, so care should be taken to ensure that the species structure meshes coherently with the loaded data.<span class="Apple-converted-space">  </span>Indeed, state such as the selfing and cloning rates of subpopulations, and values set onto objects with <span class="s1">setValue()</span>, will also be lost, since it is not saved out by <span class="s1">outputFull()</span>.<span class="Apple-converted-space">  </span>Only information saved by <span class="s1">outputFull()</span> will be restored; all other state associated with the mutations, haplosomes, individuals, and subpopulations in the simulation will be lost, and should be re-established by the model if it is still needed.<span class="Apple-converted-space">  </span>Note that some state is saved by <span class="s1">outputFull()</span> only optionally, such as the <span class="s1">tag</span> values of individuals; if a given option is enabled and the corresponding information is saved, then that information will be restored, otherwise it will not be.</p>
<p class="p6">As of SLiM 2.3, this method will read and restore the spatial positions of individuals if that information is present in the output file and the species has enabled continuous space.<span class="Apple-converted-space">  </span>If spatial positions are present in the output file but the species has not enabled continuous space (or the number of spatial dimensions does not match), an error will result.<span class="Apple-converted-space">  </span>If the species has enabled continuous space but spatial positions are not present in the output file, the spatial positions of the individuals read will be undefined, but an error is not raised.</p>
<p class="p6"><span class="s3">As of SLiM 3.0, this method will read and restore the ages of individuals if that information is present in the output file and the simulation is based upon the nonWF model.<span class="Apple-converted-space">  </span>If ages are present but the simulation uses a WF model, an error will result; the WF model does not use age information.<span class="Apple-converted-space">  </span>If ages are not present but the simulation uses a nonWF model, an error will also result; the nonWF model requires age information.</span></p>
<p class="p6"><span class="s3">As of SLiM 3.3, this method will restore the nucleotides of nucleotide-based mutations, and will restore the ancestral nucleotide sequence, if that information is present in the output file.<span class="Apple-converted-space">  </span>Loading an output file that contains nucleotide information in a non-nucleotide-based model, and <i>vice versa</i>, will produce an error.</span></p>
<p class="p6">As of SLiM 3.5, this method will read and restore the pedigree IDs of individuals and haplosomes if that information is present in the output file (as requested with <span class="s1">outputFull(pedigreeIDs=T)</span>) <i>and</i> if SLiM’s optional pedigree tracking has been enabled with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>.</p>
<p class="p6">As of SLiM 5.0, this method will read and restore tag values for objects of supported classes (<span class="s1">Chromosome</span>, <span class="s1">Subpopulation</span>, <span class="s1">Individual</span>, <span class="s1">Haplosome</span>, <span class="s1">Mutation</span>, <span class="s1">Substitution</span>) if they were saved by <span class="s1">outputFull()</span> with its <span class="s1">objectTags=T</span> option.<span class="Apple-converted-space">  </span>This facility is only available when reading binary output from <span class="s1">outputFull()</span>, as chosen by its <span class="s1">binary=T</span> option; otherwise, an error will result.</p>
<p class="p6">As of SLiM 5.0, this method will read and restore substitutions if they were saved by <span class="s1">outputFull()</span> with its <span class="s1">substitutions=T</span> option.<span class="Apple-converted-space">  </span>This facility is only available when reading binary output from <span class="s1">outputFull()</span>, as chosen by its <span class="s1">binary=T</span> option; otherwise, an error will result.</p>
<p class="p6">This method can also be used to read tree-sequence information, in the form of single-chromosome <span class="s1">.trees</span> files and multi-chromosome trees archives, as saved by <span class="s1">treeSeqOutput()</span> or generated by the Python <span class="s1">pyslim</span> package.<span class="Apple-converted-space">  </span>Note that the user metadata for a tree-sequence file can be read separately with the <span class="s1">treeSeqMetadata()</span> function.<span class="Apple-converted-space">  </span>Beginning with SLiM 4, the <span class="s1">subpopMap</span> parameter may be supplied to re-order the populations of the input tree sequence when it is loaded in to SLiM.<span class="Apple-converted-space">  </span>This parameter must have a value that is a <span class="s1">Dictionary</span>; the keys of this dictionary should be SLiM population identifiers as <span class="s1">string</span> values (e.g., <span class="s1">"p2"</span>), and the values should be indexes of populations in the input tree sequence; a key/value pair of <span class="s1">"p2", 4</span> would mean that the fifth population in the input (the one at zero-based index <span class="s1">4</span>) should become <span class="s1">p2</span> on loading into SLiM.<span class="Apple-converted-space">  </span>If <span class="s1">subpopMap</span> is non-<span class="s1">NULL</span>, <i>all</i> populations in the tree sequence must be explicitly mapped, even if their index will not change and even if they will not be used by SLiM; the only exception is for unused slots in the population table, which can be explicitly remapped but do not have to be.<span class="Apple-converted-space">  </span>For instance, suppose we have a tree sequence in which population <span class="s1">0</span> is unused, population <span class="s1">1</span> is not a SLiM population (for example, an ancestral population produced by <span class="s1">msprime</span>), and population 2 is a SLiM population, and we want to load this in with population 2 as <span class="s1">p0</span> in SLiM.<span class="Apple-converted-space">  </span>To do this, we could supply a value of <span class="s1">Dictionary("p0", 2, "p1", 1, "p2", 0)</span> for <span class="s1">subpopMap</span>, or we could leave out slot <span class="s1">0</span> since it is unused, with <span class="s1">Dictionary("p0", 2, "p1", 1)</span>.<span class="Apple-converted-space">  </span>Although this facility cannot be used to remove populations in the tree sequence, note that it may <i>add</i> populations that will be visible when <span class="s1">treeSeqOutput()</span> is called (although these will not be SLiM populations); if, in this example, we had used <span class="s1">Dictionary("p0", 0, "p1", 1, "p5", 2)</span> and then we wrote the result out with <span class="s1">treeSeqOutput()</span>, the resulting tree sequence would have six populations, although three of them would be empty and would not be used by SLiM.<span class="Apple-converted-space">  </span>The use of <span class="s1">subpopMap</span> makes it easier to load simulation data that was generated in Python, since that typically uses an id of <span class="s1">0</span>.<span class="Apple-converted-space">  </span>The <span class="s1">subpopMap</span> parameter may not be used with file formats other than tree-sequence files, at the present time; setting up the correct subpopulation ids is typically easier when working with those other formats.<span class="Apple-converted-space">  </span>Note the <span class="s1">tskit</span> command-line interface can be used, like <span class="s1">python3 -m tskit populations file.trees</span>, to find out the number of subpopulations in a tree-sequence file and their IDs.</p>
<p class="p6">When loading a tree sequence, a crosscheck of the loaded data will be performed to ensure that the tree sequence was well-formed and was loaded correctly.<span class="Apple-converted-space">  </span>When running a Release build of SLiM, however, this crosscheck will only occur the first time that <span class="s1">readFromPopulationFile()</span> is called to load a tree sequence; subsequent calls will not perform this crosscheck, for greater speed when running models that load saved population state many times (such as models that are conditional on fixation).<span class="Apple-converted-space">  </span>If you suspect that a tree sequence file might be corrupted, or might be read incorrectly, running a Debug build of SLiM enables crosschecks after every load.</p>
<p class="p3">– (void)recalculateFitness([Ni$ tick = NULL])</p>
<p class="p6">Force an immediate recalculation of fitness values for all individuals in all subpopulations.<span class="Apple-converted-space">  </span>Normally fitness values are calculated at a fixed point in each tick, and those values are cached and used until the next recalculation.<span class="Apple-converted-space">  </span>If simulation parameters are changed in script in a way that affects fitness calculations, and if you wish those changes to take effect immediately rather than taking effect at the next automatic recalculation, you may call <span class="s1">recalculateFitness()</span> to force an immediate recalculation and recache.</p>
<p class="p6">The optional parameter <span class="s1">tick</span> provides the tick for which <span class="s1">mutationEffect()</span> and <span class="s1">fitnessEffect()</span> callbacks should be selected; if it is <span class="s1">NULL</span> (the default), the current tick value for the simulation, <span class="s1">community.tick</span>, is used.<span class="Apple-converted-space">  </span>If you call <span class="s1">recalculateFitness()</span> in an <span class="s1">early()</span> event in a WF model, you may wish this to be <span class="s1">community.tick - 1</span> in order to utilize the <span class="s1">mutationEffect()</span> and <span class="s1">fitnessEffect()</span> callbacks for the previous tick, as if the changes that you have made to fitness-influencing parameters were already in effect at the end of the previous tick when the new generation was first created and evaluated (usually it is simpler to just make such changes in a <span class="s1">late()</span> event instead, however, in which case calling <span class="s1">recalculateFitness()</span> is probably not necessary at all since fitness values will be recalculated immediately afterwards).<span class="Apple-converted-space">  </span>Regardless of the value supplied for <span class="s1">tick</span> here, <span class="s1">community.tick</span> inside callbacks will report the true tick number, so if your callbacks consult that parameter in order to create tick-specific fitness effects you will need to handle the discrepancy somehow.<span class="Apple-converted-space">  </span>(Similar considerations apply for nonWF models that call <span class="s1">recalculateFitness()</span> in a <span class="s1">late()</span> event, which is also not advisable in general.)</p>
<p class="p6">After this call, the fitness values used for all purposes in SLiM will be the newly calculated values.<span class="Apple-converted-space">  </span>Calling this method will trigger the calling of any enabled and applicable <span class="s1">mutationEffect()</span> and <span class="s1">fitnessEffect()</span> callbacks, so this is quite a heavyweight operation; you should think carefully about what side effects might result (which is why fitness recalculation does not just occur automatically after changes that might affect fitness values).</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerFitnessEffectCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s9"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p6">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">fitnessEffect()</span> callback in the current simulation (specific to the target species), with an optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations), and optional <span class="s1">start</span> and <span class="s1">end</span> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerMateChoiceCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">mateChoice()</span> callback in the current simulation<span class="s5"> (specific to the target species)</span>, with optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations) and optional <span class="s1">start</span> and <span class="s1">end</span> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerModifyChildCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s9"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">modifyChild()</span> callback in the current simulation<span class="s5"> (specific to the target species)</span>, with optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations) and optional <span class="s1">start</span> and <span class="s1">end</span> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p5"><span class="s3">– (object&lt;SLiMEidosBlock&gt;$)registerMutationCallback(Nis$ id, string$ source, [Nio&lt;MutationType&gt;$ mutType = NULL], [Nio&lt;Subpopulation&gt;$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</span></p>
<p class="p6"><span class="s3">Register a block of Eidos source code, represented as the </span><span class="s4">string</span><span class="s3"> singleton </span><span class="s4">source</span><span class="s3">, as an Eidos </span><span class="s4">mutation()</span><span class="s3"> callback in the current simulation</span> (specific to the target species)<span class="s3">, with an optional mutation type </span><span class="s4">mutType</span><span class="s3"> (which may be an </span><span class="s4">integer</span><span class="s3"> mutation type identifier, or </span><span class="s4">NULL</span><span class="s3">, the default, to indicate all mutation types), optional subpopulation </span><span class="s4">subpop</span><span class="s3"> (which may also be an </span><span class="s4">integer</span><span class="s3"> identifier, or </span><span class="s4">NULL</span><span class="s3">, the default, to indicate all subpopulations), and optional </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier </span><span class="s4">id</span><span class="s3"> (specified as an </span><span class="s4">integer</span><span class="s3">, or as a </span><span class="s4">string</span><span class="s3"> symbolic name such as </span><span class="s4">"s5"</span><span class="s3">); this may be </span><span class="s4">NULL</span><span class="s3"> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered </span><span class="s4">SLiMEidosBlock</span><span class="s3"> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new </span><span class="s4">SLiMEidosBlock</span><span class="s3"> will be defined as a global variable immediately by this method, and will also be returned by this method.</span></p>
<p class="p5">– (object&lt;SLiMEidosBlock&gt;$)registerMutationEffectCallback(Nis$ id, string$ source, io&lt;MutationType&gt;$ mutType, [Nio&lt;Subpopulation&gt;$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p6">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">mutationEffect()</span> callback in the current simulation (specific to the target species), with a required mutation type <span class="s1">mutType</span> (which may be an <span class="s1">integer</span> mutation type identifier), optional subpopulation <span class="s1">subpop</span> (which may also be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations), and optional <span class="s1">start</span> and <span class="s1">end</span> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerRecombinationCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s9"> </span>= NULL]<span class="s5">, [Niso&lt;Chromosome&gt;$ chromosome = NULL]</span>, [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p6">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">recombination()</span> callback in the current simulation (specific to the target species), with optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations) and optional <span class="s1">start</span> and <span class="s1">end</span> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>In multi-chromosome models, parameter <span class="s1">chromosome</span>, if non-<span class="s1">NULL</span>, may specify a chromosome to which the callback will apply (as either an <span class="s1">integer</span> id, a <span class="s1">string</span> symbol, or a <span class="s1">Chromosome</span> object); otherwise, <span class="s1">NULL</span> indicates that the callback applies to all chromosomes.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerReproductionCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s9"> </span>= NULL], <span class="s7">[Ns$ sex = NULL], </span>[Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p6"><span class="s3">Register a block of Eidos source code, represented as the </span><span class="s4">string</span><span class="s3"> singleton </span><span class="s4">source</span><span class="s3">, as an Eidos </span><span class="s4">reproduction()</span><span class="s3"> callback in the current simulation</span> (specific to the target species)<span class="s3">, with optional subpopulation </span><span class="s4">subpop</span><span class="s3"> (which may be an </span><span class="s4">integer</span><span class="s3"> identifier, or </span><span class="s4">NULL</span><span class="s3">, the default, to indicate all subpopulations), optional sex-specificity </span><span class="s4">sex</span><span class="s3"> (which may be </span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3"> in sexual species to make the callback specific to males or females respectively, or </span><span class="s4">NULL</span><span class="s3"> for no sex-specificity), and optional </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier </span><span class="s4">id</span><span class="s3"> (specified as an </span><span class="s4">integer</span><span class="s3">, or as a </span><span class="s4">string</span><span class="s3"> symbolic name such as </span><span class="s4">"s5"</span><span class="s3">); this may be </span><span class="s4">NULL</span><span class="s3"> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered </span><span class="s4">SLiMEidosBlock</span><span class="s3"> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new </span><span class="s4">SLiMEidosBlock</span><span class="s3"> will be defined as a global variable immediately by this method, and will also be returned by this method.</span></p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerSurvivalCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s9"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">survival()</span> callback in the current simulation<span class="s5"> (specific to the target species)</span>, with optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations) and optional <span class="s1">start</span> and <span class="s1">end</span> ticks all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current tick.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (void)simulationFinished(void)</p>
<p class="p6">Declare the current simulation finished.<span class="Apple-converted-space">  </span>This method is equivalent to the <span class="s1">Community</span> method <span class="s1">simulationFinished()</span>, except that this method is only legal to call in single-species models (to provide backward compatibility).<span class="Apple-converted-space">  </span>It is recommended that new code should call the <span class="s1">Community</span> method; this method may be deprecated in the future.</p>
<p class="p3">– (void)skipTick(void)</p>
<p class="p6">Deactivate the target species for the current tick.<span class="Apple-converted-space">  </span>This sets the <span class="s1">active</span> property of the species to <span class="s1">F</span>; it also set the <span class="s1">active</span> property of all callbacks that belong to the species (with the species as their <span class="s1">species</span> specifier) to <span class="s1">F</span>, and sets the active property of all events that are synchronized with the species (with the species as their <span class="s1">ticks</span> specifier) to <span class="s1">F</span>.<span class="Apple-converted-space">  </span>The cycle counter for the species will not be incremented at the end of the tick.<span class="Apple-converted-space">  </span>This method may only be called in <span class="s1">first()</span> events, to ensure that species are either active or inactive throughout a given tick.</p>
<p class="p5">– (object&lt;Mutation&gt;)subsetMutations([No&lt;Mutation&gt;$ exclude = NULL], [Nio&lt;MutationType&gt;$ mutType = NULL], [Ni$ position = NULL], [Nis$ nucleotide = NULL], [Ni$ tag = NULL], [Ni$ id = NULL], [Niso&lt;Chromosome&gt; chromosome = NULL])</p>
<p class="p6">Returns a vector of mutations subset from the list of all active mutations in the species (as would be provided by the <span class="s1">mutations</span> property).<span class="Apple-converted-space">  </span>The parameters specify constraints upon the subset of mutations that will be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">exclude</span>, if non-<span class="s1">NULL</span>, may specify a specific mutation that should not be included (typically the focal mutation in some operation).<span class="Apple-converted-space">  </span>Parameter <span class="s1">mutType</span>, if non-<span class="s1">NULL</span>, may specify a mutation type for the mutations to be returned (as either a <span class="s1">MutationType</span> object or an <span class="s1">integer</span> identifier).<span class="Apple-converted-space">  </span>Parameter <span class="s1">position</span>, if non-<span class="s1">NULL</span>, may specify a base position for the mutations to be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">nucleotide</span>, if non-<span class="s1">NULL</span>, may specify a nucleotide for the mutations to be returned (either as a string, <span class="s1">"A"</span> / <span class="s1">"C"</span> / <span class="s1">"G"</span> / <span class="s1">"T"</span>, or as an integer, <span class="s1">0</span> / <span class="s1">1</span> / <span class="s1">2</span> / <span class="s1">3</span> respectively).<span class="Apple-converted-space">  </span>Parameter <span class="s1">tag</span>, if non-<span class="s1">NULL</span>, may specify a tag value for the mutations to be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">id</span>, if non-<span class="s1">NULL</span>, may specify a required value for the <span class="s1">id</span> property of the mutations to be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">chromosome</span>, if non-<span class="s1">NULL</span>, may specify a chromosome or chromosomes with which the mutations returned must be associated (as either <span class="s1">integer</span> ids, <span class="s1">string</span> symbols, or <span class="s1">Chromosome</span> objects).</p>
<p class="p6">This method is shorthand for getting the <span class="s1">mutations</span> property of the subpopulation, and then using operator <span class="s1">[]</span> to select only mutations with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.<span class="Apple-converted-space">  </span>Note that if you only need to select on mutation type, the <span class="s1">mutationsOfType()</span> method will be even faster.</p>
<p class="p5">– (object&lt;Substitution&gt;)substitutionsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p6">Returns an <span class="s1">object</span> vector of all the substitutions that are of the type specified by <span class="s1">mutType</span>, out of all of the substitutions that are currently present in the species.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="Apple-converted-space">  </span>See also <span class="s1">mutationsOfType()</span>.</p>
<p class="p5"><span class="s3">– (logical$)treeSeqCoalesced(void)</span></p>
<p class="p6"><span class="s3">Returns the coalescence state for the recorded tree sequence at the last simplification.<span class="Apple-converted-space">  </span>The returned value is a logical singleton flag, </span><span class="s4">T</span><span class="s3"> to indicate that full coalescence was observed at the last tree-sequence simplification (meaning that there is a single ancestral individual that roots all ancestry trees at all sites along the chromosome – although not necessarily the <i>same</i> ancestor at all sites), or </span><span class="s4">F</span><span class="s3"> if full coalescence was not observed.<span class="Apple-converted-space">  </span>For simple models, reaching coalescence may indicate that the model has reached an equilibrium state, but this may not be true in models that modify the dynamics of the model during execution by changing migration rates, introducing new mutations programmatically, dictating non-random mating, etc., so be careful not to attach more meaning to coalescence than it is due; some models may require burn-in beyond coalescence to reach equilibrium, or may not have an equilibrium state at all.<span class="Apple-converted-space">  </span>Also note that some actions by a model, such as adding a new subpopulation, may cause the coalescence state to revert from </span><span class="s4">T</span><span class="s3"> back to </span><span class="s4">F</span><span class="s3"> (at the next simplification), so a return value of </span><span class="s4">T</span><span class="s3"> may not necessarily mean that the model is coalesced at the present moment – only that it <i>was</i> coalesced at the last simplification.</span></p>
<p class="p6"><span class="s3">This method may only be called if tree sequence recording has been turned on with </span><span class="s4">initializeTreeSeq()</span><span class="s3">; in addition, </span><span class="s4">checkCoalescence=T</span><span class="s3"> must have been supplied to </span><span class="s4">initializeTreeSeq()</span><span class="s3">, so that the necessary work is done during each tree-sequence simplification.<span class="Apple-converted-space">  </span>Since this method does not perform coalescence checking itself, but instead simply returns the coalescence state observed at the last simplification, it may be desirable to call </span><span class="s4">treeSeqSimplify()</span><span class="s3"> immediately before </span><span class="s4">treeSeqCoalesced()</span><span class="s3"> to obtain up-to-date information.<span class="Apple-converted-space">  </span>However, the speed penalty of doing this in every tick would be large, and most models do not need this level of precision; usually it is sufficient to know that the model has coalesced, without knowing whether that happened in the current tick or in a recent preceding tick.</span></p>
<p class="p5"><span class="s3">– (void)treeSeqOutput(string$ path, [logical$ simplify = T], [logical$ includeModel = T], </span>[No&lt;Dictionary&gt;$ metadata = NULL], [logical$ overwriteDirectory = F]<span class="s3">)</span></p>
<p class="p6">Outputs the current tree sequence recording tables to the path specified by <span class="s1">path</span>.<span class="Apple-converted-space">  </span>This method may only be called if tree sequence recording has been turned on with <span class="s1">initializeTreeSeq()</span>.<span class="Apple-converted-space">  </span>If <span class="s1">simplify</span> is <span class="s1">T</span> (the default), simplification will be done immediately prior to output; this is almost always desirable, unless a model wishes to avoid simplification entirely.<span class="Apple-converted-space">  </span>(Note that if simplification is not done, then all haplosomes since the last simplification will be marked as samples in the resulting tree sequence.)</p>
<p class="p6">In a model of a single chromosome, a binary tree sequence file will be written to the specified path; a filename extension of <span class="s1">.trees</span> is suggested for this type of file, and such a file is often referred to as a “<span class="s1">.trees</span> file”.<span class="Apple-converted-space">  </span>In a multi-chromosome model, a directory will instead be created at the specified path, and a separate <span class="s1">.trees</span> file will be created within that directory for each chromosome in the model, mirroring the fact that SLiM keeps a separate tree sequence for each chromosome in a multi-chromosome model.<span class="Apple-converted-space">  </span>These <span class="s1">.trees</span> files will be given filenames based upon the <span class="s1">symbol</span> property of each chromosome, as provided to <span class="s1">initializeChromosome()</span>; for example, the tree sequence for a chromosome with symbol <span class="s1">"X"</span> will be saved as <span class="s1">chromosome_X.trees</span> within the specified directory.<span class="Apple-converted-space">  </span>For the name of the directory itself, a suffix of <span class="s1">_trees</span> is suggested, rather than <span class="s1">.trees</span>, since the use of dot-extensions in directory names is not common; for example, <span class="s1">"model_Q_seed_17_trees"</span> would be a path you might pass to <span class="s1">treeSeqOutput()</span> as a directory name in a multi-chromosome model.<span class="Apple-converted-space">  </span>Such a directory, containing separate <span class="s1">.trees</span> files for each chromosome, is called a “trees archive”.<span class="Apple-converted-space">  </span>Both <span class="s1">.trees</span> files and trees archives can be read by <span class="s1">readFromPopulationFile()</span>, as discussed in its documentation.</p>
<p class="p6">Normally, the full SLiM script used to generate the tree sequence is written out to the provenance entry of the tree sequence file, to the <span class="s1">model</span> subkey of the <span class="s1">parameters</span> top-level key.<span class="Apple-converted-space">  </span>Supplying <span class="s1">F</span> for <span class="s1">includeModel</span> suppresses output of the full script.</p>
<p class="p6">A <span class="s1">Dictionary</span> object containing user-generated metadata may be supplied with the <span class="s1">metadata</span> parameter.<span class="Apple-converted-space">  </span>If present, this dictionary will be serialized as JSON and attached to the saved tree sequence under a key named <span class="s1">user_metadata</span>, within the <span class="s1">SLiM</span> key.<span class="Apple-converted-space">  </span>If <span class="s1">tskit</span> is used to read the tree sequence in Python, this metadata will automatically be deserialized and made available at <span class="s1">ts.metadata["SLiM"]["user_metadata"]</span>.<span class="Apple-converted-space">  </span>This metadata dictionary is not used by SLiM, or by <span class="s1">pyslim</span>, <span class="s1">tskit</span>, or <span class="s1">msprime</span>; you may use it for any purpose you wish.<span class="Apple-converted-space">  </span>Note that <span class="s1">metadata</span> may actually be any subclass of <span class="s1">Dictionary</span>, such as a <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>It can even be a <span class="s1">Species</span> object such as <span class="s1">sim</span>, or a <span class="s1">LogFile</span> instance; however, only the keys and values contained by the object’s <span class="s1">Dictionary</span> superclass state will be serialized into the metadata (properties of the subclass will be ignored).<span class="Apple-converted-space">  </span>This metadata dictionary can be recovered from the saved file using the <span class="s1">treeSeqMetadata()</span> function.</p>
<p class="p6">When saving a single <span class="s1">.trees</span> file, the standard behavior is to overwrite an existing file of the same name; the convenience of this generally outweighs the danger.<span class="Apple-converted-space">  </span>When saving a trees archive, however, that balance shifts; overwriting an entire directory is potentially quite dangerous.<span class="Apple-converted-space">  </span>For this reason, <span class="s1">overwriteDirectory=F</span> (the default) specifies that <span class="s1">treeSeqOutput()</span> should not overwrite an existing directory; it will instead raise an error.<span class="Apple-converted-space">  </span>If <span class="s1">overwriteDirectory</span> is <span class="s1">T</span>, <span class="s1">treeSeqOutput()</span> will overwrite an existing directory of the same name (if the existing directory can be deleted without permissions errors and so forth), but only if the existing directory is empty or contains only files with a <span class="s1">.trees</span> suffix, for safety; if other files are present, an error will still be raised.</p>
<p class="p5"><span class="s3">– (void)treeSeqRememberIndividuals(object&lt;Individual&gt; individuals</span>, [logical$ permanent = T]<span class="s3">)</span></p>
<p class="p6">Mark the individuals specified by <span class="s1">individuals</span> to be kept across tree sequence table simplification.<span class="Apple-converted-space">  </span>This method may only be called if tree sequence recording has been turned on with <span class="s1">initializeTreeSeq()</span>.<span class="Apple-converted-space">  </span>All currently living individuals are always kept across simplification; this method does not need to be called, and indeed should not be called, for that purpose.<span class="Apple-converted-space">  </span>Instead, <span class="s1">treeSeqRememberIndividuals()</span> allows any individual, including dead individuals, to be kept in the final tree sequence.<span class="Apple-converted-space">  </span>Typically this would be used, for example, to keep particular individuals that you wanted to be able to trace ancestry back to in later analysis.<span class="Apple-converted-space">  </span>However, this is not the typical usage pattern for tree sequence recording; most models will not need to call this method.</p>
<p class="p6">There are two ways to keep individuals across simplification.<span class="Apple-converted-space">  </span>If <span class="s1">permanent</span> is <span class="s1">T</span> (the default), then the specified individuals will be permanently remembered: their haplosomes will be added to the current sample, and they will always be present in the tree sequence.<span class="Apple-converted-space">  </span>Permanently remembering a large number of individuals will, of course, markedly increase memory usage and runtime.</p>
<p class="p6">Supplying <span class="s1">F</span> for <span class="s1">permanent</span> will instead mark the individuals only for (temporary) retention: their haplosomes will not be added to the sample, and they will appear in the final tree sequence only if one of their haplosomes is retained across simplification.<span class="Apple-converted-space">  </span>In other words, the rule of thumb for retained individuals is simple: if a haplosome is kept by simplification, the haplosome’s corresponding individual is kept also, <i>if</i> it is retained.<span class="Apple-converted-space">  </span>Note that permanent remembering takes priority; calling this function with <span class="s1">permanent=F</span> on an individual that has previously been permanently remembered will not remove it from the sample.</p>
<p class="p6">The behavior of simplification for individuals retained with <span class="s1">permanent=F</span> depends upon the value of the <span class="s1">retainCoalescentOnly</span> flag passed to <span class="s1">initializeTreeSeq()</span>; here we will discuss the behavior of that flag in detail.<span class="Apple-converted-space">  </span>First of all, haplosomes are <i>always</i> removed by simplification unless they are (a) part of the final generation (i.e., in a living individual when simplification occurs), (b) ancestral to the final generation, (c) a haplosome of a permanently remembered individual, or (d) ancestral to a permanently remembered individual.<span class="Apple-converted-space">  </span>If <span class="s1">retainCoalescentOnly</span> is <span class="s1">T</span> (the default), they are <i>also</i> always removed if they are not a branch point (i.e., a coalescent node or most recent common ancestor) in the tree sequence.<span class="Apple-converted-space">  </span>In some cases it may be useful to retain a haplosome and its associated individual when it is simply an intermediate node in the ancestry (i.e., in the middle of a branch).<span class="Apple-converted-space">  </span>This can be enabled by setting <span class="s1">retainCoalescentOnly</span> to <span class="s1">F</span> in your call to <span class="s1">initializeTreeSeq()</span>.<span class="Apple-converted-space">  </span>In this case, ancestral haplosomes that are intermediate (“unary nodes”, in <span class="s1">tskit</span> parlance) and are within an individual that has been retained using the <span class="s1">permanent=F</span> flag here are kept, along with the retained individual itself.<span class="Apple-converted-space">  </span>Since setting <span class="s1">retainCoalescentOnly</span> to <span class="s1">F</span> will prevent the unary nodes for retained individuals from being pruned, simplification may often be unable to prune very much at all from the tree sequence, and memory usage and runtime may increase rapidly.<span class="Apple-converted-space">  </span>If you are retaining many individuals, this setting should therefore be used only with caution; it is not necessary if you are purely interested in the most recent common ancestors.<span class="Apple-converted-space">  </span>See the <span class="s1">pyslim</span> documentation for further discussion of retaining and remembering individuals and the effects of the <span class="s1">retainCoalescentOnly</span> flag.</p>
<p class="p6"><span class="s3">The metadata (age, location, etc) that are stored in the resulting tree sequence are those values present at either (a) the final generation, </span>if the individual is alive when the tree sequence is output<span class="s3">, or (b) the last time that the individual was remembered, if not.<span class="Apple-converted-space">  </span>Calling </span><span class="s4">treeSeqRememberIndividuals()</span><span class="s3"> on an individual that is already remembered will cause the archived information about the remembered individual to be updated to reflect the individual’s current state.<span class="Apple-converted-space">  </span>A case where this is particularly important is for the spatial location of individuals in continuous-space models.<span class="Apple-converted-space">  </span>SLiM automatically remembers the individuals that comprise the first generation of any new subpopulation created with </span><span class="s4">addSubpop()</span><span class="s3">, for easy recapitation and other analysis.<span class="Apple-converted-space">  </span>However, since these first-generation individuals are remembered at the moment they are created, their spatial locations have not yet been set up, and will contain garbage – and those garbage values will be archived in their remembered state.<span class="Apple-converted-space">  </span>If you need correct spatial locations of first-generation individuals for your post-simulation analysis, you should call </span><span class="s4">treeSeqRememberIndividuals()</span><span class="s3"> explicitly on the first generation, after setting spatial locations, to update the archived information with the correct spatial positions.</span></p>
<p class="p5"><span class="s3">– (void)treeSeqSimplify(void)</span></p>
<p class="p6"><span class="s3">Triggers an immediate simplification of the tree sequence recording tables.<span class="Apple-converted-space">  </span>This method may only be called if tree sequence recording has been turned on with </span><span class="s4">initializeTreeSeq()</span><span class="s3">.<span class="Apple-converted-space">  </span>A call to this method will free up memory being used by entries that are no longer in the ancestral path of any individual within the current sample (currently living individuals, in other words, plus those explicitly added to the sample with </span><span class="s4">treeSeqRememberIndividuals()</span><span class="s3">), but it can also take a significant amount of time.<span class="Apple-converted-space">  </span>Typically calling this method is not necessary; the automatic simplification performed occasionally by SLiM should be sufficient for most models.</span></p>
<p class="p1"><b>5.17<span class="Apple-converted-space">  </span>Class Subpopulation</b></p>
<p class="p2"><i>5.17.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Subpopulation</i></span><i> properties</i></p>
<p class="p3">cloningRate =&gt; (float)</p>
<p class="p4">The fraction of children in the next generation that will be produced by cloning (as opposed to biparental mating).<span class="Apple-converted-space">  </span>In non-sexual (i.e. hermaphroditic) simulations, this property is a singleton <span class="s1">float</span> representing the overall subpopulation cloning rate.<span class="Apple-converted-space">  </span>In sexual simulations, this property is a <span class="s1">float</span> vector with two values: the cloning rate for females (at index <span class="s1">0</span>) and for males (at index <span class="s1">1</span>).</p>
<p class="p5">description &lt;–&gt; (string$)</p>
<p class="p6">A human-readable <span class="s1">string</span> description for the subpopulation.<span class="Apple-converted-space">  </span>By default, this is the empty string, <span class="s1">""</span>; however, it may be set to whatever you wish.<span class="Apple-converted-space">  </span>When tree-sequence recording is enabled, <span class="s1">description</span> is persisted in the subpopulation’s metadata in tree-sequence output.</p>
<p class="p3">firstMaleIndex =&gt; (integer$)</p>
<p class="p6">The index of the first male individual in the subpopulation.<span class="Apple-converted-space">  </span>The <span class="s1">individuals</span> vector of the subpopulation is sorted into females first and males second; <span class="s1">firstMaleIndex</span> gives the position of the boundary between those sections.<span class="Apple-converted-space">  </span>The <span class="s1">firstMaleIndex</span> property is also the number of females in the subpopulation, given this design.<span class="Apple-converted-space">  </span>For non-sexual (i.e. hermaphroditic) simulations, the value of this property is undefined and should not be used.</p>
<p class="p5"><span class="s3">fitnessScaling &lt;–&gt; (float$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">float</span><span class="s3"> scaling factor applied to the fitness of all individuals in this subpopulation (i.e., the fitness value computed for each individual will be multiplied by this value).<span class="Apple-converted-space">  </span>This is primarily of use in nonWF models, where fitness is absolute, rather than in WF models, where fitness is relative (and thus a constant factor multiplied into the fitness of every individual will make no difference); however, it may be used in either type of model.<span class="Apple-converted-space">  </span>This provides a simple, fast way to modify the fitness of all individuals in a subpopulation; conceptually it is similar to returning the same fitness effect for all individuals in the subpopulation from a </span><span class="s4">fitnessEffect()</span><span class="s3"> callback, but without the complexity and performance overhead of implementing such a callback.<span class="Apple-converted-space">  </span>To scale the fitness of individuals by different (individual-specific) factors, see the </span><span class="s4">fitnessScaling</span><span class="s3"> property of </span><span class="s4">Individual</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The value of </span><span class="s4">fitnessScaling</span><span class="s3"> is reset to </span><span class="s4">1.0</span><span class="s3"> every tick, so that any scaling factor set lasts for only a single tick.<span class="Apple-converted-space">  </span>This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.</span></p>
<p class="p5">haplosomes =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">All of the haplosomes contained by the subpopulation.<span class="Apple-converted-space">  </span>All of the haplosomes for the first individual in the <span class="s1">individuals</span> property are provided, followed by all the haplosomes for the second individual, etc., in the same order as <span class="s1">individuals</span>.</p>
<p class="p5">haplosomesNonNull =&gt; (object&lt;Haplosome&gt;)</p>
<p class="p6">All of the haplosomes contained by the subpopulation, as with the <span class="s1">haplosomes</span> property, if all of them are not null haplosomes; any null haplosomes present are excluded from the returned vector.<span class="Apple-converted-space">  </span>This is a convenience shorthand, sometimes useful in models that involve null haplosomes.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this subpopulation; for subpopulation <span class="s1">p3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">immigrantSubpopFractions =&gt; (float)</p>
<p class="p4">The expected value of the fraction of children in the next generation that are immigrants arriving from particular subpopulations.</p>
<p class="p3">immigrantSubpopIDs =&gt; (integer)</p>
<p class="p4">The identifiers of the particular subpopulations from which immigrants will arrive in the next generation.</p>
<p class="p3">individualCount =&gt; (integer$)</p>
<p class="p4">The number of individuals in the subpopulation.</p>
<p class="p3">individuals =&gt; (object&lt;Individual&gt;)</p>
<p class="p6">All of the individuals contained by the subpopulation.<span class="Apple-converted-space">  </span>See the <span class="s1">sampleIndividuals()</span> and <span class="s1">subsetIndividuals()</span> for fast ways to get a subset of the individuals in a subpopulation.</p>
<p class="p5">lifetimeReproductiveOutput =&gt; (integer)</p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">lifetimeReproductiveOutput</span> contains the value of the <span class="s1">Individual</span> property <span class="s1">reproductiveOutput</span> for all individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).<span class="Apple-converted-space">  </span>This allows access to the lifetime reproductive output of individuals in the subpopulation at the end of their lives.<span class="Apple-converted-space">  </span>If pedigree tracking is not on, this property is unavailable.</p>
<p class="p5">lifetimeReproductiveOutputF =&gt; (integer)</p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">lifetimeReproductiveOutputF</span> contains the value of the <span class="s1">Individual</span> property <span class="s1">reproductiveOutput</span> for all female individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).<span class="Apple-converted-space">  </span>This property is undefined if separate sexes have not been enabled, or if pedigree tracking is not on.</p>
<p class="p5">lifetimeReproductiveOutputM =&gt; (integer)</p>
<p class="p6">If pedigree tracking is turned on with <span class="s1">initializeSLiMOptions(keepPedigrees=T)</span>, <span class="s1">lifetimeReproductiveOutputM</span> contains the value of the <span class="s1">Individual</span> property <span class="s1">reproductiveOutput</span> for all male individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).<span class="Apple-converted-space">  </span>This property is undefined if separate sexes have not been enabled, or if pedigree tracking is not on.</p>
<p class="p5">name &lt;–&gt; (string$)</p>
<p class="p6">A human-readable <span class="s1">string</span> name for the subpopulation.<span class="Apple-converted-space">  </span>By default, this is the subpopulation’s symbol as a <span class="s1">string</span>; for subpopulation <span class="s1">p3</span>, for example, <span class="s1">name</span> defaults to <span class="s1">"p3"</span>.<span class="Apple-converted-space">  </span>However, it may be set to whatever you wish except that subpopulation names must be unique across time (two different subpopulations may not both have the name <span class="s1">"foo"</span>, even if they never exist at the same time).<span class="Apple-converted-space">  </span>A subpopulation’s <span class="s1">name</span> may appear as a label in SLiMgui, and it can be useful in generating output, debugging, and other purposes.<span class="Apple-converted-space">  </span>When tree-sequence recording is enabled, <span class="s1">name</span> is persisted in the subpopulation’s metadata in tree-sequence output, and can then be used in Python to identify the subpopulation; if you plan to take advantage of that feature, <span class="s1">name</span> should follow the syntax of Python identifiers: starting with a letter or underscore <span class="s1">[a-zA-Z_]</span>, followed by letters, digits, or underscores <span class="s1">[a-zA-Z0-9_]</span>, without spaces, hyphens, or other characters.</p>
<p class="p3">selfingRate =&gt; (float$)</p>
<p class="p4">The expected value of the fraction of children in the next generation that will be produced by selfing (as opposed to biparental mating).<span class="Apple-converted-space">  </span>Selfing is only possible in non-sexual (i.e. hermaphroditic) simulations; for sexual simulations this property always has a value of <span class="s1">0.0</span><span class="s2">.</span></p>
<p class="p3">sexRatio =&gt; (float$)</p>
<p class="p4">For sexual simulations, the sex ratio for the subpopulation.<span class="Apple-converted-space">  </span>This is defined, in SLiM, as the fraction of the subpopulation that is male; in other words, it is actually the M:(M+F) ratio.<span class="Apple-converted-space">  </span>For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used.</p>
<p class="p5">spatialMaps =&gt; (object&lt;SpatialMap&gt;)</p>
<p class="p6">The spatial maps that are currently added to the subpopulation.</p>
<p class="p3">spatialBounds =&gt; (float)</p>
<p class="p4">The spatial boundaries of the subpopulation.<span class="Apple-converted-space">  </span>The length of the <span class="s1">spatialBounds</span> property depends upon the spatial dimensionality declared with <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>If the spatial dimensionality is zero (as it is by default), the value of this property is <span class="s1">float(0)</span> (a zero-length <span class="s1">float</span> vector).<span class="Apple-converted-space">  </span>Otherwise, minimums are supplied for each coordinate used by the dimensionality of the simulation, followed by maximums for each.<span class="Apple-converted-space">  </span>In other words, if the declared dimensionality is <span class="s1">"xy"</span>, the <span class="s1">spatialBounds</span> property will contain values <span class="s1">(x0, y0, x1, y1)</span>; bounds for the <i>z</i> coordinate will not be included in that case, since that coordinate is not used in the simulation’s dimensionality.<span class="Apple-converted-space">  </span>This property cannot be set, but the <span class="s1">setSpatialBounds()</span> method may be used to achieve the same thing.</p>
<p class="p3">species =&gt; (object&lt;Species&gt;$)</p>
<p class="p6"><span class="s3">The species to which the target object belongs.</span></p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s7">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods<span class="s5"> (provided by the </span><span class="s6">Dictionary</span><span class="s5"> class; see the Eidos manual)</span>, for another way of attaching state to subpopulations.</p>
<p class="p2"><i>5.17.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Subpopulation</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (object&lt;Individual&gt;)addCloned(object&lt;Individual&gt;$ parent, [integer$ count = 1], [logical$ defer = F])</span></p>
<p class="p6">Generates a new offspring individual from the given parent by clonal reproduction, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.<span class="Apple-converted-space">  </span>The subpopulation of <span class="s1">parent</span> will be used to locate applicable <span class="s1">mutation()</span> and <span class="s1">modifyChild()</span> callbacks governing the generation of the offspring individual.</p>
<p class="p6">Beginning in SLiM 4.1, the <span class="s1">count</span> parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).<span class="Apple-converted-space">  </span>Each offspring is generated independently, based upon the given parameters.<span class="Apple-converted-space">  </span>The returned vector contains all generated offspring, except those that were rejected by a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>If all offspring are rejected, <span class="s1">object&lt;Individual&gt;(0)</span> is returned, which is a zero-length <span class="s1">object</span> vector of class <span class="s1">Individual</span>; note that this is a change in behavior from earlier versions, which would return <span class="s1">NULL</span>.</p>
<p class="p6">Beginning in SLiM 4.1, passing <span class="s1">T</span> for <span class="s1">defer</span> requests that the generation of the haplosomes of the produced offspring be deferred until the end of the reproduction phase.<span class="Apple-converted-space">  </span>SLiM may or may not honor this request; if not, the offspring will be generated synchronously just as if <span class="s1">defer</span> were <span class="s1">F</span>.<span class="Apple-converted-space">  </span>Haplosome generation can only be deferred if there are no active <span class="s1">mutation()</span> callbacks; otherwise, an error will result.<span class="Apple-converted-space">  </span>Furthermore, when haplosome generation is deferred the mutations of the haplosomes of the generated offspring may not be accessed until reproduction is complete (whether from a <span class="s1">modifyChild()</span> callback or otherwise).<span class="Apple-converted-space">  </span>There is little or no advantage to deferring haplosome generation when running single-threaded; in that case, the default of <span class="s1">F</span> for <span class="s1">defer</span> is generally preferable since it has fewer restrictions.<span class="Apple-converted-space">  </span>When running multi-threaded, deferring haplosome generation allows that task to be done in parallel (which is the reason this option exists).</p>
<p class="p6">Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from <span class="s1">parent</span>; more specifically, the <span class="s1">x</span> property will be inherited in all spatial models (1D/2D/3D), the <span class="s1">y</span> property in 2D/3D models, and the <span class="s1">z</span> property in 3D models.<span class="Apple-converted-space">  </span>Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.<span class="Apple-converted-space">  </span>The parent’s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to <span class="s1">deviatePositions()</span> / <span class="s1">pointDeviated()</span>.</p>
<p class="p6">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See <span class="s1">addCrossed()</span> for further general notes on the addition of new offspring individuals.</p>
<p class="p5"><span class="s3">– (object&lt;Individual&gt;)addCrossed(object&lt;Individual&gt;$ parent1, object&lt;Individual&gt;$ parent2, [Nfs$ sex = NULL], [integer$ count = 1], [logical$ defer = F])</span></p>
<p class="p6">Generates a new offspring individual from the given parents by biparental sexual reproduction, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.<span class="Apple-converted-space">  </span>Attempting to use a newly generated offspring individual as a mate, or to reference it as a member of the target subpopulation in any other way, will result in an error.<span class="Apple-converted-space">  </span>In most models the returned individual is not used, but it is provided for maximal generality and flexibility.</p>
<p class="p6">The new offspring individual is generated from <span class="s1">parent1</span> and <span class="s1">parent2</span> by crossing them.<span class="Apple-converted-space">  </span>In sexual models <span class="s1">parent1</span> must be female and <span class="s1">parent2</span> must be male; in hermaphroditic models, <span class="s1">parent1</span> and <span class="s1">parent2</span> are unrestricted.<span class="Apple-converted-space">  </span>If <span class="s1">parent1</span> and <span class="s1">parent2</span> are the same individual in a hermaphroditic model, that parent self-fertilizes, or “selfs”, to generate the offspring sexually (note this is not the same as clonal reproduction).<span class="Apple-converted-space">  </span>Such selfing is considered “incidental” by <span class="s1">addCrossed()</span>, however; if the <span class="s1">preventIncidentalSelfing</span> flag of <span class="s1">initializeSLiMOptions()</span> is <span class="s1">T</span>, supplying the same individual for <span class="s1">parent1</span> and <span class="s1">parent2</span> is an error (you must check for and prevent incidental selfing if you set that flag in a nonWF model).<span class="Apple-converted-space">  </span>If non-incidental selfing is desired, <span class="s1">addSelfed()</span> should be used instead.</p>
<p class="p6">The <span class="s1">sex</span> parameter specifies the sex of the offspring.<span class="Apple-converted-space">  </span>A value of <span class="s1">NULL</span> means “make the default choice”; in non-sexual models it is the only legal value for <span class="s1">sex</span>, and does nothing, whereas in sexual models it causes male or female to be chosen with equal probability.<span class="Apple-converted-space">  </span>A value of <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">sex</span> specifies that the offspring should be male or female, respectively.<span class="Apple-converted-space">  </span>Finally, a <span class="s1">float</span> value from <span class="s1">0.0</span> to <span class="s1">1.0</span> for <span class="s1">sex</span> provides the probability that the offspring will be male; a value of <span class="s1">0.0</span> will produce a female, a value of <span class="s1">1.0</span> will produce a male, and for intermediate values SLiM will draw the sex of the offspring randomly according to the specified probability.<span class="Apple-converted-space">  </span>Unless you wish the bias the sex ratio of offspring, the default value of <span class="s1">NULL</span> should generally be used.</p>
<p class="p6">Note that any defined, active, and applicable <span class="s1">recombination()</span>, <span class="s1">mutation()</span>, and <span class="s1">modifyChild()</span> callbacks will be called as a side effect of calling this method, before this method even returns.<span class="Apple-converted-space">  </span>For <span class="s1">recombination()</span> and <span class="s1">mutation()</span> callbacks, the subpopulation of the parent that is generating a given gamete is used; for <span class="s1">modifyChild()</span> callbacks the situation is more complex.<span class="Apple-converted-space">  </span>In most biparental mating events, <span class="s1">parent1</span> and <span class="s1">parent2</span> will belong to the same subpopulation, and <span class="s1">modifyChild()</span> callbacks for that subpopulation will be used, just as in WF models.<span class="Apple-converted-space">  </span>In certain models (such as models of pollen flow and broadcast spawning), however, biparental mating may occur between parents that are not from the same subpopulation; that is legal in nonWF models, and in that case, <span class="s1">modifyChild()</span> callbacks for the subpopulation of <span class="s1">parent1</span> are used (since that is the maternal parent).</p>
<p class="p6">If the <span class="s1">modifyChild()</span> callback process results in rejection of the proposed child, a new offspring individual is not generated.<span class="Apple-converted-space">  </span>To force the generation of an offspring individual from a given pair of parents, you could loop until <span class="s1">addCrossed()</span> succeeds, but note that if your <span class="s1">modifyChild()</span> callback rejects all proposed children from those particular parents, your model will then hang, so care must be taken with this approach.<span class="Apple-converted-space">  </span>Usually, nonWF models do not force generation of offspring in this manner; rejection of a proposed offspring by a <span class="s1">modifyChild()</span> callback typically represents a phenomenon such as post-mating reproductive isolation or lethal genetic incompatibilities that would reduce the expected litter size, so the default behavior is typically desirable.</p>
<p class="p6">Beginning in SLiM 4.1, the <span class="s1">count</span> parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).<span class="Apple-converted-space">  </span>Each offspring is generated independently, based upon the given parameters.<span class="Apple-converted-space">  </span>The returned vector contains all generated offspring, except those that were rejected by a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>If all offspring are rejected, <span class="s1">object&lt;Individual&gt;(0)</span> is returned, which is a zero-length <span class="s1">object</span> vector of class <span class="s1">Individual</span>; note that this is a change in behavior from earlier versions, which would return <span class="s1">NULL</span>.</p>
<p class="p6">Beginning in SLiM 4.1, passing <span class="s1">T</span> for <span class="s1">defer</span> requests that the generation of the haplosomes of the produced offspring be deferred until the end of the reproduction phase.<span class="Apple-converted-space">  </span>SLiM may or may not honor this request; if not, the offspring will be generated synchronously just as if <span class="s1">defer</span> were <span class="s1">F</span>.<span class="Apple-converted-space">  </span>Haplosome generation can only be deferred if there are no active <span class="s1">mutation()</span> or <span class="s1">recombination()</span> callbacks; otherwise, an error will result.<span class="Apple-converted-space">  </span>Furthermore, when haplosome generation is deferred the mutations of the haplosomes of the generated offspring may not be accessed until reproduction is complete (whether from a <span class="s1">modifyChild()</span> callback or otherwise).<span class="Apple-converted-space">  </span>There is little or no advantage to deferring haplosome generation when running single-threaded; in that case, the default of <span class="s1">F</span> for <span class="s1">defer</span> is generally preferable since it has fewer restrictions.<span class="Apple-converted-space">  </span>When running multi-threaded, deferring haplosome generation allows that task to be done in parallel (which is the reason this option exists).</p>
<p class="p6">Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from <span class="s1">parent1</span>; more specifically, the <span class="s1">x</span> property will be inherited in all spatial models (1D/2D/3D), the <span class="s1">y</span> property in 2D/3D models, and the <span class="s1">z</span> property in 3D models.<span class="Apple-converted-space">  </span>Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.<span class="Apple-converted-space">  </span>The parent’s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to <span class="s1">deviatePositions()</span> / <span class="s1">pointDeviated()</span>.</p>
<p class="p6">Note that this method is only for use in nonWF models, in which offspring generation is managed manually by the model script; in such models, <span class="s1">addCrossed()</span> must be called only from <span class="s1">reproduction()</span> callbacks, and may not be called at any other time.<span class="Apple-converted-space">  </span>In WF models, offspring generation is managed automatically by the SLiM core.</p>
<p class="p5"><span class="s3">– (object&lt;Individual&gt;)addEmpty([Nfs$ sex = NULL], [Nl$ haplosome1Null = NULL], [Nl$ haplosome2Null = NULL], [integer$ count = 1])</span></p>
<p class="p6">Generates a new offspring individual with empty haplosomes (i.e., containing no mutations), queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.<span class="Apple-converted-space">  </span>No <span class="s1">recombination()</span> or <span class="s1">mutation()</span> callbacks will be called.<span class="Apple-converted-space">  </span>The target subpopulation will be used to locate applicable <span class="s1">modifyChild()</span> callbacks governing the generation of the offspring individual (unlike the other <span class="s1">addX()</span> methods, because there is no parental individual to reference).<span class="Apple-converted-space">  </span>The offspring is considered to have no parents for the purposes of pedigree tracking.<span class="Apple-converted-space">  </span>The <span class="s1">sex</span> parameter is treated as in <span class="s1">addCrossed()</span>.</p>
<p class="p6">For all chromosome types except <span class="s1">"A"</span>, null haplosomes will be generated as dictated by the sex of the individual and type of the chromosome.<span class="Apple-converted-space">  </span>For example, for chromosome type <span class="s1">"X"</span> a female would be generated with two empty haplosomes for that chromosome (XX), whereas a male would be generated with one empty haplosome and one null haplosome (X–, in SLiM parlance).<span class="Apple-converted-space">  </span>For chromosome type <span class="s1">"H"</span> an empty haplosome is always generated, not a null haplosome.<span class="Apple-converted-space">  </span>But for chromosome type <span class="s1">"A"</span>, in particular, more control is afforded.<span class="Apple-converted-space">  </span>Passing <span class="s1">NULL</span> (the default) or <span class="s1">F</span> for <span class="s1">haplosome1Null</span> will make the first haplosome for every chromosome of type <span class="s1">"A"</span> be a non-null (empty) haplosome, the standard behavior.<span class="Apple-converted-space">  </span>More interestingly, passing <span class="s1">T</span> for <span class="s1">haplosome1Null</span> would make the first haplosome for every chromosome of type <span class="s1">"A"</span> be a null haplosome.<span class="Apple-converted-space">  </span>Similarly, passing <span class="s1">T</span> for <span class="s1">haplosome2Null</span> would make the second haplosome for every chromosome of type <span class="s1">"A"</span> be a null haplosome.<span class="Apple-converted-space">  </span>This option could be useful for situations such as adding new haploids into a haplodiploid model.<span class="Apple-converted-space">  </span>(Separate control over the haploid or diploid configuration of each chromosome of type <span class="s1">"A"</span> is not presently supported, but would be a simple extension to the design, by allowing <span class="s1">haplosome1Null</span> and <span class="s1">haplosome2Null</span> to provide a whole vector of <span class="s1">logical</span> flags rather than just a singleton value; please request this feature if you require it.)</p>
<p class="p6">Beginning in SLiM 4.1, the <span class="s1">count</span> parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).<span class="Apple-converted-space">  </span>Each offspring is generated independently, based upon the given parameters.<span class="Apple-converted-space">  </span>The returned vector contains all generated offspring, except those that were rejected by a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>If all offspring are rejected, <span class="s1">object&lt;Individual&gt;(0)</span> is returned, which is a zero-length <span class="s1">object</span> vector of class <span class="s1">Individual</span>; note that this is a change in behavior from earlier versions, which would return <span class="s1">NULL</span>.</p>
<p class="p6">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See <span class="s1">addCrossed()</span> for further general notes on the addition of new offspring individuals.</p>
<p class="p5">– (object&lt;Individual&gt;)addMultiRecombinant(object&lt;Dictionary&gt;$ pattern, [Nfs$ sex = NULL], [No&lt;Individual&gt;$ parent1 = NULL], [No&lt;Individual&gt;$ parent2 = NULL], [Nl$ randomizeStrands = NULL], [integer$ count = 1], [logical$ defer = F])</p>
<p class="p6">Generates a new offspring individual based upon the inheritance pattern specified by <span class="s1">pattern</span>, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.<span class="Apple-converted-space">  </span>The “pattern dictionary” supplied in <span class="s1">pattern</span> must be of class <span class="s1">Dictionary</span> (or a subclass of <span class="s1">Dictionary</span>), and more particularly, must be a dictionary of dictionaries structured in a specific way as described below.<span class="Apple-converted-space">  </span>This method is a multi-chromosome version of the <span class="s1">addRecombinant()</span> method.<span class="Apple-converted-space">  </span>For single-chromosome models, using <span class="s1">addRecombinant()</span> will be simpler; and it will be easier to understand this extremely complex method if you understand <span class="s1">addRecombinant()</span> first.</p>
<p class="p6">The top-level “pattern dictionary” given by <span class="s1">pattern</span> specifies the way in which each chromosome should be handled.<span class="Apple-converted-space">  </span>It can use <span class="s1">integer</span> keys, in which case each key is the <span class="s1">id</span> of a chromosome, or <span class="s1">string</span> keys, in which case each key is the <span class="s1">symbol</span> of a chromosome.<span class="Apple-converted-space">  </span>In either case, a chromosome’s inheritance pattern is specified by an “inheritance dictionary” in <span class="s1">pattern</span> attached to such a chromosome <span class="s1">id</span> or <span class="s1">symbol</span> key.<span class="Apple-converted-space">  </span>That inheritance dictionary should itself contain up to six keys, with the standard names <span class="s1">"strand1"</span>, <span class="s1">"strand2"</span>, <span class="s1">"breaks1"</span>, <span class="s1">"strand3"</span>, <span class="s1">"strand4"</span>, and <span class="s1">"breaks2"</span>.<span class="Apple-converted-space">  </span>Any key which is missing in an inheritance dictionary is assumed to have a value of <span class="s1">NULL</span>, and missing keys will be referred to having a value of <span class="s1">NULL</span> here for simplicity.<span class="Apple-converted-space">  </span>These key-value pairs are used in precisely the same way as the parameters of the same names for <span class="s1">addRecombinant()</span>, to produce the offspring haplosome(s) for each specified chromosome.<span class="Apple-converted-space">  </span>There is some complication regarding how these six values can be used to produce results like crossing, cloning, and selfing, involving as many as four different “parents” for each chromosome; rather than repeating all of that documentation here, please see the <span class="s1">addRecombinant()</span> documentation for more information.<span class="Apple-converted-space">  </span>When an inheritance dictionary is supplied for a particular chromosome, this method uses the six values that dictionary contains (<span class="s1">strand1</span>, <span class="s1">strand2</span>, <span class="s1">breaks1</span>, <span class="s1">strand3</span>, <span class="s1">strand4</span>, <span class="s1">breaks2</span>) in exactly the same way as <span class="s1">addRecombinant()</span> does; <span class="s1">addMultiRecombinant()</span> simply supports multiple chromosomes.<span class="Apple-converted-space">  </span>In addition to that, however, <span class="s1">addMultiRecombinant()</span> also allows the pattern dictionary to omit the inheritance dictionaries for particular chromosomes; the behavior of <span class="s1">addMultiRecombinant()</span> in that special case will be described below, after discussing all other aspects of the method’s implementation.</p>
<p class="p6">The <span class="s1">sex</span> parameter optionally specifies the sex of the offspring.<span class="Apple-converted-space">  </span>The default value of <span class="s1">NULL</span> for <span class="s1">sex</span> specifies “default behavior”; in a non-sexual model this is the only legal value, and produces a hermaphroditic offspring.<span class="Apple-converted-space">  </span>In a sexual model, the “default behavior” of <span class="s1">NULL</span> is that the offspring’s sex is dictated by the haplosome structure it inherits.<span class="Apple-converted-space">  </span>For example, if <span class="s1">pattern</span> specifies that the offspring will have two non-null haplosomes for a chromosome of type <span class="s1">"X"</span>, the sex of the offspring must therefore be female, whereas if it will have one non-null <span class="s1">"X"</span> haplosome and one null <span class="s1">"X"</span> haplosome, it must therefore be male.<span class="Apple-converted-space">  </span>SLiM will scan through <span class="s1">pattern</span> to determine such constraints and enforce them.<span class="Apple-converted-space">  </span>If the constraints implied by <span class="s1">pattern</span> are not self-consistent (if the offspring would have two non-null <span class="s1">"X"</span> haplosomes but also a non-null <span class="s1">"Y"</span> haplosome, for example), an error will be raised.<span class="Apple-converted-space">  </span>The constraints defined by each chromosome type, as described in <span class="s1">initializeChromosome()</span>, must always be followed, even when using <span class="s1">addMultiRecombinant()</span>.<span class="Apple-converted-space">  </span>If <span class="s1">sex</span> is <span class="s1">NULL</span> and <span class="s1">pattern</span> imposes no constraints upon the sex of the offspring, the offspring will be chosen as male or female with equal probability.<span class="Apple-converted-space">  </span>A value of <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">sex</span> specifies that the offspring should be male or female, respectively.<span class="Apple-converted-space">  </span>A <span class="s1">float</span> value from <span class="s1">0.0</span> to <span class="s1">1.0</span> for <span class="s1">sex</span> provides the probability that the offspring will be male; a value of <span class="s1">0.0</span> will produce a female, a value of <span class="s1">1.0</span> will produce a male, and for intermediate values SLiM will draw the sex of the offspring randomly according to the specified probability.<span class="Apple-converted-space">  </span>In these cases where <span class="s1">sex</span> is not <span class="s1">NULL</span>, SLiM will first determine the sex of the individual as just described, and will then scan through <span class="s1">pattern</span> to confirm that it is compatible with the sex that was determined.<span class="Apple-converted-space">  </span>Again, if there is a conflict an error will be raised; you cannot specify the sex of an individual to be incompatible with the haplosomes that it inherits, and if you specify a sex with a <span class="s1">string</span> or <span class="s1">float</span> value it is up to you to ensure that that is compatible with the specifications in <span class="s1">pattern</span>.<span class="Apple-converted-space">  </span>(If you need more flexibility, you should probably not use a sexual model at all, but simply use chromosome types <span class="s1">"A"</span> and <span class="s1">"H"</span> in a non-sexual model, track the sex of individuals yourself with a tag value such as <span class="s1">tagL0</span>, and manipulate haplosomes during reproduction however you wish; SLiM then imposes no constraints.)</p>
<p class="p6">By default, the offspring is considered to have no parents, since there may be more than two “parents” in the general case.<span class="Apple-converted-space">  </span>If specifying parentage is desired, <span class="s1">parent1</span> and/or <span class="s1">parent2</span> may be passed explicitly; this will establish those individuals as the parents of the offspring for purposes of pedigree tracking, and for several other purposes described below.<span class="Apple-converted-space">  </span>If only one of <span class="s1">parent1</span> and <span class="s1">parent2</span> is non-<span class="s1">NULL</span>, that individual will be set as <i>both</i> of the parents of the offspring, mirroring the way that parentage is tracked for other cases such as <span class="s1">addCloned()</span> and <span class="s1">addSelfed()</span>.<span class="Apple-converted-space">  </span>It is not required for <span class="s1">parent1</span> or <span class="s1">parent2</span> to actually be a genetic parent of the offspring at all, although typically they would be.<span class="Apple-converted-space">  </span>To benefit from the full functionality of <span class="s1">addMultiRecombinant()</span> as described below, it is best to supply <span class="s1">parent1</span> and <span class="s1">parent2</span> when possible.</p>
<p class="p6">The <span class="s1">randomizeStrands</span> parameter is used to control the recombination behavior of <span class="s1">addMultiRecombinant()</span>.<span class="Apple-converted-space">  </span>An inheritance dictionary can specify two parental strands with crossover breakpoints between them to generate one offspring strand with recombination – for example, with the <span class="s1">"strand1"</span>, <span class="s1">"strand2"</span>, and <span class="s1">"breaks1"</span> keys, as described above, but the same is true of the <span class="s1">"strand3"</span>, <span class="s1">"strand4"</span>, and <span class="s1">"breaks2"</span> keys, and the discussion that follows applies to both cases.<span class="Apple-converted-space">  </span>If <span class="s1">randomizeStrands</span> is <span class="s1">F</span>, the supplied strands are used as given; for example, <span class="s1">"strand1"</span> will be the initial copy strand when generating the first gamete to form the offspring.<span class="Apple-converted-space">  </span>This mode should be used if you want explicit control over the initial copy strand; one example would be if your script is explicitly generating all four of the products of a meiosis event.<span class="Apple-converted-space">  </span>If <span class="s1">randomizeStrands</span> is T, then if <span class="s1">"strand1"</span> and <span class="s1">"strand2"</span> are both non-<span class="s1">NULL</span>, 50% of the time they will be swapped, making <span class="s1">"strand2"</span> the initial copy strand for the first gamete instead.<span class="Apple-converted-space">  </span>This mode (<span class="s1">randomizeStrands</span>=<span class="s1">T</span>) is usually the desired behavior, to avoid an inheritance bias due to a lack of randomization in the initial copy strand, so passing <span class="s1">T</span> for <span class="s1">randomizeStrands</span> is recommended unless you specifically desire otherwise.<span class="Apple-converted-space">  </span>The default value of <span class="s1">randomizeStrands</span> is <span class="s1">NULL</span> in order to force either <span class="s1">T</span> or <span class="s1">F</span> to be explicitly chosen whenever it would make a difference; if it is left as <span class="s1">NULL</span>, an error will be raised if generation of the specified offspring involves recombination, since then SLiM needs to know whether the value is <span class="s1">T</span> or <span class="s1">F</span>.<span class="Apple-converted-space">  </span>(This unconventional approach has been adopted because the default value was <span class="s1">F</span> prior to SLiM 5, but <span class="s1">T</span> is almost always the correct behavior, as explained above.<span class="Apple-converted-space">  </span>To try to prevent accidental bugs, this new policy was adopted to force the user to explicitly choose <span class="s1">T</span> or <span class="s1">F</span> whenever it matters.)</p>
<p class="p6">The value of the <span class="s1">meanParentAge</span> property of the generated offspring is calculated from the mean parent age of each of its two haplosomes (whether they turn out to be null haplosomes or not).<span class="Apple-converted-space">  </span>The <span class="s1">addRecombinant()</span> documentation provides a simple example; for <span class="s1">addMultiRecombinant()</span> the logic is the same, but potentially extended to more than two offspring haplosomes.</p>
<p class="p6">Callbacks can be involved in offspring generation with <span class="s1">addMultiRecombinant()</span>, but because there are up to four strands with up to four different parents, things are a bit complicated and different from other <span class="s1">add...()</span> methods; the policy described here seems like the best compromise.<span class="Apple-converted-space">  </span>The target subpopulation for the <span class="s1">addMultiRecombinant()</span> call will be used to locate applicable <span class="s1">mutation()</span> and <span class="s1">modifyChild()</span> callbacks governing the generation of the offspring individual.<span class="Apple-converted-space">  </span>On the other hand, <span class="s1">recombination()</span> callbacks will be found based upon the subpopulations to which <span class="s1">parent1</span> and <span class="s1">parent2</span> belong (for reasons discussed further in <span class="s1">drawBreakpoints()</span>); if a parent individual is not supplied, <span class="s1">recombination()</span> callbacks will not be called at all when generating the corresponding offspring haplosome.</p>
<p class="p6">When breakpoints are explicitly supplied to <span class="s1">addMultiRecombinant()</span> with <span class="s1">breaks1</span> or <span class="s1">breaks2</span>, gene conversion tracts are not well-supported by this method; the <span class="s1">breaks1</span> and <span class="s1">breaks2</span> vectors provide simple crossover breakpoints, which may be used to implement crossovers or simple gene conversion tracts, but complex gene conversion tracts with heteroduplex mismatch repair are not supported in this mode of operation since there is no way to supply the relevant information.<span class="Apple-converted-space">  </span>If, on the other hand, <span class="s1">breaks1</span> or <span class="s1">breaks2</span> is <span class="s1">NULL</span> when generating a haplosome with recombination, then as described above, <span class="s1">addRecombinant()</span> will generate breakpoints internally for that cross, and in this case, complex gene conversion tracts with heteroduplex mismatch repair are supported, since all of the necessary information is available.<span class="Apple-converted-space">  </span>Similarly, if the inheritance dictionary for a given chromosome is omitted from <span class="s1">pattern</span> entirely and a cross between <span class="s1">parent1</span> and <span class="s1">parent2</span> is inferred (as discussed below), the recombination algorithm used will support gene conversion including heteroduplex mismatch repair.</p>
<p class="p6">Finally, <span class="s1">count</span> is the number of offspring to generate using the given pattern and parameters, and <span class="s1">defer</span> is used for deferral of offspring generation, as described for <span class="s1">addRecombinant()</span>.<span class="Apple-converted-space">  </span>Any other details omitted from this documentation are all as described for <span class="s1">addRecombinant()</span>.</p>
<p class="p6">Constructing a well-formed pattern dictionary with inheritance dictionaries for every chromosome can be a bit complex and require many lines of code.<span class="Apple-converted-space">  </span>To ease the process, see the <span class="s1">Species</span> methods <span class="s1">addPatternForCross()</span>, <span class="s1">addPatternForClone()</span>, <span class="s1">addPatternForNull()</span>, and <span class="s1">addPatternForRecombinant()</span>, which help you to build a pattern dictionary one inheritance dictionary at a time.<span class="Apple-converted-space">  </span>However, several of these methods will probably be used infrequently, because of the final aspect of <span class="s1">addMultiRecombinant()</span> that we have not yet properly discussed.</p>
<p class="p6">As mentioned earlier, not all chromosomes need to be specified with an inheritance dictionary in <span class="s1">pattern</span>; whenever SLiM’s default inheritance behavior is well-defined and is desired for a given chromosome, the inheritance dictionary for that chromosome may be omitted, and will be inferred by <span class="s1">addMultiRecombinant()</span> automatically.<span class="Apple-converted-space">  </span>This behavior makes it easy to specify a reproduction event that is, for example, like a regular biparental cross involving many chromosomes, but that uses a different reproductive pattern just for one particular chromosome that behaves in a special way.<span class="Apple-converted-space">  </span>The inferred inheritance dictionary for a given chromosome is based upon the chromosome type, the values of <span class="s1">parent1</span> and <span class="s1">parent2</span>, and the sex of the offspring (which has, by this point, been determined in all cases).<span class="Apple-converted-space">  </span>The rules for this inference are actually quite simple.<span class="Apple-converted-space">  </span>If both parents are specified (that is, are both non-<span class="s1">NULL</span>), the inferred inheritance dictionary is the same as would be produced by a call to <span class="s1">addPatternForCross()</span> with those two parents, given in that order, for that chromosome, for the determined offspring sex.<span class="Apple-converted-space">  </span>If only one parent is specified (non-<span class="s1">NULL</span>), the inferred inheritance dictionary is the same as would be produced by a call to <span class="s1">addPatternForClone()</span> with that one parent, for that chromosome, for the determined offspring sex.<span class="Apple-converted-space">  </span>If selfing is desired for the inferred inheritance dictionary, pass the same individual for both <span class="s1">parent1</span> and <span class="s1">parent2</span>; the behavior of <span class="s1">addPatternForCross()</span> in that case is essentially to self the individual, as discussed in that method.<span class="Apple-converted-space">  </span>If the inferred inheritance dictionary for a given chromosome is not well-defined, as discussed in the documentation for <span class="s1">addPatternForCross()</span> and <span class="s1">addPatternForClone()</span>, or if both <span class="s1">parent1</span> and <span class="s1">parent2</span> are <span class="s1">NULL</span>, an error will be raised.<span class="Apple-converted-space">  </span>In such cases, the inheritance dictionary cannot be inferred, and will need to be given explicitly in <span class="s1">pattern</span>.</p>
<p class="p5">– (object&lt;Individual&gt;)addRecombinant(No&lt;Haplosome&gt;$ strand1, No&lt;Haplosome&gt;$ strand2, Ni breaks1, No&lt;Haplosome&gt;$ strand3, No&lt;Haplosome&gt;$ strand4, Ni breaks2, [Nfs$ sex = NULL], [No&lt;Individual&gt;$ parent1 = NULL], [No&lt;Individual&gt;$ parent2 = NULL], [Nl$ randomizeStrands = NULL], [integer$ count = 1], [logical$ defer = F])</p>
<p class="p6">Generates a new offspring individual from the given parental haplosomes with the specified crossover breakpoints, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.<span class="Apple-converted-space">  </span>This method is an advanced feature; most models will use <span class="s1">addCrossed()</span>, <span class="s1">addSelfed()</span>, or <span class="s1">addCloned()</span> instead.<span class="Apple-converted-space">  </span>This method may only be used in single-chromosome models; in multi-chromosome models, use <span class="s1">addMultiRecombinant()</span>, a more general version of <span class="s1">addRecombinant()</span>.</p>
<p class="p6">This method supports several possible configurations for <span class="s1">strand1</span>, <span class="s1">strand2</span>, and <span class="s1">breaks1</span> (and the same applies for <span class="s1">strand3</span>, <span class="s1">strand4</span>, and <span class="s1">breaks2</span>).<span class="Apple-converted-space">  </span>If <span class="s1">strand1</span> and <span class="s1">strand2</span> are both <span class="s1">NULL</span>, the corresponding haplosome in the generated offspring will be a null haplosome; in this case, <span class="s1">breaks1</span> must be <span class="s1">NULL</span> or zero-length.<span class="Apple-converted-space">  </span>If <span class="s1">strand1</span> is non-<span class="s1">NULL</span> but <span class="s1">strand2</span> is <span class="s1">NULL</span>, the corresponding haplosome in the generated offspring will be a clonal copy of <span class="s1">strand1</span> with mutations added, as from <span class="s1">addCloned()</span>; in this case, <span class="s1">breaks1</span> must again be <span class="s1">NULL</span> or zero-length.<span class="Apple-converted-space">  </span>If <span class="s1">strand1</span> and <span class="s1">strand2</span> are both non-<span class="s1">NULL</span>, the corresponding haplosome in the generated offspring will result from recombination between <span class="s1">strand1</span> and <span class="s1">strand2</span> with mutations added, as from <span class="s1">addCrossed()</span>, with <span class="s1">strand1</span> being the initial copy strand by default (but see below).<span class="Apple-converted-space">  </span>Copying will switch between strands at each crossover breakpoint.<span class="Apple-converted-space">  </span>Breakpoints may be supplied in <span class="s1">breaks1</span>, which need not be sorted or uniqued (SLiM will sort and unique the supplied breakpoints internally).<span class="Apple-converted-space">  </span>Alternatively, <span class="s1">breaks1</span> may be <span class="s1">NULL</span>, which requests that <span class="s1">addRecombinant()</span> draw breakpoints automatically to recombine <span class="s1">strand1</span> and <span class="s1">strand2</span>, following SLiM’s usual breakpoint-drawing algorithm.<span class="Apple-converted-space">  </span>(If you do not want any breakpoints, pass <span class="s1">integer(0)</span>, a zero-length <span class="s1">integer</span> vector, for <span class="s1">breaks1</span>.)<span class="Apple-converted-space">  </span>Finally, it is not currently legal for <span class="s1">strand1</span> to be <span class="s1">NULL</span> and <span class="s1">strand2</span> non-<span class="s1">NULL</span>; that variant may be assigned some meaning in future.<span class="Apple-converted-space">  </span>Again, this discussion applies equally to <span class="s1">strand3</span>, <span class="s1">strand4</span>, and <span class="s1">breaks2</span>, <i>mutatis mutandis</i>.<span class="Apple-converted-space">  </span>Null haplosomes may never be passed as any of the four parental strands; pass <span class="s1">NULL</span>, not a null haplosome, if that strand is not inherited from.<span class="Apple-converted-space">  </span>When modeling a chromosome that is intrinsically haploid, such as the Y, <span class="s1">NULL</span> must be passed for <span class="s1">strand3</span>, <span class="s1">strand4</span>, and <span class="s1">breaks2</span>; you cannot supply genetic information for an offspring haplosome that will not exist.<span class="Apple-converted-space">  </span>Note that when new mutations are generated by <span class="s1">addRecombinant()</span>, their <span class="s1">subpopID</span> property will be the <span class="s1">id</span> of the offspring’s subpopulation, since the parental subpopulation is ambiguous in the general case; this behavior differs from the other <span class="s1">add...()</span> methods.</p>
<p class="p6">These semantics allow several uses for <span class="s1">addRecombinant()</span>.<span class="Apple-converted-space">  </span>When all strands are non-<span class="s1">NULL</span>, it is similar to <span class="s1">addCrossed()</span> except that the recombination breakpoints can be specified explicitly, allowing very precise offspring generation without having to override SLiM’s breakpoint generation with a <span class="s1">recombination()</span> callback.<span class="Apple-converted-space">  </span>When only <span class="s1">strand1</span> and <span class="s1">strand3</span> are supplied, it is very similar to <span class="s1">addCloned()</span>, creating a clonal offspring, except that the two parental haplosomes need not belong to the same individual (whatever that might mean biologically).<span class="Apple-converted-space">  </span>Supplying only <span class="s1">strand1</span> is useful for modeling clonally reproducing haploids, or any chromosome type that is intrinsically haploid, such as the Y chromosome.<span class="Apple-converted-space">  </span>For a model of clonally reproducing haploids that undergo horizontal gene transfer (HGT), supplying only <span class="s1">strand1</span> and <span class="s1">strand2</span> will allow HGT from <span class="s1">strand2</span> to replace segments of an otherwise clonal copy of <span class="s1">strand1</span>, while the second haplosome of the generated offspring will be a null haplosome; this could be useful for modeling bacterial conjugation, for example.<span class="Apple-converted-space">  </span>Other variations are also possible.</p>
<p class="p6">The <span class="s1">sex</span> parameter optionally specifies the sex of the offspring.<span class="Apple-converted-space">  </span>The default value of <span class="s1">NULL</span> for <span class="s1">sex</span> specifies “default behavior”; in a non-sexual model this is the only legal value, and produces a hermaphroditic offspring.<span class="Apple-converted-space">  </span>In a sexual model, the “default behavior” of <span class="s1">NULL</span> is that the offspring’s sex is dictated by the haplosome structure it inherits.<span class="Apple-converted-space">  </span>For example, if the supplied strands indicate that the offspring will have two non-null haplosomes for a chromosome of type <span class="s1">"X"</span>, the sex of the offspring must therefore be female, whereas if it will have one non-null <span class="s1">"X"</span> haplosome and one null <span class="s1">"X"</span> haplosome, it must therefore be male.<span class="Apple-converted-space">  </span>SLiM will examine the supplied strands to determine such constraints and enforce them.<span class="Apple-converted-space">  </span>The constraints defined by each chromosome type, as described in <span class="s1">initializeChromosome()</span>, must always be followed, even when using <span class="s1">addRecombinant()</span>.<span class="Apple-converted-space">  </span>If <span class="s1">sex</span> is <span class="s1">NULL</span> and the sex of the offspring is unconstrained, the offspring will be chosen as male or female with equal probability.<span class="Apple-converted-space">  </span>A value of <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">sex</span> specifies that the offspring should be male or female, respectively.<span class="Apple-converted-space">  </span>A <span class="s1">float</span> value from <span class="s1">0.0</span> to <span class="s1">1.0</span> for <span class="s1">sex</span> provides the probability that the offspring will be male; a value of <span class="s1">0.0</span> will produce a female, a value of <span class="s1">1.0</span> will produce a male, and for intermediate values SLiM will draw the sex of the offspring randomly according to the specified probability.<span class="Apple-converted-space">  </span>In these cases where <span class="s1">sex</span> is not <span class="s1">NULL</span>, SLiM will first determine the sex of the individual as just described, and will then examine the supplied strands to confirm that it is compatible with the sex that was determined.<span class="Apple-converted-space">  </span>Again, if there is a conflict an error will be raised; you cannot specify the sex of an individual to be incompatible with the haplosomes that it inherits, and if you specify a sex with a <span class="s1">string</span> or <span class="s1">float</span> value it is up to you to ensure that that is compatible with the supplied strands.<span class="Apple-converted-space">  </span>(If you need more flexibility, you should probably not use a sexual model at all, but simply use chromosome type <span class="s1">"A"</span> or <span class="s1">"H"</span> in a non-sexual model, track the sex of individuals yourself with a tag value such as <span class="s1">tagL0</span>, and manipulate haplosomes during reproduction however you wish; SLiM then imposes no constraints.)</p>
<p class="p6">By default, the offspring is considered to have no parents, since there may be more than two “parents” in the general case.<span class="Apple-converted-space">  </span>If specifying parentage is desired, <span class="s1">parent1</span> and/or <span class="s1">parent2</span> may be passed to explicitly; this will establish those individuals as the parents of the offspring for purposes of pedigree tracking, and for several other purposes described below.<span class="Apple-converted-space">  </span>If only one of <span class="s1">parent1</span> and <span class="s1">parent2</span> is non-<span class="s1">NULL</span>, that individual will be set as <i>both</i> of the parents of the offspring, mirroring the way that parentage is tracked for other cases such as <span class="s1">addCloned()</span> and <span class="s1">addSelfed()</span>.<span class="Apple-converted-space">  </span>It is not required for <span class="s1">parent1</span> or <span class="s1">parent2</span> to actually be a genetic parent of the offspring at all, although typically they would be.<span class="Apple-converted-space">  </span>To benefit from the full functionality of <span class="s1">addRecombinant()</span> as described below, it is best to supply <span class="s1">parent1</span> and <span class="s1">parent2</span> when possible.</p>
<p class="p6">The <span class="s1">randomizeStrands</span> parameter is used to control the recombination behavior of <span class="s1">addRecombinant()</span>.<span class="Apple-converted-space">  </span>As described above, two parental strands with crossover breakpoints between them can be specified to generate one offspring strand with recombination – for example, with the <span class="s1">strand1</span>, <span class="s1">strand2</span>, and <span class="s1">breaks1</span> parameters, but the same is true of the <span class="s1">strand3</span>, <span class="s1">strand4</span>, and <span class="s1">breaks2</span> parameters, and the discussion that follows applies to both cases.<span class="Apple-converted-space">  </span>If <span class="s1">randomizeStrands</span> is <span class="s1">F</span>, the supplied strands are used as given; for example, <span class="s1">strand1</span> will be the initial copy strand when generating the first gamete to form the offspring.<span class="Apple-converted-space">  </span>This mode should be used if you want explicit control over the initial copy strand; one example would be if your script is explicitly generating all four of the products of a meiosis event.<span class="Apple-converted-space">  </span>If <span class="s1">randomizeStrands</span> is <span class="s1">T</span>, then if <span class="s1">strand1</span> and <span class="s1">strand2</span> are both non-<span class="s1">NULL</span>, 50% of the time they will be swapped, making <span class="s1">strand2</span> the initial copy strand for the first gamete instead.<span class="Apple-converted-space">  </span>This mode (<span class="s1">randomizeStrands</span>=<span class="s1">T</span>) is usually the desired behavior, to avoid an inheritance bias due to a lack of randomization in the initial copy strand, so passing <span class="s1">T</span> for <span class="s1">randomizeStrands</span> is recommended unless you specifically desire otherwise.<span class="Apple-converted-space">  </span>The default value of <span class="s1">randomizeStrands</span> is <span class="s1">NULL</span> in order to force either <span class="s1">T</span> or <span class="s1">F</span> to be explicitly chosen whenever it would make a difference; if it is left as <span class="s1">NULL</span>, an error will be raised if generation of the specified offspring involves recombination, since then SLiM needs to know whether the value is <span class="s1">T</span> or <span class="s1">F</span>.<span class="Apple-converted-space">  </span>(This unconventional approach has been adopted because the default value was <span class="s1">F</span> prior to SLiM 5, but <span class="s1">T</span> is almost always the correct behavior, as explained above.<span class="Apple-converted-space">  </span>To try to prevent accidental bugs, this new policy was adopted to force the user to explicitly choose <span class="s1">T</span> or <span class="s1">F</span> whenever it matters.)</p>
<p class="p6">The value of the <span class="s1">meanParentAge</span> property of the generated offspring is calculated from the mean parent age of each of its two haplosomes (whether they turn out to be null haplosomes or not); that may be an average of two values (if both offspring haplosomes have at least one parent), a single value (if one offspring haplosome has no parent), or no values (if both offspring haplosomes have no parent, in which case <span class="s1">0.0</span> results).<span class="Apple-converted-space">  </span>The mean parent age of a given offspring haplosome is the mean of the ages of the parents of the two strands used to generate that offspring haplosome; if one strand is <span class="s1">NULL</span> then the mean parent age for that offspring haplosome is the age of the parent of the non-<span class="s1">NULL</span> strand, while if both strands are <span class="s1">NULL</span> then that offspring haplosome is parentless and is not used in the final calculation.<span class="Apple-converted-space">  </span>In other words, if one offspring haplosome has two parents with ages A and B, and the other offspring haplosome has one parent with age C, the <span class="s1">meanParentAge</span> of the offspring will be (A+B+C+C) / 4, or equivalently, ((A+B)/2 + C) / 2, not (A+B+C) / 3.</p>
<p class="p6">Callbacks can be involved in offspring generation with <span class="s1">addRecombinant()</span>, but because there are up to four strands with up to four different parents, things are a bit complicated and different from other <span class="s1">add...()</span> methods; the policy described here seems like the best compromise.<span class="Apple-converted-space">  </span>The target subpopulation for the <span class="s1">addRecombinant()</span> call will be used to locate applicable <span class="s1">mutation()</span> and <span class="s1">modifyChild()</span> callbacks governing the generation of the offspring individual.<span class="Apple-converted-space">  </span>On the other hand, <span class="s1">recombination()</span> callbacks will be found based upon the subpopulations to which <span class="s1">parent1</span> and <span class="s1">parent2</span> belong (for reasons discussed further in <span class="s1">drawBreakpoints()</span>); if a parent individual is not supplied, <span class="s1">recombination()</span> callbacks will not be called at all when generating the corresponding offspring haplosome.</p>
<p class="p6">When breakpoints are explicitly supplied to <span class="s1">addRecombinant()</span> with <span class="s1">breaks1</span> or <span class="s1">breaks2</span>, gene conversion tracts are not well-supported by this method; the <span class="s1">breaks1</span> and <span class="s1">breaks2</span> vectors provide simple crossover breakpoints, which may be used to implement crossovers or simple gene conversion tracts, but complex gene conversion tracts with heteroduplex mismatch repair are not supported in this mode of operation since there is no way to supply the relevant information.<span class="Apple-converted-space">  </span>If, on the other hand, <span class="s1">breaks1</span> or <span class="s1">breaks2</span> is <span class="s1">NULL</span> when generating a haplosome with recombination, then as described above, <span class="s1">addRecombinant()</span> will generate breakpoints internally for that cross, and in this case, complex gene conversion tracts with heteroduplex mismatch repair are supported, since all of the necessary information is available.</p>
<p class="p6">Beginning in SLiM 4.1, the <span class="s1">count</span> parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).<span class="Apple-converted-space">  </span>Each offspring is generated independently, based upon the given parameters.<span class="Apple-converted-space">  </span>The returned vector contains all generated offspring, except those that were rejected by a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>If all offspring are rejected, <span class="s1">object&lt;Individual&gt;(0)</span> is returned, which is a zero-length <span class="s1">object</span> vector of class <span class="s1">Individual</span>; note that this is a change in behavior from earlier versions, which would return <span class="s1">NULL</span>.</p>
<p class="p6">Beginning in SLiM 4.1, passing <span class="s1">T</span> for <span class="s1">defer</span> requests that the generation of the haplosomes of the produced offspring be deferred until the end of the reproduction phase.<span class="Apple-converted-space">  </span>SLiM may or may not honor this request; if not, the offspring will be generated synchronously just as if <span class="s1">defer</span> were <span class="s1">F</span>.<span class="Apple-converted-space">  </span>Haplosome generation can only be deferred if there are no active <span class="s1">mutation()</span> callbacks; otherwise, an error will result.<span class="Apple-converted-space">  </span>Furthermore, when haplosome generation is deferred the mutations of the haplosomes of the generated offspring may not be accessed until reproduction is complete (whether from a <span class="s1">modifyChild()</span> callback or otherwise).<span class="Apple-converted-space">  </span>There is little or no advantage to deferring haplosome generation when running single-threaded; in that case, the default of <span class="s1">F</span> for <span class="s1">defer</span> is generally preferable since it has fewer restrictions.<span class="Apple-converted-space">  </span>When running multi-threaded, deferring haplosome generation allows that task to be done in parallel (which is the reason this option exists).</p>
<p class="p6">Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from <span class="s1">parent1</span>; more specifically, the <span class="s1">x</span> property will be inherited in all spatial models (1D/2D/3D), the <span class="s1">y</span> property in 2D/3D models, and the <span class="s1">z</span> property in 3D models.<span class="Apple-converted-space">  </span>Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.<span class="Apple-converted-space">  </span>The parent’s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to <span class="s1">deviatePositions()</span> / <span class="s1">pointDeviated()</span>.<span class="Apple-converted-space">  </span>If <span class="s1">parent1</span> is <span class="s1">NULL</span>, <span class="s1">parent2</span> will be used; if it is also <span class="s1">NULL</span>, no spatial position will be inherited.</p>
<p class="p6">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See <span class="s1">addCrossed()</span> for further general notes on the addition of new offspring individuals.</p>
<p class="p5"><span class="s3">– (object&lt;Individual&gt;)addSelfed(object&lt;Individual&gt;$ parent, [integer$ count = 1], [logical$ defer = F])</span></p>
<p class="p6">Generates a new offspring individual from the given parent by selfing, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.<span class="Apple-converted-space">  </span>The subpopulation of <span class="s1">parent</span> will be used to locate applicable <span class="s1">mutation()</span>, <span class="s1">recombination()</span>, and <span class="s1">modifyChild()</span> callbacks governing the generation of the offspring individual.</p>
<p class="p6">Since selfing requires that <span class="s1">parent</span> act as a source of both a male and a female gamete, this method may be called only in hermaphroditic models; calling it in sexual models will result in an error.<span class="Apple-converted-space">  </span>This method represents a non-incidental selfing event, so the <span class="s1">preventIncidentalSelfing</span> flag of <span class="s1">initializeSLiMOptions()</span> has no effect on this method (in contrast to the behavior of <span class="s1">addCrossed()</span>, where selfing is assumed to be incidental).</p>
<p class="p6">Beginning in SLiM 4.1, the <span class="s1">count</span> parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).<span class="Apple-converted-space">  </span>Each offspring is generated independently, based upon the given parameters.<span class="Apple-converted-space">  </span>The returned vector contains all generated offspring, except those that were rejected by a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>If all offspring are rejected, <span class="s1">object&lt;Individual&gt;(0)</span> is returned, which is a zero-length <span class="s1">object</span> vector of class <span class="s1">Individual</span>; note that this is a change in behavior from earlier versions, which would return <span class="s1">NULL</span>.</p>
<p class="p6">Beginning in SLiM 4.1, passing <span class="s1">T</span> for <span class="s1">defer</span> requests that the generation of the haplosomes of the produced offspring be deferred until the end of the reproduction phase.<span class="Apple-converted-space">  </span>SLiM may or may not honor this request; if not, the offspring will be generated synchronously just as if <span class="s1">defer</span> were <span class="s1">F</span>.<span class="Apple-converted-space">  </span>Haplosome generation can only be deferred if there are no active <span class="s1">mutation()</span> or <span class="s1">recombination()</span> callbacks; otherwise, an error will result.<span class="Apple-converted-space">  </span>Furthermore, when haplosome generation is deferred the mutations of the haplosomes of the generated offspring may not be accessed until reproduction is complete (whether from a <span class="s1">modifyChild()</span> callback or otherwise).<span class="Apple-converted-space">  </span>There is little or no advantage to deferring haplosome generation when running single-threaded; in that case, the default of <span class="s1">F</span> for <span class="s1">defer</span> is generally preferable since it has fewer restrictions.<span class="Apple-converted-space">  </span>When running multi-threaded, deferring haplosome generation allows that task to be done in parallel (which is the reason this option exists).</p>
<p class="p6">Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from <span class="s1">parent</span>; more specifically, the <span class="s1">x</span> property will be inherited in all spatial models (1D/2D/3D), the <span class="s1">y</span> property in 2D/3D models, and the <span class="s1">z</span> property in 3D models.<span class="Apple-converted-space">  </span>Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.<span class="Apple-converted-space">  </span>The parent’s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to <span class="s1">deviatePositions()</span> / <span class="s1">pointDeviated()</span>.</p>
<p class="p6">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See <span class="s1">addCrossed()</span> for further general notes on the addition of new offspring individuals.</p>
<p class="p5">– (void)addSpatialMap(object&lt;SpatialMap&gt;$ map)</p>
<p class="p6">Adds the given <span class="s1">SpatialMap</span> object, <span class="s1">map</span>, to the subpopulation.<span class="Apple-converted-space">  </span>(The spatial map would have been previously created with a call to <span class="s1">defineSpatialMap()</span> on a different subpopulation; <span class="s1">addSpatialMap()</span> can then be used to add that existing spatial map with other subpopulations, sharing the map between subpopulations.)<span class="Apple-converted-space">  </span>If the map is already added to the target subpopulation, this method does nothing; if a different map with the same name is already added to the subpopulation, an error results (because map names must be unique within each subpopulation).<span class="Apple-converted-space">  </span>The map being added must be compatible with the target subpopulation; in particular, the spatial bounds utilized by the map must exactly match the corresponding spatial bounds for the subpopulation, and the dimensionality of the subpopulation must encompass the spatiality of the map.<span class="Apple-converted-space">  </span>For example, if the map has a spatiality of <span class="s1">"xz"</span> then the subpopulation must have a dimensionality of <span class="s1">"xyz"</span> so that it encompasses both <span class="s1">"x"</span> and <span class="s1">"z"</span>, and the subpopulation’s spatial bounds for <span class="s1">"x"</span> and <span class="s1">"z"</span> must match those for the map (but the spatial bounds for <span class="s1">"y"</span> are unimportant, since the map does not use that dimension).</p>
<p class="p6">Adding a map to a subpopulation is not strictly necessary, at present; one may query a <span class="s1">SpatialMap</span> object directly using <span class="s1">mapValue()</span>, regarding points in a subpopulation, without the map actually having been added to that subpopulation.<span class="Apple-converted-space">  </span>However, it is a good idea to use <span class="s1">addSpatialMap()</span>, both for its compatibility check that prevents unnoticed scripting errors, and because it ensures correct display of the model in SLiMgui.</p>
<p class="p3">– (float)cachedFitness(Ni indices)</p>
<p class="p6">The fitness values calculated for the individuals at the indices given are returned.<span class="Apple-converted-space">  </span>If <span class="s1">NULL</span> is passed, fitness values for all individuals in the subpopulation are returned.<span class="Apple-converted-space">  </span>The fitness values returned are cached values; <span class="s1">mutationEffect()</span> and <span class="s1">fitnessEffect()</span> callbacks are therefore not called as a side effect of this method.<span class="Apple-converted-space">  </span>It is always an error to call <span class="s1">cachedFitness()</span> from inside a <span class="s1">mutationEffect()</span> or <span class="s1">fitnessEffect()</span> callback, since fitness values are in the middle of being set up.<span class="Apple-converted-space">  </span>In WF models, it is also an error to call <span class="s1">cachedFitness()</span> from a <span class="s1">late()</span> event, because fitness values for the new offspring generation have not yet been calculated and are undefined.<span class="Apple-converted-space">  </span>In nonWF models, the population may be a mixture of new and old individuals, so instead, <span class="s1">NAN</span> will be returned as the fitness of any new individuals whose fitness has not yet been calculated.<span class="Apple-converted-space">  </span>When new subpopulations are first created with <span class="s1">addSubpop()</span> or <span class="s1">addSubpopSplit()</span>, the fitness of all of the newly created individuals is considered to be <span class="s1">1.0</span> until fitness values are recalculated.</p>
<p class="p5"><span class="s3">– (void)configureDisplay([Nf center = NULL], [Nf$ scale = NULL], [Ns$ color = NULL])</span></p>
<p class="p6"><span class="s3">This method customizes the display of the subpopulation in SLiMgui’s Population Visualization graph.<span class="Apple-converted-space">  </span>When this method is called by a model running outside SLiMgui, it will do nothing except type-checking and bounds-checking its arguments.<span class="Apple-converted-space">  </span>When called by a model running in SLiMgui, the position, size, and color of the subpopulation’s displayed circle can be controlled as specified below.</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">center</span><span class="s3"> parameter sets the coordinates of the center of the subpopulation’s displayed circle; it must be a </span><span class="s4">float</span><span class="s3"> vector of length two, such that </span><span class="s4">center[0]</span><span class="s3"> provides the <i>x</i>-coordinate and </span><span class="s4">center[1]</span><span class="s3"> provides the <i>y</i>-coordinate.<span class="Apple-converted-space">  </span>The square central area of the Population Visualization occupies scaled coordinates in [0,1] for both <i>x</i> and <i>y</i>, so the values in </span><span class="s4">center</span><span class="s3"> must be within those bounds.<span class="Apple-converted-space">  </span>If a value of </span><span class="s4">NULL</span><span class="s3"> is provided, SLiMgui’s default center will be used (which currently arranges subpopulations in a circle).</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">scale</span><span class="s3"> parameter sets a scaling factor to be applied to the radius of the subpopulation’s displayed circle.<span class="Apple-converted-space">  </span>The default radius used by SLiMgui is a function of the subpopulation’s number of individuals; this default radius is then multiplied by </span><span class="s4">scale</span><span class="s3">.<span class="Apple-converted-space">  </span>If a value of </span><span class="s4">NULL</span><span class="s3"> is provided, the default radius will be used; this is equivalent to supplying a </span><span class="s4">scale</span><span class="s3"> of </span><span class="s4">1.0</span><span class="s3">.<span class="Apple-converted-space">  </span>Typically the same </span><span class="s4">scale</span><span class="s3"> value should be used by all subpopulations, to scale all of their circles up or down uniformly, but that is not required.</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">color</span><span class="s3"> parameter sets the color to be used for the displayed subpopulation’s circle.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form </span><span class="s4">"#RRGGBB"</span><span class="s3"> (see the Eidos manual).<span class="Apple-converted-space">  </span>If </span><span class="s4">color</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> or the empty string, </span><span class="s4">""</span><span class="s3">, SLiMgui’s default (fitness-based) color will be used.</span></p>
<p class="p5">– (object&lt;SpatialMap&gt;$)defineSpatialMap(string$ name, string$ spatiality, numeric values, [logical$ interpolate = F], [Nif valueRange = NULL], [Ns colors = NULL])</p>
<p class="p6">Defines a spatial map for the subpopulation; see the <span class="s1">SpatialMap</span> documentation regarding this class.<span class="Apple-converted-space">  </span>The new map is automatically added to the subpopulation; <span class="s1">addSpatialMap()</span> does not need to be called.<span class="Apple-converted-space">  </span>(That method is for sharing the map with additional subpopulations, beyond the one for which the map was originally defined.)<span class="Apple-converted-space">  </span>The new <span class="s1">SpatialMap</span> object is returned, and may be retained permanently using <span class="s1">defineConstant()</span> or <span class="s1">defineGlobal()</span> for convenience.</p>
<p class="p6">The name of the map is given by <span class="s1">name</span>, and can be used to identify it.<span class="Apple-converted-space">  </span>The map uses the spatial dimensions referenced by <span class="s1">spatiality</span>, which must be a subset of the dimensions defined for the simulation in <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>Spatiality <span class="s1">"x"</span> is permitted for dimensionality <span class="s1">"x"</span>; spatiality <span class="s1">"x"</span>, <span class="s1">"y"</span>, or <span class="s1">"xy"</span> for dimensionality <span class="s1">"xy"</span>; and spatiality <span class="s1">"x"</span>, <span class="s1">"y"</span>, <span class="s1">"z"</span>, <span class="s1">"xy"</span>, <span class="s1">"yz"</span>, <span class="s1">"xz"</span>, or <span class="s1">"xyz"</span> for dimensionality <span class="s1">"xyz"</span>.<span class="Apple-converted-space">  </span>The spatial map is defined by a grid of values supplied in parameter <span class="s1">values</span>.<span class="Apple-converted-space">  </span>That grid of values is aligned with the spatial bounds of the subpopulation, as described in more detail below; the spatial map is therefore coupled to those spatial bounds, and can only be used in subpopulations that match those particular spatial bounds (to avoid stretching or shrinking the map).<span class="Apple-converted-space">  </span>The remaining optional parameters are described below.</p>
<p class="p6">Note that the semantics of this method changed in SLiM 3.5; in particular, the <span class="s1">gridSize</span> parameter was removed, and the interpretation of the <span class="s1">values</span> parameter changed as described below.<span class="Apple-converted-space">  </span>Existing code written prior to SLiM 3.5 will produce an error, due to the removed <span class="s1">gridSize</span> parameter, and must be revised carefully to obtain the same result, even if <span class="s1">NULL</span> had been passed for <span class="s1">gridSize</span> previously.</p>
<p class="p6">Beginning in SLiM 3.5, the <span class="s1">values</span> parameter must be a vector/matrix/array with the number of dimensions appropriate for the declared spatiality of the map; for example, a map with spatiality <span class="s1">"x"</span> would require a (one-dimensional) vector, spatiality <span class="s1">"xy"</span> would require a (two-dimensional) matrix, and a map with spatiality of <span class="s1">"xyz"</span> would require a three-dimensional array.<span class="Apple-converted-space">  </span>(See the Eidos manual for discussion of vectors, matrices, and arrays.)<span class="Apple-converted-space">  </span>The data in <span class="s1">values</span> is interpreted in such a way that a two-dimensional matrix of values, with (0, 0) at upper left and values by column, is transformed into the format expected by SLiM, with (0, 0) at lower left and values by row; in other words, the two-dimensional matrix as it prints in the Eidos console will match the appearance of the two-dimensional spatial map as seen in SLiMgui.<span class="Apple-converted-space">  </span><i>This is a change in behavior from versions prior to SLiM 3.5</i>; it ensures that images loaded from disk with the Eidos class <span class="s1">Image</span> can be used directly as spatial maps, achieving the expected orientation, with no need for transposition or flipping.<span class="Apple-converted-space">  </span>If the spatial map is a three-dimensional array, it is read as successive <i>z</i>-axis “planes”, each of which is a two-dimensional matrix that is treated as described above.</p>
<p class="p6">Moving on to the other parameters of <span class="s1">defineSpatialMap()</span>: if <span class="s1">interpolate</span> is <span class="s1">F</span>, values across the spatial map are not interpolated; the value at a given point is equal to the nearest value defined by the grid of values specified.<span class="Apple-converted-space">  </span>If <span class="s1">interpolate</span> is <span class="s1">T</span>, values across the spatial map will be interpolated (using linear, bilinear, or trilinear interpolation as appropriate) to produce spatially continuous variation in values.<span class="Apple-converted-space">  </span>In either case, the corners of the value grid are exactly aligned with the corners of the spatial boundaries of the subpopulation as specified by <span class="s1">setSpatialBounds()</span>, and the value grid is then stretched across the spatial extent of the subpopulation in such a manner as to produce equal spacing between the values along each dimension.<span class="Apple-converted-space">  </span>The setting of <span class="s1">interpolation</span> only affects how values between these grid points are calculated: by nearest-neighbor, or by linear interpolation.<span class="Apple-converted-space">  </span>Interpolation of spatial maps with periodic boundaries is not handled specially; to ensure that the edges of a periodic spatial map join smoothly, simply ensure that the grid values at the edges of the map are identical, since they will be coincident after periodic wrapping.<span class="Apple-converted-space">  </span>Note that cubic/bicubic interpolation is generally smoother than linear/bilinear interpolation, with fewer artifacts, but it is substantially slower to calculate; use the <span class="s1">interpolate()</span> method of <span class="s1">SpatialMap</span> to precalculate an interpolated map using cubic/bucubic interpolation.</p>
<p class="p6">The <span class="s1">valueRange</span> and <span class="s1">colors</span> parameters travel together; either both are unspecified, or both are specified.<span class="Apple-converted-space">  </span>They control how map values will be transformed into colors, by SLiMgui and by the <span class="s1">mapColor()</span> method.<span class="Apple-converted-space">  </span>The <span class="s1">valueRange</span> parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.<span class="Apple-converted-space">  </span>The <span class="s1">colors</span> parameter then establishes the corresponding colors for values within the interval defined by <span class="s1">valueRange</span>: values less than or equal to <span class="s1">valueRange[0]</span> will map to <span class="s1">colors[0]</span>, values greater than or equal to <span class="s1">valueRange[1]</span> will map to the last <span class="s1">colors</span> value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.<span class="Apple-converted-space">  </span>This is much simpler than it sounds in this description; see the recipes for an illustration of its use.</p>
<p class="p6">Note that at present, SLiMgui will only display spatial maps of spatiality <span class="s1">"x"</span>, <span class="s1">"y"</span>, or <span class="s1">"xy"</span>; the color-mapping parameters will simply be ignored by SLiMgui for other spatiality values (even if the spatiality is a superset of these values; SLiMgui will not attempt to display an <span class="s1">"xyz"</span> spatial map, for example, since it has no way to choose which 2D slice through the <i>xyz</i> space it ought to display).<span class="Apple-converted-space">  </span>The <span class="s1">mapColor()</span> method will return translated color strings for any spatial map, however, even if SLiMgui is unable to display the spatial map.<span class="Apple-converted-space">  </span>If there are multiple spatial maps that SLiMgui is capable of displaying, it choose one for display by default, but other maps may be selected from the action menu on the individuals view (by clicking on the button with the gear icon).</p>
<p class="p5">– (object&lt;Individual&gt;)deviatePositions(No&lt;Individual&gt; individuals, string$ boundary, numeric$ maxDistance, string$ functionType, ...)</p>
<p class="p6">Deviates the spatial positions of the individuals supplied in <span class="s1">individuals</span>, using the provided boundary condition and dispersal kernel.<span class="Apple-converted-space">  </span>If <span class="s1">individuals</span> is <span class="s1">NULL</span>, the positions of all individuals in the target subpopulation are deviated.<span class="Apple-converted-space">  </span>This method is essentially a more efficient shorthand for getting the spatial positions of <span class="s1">individuals</span> from the <span class="s1">spatialPosition</span> property, deviating those positions with <span class="s1">pointDeviated()</span>, and setting the deviated positions back into <span class="s1">individuals</span> with the <span class="s1">setSpatialPosition()</span> method.</p>
<p class="p6">The boundary condition <span class="s1">boundary</span> must be one of <span class="s1">"none"</span>, <span class="s1">"periodic"</span>, <span class="s1">"reflecting"</span>, <span class="s1">"stopping"</span>, <span class="s1">"reprising"</span>, or <span class="s1">"absorbing"</span>, and the spatial kernel type <span class="s1">functionType</span> must be one of <span class="s1">"f"</span>, <span class="s1">"l"</span>, <span class="s1">"e"</span>, <span class="s1">"n"</span>, or <span class="s1">"t"</span>, with the ellipsis parameters <span class="s1">...</span> supplying kernel configuration parameters appropriate for that kernel type; see <span class="s1">pointDeviated()</span> for further details.<span class="Apple-converted-space">  </span>As with <span class="s1">pointDeviated()</span>, the ellipsis parameters that follow <span class="s1">functionType</span> may each, independently, be either a singleton or a vector of length equal to <span class="s1">n</span>.<span class="Apple-converted-space">  </span>This allows each individual’s position to be deviated with a different kernel, representing, for example, the movements of individuals with differing dispersal capabilities/propensities.<span class="Apple-converted-space">  </span>(However, other parameters such as <span class="s1">boundary</span>, <span class="s1">maxDistance</span>, and <span class="s1">functionType</span> must be the same for all of the points, in the present design.)</p>
<p class="p6">The returned vector contains individuals that did not survive the dispersal process.<span class="Apple-converted-space">  </span>For <span class="s1">"absorbing"</span> boundaries, this will contain the individuals that attempted to disperse beyond the spatial bounds, and in most cases the caller will then kill those individuals – probably by passing them to <span class="s1">killIndividuals()</span>, but perhaps by setting their <span class="s1">fitnessScaling</span> to zero.<span class="Apple-converted-space">  </span>(The positions of the individuals in the returned vector will be the out-of-bounds positions that were drawn for them; rather than killing those individuals, the caller could conceivably handle them in some other way.)<span class="Apple-converted-space">  </span>For all other boundary conditions, the returned vector of individuals will be empty and may be ignored by the caller.</p>
<p class="p5">– (object&lt;Individual&gt;)deviatePositionsWithMap(No&lt;Individual&gt; individuals, string$ boundary, so&lt;SpatialMap&gt;$ map, numeric$ maxDistance, string$ functionType, ...)</p>
<p class="p6">Deviates the spatial positions of the individuals supplied in <span class="s1">individuals</span>, using the provided boundary condition and dispersal kernel.<span class="Apple-converted-space">  </span>The supplied <span class="s1">SpatialMap</span> object (or a <span class="s1">string</span> specifying a map by name), <span class="s1">map</span>, is used (in addition to the spatial bounds of the subpopulation) to define which positions are considered to be “out of bounds”, as described below.<span class="Apple-converted-space">  </span>If <span class="s1">individuals</span> is <span class="s1">NULL</span>, the positions of all individuals in the target subpopulation are deviated.<span class="Apple-converted-space">  </span>This method is essentially an extension of the <span class="s1">deviatePositions()</span> method, adding bounds-checking using <span class="s1">map</span>; however, there are some differences as described below.</p>
<p class="p6">The boundary condition <span class="s1">boundary</span> must be either <span class="s1">"reprising"</span> or <span class="s1">"absorbing"</span>.<span class="Apple-converted-space">  </span>In the simple case where map values are either <span class="s1">0</span> (bad habitat) or <span class="s1">1</span> (good habitat), <span class="s1">"reprising"</span> means a new location is drawn conditional on falling within the good habitat; <span class="s1">"absorbing"</span> means individuals falling outside the good habitat are “absorbed” (killed, probably).<span class="Apple-converted-space">  </span>The details are discussed below, when <span class="s1">map</span> is discussed.<span class="Apple-converted-space">  </span>Note that the boundary condition <span class="s1">"none"</span> is not supported because points must be within the boundaries of the spatial map to be checked.<span class="Apple-converted-space">  </span>Reflecting and stopping boundaries are not supported because, with the spatial map, if a drawn point is considered out-of-bounds it is not clear where the “edge” is, and therefore reflecting off of the edge, or stopping at the edge, are not well-defined.<span class="Apple-converted-space">  </span>Finally, <span class="s1">"periodic"</span> is not supported because it does not specify any action to be taken when a drawn point is considered to be “out of bounds” according to the spatial map; instead, this method automatically applies any periodic boundaries that have been defined and then, using the resulting point, checks the subpopulation’s spatial bounds and the spatial map, and applies reprising or absorbing boundaries as requested if the point is “out of bounds”.</p>
<p class="p6">The spatial map defined by <span class="s1">map</span> must be configured in a specific way.<span class="Apple-converted-space">  </span>First of all, it must be defined in, or added to, the target subpopulation (and thus, by implication, it must match the spatial bounds of the subpopulation.<span class="Apple-converted-space">  </span>Second, its spatiality must be equal to the dimensionality of the species; in an <span class="s1">"xy"</span> species, for example, the map must also be <span class="s1">"xy"</span>.<span class="Apple-converted-space">  </span>Third, the values in the spatial map must represent “habitability”, in the following sense.<span class="Apple-converted-space">  </span>The value of <span class="s1">map</span> at a given drawn point is obtained, symbolized here by <span class="s1">x</span>.<span class="Apple-converted-space">  </span>Next, <span class="s1">x</span> is clamped to the range [<span class="s1">0</span>, <span class="s1">1</span>]; values less than <span class="s1">0</span> become <span class="s1">0</span>, values greater than <span class="s1">1</span> become <span class="s1">1</span>.<span class="Apple-converted-space">  </span>The resulting <span class="s1">x</span> value is then interpreted as the probability that the point is considered “within bounds” (as far as the spatial map is concerned; points that are outside the subpopulation’s spatial bounds are <i>always</i> considered “out of bounds”).<span class="Apple-converted-space">  </span>If <span class="s1">boundary</span> is <span class="s1">"reprising"</span>, <span class="s1">1-x</span> is thus the probability that the point will be redrawn; if boundary is <span class="s1">"absorbing"</span>, <span class="s1">1-x</span> is thus the probability that the individual will be considered “absorbed”, as discussed below.<span class="Apple-converted-space">  </span>In this manner, the concept of “out of bounds” is treated as a probability by this method, rather than a binary state.</p>
<p class="p6">The spatial kernel type <span class="s1">functionType</span> must be one of <span class="s1">"f"</span>, <span class="s1">"l"</span>, <span class="s1">"e"</span>, <span class="s1">"n"</span>, or <span class="s1">"t"</span>, with the ellipsis parameters <span class="s1">...</span> supplying kernel configuration parameters appropriate for that kernel type; see <span class="s1">pointDeviated()</span> for further details.<span class="Apple-converted-space">  </span>As with <span class="s1">pointDeviated()</span>, the ellipsis parameters that follow <span class="s1">functionType</span> may each, independently, be either a singleton or a vector of length equal to <span class="s1">n</span>.<span class="Apple-converted-space">  </span>This allows each individual’s position to be deviated with a different kernel, representing, for example, the movements of individuals with differing dispersal capabilities/propensities.<span class="Apple-converted-space">  </span>(However, other parameters such as <span class="s1">boundary</span>, <span class="s1">maxDistance</span>, and <span class="s1">functionType</span> must be the same for all of the points, in the present design.)</p>
<p class="p6">The returned vector contains individuals that did not survive the dispersal process.<span class="Apple-converted-space">  </span>For <span class="s1">"absorbing"</span> boundaries, this will contain the individuals that attempted to disperse to a point considered “out of bounds” as described above, and in most cases the caller will then kill those individuals – probably by passing them to <span class="s1">killIndividuals()</span>, but perhaps by setting their <span class="s1">fitnessScaling</span> to zero.<span class="Apple-converted-space">  </span>(The positions of the individuals in the returned vector will be the out-of-bounds positions that were drawn for them; rather than killing those individuals, the caller could conceivably handle them in some other way.)<span class="Apple-converted-space">  </span>For all other boundary conditions, the returned vector of individuals will be empty and may be ignored by the caller.</p>
<p class="p6">See also the <span class="s1">SpatialMap</span> methods <span class="s1">sampleNearbyPoint()</span> and <span class="s1">sampleImprovedNearbyPoint()</span>, which are in some ways conceptually similar to this method.</p>
<p class="p5">– (object&lt;Haplosome&gt;)haplosomesForChromosomes([Niso&lt;Chromosome&gt; chromosomes = NULL], [Ni$ index = NULL], [logical$ includeNulls = T])</p>
<p class="p6">Returns a vector containing the subpopulation’s haplosomes that correspond to the chromosomes passed in <span class="s1">chromosomes</span> (following the order of the <span class="s1">chromosomes</span> property of <span class="s1">Individual</span>).<span class="Apple-converted-space">  </span>Chromosomes can be specified by id (<span class="s1">integer</span>), by symbol (<span class="s1">string</span>) or by the <span class="s1">Chromosome</span> objects themselves; if <span class="s1">NULL</span> is passed (the default), all chromosomes defined for the species are used, in the order in which they were defined.</p>
<p class="p6">This method is equivalent to calling <span class="s1">haplosomesForChromosomes(chromosomes, index, includeNulls)</span> on <span class="s1">subpop.individuals</span>, where <span class="s1">subpop</span> is the target subpopulation.<span class="Apple-converted-space">  </span>It therefore appends together the specified haplosomes from each individual in the subpopulation to form a single vector.<span class="Apple-converted-space">  </span>See the documentation for the <span class="s1">Individual</span> method <span class="s1">haplosomesForChromosomes()</span> for further details, such as on the meaning of the <span class="s1">index</span> and <span class="s1">includeNulls</span> parameters.</p>
<p class="p5">– (void)outputMSSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = "*"], [Ns$ filePath = NULL], [logical$ append = F], [logical$ filterMonomorphic = F], [Niso&lt;Chromosome&gt;$ chromosome = NULL])</p>
<p class="p6">Output a random sample from the subpopulation in MS format.<span class="Apple-converted-space">  </span>Positions in the output will span the interval [0,1].<span class="Apple-converted-space">  </span>A sample of non-null haplosomes (not entire individuals, note) of size <span class="s1">sampleSize</span> from the subpopulation will be output.<span class="Apple-converted-space">  </span>The sample may be done either with or without replacement, as specified by <span class="s1">replace</span>; the default is to sample with replacement.<span class="Apple-converted-space">  </span>A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">requestedSex</span>; passing <span class="s1">"*"</span>, the default, indicates that haplosomes from individuals should be selected randomly, without respect to sex.<span class="Apple-converted-space">  </span>If the sampling options provided by this method are not adequate, see the <span class="s1">outputHaplosomesToMS()</span> method of <span class="s1">Haplosome</span> for a more flexible low-level option.</p>
<p class="p6">If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.</p>
<p class="p6">If <span class="s1">filterMonomorphic</span> is <span class="s1">F</span> (the default), all mutations that are present in the sample will be included in the output.<span class="Apple-converted-space">  </span>This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in <i>every</i> sampled haplosome, and are thus apparently fixed).<span class="Apple-converted-space">  </span>These may be filtered out with <span class="s1">filterMonomorphic = T</span> if desired; note that this option means that some mutations that do exist in the sampled haplosomes might not be included in the output, simply because they exist in every sampled haplosome.</p>
<p class="p6">The <span class="s1">chromosome</span> parameter identifies the chromosome for which the sample of haplosomes should be taken.<span class="Apple-converted-space">  </span>The default of <span class="s1">NULL</span> may be used only in single-chromosome models where the choice of chromosome is unambiguous.<span class="Apple-converted-space">  </span>In multi-chromosome models, chromosome must be non-<span class="s1">NULL</span>; it must specify the chromosome by id (<span class="s1">integer</span>), by symbol (<span class="s1">string</span>) or by the <span class="s1">Chromosome</span> object itself.</p>
<p class="p6">See <span class="s1">outputSample()</span> and <span class="s1">outputVCFSample()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p5">– (void)outputSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = "*"], [Ns$ filePath = NULL], [logical$ append = F], [Niso&lt;Chromosome&gt;$ chromosome = NULL])</p>
<p class="p6">Output a random sample from the subpopulation in SLiM’s native format.<span class="Apple-converted-space">  </span>A sample of non-null haplosomes (not entire individuals, note) of size <span class="s1">sampleSize</span> from the subpopulation will be output.<span class="Apple-converted-space">  </span>The sample may be done either with or without replacement, as specified by <span class="s1">replace</span>; the default is to sample with replacement.<span class="Apple-converted-space">  </span>A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">requestedSex</span>; passing <span class="s1">"*"</span>, the default, indicates that haplosomes from individuals should be selected randomly, without respect to sex.<span class="Apple-converted-space">  </span>If the sampling options provided by this method are not adequate, see the <span class="s1">outputHaplosomes()</span> method of <span class="s1">Haplosome</span> for a more flexible low-level option.</p>
<p class="p6">If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.</p>
<p class="p6">The <span class="s1">chromosome</span> parameter identifies the chromosome for which the sample of haplosomes should be taken.<span class="Apple-converted-space">  </span>The default of <span class="s1">NULL</span> may be used only in single-chromosome models where the choice of chromosome is unambiguous.<span class="Apple-converted-space">  </span>In multi-chromosome models, chromosome must be non-<span class="s1">NULL</span>; it must specify the chromosome by id (<span class="s1">integer</span>), by symbol (<span class="s1">string</span>) or by the <span class="s1">Chromosome</span> object itself.</p>
<p class="p6">See <span class="s1">outputMSSample()</span> and <span class="s1">outputVCFSample()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p5">– (void)outputVCFSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = "*"], [logical$ outputMultiallelics = T], [Ns$ filePath = NULL], [logical$ append = F], [logical$ simplifyNucleotides = F], [logical$ outputNonnucleotides = T], [logical$ groupAsIndividuals = T], [Niso&lt;Chromosome&gt;$ chromosome = NULL])</p>
<p class="p6">Output a random sample from the subpopulation in VCF format.<span class="Apple-converted-space">  </span>A sample of individuals (not haplosomes, note – unlike the <span class="s1">outputSample()</span> and <span class="s1">outputMSSample()</span> methods) of size <span class="s1">sampleSize</span> from the subpopulation will be output.<span class="Apple-converted-space">  </span>The sample may be done either with or without replacement, as specified by <span class="s1">replace</span>; the default is to sample with replacement.<span class="Apple-converted-space">  </span>A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">requestedSex</span>; passing <span class="s1">"*"</span>, the default, indicates that individuals should be selected randomly, without respect to sex.<span class="Apple-converted-space">  </span>If the sampling options provided by this method are not adequate, see the <span class="s1">outputHaplosomesToVCF()</span> method of <span class="s1">Haplosome</span> for a more flexible low-level option.</p>
<p class="p6">If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span>.</p>
<p class="p10"><span class="s11">The parameters </span>outputMultiallelics<span class="s11">, </span>simplifyNucleotides<span class="s11">, </span>outputNonnucleotides<span class="s11">, and </span>groupAsIndividuals<span class="s11"> affect the format of the output produced.</span></p>
<p class="p6">The <span class="s1">chromosome</span> parameter identifies the chromosome for which haplosomes of the sampled individuals should be output.<span class="Apple-converted-space">  </span>The default of <span class="s1">NULL</span> may be used only in single-chromosome models where the choice of chromosome is unambiguous.<span class="Apple-converted-space">  </span>In multi-chromosome models, chromosome must be non-<span class="s1">NULL</span>; it must specify the chromosome by id (<span class="s1">integer</span>), by symbol (<span class="s1">string</span>) or by the <span class="s1">Chromosome</span> object itself.<span class="Apple-converted-space">  </span>The <span class="s1">symbol</span> property of the chromosome will be output in the <span class="s1">CHROM</span> field of call lines in the VCF output.</p>
<p class="p6">See <span class="s1">outputMSSample()</span> and <span class="s1">outputSample()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a tick.</p>
<p class="p5">– (float)pointDeviated(integer$ n, float point, string$ boundary, numeric$ maxDistance, string$ functionType, ...)</p>
<p class="p6">Returns a vector containing <span class="s1">n</span> points that are derived from <span class="s1">point</span> by adding a deviation drawn from a dispersal kernel (specified by <span class="s1">maxDistance</span>, <span class="s1">functionType</span>, and the ellipsis parameters <span class="s1">...</span>, as detailed below) and then applying a boundary condition specified by <span class="s1">boundary</span>.<span class="Apple-converted-space">  </span>This method therefore performs the steps of a simple dispersal algorithm in a single vectorized call.<span class="Apple-converted-space">  </span>See <span class="s1">deviatePositions()</span> for an even more efficient approach.</p>
<p class="p6">The parameter <span class="s1">point</span> may contain a single point which is deviated and bounded <span class="s1">n</span> independent times, or may contain <span class="s1">n</span> points each of which is deviated and bounded.<span class="Apple-converted-space">  </span>In any case, each point in <span class="s1">point</span> should match the dimensionality of the model – one element in a 1D model, two elements in a 2D model, or three elements in a 3D model.<span class="Apple-converted-space">  </span>This method should not be called in a non-spatial model.</p>
<p class="p6">The dispersal kernel is specified similarly to other kernel-based methods, such as <span class="s1">setInteractionFunction()</span> and <span class="s1">smooth()</span>.<span class="Apple-converted-space">  </span>For <span class="s1">pointDeviated()</span>, <span class="s1">functionType</span> may be <span class="s1">"f"</span> with no ellipsis arguments <span class="s1">...</span> to use a flat kernel out to <span class="s1">maxDistance</span>; <span class="s1">"l"</span> with no ellipsis arguments for a kernel that decreases linearly from the center to zero at <span class="s1">maxDistance</span>; <span class="s1">"e"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> lambda (rate) parameter for a negative exponential function; <span class="s1">"n"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> sigma (standard deviation) parameter for a Gaussian function; or <span class="s1">"t"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> degrees of freedom and a <span class="s1">numeric$</span> scale parameter for a <i>t</i>-distribution function.<span class="Apple-converted-space">  </span>The Cauchy (<span class="s1">"c"</span>) kernel is not supported by <span class="s1">pointDeviated()</span> since it is not well-behaved for this purpose, and the Student’s <i>t</i> (<span class="s1">"t"</span>) kernel is not allowed in 3D models at present simply because it hasn’t been implemented.<span class="Apple-converted-space">  </span>See the <span class="s1">InteractionType</span> class documentation for more detailed discussion of the available kernel types and their parameters and probability distribution functions.<span class="Apple-converted-space">  </span>For <span class="s1">pointDeviated()</span>, the ellipsis parameters that follow <span class="s1">functionType</span> may each, independently, be either a singleton or a vector of length equal to <span class="s1">n</span>.<span class="Apple-converted-space">  </span>This allows each point to be deviated with a different kernel, representing, for example, the movements of individuals with differing dispersal capabilities/propensities.<span class="Apple-converted-space">  </span>(However, other parameters such as <span class="s1">boundary</span>, <span class="s1">maxDistance</span>, and <span class="s1">functionType</span> must be the same for all of the points, in the present design.)</p>
<p class="p6">The random points returned from this method are drawn from the probability distribution that is radially symmetric and has density proportional to the kernel – in other words, at distance <i>r</i> the density is proportional to the kernel type referred to by <span class="s1">functionType</span>.<span class="Apple-converted-space">  </span>(Said another way, the shape of the <i>cross-section</i> through the probability density function is given by the kernel.)<span class="Apple-converted-space">  </span>For instance, the value of the type <span class="s1">"e"</span> (exponential) kernel with rate <i>a</i> at <i>r</i> is proportional to exp(−<i>ar</i>), and so in 2D, the probability density that this method with kernel type <span class="s1">"e"</span> draws from has density proportional to p(<i>x</i>, <i>y</i>) = exp(−<i>a</i> sqrt(<i>x</i><span class="s18"><sup>2</sup></span> + <i>y</i><span class="s18"><sup>2</sup></span>)), since <i>r</i> = sqrt(x<span class="s18"><sup>2</sup></span> + y<span class="s18"><sup>2</sup></span>) is the distance.<span class="Apple-converted-space">  </span>Note that the <i>distribution of the distance</i> is not given by the kernel except in 1D: in the type <span class="s1">"e"</span> example, the distribution of the distance in 1D is exponential, while in 2D it has density proportional to <i>r</i> exp(−<i>ar</i>) (i.e., Gamma with shape parameter 1).<span class="Apple-converted-space">  </span>For another example, the value of the type <span class="s1">"n"</span> (Normal) kernel at <i>r</i> with standard deviation 1 is proportional to exp(−<i>r</i><span class="s18"><sup>2</sup></span> / 2), and so the density is proportional to p(<i>x</i>, <i>y</i>) = exp(−(<i>x</i><span class="s18"><sup>2</sup></span> + <i>y</i><span class="s18"><sup>2</sup></span>) / 2).<span class="Apple-converted-space">  </span>This is the standard bivariate Normal, and equivalent to drawing independent Normals for the <i>x</i> and <i>y</i> directions; however, the Normal is the <i>only</i> distribution for which independent draws along each axis will result in a radially symmetric distribution.<span class="Apple-converted-space">  </span>The distribution of the distance in 2D with type <span class="s1">"n"</span> is proportional to <i>r</i> exp(−<i>r</i><span class="s18"><sup>2</sup></span> / 2), i.e., Rayleigh.</p>
<p class="p6">The boundary condition must be one of <span class="s1">"none"</span>, <span class="s1">"periodic"</span>, <span class="s1">"reflecting"</span>, <span class="s1">"stopping"</span>, or <span class="s1">"reprising"</span>.<span class="Apple-converted-space">  </span>For <span class="s1">"none"</span>, no boundary condition is enforced; the deviated points are simply returned as is.<span class="Apple-converted-space">  </span>For <span class="s1">"periodic"</span>, <span class="s1">"reflecting"</span>, and <span class="s1">"stopping"</span>, the boundary condition is enforced just as it is by the <span class="s1">pointPeriodic()</span>, <span class="s1">pointReflected()</span>, and <span class="s1">pointStopped()</span> methods; see their documentation for further details.<span class="Apple-converted-space">  </span>For <span class="s1">"reprising"</span>, if the deviated point is out of bounds a new deviated point will be chosen, based upon the same original point, until a point inside bounds is obtained.<span class="Apple-converted-space">  </span>Note that absorbing boundaries (for which being out-of-bounds is lethal) would need to be implemented in script; this method cannot enforce them.<span class="Apple-converted-space">  </span>(Note, however, that the <span class="s1">deviatePositions()</span> method of <span class="s1">Subpopulation</span> can enforce absorbing boundaries.)</p>
<p class="p6">Note that for the typical usage case, in which <span class="s1">point</span> comes from the <span class="s1">spatialPosition</span> property for a vector of individuals, and the result is then set back onto the same vector of individuals using the <span class="s1">setSpatialPosition()</span> method, the <span class="s1">deviatePositions()</span> method provides an even more efficient alternative.</p>
<p class="p3">– (logical)pointInBounds(float point)</p>
<p class="p6"><span class="s3">Returns </span><span class="s4">T</span><span class="s3"> if </span><span class="s4">point</span><span class="s3"> is inside the spatial boundaries of the subpopulation, </span><span class="s4">F</span><span class="s3"> otherwise.<span class="Apple-converted-space">  </span>For example, for a simulation with </span><span class="s4">"xy"</span><span class="s3"> dimensionality, if </span><span class="s4">point</span><span class="s3"> contains exactly two values constituting an (<i>x</i>,<i>y</i>) point, the result will be </span><span class="s4">T</span><span class="s3"> if and only if </span><span class="s4">((point[0]&gt;=x0) &amp; (point[0]&lt;=x1) &amp; (point[1]&gt;=y0) &amp; (point[1]&lt;=y1))</span><span class="s3"> given spatial bounds </span><span class="s4">(x0, y0, x1, y1)</span><span class="s3">.<span class="Apple-converted-space">  </span>This method is useful for implementing absorbing or reprising boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, a </span><span class="s4">logical</span><span class="s3"> vector will be returned in which each element is </span><span class="s4">T</span><span class="s3"> if the corresponding point in </span><span class="s4">point</span><span class="s3"> is inside the spatial boundaries of the subpopulation, </span><span class="s4">F</span><span class="s3"> otherwise.</span></p>
<p class="p5"><span class="s3">– (float)pointPeriodic(float point)</span></p>
<p class="p6"><span class="s3">Returns a revised version of </span><span class="s4">point</span><span class="s3"> that has been brought inside the periodic spatial boundaries of the subpopulation (as specified by the </span><span class="s4">periodicity</span><span class="s3"> parameter of </span><span class="s4">initializeSLiMOptions()</span><span class="s3">) by wrapping around periodic spatial boundaries.<span class="Apple-converted-space">  </span>In brief, if a coordinate of </span><span class="s4">point</span><span class="s3"> lies beyond a periodic spatial boundary, that coordinate is wrapped around the boundary, so that it lies inside the spatial extent by the same magnitude that it previously lay outside, but on the opposite side of the space; in effect, the two edges of the periodic spatial boundary are seamlessly joined.<span class="Apple-converted-space">  </span>This is done iteratively until all coordinates lie inside the subpopulation’s periodic boundaries.<span class="Apple-converted-space">  </span>Note that non-periodic spatial boundaries are not enforced by this method; they should be enforced using </span><span class="s4">pointReflected()</span><span class="s3">, </span><span class="s4">pointStopped()</span><span class="s3">, or some other means of enforcing boundary constraints (which can be used after </span><span class="s4">pointPeriodic()</span><span class="s3"> to bring the remaining coordinates into bounds; coordinates already brought into bounds by </span><span class="s4">pointPeriodic()</span><span class="s3"> will be unaffected by those calls).<span class="Apple-converted-space">  </span>This method is useful for implementing periodic boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space<span class="Apple-converted-space">  </span>and at least one periodic spatial dimension have been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.</span></p>
<p class="p5"><span class="s3">– (float)pointReflected(float point)</span></p>
<p class="p6"><span class="s3">Returns a revised version of </span><span class="s4">point</span><span class="s3"> that has been brought inside the spatial boundaries of the subpopulation by reflection.<span class="Apple-converted-space">  </span>In brief, if a coordinate of </span><span class="s4">point</span><span class="s3"> lies beyond a spatial boundary, that coordinate is reflected across the boundary, so that it lies inside the boundary by the same magnitude that it previously lay outside the boundary.<span class="Apple-converted-space">  </span>This is done iteratively until all coordinates lie inside the subpopulation’s boundaries.<span class="Apple-converted-space">  </span>This method is useful for implementing reflecting boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.</span></p>
<p class="p5"><span class="s3">– (float)pointStopped(float point)</span></p>
<p class="p6"><span class="s3">Returns a revised version of </span><span class="s4">point</span><span class="s3"> that has been brought inside the spatial boundaries of the subpopulation by clamping.<span class="Apple-converted-space">  </span>In brief, if a coordinate of </span><span class="s4">point</span><span class="s3"> lies beyond a spatial boundary, that coordinate is set to exactly the position of the boundary, so that it lies on the edge of the spatial boundary.<span class="Apple-converted-space">  </span>This method is useful for implementing stopping boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.</span></p>
<p class="p5"><span class="s3">– (float)pointUniform([integer$ n = 1])</span></p>
<p class="p6"><span class="s3">Returns a new point (or points, for </span><span class="s4">n</span><span class="s3"> &gt; 1) generated from uniform draws for each coordinate, within the spatial boundaries of the subpopulation.<span class="Apple-converted-space">  </span>The returned vector will contain </span><span class="s4">n</span><span class="s3"> points, each comprised of a number of coordinates equal to the dimensionality of the simulation, so it will be of total length </span><span class="s4">n</span><span class="s3">*dimensionality.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>See <span class="s1">pointUniformWithMap()</span> for an extension to this method which uses a spatial map to govern the probability of a particular point being chosen.</p>
<p class="p5">– (float)pointUniformWithMap(integer$ n, so&lt;SpatialMap&gt;$ map)</p>
<p class="p6">Returns a new point (or points, for <span class="s1">n</span> &gt; 1) generated from uniform draws for each coordinate, within the spatial boundaries of the subpopulation, and rejection sampled using the spatial map <span class="s1">map</span> as described below.<span class="Apple-converted-space">  </span>The returned vector will contain <span class="s1">n</span> points, each comprised of a number of coordinates equal to the dimensionality of the simulation, so it will be of total length <span class="s1">n</span>*dimensionality.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with <span class="s1">initializeSLiMOptions()</span>.</p>
<p class="p6">The spatial map defined by <span class="s1">map</span> must be configured in a specific way.<span class="Apple-converted-space">  </span>First of all, it must be defined in, or added to, the target subpopulation (and thus, by implication, it must match the spatial bounds of the subpopulation, and its spatiality must be compatible with the subpopulation’s dimensionality, as discussed in <span class="s1">defineSpatialMap()</span> and/or <span class="s1">addSpatialMap()</span>).<span class="Apple-converted-space">  </span>Second, the values in the spatial map must represent “habitability”, in the following sense.<span class="Apple-converted-space">  </span>The value of <span class="s1">map</span> at a given drawn point is obtained, symbolized here by <span class="s1">x</span>.<span class="Apple-converted-space">  </span>Next, <span class="s1">x</span> is clamped to the range [<span class="s1">0</span>, <span class="s1">1</span>]; values less than <span class="s1">0</span> become <span class="s1">0</span>, values greater than <span class="s1">1</span> become <span class="s1">1</span>.<span class="Apple-converted-space">  </span>The resulting <span class="s1">x</span> value is then interpreted as the probability that the point is considered “within bounds” (as far as the spatial map is concerned; points that are outside the subpopulation’s spatial bounds are <i>always</i> considered “out of bounds”).<span class="Apple-converted-space">  </span>Given this, <span class="s1">1-x</span> is thus the probability that the point will be redrawn because it fell out of bounds.<span class="Apple-converted-space">  </span>Each point will be redrawn repeatedly until a point considered “within bounds” is obtained.</p>
<p class="p5">– (void)removeSpatialMap(so&lt;SpatialMap&gt;$ map)</p>
<p class="p6">Removes the <span class="s1">SpatialMap</span> object specified by <span class="s1">map</span> from the subpopulation.<span class="Apple-converted-space">  </span>The parameter <span class="s1">map</span> may be either a <span class="s1">SpatialMap</span> object, or a <span class="s1">string</span> name for spatial map.<span class="Apple-converted-space">  </span>The map must have been added to the subpopulation with <span class="s1">addSpatialMap()</span>; if it has not been, an error results.<span class="Apple-converted-space">  </span>Removing spatial maps that are no longer in use is optional in most cases.<span class="Apple-converted-space">  </span>It is generally a good idea because it might decrease SLiM’s memory footprint; also, it avoids an error if the subpopulation’s spatial bounds are changed (see <span class="s1">setSpatialBounds()</span>).</p>
<p class="p3">– (void)removeSubpopulation(void)</p>
<p class="p6"><span class="s3">Removes this subpopulation from the model.<span class="Apple-converted-space">  </span>The subpopulation is immediately removed from the list of active subpopulations, and the symbol representing the subpopulation is undefined.<span class="Apple-converted-space">  </span>The subpopulation object itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models, in which there is a distinction between a subpopulation being empty and a subpopulation being removed from the simulation; an empty subpopulation may be re-colonized by migrants, whereas as a removed subpopulation no longer exists at all.<span class="Apple-converted-space">  </span>WF models do not make this distinction; when a subpopulation is empty it is automatically removed.<span class="Apple-converted-space">  </span>WF models should therefore call </span><span class="s4">setSubpopulationSize(0)</span><span class="s3"> instead of this method; </span><span class="s4">setSubpopulationSize()</span><span class="s3"> is the standard way for WF models to change the subpopulation size, including to a size of </span><span class="s4">0</span><span class="s3">.</span></p>
<p class="p5"><span class="s5">– </span><span class="s3">(object&lt;Individual&gt;)sampleIndividuals(integer$ size, [logical$ replace = F], [No&lt;Individual&gt;$ exclude = NULL], [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL]</span>, [Nl$ tagL0 = NULL], [Nl$ tagL1 = NULL], [Nl$ tagL2 = NULL], [Nl$ tagL3 = NULL], [Nl$ tagL4 = NULL]<span class="s3">)</span></p>
<p class="p6">Returns a vector of individuals, of size less than or equal to parameter <span class="s1">size</span>, sampled from the individuals in the target subpopulation.<span class="Apple-converted-space">  </span>Sampling is done without replacement if <span class="s1">replace</span> is <span class="s1">F</span> (the default), or with replacement if <span class="s1">replace</span> is <span class="s1">T</span>.<span class="Apple-converted-space">  </span>The remaining parameters specify constraints upon the pool of individuals that will be considered candidates for the sampling.<span class="Apple-converted-space">  </span>Parameter <span class="s1">exclude</span>, if non-<span class="s1">NULL</span>, may specify a specific individual that should not be considered a candidate (typically the focal individual in some operation).<span class="Apple-converted-space">  </span>Parameter <span class="s1">sex</span>, if non-<span class="s1">NULL</span>, may specify a sex (<span class="s1">"M"</span> or <span class="s1">"F"</span>) for the individuals to be drawn, in sexual models.<span class="Apple-converted-space">  </span>Parameter <span class="s1">tag</span>, if non-<span class="s1">NULL</span>, may specify a <span class="s1">tag</span> property value for the individuals to be drawn.<span class="Apple-converted-space">  </span>Parameters <span class="s1">minAge</span> and <span class="s1">maxAge</span>, if non-<span class="s1">NULL</span>, may specify a minimum or maximum age for the individuals to be drawn, in nonWF models.<span class="Apple-converted-space">  </span>Parameter <span class="s1">migrant</span>, if non-<span class="s1">NULL</span>, may specify a required value for the <span class="s1">migrant</span> property of the individuals to be drawn (so <span class="s1">T</span> will require that individuals be migrants, <span class="s1">F</span> will require that they not be).<span class="Apple-converted-space">  </span>Finally, parameters <span class="s1">tagL0</span>, <span class="s1">tagL1</span>, <span class="s1">tagL2</span>, <span class="s1">tagL3</span>, and <span class="s1">tagL4</span>, if non-<span class="s1">NULL</span>, may specify a required value (<span class="s1">T</span> or <span class="s1">F</span>) for the corresponding properties (<span class="s1">tagL0</span>, <span class="s1">tagL1</span>, <span class="s1">tagL2</span>, <span class="s1">tagL3</span>, and <span class="s1">tagL4</span>) of the individuals to be drawn.<span class="Apple-converted-space">  </span>Note that if any <span class="s1">tag</span>/<span class="s1">tagL</span> parameter is specified as non-<span class="s1">NULL</span>, that <span class="s1">tag</span>/<span class="s1">tagL</span> property must have a defined value for every individual in the subpopulation, otherwise an error may result (although this requirement will not necessarily be checked comprehensively by this method in every invocation).<span class="Apple-converted-space">  </span>If the candidate pool is smaller than the requested sample size, all eligible candidates will be returned (in randomized order); the result will be a zero-length vector if no eligible candidates exist (unlike <span class="s1">sample()</span>).</p>
<p class="p6"><span class="s3">This method is similar to getting the </span><span class="s4">individuals</span><span class="s3"> property of the subpopulation, using operator </span><span class="s4">[]</span><span class="s3"> to select only individuals with the desired properties, and then using </span><span class="s4">sample()</span><span class="s3"> to sample from that candidate pool.<span class="Apple-converted-space">  </span>However, besides being much simpler than the equivalent Eidos code, it is also much faster, and it does not fail if less than the full sample size is available.<span class="Apple-converted-space">  </span>See </span><span class="s4">subsetIndividuals()</span><span class="s3"> for a similar method that returns a full subset, rather than a sample.</span></p>
<p class="p3">– (void)setCloningRate(numeric rate)</p>
<p class="p4">Set the cloning rate of this subpopulation.<span class="Apple-converted-space">  </span>The rate is changed to <span class="s1">rate</span>, which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>Clonal reproduction can be enabled in both non-sexual (i.e. hermaphroditic) and sexual simulations.<span class="Apple-converted-space">  </span>In non-sexual simulations, <span class="s1">rate</span> must be a singleton value representing the overall clonal reproduction rate for the subpopulation.<span class="Apple-converted-space">  </span>In sexual simulations, <span class="s1">rate</span> may be either a singleton (specifying the clonal reproduction rate for both sexes) or a vector containing two numeric values (the female and male cloning rates specified separately, at indices <span class="s1">0</span> and <span class="s1">1</span> respectively).<span class="Apple-converted-space">  </span>During mating and offspring generation, the probability that any given offspring individual will be generated by cloning – by asexual reproduction without gametes or meiosis – will be equal to the cloning rate (for its sex, in sexual simulations) set in the parental (not the offspring!) subpopulation.</p>
<p class="p3">– (void)setMigrationRates(io&lt;Subpopulation&gt; sourceSubpops, numeric rates)</p>
<p class="p4">Set the migration rates to this subpopulation from the subpopulations in <span class="s1">sourceSubpops</span> to the corresponding rates specified in <span class="s1">rates</span>; in other words, <span class="s1">rates</span> gives the expected fractions of the children in this subpopulation that will subsequently be generated from parents in the subpopulations <span class="s1">sourceSubpops</span> (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>This method will only set the migration fractions from the subpopulations given; migration rates from other subpopulations will be left unchanged (explicitly set a zero rate to turn off migration from a given subpopulation).<span class="Apple-converted-space">  </span>The type of <span class="s1">sourceSubpops</span> may be either <span class="s1">integer</span>, specifying subpopulations by identifier, or <span class="s1">object</span>, specifying subpopulations directly.</p>
<p class="p3">– (void)setSelfingRate(numeric$ rate)</p>
<p class="p4">Set the selfing rate of this subpopulation.<span class="Apple-converted-space">  </span>The rate is changed to <span class="s1">rate</span>, which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>Selfing can only be enabled in non-sexual (i.e. hermaphroditic) simulations.<span class="Apple-converted-space">  </span>During mating and offspring generation, the probability that any given offspring individual will be generated by selfing – by self-fertilization via gametes produced by meiosis by a single parent – will be equal to the selfing rate set in the parental (not the offspring!) subpopulation.</p>
<p class="p3">– (void)setSexRatio(float$ sexRatio)</p>
<p class="p4">Set the sex ratio of this subpopulation to <span class="s1">sexRatio</span>.<span class="Apple-converted-space">  </span>As defined in SLiM, this is actually the fraction of the subpopulation that is male; in other words, the M:(M+F) ratio.<span class="Apple-converted-space">  </span>This will take effect when children are next generated; it does not change the current subpopulation state.<span class="Apple-converted-space">  </span>Unlike the selfing rate, the cloning rate, and migration rates, the sex ratio is deterministic: SLiM will generate offspring that exactly satisfy the requested sex ratio (within integer roundoff limits).</p>
<p class="p3">– (void)setSpatialBounds(numeric bounds)</p>
<p class="p6"><span class="s3">Set the spatial boundaries of the subpopulation to </span><span class="s4">bounds</span><span class="s3">.<span class="Apple-converted-space">  </span>This method may be called only for simulations in which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.<span class="Apple-converted-space">  </span>The length of </span><span class="s4">bounds</span><span class="s3"> must be double the spatial dimensionality, so that it supplies both minimum and maximum values for each coordinate.<span class="Apple-converted-space">  </span>More specifically, for a dimensionality of </span><span class="s4">"x"</span><span class="s3">, </span><span class="s4">bounds</span><span class="s3"> should supply </span><span class="s4">(x0, x1)</span><span class="s3"> values; for dimensionality </span><span class="s4">"xy"</span><span class="s3"> it should supply </span><span class="s4">(x0, y0, x1, y1)</span><span class="s3"> values; and for dimensionality </span><span class="s4">"xyz"</span><span class="s3"> it should supply </span><span class="s4">(x0, y0, z0, x1, y1, z1)</span><span class="s3"> (in that order).<span class="Apple-converted-space">  </span>These boundaries will be used by SLiMgui to calibrate the display of the subpopulation, and will be used by methods such as </span><span class="s4">pointInBounds()</span><span class="s3">, </span><span class="s4">pointReflected()</span><span class="s3">, </span><span class="s4">pointStopped()</span><span class="s3">, and </span><span class="s4">pointUniform()</span><span class="s3">.<span class="Apple-converted-space">  </span>The default spatial boundaries for all subpopulations span the interval </span><span class="s4">[0,1]</span><span class="s3"> in each dimension.<span class="Apple-converted-space">  </span>Spatial dimensions that are periodic (as established with the </span><span class="s4">periodicity</span><span class="s3"> parameter to </span><span class="s4">initializeSLiMOptions()</span><span class="s3">) must have a minimum coordinate value of </span><span class="s4">0.0</span><span class="s3"> (a restriction that allows the handling of periodicity to be somewhat more efficient).<span class="Apple-converted-space">  </span>The current spatial bounds for the subpopulation may be obtained through the </span><span class="s4">spatialBounds</span><span class="s3"> property.</span></p>
<p class="p6">The spatial bounds of a subpopulation are shared with any <span class="s1">SpatialMap</span> objects added to the subpopulation.<span class="Apple-converted-space">  </span>For this reason, once a spatial map has been added to a subpopulation, the spatial bounds of the subpopulation can no longer be changed (because it would stretch or shrink the associated spatial map, which does not seem to make physical sense).<span class="Apple-converted-space">  </span>The bounds for a subpopulation should therefore be configured before any spatial maps are added to it.<span class="Apple-converted-space">  </span>If those bounds do need to change subsequently, any associated spatial maps must first be removed with <span class="s1">removeSpatialMap()</span>, to ensure model consistency.</p>
<p class="p3">– (void)setSubpopulationSize(integer$ size)</p>
<p class="p4">Set the size of this subpopulation to <span class="s1">size</span> individuals (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>This will take effect when children are next generated; it does not change the current subpopulation state.<span class="Apple-converted-space">  </span>Setting a subpopulation to a size of 0 does have some immediate effects that serve to disconnect it from the simulation: the subpopulation is removed from the list of active subpopulations, the subpopulation is removed as a source of migration for all other subpopulations, and the symbol representing the subpopulation is undefined.<span class="Apple-converted-space">  </span>In this case, the subpopulation itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.</p>
<p class="p3">–<span class="s9"> </span>(string)spatialMapColor(string$ name, numeric value)</p>
<p class="p6"><b>This method has been deprecated, and may be removed in a future release of SLiM.</b><span class="Apple-converted-space">  </span>In SLiM 4.1 and later, use the <span class="s1">SpatialMap</span> method <span class="s1">mapColor()</span> instead, and see that method’s documentation.<span class="Apple-converted-space">  </span>(This method differs only in taking a <span class="s1">name</span> parameter, which is used to look up the spatial map from those that have been added to the subpopulation.)</p>
<p class="p5">– (object&lt;Image&gt;$)spatialMapImage(string$ name, [Ni$ width = NULL], [Ni$ height = NULL], [logical$ centers = F], [logical$ color = T])</p>
<p class="p6"><b>This method has been deprecated, and may be removed in a future release of SLiM.</b><span class="Apple-converted-space">  </span>In SLiM 4.1 and later, use the <span class="s1">SpatialMap</span> method <span class="s1">mapImage()</span> instead, and see that method’s documentation.<span class="Apple-converted-space">  </span>(This method differs only in taking a <span class="s1">name</span> parameter, which is used to look up the spatial map from those that have been added to the subpopulation.)</p>
<p class="p3">–<span class="s9"> </span>(float)spatialMapValue(so&lt;SpatialMap&gt;$ map, float point)</p>
<p class="p6">Looks up the spatial map specified by <span class="s1">map</span>, and uses its mapping machinery (as defined by the <span class="s1">gridSize</span>, <span class="s1">values</span>, and <span class="s1">interpolate</span> parameters to <span class="s1">defineSpatialMap()</span>) to translate the coordinates of <span class="s1">point</span> into a corresponding map value.<span class="Apple-converted-space">  </span>The parameter <span class="s1">map</span> may specify the map either as a <span class="s1">SpatialMap</span> object, or by its <span class="s1">string</span> name; in either case, the map must have been added to the subpopulation.<span class="Apple-converted-space">  </span>The length of <span class="s1">point</span> must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality <span class="s1">"xz"</span>, <span class="s1">point</span> must be of length <span class="s1">2</span>, specifying the <i>x</i> and <i>z</i> coordinates of the point to be evaluated.<span class="Apple-converted-space">  </span>Interpolation will automatically be used if it was enabled for the spatial map.<span class="Apple-converted-space">  </span>Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use <span class="s1">pointPeriodic()</span> to wrap the point coordinates first if desired.<span class="Apple-converted-space">  </span>See the documentation for <span class="s1">defineSpatialMap()</span> for information regarding the details of value mapping.</p>
<p class="p6">Beginning in SLiM 3.3, <span class="s1">point</span> may contain more than one point to be looked up.<span class="Apple-converted-space">  </span>In this case, the length of <span class="s1">point</span> must be an exact multiple of the spatiality of the spatial map; for a spatial map with spatiality <span class="s1">"xz"</span>, for example, the length of <span class="s1">point</span> must be an exact multiple of <span class="s1">2</span>, and successive pairs of elements from point (elements <span class="s1">0</span> and <span class="s1">1</span>, then elements <span class="s1">2</span> and <span class="s1">3</span>, etc.) will be taken as the <i>x</i> and <i>z</i> coordinates of the points to be evaluated.<span class="Apple-converted-space">  </span>This allows <span class="s1">spatialMapValue()</span> to be used in a vectorized fashion.</p>
<p class="p6">The <span class="s1">mapValue()</span> method of <span class="s1">SpatialMap</span> provides the same functionality directly on the <span class="s1">SpatialMap</span> class; <span class="s1">spatialMapValue()</span> is provided on <span class="s1">Subpopulation</span> partly for backward compatibility, but also for convenience in some usage cases.</p>
<p class="p5"><span class="s5">– </span><span class="s3">(object&lt;Individual&gt;)subsetIndividuals([No&lt;Individual&gt;$ exclude = NULL], [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL]</span>, [Nl$ tagL0 = NULL], [Nl$ tagL1 = NULL], [Nl$ tagL2 = NULL], [Nl$ tagL3 = NULL], [Nl$ tagL4 = NULL]<span class="s3">)</span></p>
<p class="p6">Returns a vector of individuals subset from the individuals in the target subpopulation.<span class="Apple-converted-space">  </span>The parameters specify constraints upon the subset of individuals that will be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">exclude</span>, if non-<span class="s1">NULL</span>, may specify a specific individual that should not be included (typically the focal individual in some operation).<span class="Apple-converted-space">  </span>Parameter <span class="s1">sex</span>, if non-<span class="s1">NULL</span>, may specify a sex (<span class="s1">"M"</span> or <span class="s1">"F"</span>) for the individuals to be returned, in sexual models.<span class="Apple-converted-space">  </span>Parameter <span class="s1">tag</span>, if non-<span class="s1">NULL</span>, may specify a <span class="s1">tag</span> property value for the individuals to be returned.<span class="Apple-converted-space">  </span>Parameters <span class="s1">minAge</span> and <span class="s1">maxAge</span>, if non-<span class="s1">NULL</span>, may specify a minimum or maximum age for the individuals to be returned, in nonWF models.<span class="Apple-converted-space">  </span>Parameter <span class="s1">migrant</span>, if non-<span class="s1">NULL</span>, may specify a required value for the <span class="s1">migrant</span> property of the individuals to be returned (so <span class="s1">T</span> will require that individuals be migrants, <span class="s1">F</span> will require that they not be).<span class="Apple-converted-space">  </span>Finally, parameters <span class="s1">tagL0</span>, <span class="s1">tagL1</span>, <span class="s1">tagL2</span>, <span class="s1">tagL3</span>, and <span class="s1">tagL4</span>, if non-<span class="s1">NULL</span>, may specify a required value (<span class="s1">T</span> or <span class="s1">F</span>) for the corresponding properties (<span class="s1">tagL0</span>, <span class="s1">tagL1</span>, <span class="s1">tagL2</span>, <span class="s1">tagL3</span>, and <span class="s1">tagL4</span>) of the individuals to be returned.<span class="Apple-converted-space">  </span>Note that if any <span class="s1">tag</span>/<span class="s1">tagL</span> parameter is specified as non-<span class="s1">NULL</span>, that <span class="s1">tag</span>/<span class="s1">tagL</span> property must have a defined value for every individual in the subpopulation, otherwise an error may result (although this requirement will not necessarily be checked comprehensively by this method in every invocation).</p>
<p class="p6"><span class="s3">This method is shorthand for getting the </span><span class="s4">individuals</span><span class="s3"> property of the subpopulation, and then using operator </span><span class="s4">[]</span><span class="s3"> to select only individuals with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.<span class="Apple-converted-space">  </span>See </span><span class="s4">sampleIndividuals()</span><span class="s3"> for a similar method that returns a sample taken from a chosen subset of individuals.</span></p>
<p class="p5"><span class="s3">– (void)takeMigrants(object&lt;Individual&gt; migrants)</span></p>
<p class="p6"><span class="s3">Immediately moves the individuals in </span><span class="s4">migrants</span><span class="s3"> to the target subpopulation (removing them from their previous subpopulation).<span class="Apple-converted-space">  </span>Individuals in </span><span class="s4">migrants</span><span class="s3"> that are already in the target subpopulation are unaffected.<span class="Apple-converted-space">  </span>Note that the indices and order of individuals and haplosomes in both the target and source subpopulations will change unpredictably as a side effect of this method.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models, in which migration is managed manually by the model script.<span class="Apple-converted-space">  </span>In WF models, migration is managed automatically by the SLiM core based upon the migration rates set for each subpopulation with </span><span class="s4">setMigrationRates()</span><span class="s3">.</span></p>
<p class="p1"><b>5.18<span class="Apple-converted-space">  </span>Class Substitution</b></p>
<p class="p2"><i>5.18.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Substitution</i></span><i> properties</i></p>
<p class="p5">chromosome =&gt; (object&lt;Chromosome&gt;$)</p>
<p class="p6">The <span class="s1">Chromosome</span> object with which the mutation is associated.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this mutation.<span class="Apple-converted-space">  </span>Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run, and that identifier is carried over to the <span class="s1">Substitution</span> object when the mutation fixes.</p>
<p class="p3">fixationTick =&gt; (integer$)</p>
<p class="p4">The tick in which this mutation fixed.</p>
<p class="p3">mutationType =&gt; (object&lt;MutationType&gt;$)</p>
<p class="p4">The <span class="s1">MutationType</span> from which this mutation was drawn.</p>
<p class="p5"><span class="s3">nucleotide &lt;–&gt; (string$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">string</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">.<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p5"><span class="s3">nucleotideValue &lt;–&gt; (integer$)</span></p>
<p class="p6"><span class="s3">An </span><span class="s4">integer</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">0</span><span class="s3"> (A), </span><span class="s4">1</span><span class="s3"> (C), </span><span class="s4">2</span><span class="s3"> (G), or </span><span class="s4">3</span><span class="s3"> (T).<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p3">originTick =&gt; (integer$)</p>
<p class="p4">The tick in which this mutation arose.</p>
<p class="p3">position =&gt; (integer$)</p>
<p class="p4">The position in the chromosome of this mutation.</p>
<p class="p3">selectionCoeff =&gt; (float$)</p>
<p class="p4">The selection coefficient of the mutation, drawn from the distribution of fitness effects of its <span class="s1">MutationType</span><span class="s2">.</span></p>
<p class="p3">subpopID &lt;–&gt; (integer$)</p>
<p class="p4">The identifier of the subpopulation in which this mutation arose.<span class="Apple-converted-space">  </span>This value is carried over from the <span class="s1">Mutation</span> object directly; if a “tag” value was used in the <span class="s1">Mutation</span> object, that value will carry over to the corresponding <span class="s1">Substitution</span> object.<span class="Apple-converted-space">  </span>The <span class="s1">subpopID</span> in <span class="s1">Substitution</span> is a read-write property to allow it to be used as a “tag” in the same way, if the origin subpopulation identifier is not needed.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is carried over automatically from the original <span class="s1">Mutation</span> object.<span class="Apple-converted-space">  </span>Apart from that, the value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p2"><i>5.18.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Substitution</i></span><i> methods</i></p>
<p class="p15"><br></p>
</body>
</html>
