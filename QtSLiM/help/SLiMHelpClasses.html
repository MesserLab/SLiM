<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p3 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo}
    p.p4 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima}
    p.p5 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p6 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p7 {margin: 3.0px 0.0px 3.0px 27.4px; font: 9.0px Menlo; color: #000000}
    p.p8 {margin: 6.0px 0.0px 3.0px 0.0px; font: 9.0px Menlo}
    p.p9 {margin: 3.0px 0.0px 3.0px 27.4px; font: 11.0px Optima}
    p.p10 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px 'Times New Roman'; min-height: 12.0px}
    span.s1 {font: 9.0px Menlo}
    span.s2 {font: 10.0px 'Times New Roman'}
    span.s3 {font-kerning: none}
    span.s4 {font: 9.0px Menlo; font-kerning: none}
    span.s5 {font-kerning: none; color: #000000}
    span.s6 {color: #000000}
    span.s7 {font: 9.0px Menlo; font-kerning: none; color: #000000}
    span.s8 {font: 9.0px 'Times New Roman'}
    span.s9 {font: 11.0px Optima}
    span.s10 {font: 9.0px Menlo; color: #000000}
    span.s11 {font: 11.0px 'Times New Roman'}
    span.s12 {font: 6.7px Optima; font-kerning: none}
    span.s13 {font: 10.0px 'Times New Roman'; color: #000000}
    span.s14 {font: 11.0px Helvetica}
  </style>
</head>
<body>
<p class="p1"><b>5.2<span class="Apple-converted-space">  </span>Class Chromosome</b></p>
<p class="p2"><i>5.2.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Chromosome</i></span><i> properties</i></p>
<p class="p3">colorSubstitution &lt;–&gt; (string$)</p>
<p class="p4">The color used to display substitutions in SLiMgui when both mutations and substitutions are being displayed in the chromosome view.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">colorSubstitution</span> is the empty string, <span class="s1">""</span>, SLiMgui will defer to the color scheme of each <span class="s1">MutationType</span>, just as it does when only substitutions are being displayed.<span class="Apple-converted-space">  </span>The default, <span class="s1">"3333FF"</span>, causes all substitutions to be shown as dark blue when displayed in conjunction with mutations, to prevent the view from becoming too noisy.<span class="Apple-converted-space">  </span>Note that when substitutions are displayed without mutations also being displayed, this value is ignored by SLiMgui and the substitutions use the color scheme of each <span class="s1">MutationType</span><span class="s2">.</span></p>
<p class="p5"><span class="s3">geneConversionEnabled =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">When gene conversion has been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, switching to the DSB recombination model, this property is </span><span class="s4">T</span><span class="s3">; otherwise, when using the crossover breakpoints model, it is </span><span class="s4">F</span><span class="s3">.</span></p>
<p class="p5"><span class="s3">geneConversionGCBias =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The gene conversion bias coefficient, which expresses a bias in the resolution of heteroduplex mismatches in complex gene conversion tracts.<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p5"><span class="s3">geneConversionNonCrossoverFraction =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The fraction of double-stranded breaks that result in non-crossover events.<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p5"><span class="s3">geneConversionMeanLength =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The mean length of a gene conversion tract (in base positions).<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p5"><span class="s3">geneConversionSimpleConversionFraction =&gt; (float$)</span></p>
<p class="p6"><span class="s3">The fraction of gene conversion tracts that are “simple” (i.e., not involving resolution of heteroduplex mismatches); the remainder will be “complex”.<span class="Apple-converted-space">  </span>When gene conversion has not been enabled by calling </span><span class="s4">initializeGeneConversion()</span><span class="s3">, this property will be unavailable.</span></p>
<p class="p3">genomicElements =&gt; (object&lt;GenomicElement&gt;)</p>
<p class="p4">All of the <span class="s1">GenomicElement</span> objects that comprise the chromosome.</p>
<p class="p5"><span class="s3">hotspotEndPositions =&gt; (integer)</span></p>
<p class="p6"><span class="s3">The end positions for hotspot map regions along the chromosome.<span class="Apple-converted-space">  </span>Each hotspot map region is assumed to start at the position following the end of the previous hotspot map region; in other words, the regions are assumed to be contiguous.<span class="Apple-converted-space">  </span>When using sex-specific hotspot maps, this property will unavailable; see </span><span class="s4">hotspotEndPositionsF</span><span class="s3"> and </span><span class="s4">hotspotEndPositionsM</span><span class="s3">.</span></p>
<p class="p5"><span class="s3">hotspotEndPositionsF =&gt; (integer)</span></p>
<p class="p6"><span class="s3">The end positions for hotspot map regions for females, when using sex-specific hotspot maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">hotspotEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p5"><span class="s3">hotspotEndPositionsM =&gt; (integer)</span></p>
<p class="p6"><span class="s3">The end positions for hotspot map regions for males, when using sex-specific hotspot maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">hotspotEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p5"><span class="s3">hotspotMultipliers =&gt; (float)</span></p>
<p class="p6"><span class="s3">The hotspot multiplier for each of the hotspot map regions specified by </span><span class="s4">hotspotEndPositions</span><span class="s3">.<span class="Apple-converted-space">  </span>When using sex-specific hotspot maps, this property will be unavailable; see </span><span class="s4">hotspotMultipliersF</span><span class="s3"> and </span><span class="s4">hotspotMultipliersM</span><span class="s3">.</span></p>
<p class="p5"><span class="s3">hotspotMultipliersF =&gt; (float)</span></p>
<p class="p6"><span class="s3">The hotspot multiplier for each of the hotspot map regions specified by </span><span class="s4">hotspotEndPositionsF</span><span class="s3">, when using sex-specific hotspot maps; unavailable otherwise.</span></p>
<p class="p5"><span class="s3">hotspotMultipliersM =&gt; (float)</span></p>
<p class="p6"><span class="s3">The hotspot multiplier for each of the hotspot map regions specified by </span><span class="s4">hotspotEndPositionsM</span><span class="s3">, when using sex-specific hotspot maps; unavailable otherwise.</span></p>
<p class="p3">lastPosition =&gt; (integer$)</p>
<p class="p4">The last valid position in the chromosome; its length, essentially.</p>
<p class="p3">mutationEndPositions =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for mutation rate regions along the chromosome.<span class="Apple-converted-space">  </span>Each mutation rate region is assumed to start at the position following the end of the previous mutation rate region; in other words, the regions are assumed to be contiguous.<span class="Apple-converted-space">  </span>When using sex-specific mutation rate maps, this property will unavailable; see </span><span class="s4">mutationEndPositionsF</span><span class="s3"> and </span><span class="s4">mutationEndPositionsM</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationEndPositionsF =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for mutation rate regions for females, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">mutationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationEndPositionsM =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for mutation rate regions for males, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">mutationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationRates =&gt; (float)</p>
<p class="p6"><span class="s3">The mutation rate for each of the mutation rate regions specified by </span><span class="s4">mutationEndPositions</span><span class="s3">.<span class="Apple-converted-space">  </span>When using sex-specific mutation rate maps, this property will be unavailable; see </span><span class="s4">mutationRatesF</span><span class="s3"> and </span><span class="s4">mutationRatesM</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationRatesF =&gt; (float)</p>
<p class="p6"><span class="s3">The mutation rate for each of the mutation rate regions specified by </span><span class="s4">mutationEndPositionsF</span><span class="s3">, when using sex-specific mutation rate maps; unavailable otherwise.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">mutationRatesM =&gt; (float)</p>
<p class="p6"><span class="s3">The mutation rate for each of the mutation rate regions specified by </span><span class="s4">mutationEndPositionsM</span><span class="s3">, when using sex-specific mutation rate maps; unavailable otherwise.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">overallMutationRate =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall mutation rate across the whole chromosome determining the overall number of mutation events that will occur anywhere in the chromosome, as calculated from the individual mutation ranges and rates as well as the coverage of the chromosome by genomic elements (since mutations are only generated within genomic elements, regardless of the mutation rate map).<span class="Apple-converted-space">  </span>When using sex-specific mutation rate maps, this property will unavailable; see </span><span class="s4">overallMutationRateF</span><span class="s3"> and </span><span class="s4">overallMutationRateM</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">overallMutationRateF =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall mutation rate for females, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallMutationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">overallMutationRateM =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall mutation rate for males, when using sex-specific mutation rate maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallMutationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p6"><span class="s3">This property is unavailable in nucleotide-based models.</span></p>
<p class="p3">overallRecombinationRate =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall recombination rate across the whole chromosome determining the overall number of recombination events that will occur anywhere in the chromosome, as calculated from the individual recombination ranges and rates.<span class="Apple-converted-space">  </span>When using sex-specific recombination maps, this property will unavailable; see </span><span class="s4">overallRecombinationRateF</span><span class="s3"> and </span><span class="s4">overallRecombinationRateM</span><span class="s3">.</span></p>
<p class="p3">overallRecombinationRateF =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall recombination rate for females, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallRecombinationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p3">overallRecombinationRateM =&gt; (float$)</p>
<p class="p6"><span class="s3">The overall recombination rate for males, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">overallRecombinationRate</span><span class="s3"> for further explanation.</span></p>
<p class="p3">recombinationEndPositions =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for recombination regions along the chromosome.<span class="Apple-converted-space">  </span>Each recombination region is assumed to start at the position following the end of the previous recombination region; in other words, the regions are assumed to be contiguous.<span class="Apple-converted-space">  </span>When using sex-specific recombination maps, this property will unavailable; see </span><span class="s4">recombinationEndPositionsF</span><span class="s3"> and </span><span class="s4">recombinationEndPositionsM</span><span class="s3">.</span></p>
<p class="p3">recombinationEndPositionsF =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for recombination regions for females, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">recombinationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p3">recombinationEndPositionsM =&gt; (integer)</p>
<p class="p6"><span class="s3">The end positions for recombination regions for males, when using sex-specific recombination maps; unavailable otherwise.<span class="Apple-converted-space">  </span>See </span><span class="s4">recombinationEndPositions</span><span class="s3"> for further explanation.</span></p>
<p class="p3">recombinationRates =&gt; (float)</p>
<p class="p6"><span class="s3">The recombination rate for each of the recombination regions specified by </span><span class="s4">recombinationEndPositions</span><span class="s3">.<span class="Apple-converted-space">  </span>When using sex-specific recombination maps, this property will unavailable; see </span><span class="s4">recombinationRatesF</span><span class="s3"> and </span><span class="s4">recombinationRatesM</span><span class="s3">.</span></p>
<p class="p3">recombinationRatesF =&gt; (float)</p>
<p class="p6"><span class="s3">The recombination rate for each of the recombination regions specified by </span><span class="s4">recombinationEndPositionsF</span><span class="s3">, when using sex-specific recombination maps; unavailable otherwise.</span></p>
<p class="p3">recombinationRatesM =&gt; (float)</p>
<p class="p6"><span class="s3">The recombination rate for each of the recombination regions specified by </span><span class="s4">recombinationEndPositionsM</span><span class="s3">, when using sex-specific recombination maps; unavailable otherwise.</span></p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p2"><i>5.2.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Chromosome</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (is)ancestralNucleotides([Ni$ start = NULL], [Ni$ end = NULL], [string$ format = "string"])</span></p>
<p class="p6"><span class="s3">Returns the ancestral nucleotide sequence originally supplied to </span><span class="s4">initializeAncestralNucleotides()</span><span class="s3">, including any sequence changes due to nucleotide mutations that have fixed and substituted.<span class="Apple-converted-space">  </span>This nucleotide sequence is the reference sequence for positions in a genome that do not contain a nucleotide-based mutation.<span class="Apple-converted-space">  </span>The range of the returned sequence may be constrained by a start position given in </span><span class="s4">start</span><span class="s3"> and/or an end position given in </span><span class="s4">end</span><span class="s3">; nucleotides will be returned from </span><span class="s4">start</span><span class="s3"> to </span><span class="s4">end</span><span class="s3">, inclusive.<span class="Apple-converted-space">  </span>The default value of </span><span class="s4">NULL</span><span class="s3"> for </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> represent the first and last base positions of the chromosome, respectively.</span></p>
<p class="p6"><span class="s3">The format of the returned sequence is controlled by the </span><span class="s4">format</span><span class="s3"> parameter.<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"string"</span><span class="s3"> will return the sequence as a singleton </span><span class="s4">string</span><span class="s3"> (e.g., </span><span class="s4">"TATA"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"char"</span><span class="s3"> will return a </span><span class="s4">string</span><span class="s3"> vector with one element per nucleotide (e.g., </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"integer"</span><span class="s3"> will return an </span><span class="s4">integer</span><span class="s3"> vector with values A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3"> (e.g., </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">).<span class="Apple-converted-space">  </span>If the sequence returned is likely to be long, the </span><span class="s4">"string"</span><span class="s3"> format will be the most memory-efficient, and may also be the fastest (but may be harder to work with).</span></p>
<p class="p6"><span class="s3">For purposes related to interpreting the nucleotide sequence as a coding sequence, a format of </span><span class="s4">"codon"</span><span class="s3"> is also supported.<span class="Apple-converted-space">  </span>This format will return an </span><span class="s4">integer</span><span class="s3"> vector with values from </span><span class="s4">0</span><span class="s3"> to </span><span class="s4">63</span><span class="s3">, based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three).<span class="Apple-converted-space">  </span>The codon value for a given nucleotide triplet XYZ is 16X + 4Y + Z, where X, Y, and Z have the usual values A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3">.<span class="Apple-converted-space">  </span>For example, the triplet AAA has a codon value of </span><span class="s4">0</span><span class="s3">, AAC is </span><span class="s4">1</span><span class="s3">, AAG is </span><span class="s4">2</span><span class="s3">, AAT is </span><span class="s4">3</span><span class="s3">, ACA is </span><span class="s4">4</span><span class="s3">, and on upward to TTT which is </span><span class="s4">63</span><span class="s3">.<span class="Apple-converted-space">  </span>If the nucleotide sequence AACACATTT is requested in codon format, the codon vector </span><span class="s4">1 4 63</span><span class="s3"> will therefore be returned.<span class="Apple-converted-space">  </span>These codon values can be useful in themselves; they can also be passed to </span><span class="s4">codonToAminoAcid()</span><span class="s3"> to translate them into the corresponding amino acid sequence if desired.</span></p>
<p class="p5"><span class="s6">– </span><span class="s3">(integer)drawBreakpoints([No&lt;Individual&gt;$ parent = NULL], [Ni$ n = NULL])</span></p>
<p class="p6"><span class="s3">Draw recombination breakpoints, using the chromosome’s recombination rate map, the current gene conversion parameters, and (in some cases – see below) any active and applicable </span><span class="s4">recombination()</span><span class="s3"> callbacks.<span class="Apple-converted-space">  </span>The number of breakpoints to generate, </span><span class="s4">n</span><span class="s3">, may be supplied; if it is </span><span class="s4">NULL</span><span class="s3"> (the default), the number of breakpoints will be drawn based upon the overall recombination rate and the chromosome length (following the standard procedure in SLiM).<span class="Apple-converted-space">  </span>Note that if the double-stranded breaks model has been chosen, the number of breakpoints generated will probably not be equal to the number requested, because most breakpoints will entail gene conversion tracts, which entail additional crossover breakpoints.</span></p>
<p class="p6"><span class="s3">It is generally recommended that the parent individual be supplied to this method, but </span><span class="s4">parent</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> by default.<span class="Apple-converted-space">  </span>The individual supplied in </span><span class="s4">parent</span><span class="s3"> is used for two purposes.<span class="Apple-converted-space">  </span>First, in sexual models that define separate recombination rate maps for males versus females, the sex of </span><span class="s4">parent</span><span class="s3"> will be used to determine which map is used; in this case, a non-</span><span class="s4">NULL</span><span class="s3"> value <i>must</i> be supplied for </span><span class="s4">parent</span><span class="s3">, since the choice of recombination rate map must be determined.<span class="Apple-converted-space">  </span>Second, in models that define </span><span class="s4">recombination()</span><span class="s3"> callbacks, </span><span class="s4">parent</span><span class="s3"> is used to determine the various pseudo-parameters that are passed to </span><span class="s4">recombination()</span><span class="s3"> callbacks (</span><span class="s4">individual</span><span class="s3">, </span><span class="s4">genome1</span><span class="s3">, </span><span class="s4">genome2</span><span class="s3">, </span><span class="s4">subpop</span><span class="s3">), and the subpopulation to which </span><span class="s4">parent</span><span class="s3"> belongs is used to select which </span><span class="s4">recombination()</span><span class="s3"> callbacks are applicable; given the necessity of this information, </span><span class="s4">recombination()</span><span class="s3"> callbacks will not be called as a side effect of this method if </span><span class="s4">parent</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3">.<span class="Apple-converted-space">  </span>Apart from these two uses, </span><span class="s4">parent</span><span class="s3"> is not used, and the caller does not guarantee that the generated breakpoints will actually be used to recombine the genomes of </span><span class="s4">parent</span><span class="s3"> in particular.</span></p>
<p class="p5"><span class="s3">– (integer$)setAncestralNucleotides(is sequence)</span></p>
<p class="p6"><span class="s3">This method, which may be called only in nucleotide-based models, replaces the ancestral nucleotide sequence for the model.<span class="Apple-converted-space">  </span>The </span><span class="s4">sequence</span><span class="s3"> parameter is interpreted exactly as it is in the </span><span class="s4">initializeAncestralSequence()</span><span class="s3"> function; see that documentation for details.<span class="Apple-converted-space">  </span>The length of the ancestral sequence is returned.</span></p>
<p class="p6"><span class="s3">It is unusual to replace the ancestral sequence in a running simulation, since the nucleotide states of segregating and fixed mutations will depend upon the original ancestral sequence.<span class="Apple-converted-space">  </span>It can be useful when loading a new population state with </span><span class="s4">readFromMS()</span><span class="s3"> or </span><span class="s4">readFromVCF()</span><span class="s3">, such as when resetting the simulation state to an earlier state in a conditional simulation; however, that is more commonly done using </span><span class="s4">readFromPopulationFile()</span><span class="s3"> with a SLiM or </span><span class="s4">.trees</span><span class="s3"> file.</span></p>
<p class="p5"><span class="s3">– (void)setGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0])</span></p>
<p class="p6"><span class="s3">This method switches the recombination model to the “double-stranded break (DSB)” model (if it is not already set to that), and configures the details of the gene conversion tracts that will therefore be modeled.<span class="Apple-converted-space">  </span>The meanings and effects of the parameters exactly mirror the </span><span class="s4">initializeGeneConversion()</span><span class="s3"> function.</span></p>
<p class="p5"><span class="s3">– (void)setHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = "*"])</span></p>
<p class="p6"><span class="s3">In nucleotide-based models, set the mutation rate <i>multiplier</i> along the chromosome.<span class="Apple-converted-space">  </span>There are two ways to call this method.<span class="Apple-converted-space">  </span>If the optional </span><span class="s4">ends</span><span class="s3"> parameter is </span><span class="s4">NULL</span><span class="s3"> (the default), then </span><span class="s4">multipliers</span><span class="s3"> must be a singleton value that specifies a single multiplier to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s4">ends</span><span class="s3"> is supplied, then </span><span class="s4">multipliers</span><span class="s3"> and </span><span class="s4">ends</span><span class="s3"> must be the same length, and the values in </span><span class="s4">ends</span><span class="s3"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s4">multipliers</span><span class="s3"> and </span><span class="s4">ends</span><span class="s3"> taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s4">ends</span><span class="s3"> should extend to the end of the chromosome (as previously determined, during simulation initialization).<span class="Apple-converted-space">  </span>See the </span><span class="s4">initializeHotspotMap()</span><span class="s3"> function for further discussion of precisely how these multipliers and positions are interpreted.</span></p>
<p class="p6"><span class="s3">If the optional </span><span class="s4">sex</span><span class="s3"> parameter is </span><span class="s4">"*"</span><span class="s3"> (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s4">sex</span><span class="s3"> may be </span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3"> instead, in which case the supplied hotspot map is used only for that sex.<span class="Apple-converted-space">  </span>Note that whether sex-specific hotspot maps will be used is set by the way that the simulation is initially configured with </span><span class="s4">initializeHotspot()</span><span class="s3">, and cannot be changed with this method; so if the simulation was set up to use sex-specific hotspot maps then sex must be </span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3"> here, whereas if it was set up not to, then sex must be </span><span class="s4">"*"</span><span class="s3"> or unsupplied here.<span class="Apple-converted-space">  </span>If a simulation needs sex-specific hotspot maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.</span></p>
<p class="p6"><span class="s3">The hotspot map is normally constant in simulations, so be sure you know what you are doing.</span></p>
<p class="p3">– (void)setMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p4">Set the mutation rate per base position per generation along the chromosome.<span class="Apple-converted-space">  </span>There are two ways to call this method.<span class="Apple-converted-space">  </span>If the optional <span class="s1">ends</span> parameter is <span class="s1">NULL</span> (the default), then <span class="s1">rates</span> must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, <span class="s1">ends</span> is supplied, then <span class="s1">rates</span> and <span class="s1">ends</span> must be the same length, and the values in <span class="s1">ends</span> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, <span class="s1">rates</span> and <span class="s1">ends</span> taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in <span class="s1">ends</span> should extend to the end of the chromosome (as previously determined, during simulation initialization).<span class="Apple-converted-space">  </span>See the <span class="s1">initializeMutationRate()</span> function for further discussion of precisely how these rates and positions are interpreted.</p>
<p class="p4">If the optional <span class="s1">sex</span> parameter is <span class="s1">"*"</span> (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations <span class="s1">sex</span> may be <span class="s1">"M"</span> or <span class="s1">"F"</span> instead, in which case the supplied mutation rate map is used only for that sex.<span class="Apple-converted-space">  </span>Note that whether sex-specific mutation rate maps will be used is set by the way that the simulation is initially configured with <span class="s1">initializeMutationRate()</span>, and cannot be changed with this method; so if the simulation was set up to use sex-specific mutation rate maps then sex must be <span class="s1">"M"</span> or <span class="s1">"F"</span> here, whereas if it was set up not to, then sex must be <span class="s1">"*"</span> or unsupplied here.<span class="Apple-converted-space">  </span>If a simulation needs sex-specific mutation rate maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.</p>
<p class="p4">The mutation rate intervals are normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p6"><span class="s3">In nucleotide-based models, </span><span class="s4">setMutationRate()</span><span class="s3"> may not be called.<span class="Apple-converted-space">  </span>If variation in the mutation rate along the chromosome is desired, </span><span class="s4">setHotspotMap()</span><span class="s3"> should be used.</span></p>
<p class="p3">– (void)setRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p4">Set the recombination rate per base position per generation along the chromosome.<span class="Apple-converted-space">  </span><span class="s5">All rates must be in the interval [</span><span class="s7">0.0</span><span class="s5">, </span><span class="s7">0.5</span><span class="s5">].<span class="Apple-converted-space">  </span></span>There are two ways to call this method.<span class="Apple-converted-space">  </span>If the optional <span class="s1">ends</span> parameter is <span class="s1">NULL</span> (the default), then <span class="s1">rates</span> must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, <span class="s1">ends</span> is supplied, then <span class="s1">rates</span> and <span class="s1">ends</span> must be the same length, and the values in <span class="s1">ends</span> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, <span class="s1">rates</span> and <span class="s1">ends</span> taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in <span class="s1">ends</span> should extend to the end of the chromosome (as previously determined, during simulation initialization).<span class="Apple-converted-space">  </span>See the <span class="s1">initializeRecombinationRate()</span> function for further discussion of precisely how these rates and positions are interpreted.</p>
<p class="p4">If the optional <span class="s1">sex</span> parameter is <span class="s1">"*"</span> (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations <span class="s1">sex</span> may be <span class="s1">"M"</span> or <span class="s1">"F"</span> instead, in which case the supplied recombination map is used only for that sex.<span class="Apple-converted-space">  </span>Note that whether sex-specific recombination maps will be used is set by the way that the simulation is initially configured with <span class="s1">initializeRecombinationRate()</span>, and cannot be changed with this method; so if the simulation was set up to use sex-specific recombination maps then sex must be <span class="s1">"M"</span> or <span class="s1">"F"</span> here, whereas if it was set up not to, then sex must be <span class="s1">"*"</span> or unsupplied here.<span class="Apple-converted-space">  </span>If a simulation needs sex-specific recombination maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.</p>
<p class="p4">The recombination intervals are normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p1"><b>5.3<span class="Apple-converted-space">  </span>Class Genome</b></p>
<p class="p2"><i>5.3.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Genome</i></span><i> properties</i></p>
<p class="p5"><span class="s3">genomePedigreeID =&gt; (integer$)</span></p>
<p class="p6">A unique non-negative identifier for each genome in a simulation, never re-used throughout the duration of the simulation run.<span class="Apple-converted-space">  </span>Furthermore, the <span class="s1">genomePedigreeID</span> of a given genome will be equal to either <span class="s1">(2*pedigreeID)</span> or <span class="s1">(2*pedigreeID + 1)</span> of the individual that the genome belongs to (the former for the first genome of the individual, the latter for the second genome of the individual); this invariant relationship is guaranteed.</p>
<p class="p3">genomeType =&gt; (string$)</p>
<p class="p4">The type of chromosome represented by this genome; one of <span class="s1">"A"</span>, <span class="s1">"X"</span>, or <span class="s1">"Y"</span><span class="s2">.</span></p>
<p class="p5"><span class="s3">individual =&gt; (object&lt;Individual&gt;$)</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">Individual</span><span class="s3"> object to which this genome belongs.</span></p>
<p class="p3">isNullGenome =&gt; (logical$)</p>
<p class="p4"><span class="s1">T</span> if the genome is a “null” genome, <span class="s1">F</span> if it is an ordinary genome object.<span class="Apple-converted-space">  </span>When a sex chromosome (X or Y) is simulated, the other sex chromosome also exists in the simulation, but it is a “null” genome that does not carry any mutations.<span class="Apple-converted-space">  </span>Instead, it is a placeholder, present to allow SLiM’s code to operate in much the same way as it does when an autosome is simulated.<span class="Apple-converted-space">  </span>Null genomes should not be accessed or manipulated.</p>
<p class="p3">mutations =&gt; (object&lt;Mutation&gt;)</p>
<p class="p4">All of the <span class="s1">Mutation</span> objects present in this genome.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p4">Note that the <span class="s1">Genome</span> objects used by SLiM are new with every generation, so the <span class="s1">tag</span> value of each new offspring generated in each generation will be initially undefined.<span class="Apple-converted-space">  </span>If you set a <span class="s1">tag</span> value for an offspring genome inside a <span class="s1">modifyChild()</span> callback, that <span class="s1">tag</span> value will be preserved as the offspring individual becomes a parent (across the generation boundary, in other words).<span class="Apple-converted-space">  </span>If you take advantage of this, however, you should be careful to set up initial values for the tag values of <i>all</i> offspring, otherwise undefined initial values might happen to match the values that you are trying to use to tag particular individuals.<span class="Apple-converted-space">  </span>A rule of thumb in programming: undefined values should always be assumed to take on the most inconvenient value possible.</p>
<p class="p2"><i>5.3.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Genome</i></span><i> methods</i></p>
<p class="p3">+ (void)addMutations(object&lt;Mutation&gt; mutations)</p>
<p class="p4">Add the existing mutations in <span class="s1">mutations</span> to the genome, if they are not already present (if they are already present, they will be ignored), and if the addition is not prevented by the mutation stacking policy (see the <span class="s1">mutationStackPolicy</span> property of <span class="s1">MutationType</span>).</p>
<p class="p4">Calling this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call <span class="s1">SLiMSim</span>’s method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6">Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the generation in which the individual is created (i.e., when the <span class="s1">age</span> of the individual is greater than <span class="s1">0</span>), to prevent the possibility of inconsistencies in the recorded tree sequence.</p>
<p class="p3">+ (object&lt;Mutation&gt;)addNewDrawnMutation(io&lt;MutationType&gt; mutationType, integer position, [Ni originGeneration = NULL], [Nio&lt;Subpopulation&gt; originSubpop = NULL]<span class="s5">, [Nis nucleotide = NULL]</span>)</p>
<p class="p4">Add new mutations to the target genome(s) with the specified <span class="s1">mutationType</span> (specified by the <span class="s1">MutationType</span> object or by <span class="s1">integer</span> identifier), <span class="s1">position</span>, <span class="s1">originGeneration</span> (which may be <span class="s1">NULL</span>, the default, to specify the current generation<span class="s6">; otherwise, beginning in SLiM 3.5, it must be equal to the current generation anyway, as other uses of this property have been deprecated</span>), and <span class="s1">originSubpop</span> (specified by the <span class="s1">Subpopulation</span> object or by <span class="s1">integer</span> identifier, or by <span class="s1">NULL</span>, the default, to specify the subpopulation to which the first target genome belongs).<span class="Apple-converted-space">  </span>If <span class="s1">originSubpop</span> is supplied as an <span class="s1">integer</span>, it is intentionally not checked for validity; you may use arbitrary values of <span class="s1">originSubpop</span> to “tag” the mutations that you create.<span class="Apple-converted-space">  </span>The selection coefficients of the mutations are drawn from their mutation types; <span class="s1">addNewMutation()</span> may be used instead if you wish to specify selection coefficients.</p>
<p class="p6"><span class="s3">In non-nucleotide-based models, </span><span class="s4">mutationType</span><span class="s3"> will always be a non-nucleotide-based mutation type, and so </span><span class="s4">nucleotide</span><span class="s3"> must be </span><span class="s4">NULL</span><span class="s3"> (the default).<span class="Apple-converted-space">  </span>In a nucleotide-based model, </span><span class="s4">mutationType</span><span class="s3"> might still be non-nucleotide-based (in which case </span><span class="s4">nucleotide</span><span class="s3"> must still be </span><span class="s4">NULL</span><span class="s3">), or </span><span class="s4">mutationType</span><span class="s3"> might be nucleotide-based, in which case a non-</span><span class="s4">NULL</span><span class="s3"> value must be supplied for </span><span class="s4">nucleotide</span><span class="s3">, specifying the nucleotide(s) to be associated with the new mutation(s).<span class="Apple-converted-space">  </span>Nucleotides may be specified with string values (</span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">), or with integer values (A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3">).<span class="Apple-converted-space">  </span>If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.<span class="Apple-converted-space">  </span>No check is performed that a new mutation’s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model.</span></p>
<p class="p4">Beginning in SLiM 2.5 this method is vectorized, so all of these parameters may be singletons (in which case that single value is used for all mutations created by the call) or non-singleton vectors (in which case one element is used for each corresponding mutation created).<span class="Apple-converted-space">  </span>Non-singleton parameters must match in length, since their elements need to be matched up one-to-one.</p>
<p class="p4">The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the <span class="s1">mutationStackPolicy</span> property of <span class="s1">MutationType</span>).<span class="Apple-converted-space">  </span>However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the <span class="s1">position</span> parameter is specified in ascending order.<span class="Apple-converted-space">  </span>In other words, pre-sorting the parameters to this method into ascending order by position, using <span class="s1">order()</span> and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.</p>
<p class="p4">Beginning in SLiM 2.1, this is a class method, not an instance method.<span class="Apple-converted-space">  </span>This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation objects to all of the elements of the receiver.<span class="Apple-converted-space">  </span>Before SLiM 2.1, to add the same mutations to multiple genomes, it was necessary to call <span class="s1">addNewDrawnMutation()</span> on one of the genomes, and then add the returned <span class="s1">Mutation</span> object to all of the other genomes using <span class="s1">addMutations()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).<span class="Apple-converted-space">  </span>Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).</p>
<p class="p4">Calling this will normally affect the fitness values calculated at the end of the current generation (but not sooner); if you want current fitness values to be affected, you can call <span class="s1">SLiMSim</span>’s method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6">Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the generation in which the individual is created (i.e., when the <span class="s1">age</span> of the individual is greater than <span class="s1">0</span>), to prevent the possibility of inconsistencies in the recorded tree sequence.</p>
<p class="p3">+ (object&lt;Mutation&gt;)addNewMutation(io&lt;MutationType&gt; mutationType, numeric selectionCoeff, integer position, [Ni originGeneration = NULL], [Nio&lt;Subpopulation&gt; originSubpop = NULL]<span class="s5">, [Nis nucleotide = NULL]</span>)</p>
<p class="p4">Add new mutations to the target genome(s) with the specified <span class="s1">mutationType</span> (specified by the <span class="s1">MutationType</span> object or by <span class="s1">integer</span> identifier), <span class="s1">selectionCoeff</span>, <span class="s1">position</span>, <span class="s1">originGeneration</span> (which may be <span class="s1">NULL</span>, the default, to specify the current generation<span class="s6">; otherwise, beginning in SLiM 3.5, it must be equal to the current generation anyway, as other uses of this property have been deprecated</span>), and <span class="s1">originSubpop</span> (specified by the <span class="s1">Subpopulation</span> object or by <span class="s1">integer</span> identifier, or by <span class="s1">NULL</span>, the default, to specify the subpopulation to which the first target genome belongs).<span class="Apple-converted-space">  </span>If <span class="s1">originSubpop</span> is supplied as an <span class="s1">integer</span>, it is intentionally not checked for validity; you may use arbitrary values of <span class="s1">originSubpop</span> to “tag” the mutations that you create.<span class="Apple-converted-space">  </span>The <span class="s1">addNewDrawnMutation()</span> method may be used instead if you wish selection coefficients to be drawn from the mutation types of the mutations.</p>
<p class="p6"><span class="s3">In non-nucleotide-based models, </span><span class="s4">mutationType</span><span class="s3"> will always be a non-nucleotide-based mutation type, and so </span><span class="s4">nucleotide</span><span class="s3"> must be </span><span class="s4">NULL</span><span class="s3"> (the default).<span class="Apple-converted-space">  </span>In a nucleotide-based model, </span><span class="s4">mutationType</span><span class="s3"> might still be non-nucleotide-based (in which case </span><span class="s4">nucleotide</span><span class="s3"> must still be </span><span class="s4">NULL</span><span class="s3">), or </span><span class="s4">mutationType</span><span class="s3"> might be nucleotide-based, in which case a non-</span><span class="s4">NULL</span><span class="s3"> value must be supplied for </span><span class="s4">nucleotide</span><span class="s3">, specifying the nucleotide(s) to be associated with the new mutation(s).<span class="Apple-converted-space">  </span>Nucleotides may be specified with string values (</span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">), or with integer values (A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3">).<span class="Apple-converted-space">  </span>If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.<span class="Apple-converted-space">  </span>No check is performed that a new mutation’s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model.</span></p>
<p class="p4">The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the <span class="s1">mutationStackPolicy</span> property of <span class="s1">MutationType</span>).<span class="Apple-converted-space">  </span>However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the <span class="s1">position</span> parameter is specified in ascending order.<span class="Apple-converted-space">  </span>In other words, pre-sorting the parameters to this method into ascending order by position, using <span class="s1">order()</span> and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.</p>
<p class="p4">Beginning in SLiM 2.1, this is a class method, not an instance method.<span class="Apple-converted-space">  </span>This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation object to all of the elements of the receiver.<span class="Apple-converted-space">  </span>Before SLiM 2.1, to add the same mutation to multiple genomes, it was necessary to call <span class="s1">addNewMutation()</span> on one of the genomes, and then add the returned <span class="s1">Mutation</span> object to all of the other genomes using <span class="s1">addMutations()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).<span class="Apple-converted-space">  </span>Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).</p>
<p class="p4">Calling this will normally affect the fitness values calculated at the end of the current generation (but not sooner); if you want current fitness values to be affected, you can call <span class="s1">SLiMSim</span>’s method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6">Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the generation in which the individual is created (i.e., when the <span class="s1">age</span> of the individual is greater than <span class="s1">0</span>), to prevent the possibility of inconsistencies in the recorded tree sequence.</p>
<p class="p3">–<span class="s8"> </span>(<span class="s5">Nlo&lt;Mutation&gt;$</span>)containsMarkerMutation(io&lt;MutationType&gt;$ mutType, integer$<span class="s8"> </span>position<span class="s5">, [logical$ returnMutation = F]</span>)</p>
<p class="p4">Returns <span class="s1">T</span> if the genome contains a mutation of type <span class="s1">mutType</span> at <span class="s1">position</span>, <span class="s1">F</span> otherwise<span class="s5"> (if </span><span class="s7">returnMutation</span><span class="s5"> has its default value of </span><span class="s7">F</span><span class="s5">; see below)</span>.<span class="Apple-converted-space">  </span>This method is, as its name suggests, intended for checking for “marker mutations”: mutations of a special mutation type that are not literally mutations in the usual sense, but instead are added in to particular genomes to mark them as possessing some property.<span class="Apple-converted-space">  </span>Marker mutations are not typically added by SLiM’s mutation-generating machinery; instead they are added explicitly with <span class="s1">addNewMutation()</span> or <span class="s1">addNewDrawnMutation()</span> at a known, constant position in the genome.<span class="Apple-converted-space">  </span>This method provides a check for whether a marker mutation of a given type exists in a particular genome; because the position to check is known in advance, that check can be done much faster than the equivalent check with <span class="s1">containsMutations()</span> or <span class="s1">countOfMutationsOfType()</span>, using a binary search of the genome.</p>
<p class="p6"><span class="s3">If </span><span class="s4">returnMutation</span><span class="s3"> is </span><span class="s4">T</span><span class="s3"> (an option added in SLiM 3), this method returns the actual mutation found, rather than just </span><span class="s4">T</span><span class="s3"> or </span><span class="s4">F</span><span class="s3">.<span class="Apple-converted-space">  </span>More specifically, the <i>first</i> mutation found of </span><span class="s4">mutType</span><span class="s3"> at </span><span class="s4">position</span><span class="s3"> will be returned; if more than one such mutation exists in the target genome, which one is returned is not defined.<span class="Apple-converted-space">  </span>If </span><span class="s4">returnMutation</span><span class="s3"> is T and no mutation of </span><span class="s4">mutType</span><span class="s3"> is found at </span><span class="s4">position</span><span class="s3">, </span><span class="s4">NULL</span><span class="s3"> will be returned.</span></p>
<p class="p3">– (logical)containsMutations(object&lt;Mutation&gt; mutations)</p>
<p class="p4">Returns a <span class="s1">logical</span> vector indicating whether each of the mutations in <span class="s1">mutations</span> is present in the genome; each element in the returned vector indicates whether the corresponding mutation is present (<span class="s1">T</span>) or absent (<span class="s1">F</span>).<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">–<span class="s8"> </span>(integer$)countOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the number of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the genome.<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just a count, use <span class="s1">-mutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">–<span class="s8"> </span>(object&lt;Mutation&gt;)mutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns an <span class="s1">object</span> vector of all the mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the genome.<span class="Apple-converted-space">  </span>If you just need a count of the matching <span class="s1">Mutation</span> objects, rather than a vector of the matches, use <span class="s1">-countOfMutationsOfType()</span>; if you need just the positions of matching <span class="s1">Mutation</span> objects, use <span class="s1">-positionsOfMutationsOfType()</span>; and if you are aiming for a sum of the selection coefficients of matching <span class="s1">Mutation</span> objects, use <span class="s1">-sumOfMutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p5"><span class="s3">– (is)nucleotides([Ni$ start = NULL], [Ni$ end = NULL], [string$ format = "string"])</span></p>
<p class="p6"><span class="s3">Returns the nucleotide sequence for the genome.<span class="Apple-converted-space">  </span>This is the current ancestral sequence, as would be returned by the </span><span class="s4">Chromosome</span><span class="s3"> method </span><span class="s4">ancestralNucleotides()</span><span class="s3">, with the nucleotides for any nucleotide-based mutations in the genome overlaid.<span class="Apple-converted-space">  </span>The range of the returned sequence may be constrained by a start position given in </span><span class="s4">start</span><span class="s3"> and/or an end position given in </span><span class="s4">end</span><span class="s3">; nucleotides will be returned from </span><span class="s4">start</span><span class="s3"> to </span><span class="s4">end</span><span class="s3">, inclusive.<span class="Apple-converted-space">  </span>The default value of </span><span class="s4">NULL</span><span class="s3"> for </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> represent the first and last base positions of the chromosome, respectively.</span></p>
<p class="p6"><span class="s3">The format of the returned sequence is controlled by the </span><span class="s4">format</span><span class="s3"> parameter.<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"string"</span><span class="s3"> will return the sequence as a singleton </span><span class="s4">string</span><span class="s3"> (e.g., </span><span class="s4">"TATA"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"char"</span><span class="s3"> will return a </span><span class="s4">string</span><span class="s3"> vector with one element per nucleotide (e.g., </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"T"</span><span class="s3">, </span><span class="s4">"A"</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"integer"</span><span class="s3"> will return an </span><span class="s4">integer</span><span class="s3"> vector with values A=</span><span class="s4">0</span><span class="s3">, C=</span><span class="s4">1</span><span class="s3">, G=</span><span class="s4">2</span><span class="s3">, T=</span><span class="s4">3</span><span class="s3"> (e.g., </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">).<span class="Apple-converted-space">  </span>A format of </span><span class="s4">"codon"</span><span class="s3"> will return an </span><span class="s4">integer</span><span class="s3"> vector with values from </span><span class="s4">0</span><span class="s3"> to </span><span class="s4">63</span><span class="s3">, based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three); see the </span><span class="s4">ancestralNucleotides()</span><span class="s3"> documentation for details.<span class="Apple-converted-space">  </span>If the sequence returned is likely to be long, the </span><span class="s4">"string"</span><span class="s3"> format will be the most memory-efficient, and may also be the fastest (but may be harder to work with).</span></p>
<p class="p6"><span class="s3">Several helper functions are provided for working with sequences, such as </span><span class="s4">nucleotideCounts()</span><span class="s3"> to get the counts of A/C/G/T nucleotides in a sequence, </span><span class="s4">nucleotideFrequencies()</span><span class="s3"> to get the same information as frequencies, and </span><span class="s4">codonsToAminoAcids()</span><span class="s3"> to convert a codon sequence (such as provided by the codon format described above) to an amino acid sequence.</span></p>
<p class="p3">+ (void)output([Ns$ filePath = NULL], [logical$ append = F])</p>
<p class="p4">Output the target genomes in SLiM’s native format.<span class="Apple-converted-space">  </span>This low-level output method may be used to output any sample of <span class="s1">Genome</span> objects (the Eidos function <span class="s1">sample()</span> may be useful for constructing custom samples, as may the SLiM class <span class="s1">Individual</span>).<span class="Apple-converted-space">  </span>For output of a sample from a single <span class="s1">Subpopulation</span>, the <span class="s1">outputSample()</span> of <span class="s1">Subpopulation</span> may be more straightforward to use.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output is directed to SLiM’s standard output.<span class="Apple-converted-space">  </span>Otherwise, the output is sent to the file specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span></p>
<p class="p4">See <span class="s1">outputMS()</span> and <span class="s1">outputVCF()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">+ (void)outputMS([Ns$ filePath = NULL], [logical$ append = F]<span class="s5">, [logical$ filterMonomorphic = F]</span>)</p>
<p class="p4">Output the target genomes in MS format.<span class="Apple-converted-space">  </span>This low-level output method may be used to output any sample of <span class="s1">Genome</span> objects (the Eidos function <span class="s1">sample()</span> may be useful for constructing custom samples, as may the SLiM class <span class="s1">Individual</span>).<span class="Apple-converted-space">  </span>For output of a sample from a single <span class="s1">Subpopulation</span>, the <span class="s1">outputMSSample()</span> of <span class="s1">Subpopulation</span> may be more straightforward to use.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output is directed to SLiM’s standard output.<span class="Apple-converted-space">  </span>Otherwise, the output is sent to the file specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span><span class="Apple-converted-space">  </span>Positions in the output will span the interval [0,1].</p>
<p class="p6"><span class="s3">If </span><span class="s4">filterMonomorphic</span><span class="s3"> is </span><span class="s4">F</span><span class="s3"> (the default), all mutations that are present in the sample will be included in the output.<span class="Apple-converted-space">  </span>This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in <i>every</i> sampled genome, and are thus apparently fixed).<span class="Apple-converted-space">  </span>These may be filtered out with </span><span class="s4">filterMonomorphic = T</span><span class="s3"> if desired; note that this option means that some mutations that do exist in the sampled genomes might not be included in the output, simply because they exist in every sampled genome.</span></p>
<p class="p4">See <span class="s1">output()</span> and <span class="s1">outputVCF()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">+ (void)outputVCF([Ns$ filePath = NULL], [logical$ outputMultiallelics = T], [logical$ append = F]<span class="s5">, [logical$ simplifyNucleotides = F], [logical$ outputNonnucleotides = T]</span>)</p>
<p class="p4">Output the target genomes in VCF format.<span class="Apple-converted-space">  </span>The target genomes are treated as pairs comprising individuals for purposes of structuring the VCF output, so an even number of genomes is required.<span class="Apple-converted-space">  </span>This low-level output method may be used to output any sample of <span class="s1">Genome</span> objects (the Eidos function <span class="s1">sample()</span> may be useful for constructing custom samples, as may the SLiM class <span class="s1">Individual</span>).<span class="Apple-converted-space">  </span>For output of a sample from a single <span class="s1">Subpopulation</span>, the <span class="s1">outputVCFSample()</span> of <span class="s1">Subpopulation</span> may be more straightforward to use.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output is directed to SLiM’s standard output.<span class="Apple-converted-space">  </span>Otherwise, the output is sent to the file specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span></p>
<p class="p6"><span class="s3">The parameters </span><span class="s4">outputMultiallelics</span><span class="s3">, </span><span class="s4">simplifyNucleotides</span><span class="s3">, and </span><span class="s4">outputNonnucleotides</span><span class="s3"> affect the format of the output produced; see the reference documentation for further discussion.</span></p>
<p class="p4">See <span class="s1">outputMS()</span> and <span class="s1">output()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">– (integer)positionsOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the positions of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the genome.<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just positions, use <span class="s1">-mutationsOfType()</span>.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p5"><span class="s3">+ (</span><span class="s6">object</span><span class="s3">&lt;Mutation&gt;)readFromMS(string$ filePath, io&lt;MutationType&gt;$ mutationType)</span></p>
<p class="p6"><span class="s3">Read new mutations from the MS format file at </span><span class="s4">filePath</span><span class="s3"> and add them to the target genomes.<span class="Apple-converted-space">  </span>The number of target genomes must match the number of genomes represented in the MS file.<span class="Apple-converted-space">  </span>To read into all of the genomes in a given subpopulation </span><span class="s4">pN</span><span class="s3">, simply call </span><span class="s4">pN.genomes.readFromMS()</span><span class="s3">, assuming the subpopulation’s size matches that of the MS file.<span class="Apple-converted-space">  </span>A vector containing all of the mutations created by </span><span class="s4">readFromMS()</span><span class="s3"> is returned.</span></p>
<p class="p6"><span class="s3">Each mutation is created at the position specified in the file, using the mutation type given by </span><span class="s4">mutationType</span><span class="s3">.<span class="Apple-converted-space">  </span>Positions are expected to be in [0,1], and are scaled to the length of the chromosome by multiplying by the last valid base position of the chromosome (i.e., one less than the chromosome length).<span class="Apple-converted-space">  </span>Selection coefficients are drawn from the mutation type.<span class="Apple-converted-space">  </span>The population of origin for each mutation is set to </span><span class="s4">-1</span><span class="s3">, and the generation of origin is set to the current generation.<span class="Apple-converted-space">  </span>In a nucleotide-based model, if </span><span class="s4">mutationType</span><span class="s3"> is nucleotide-based, a random nucleotide different from the ancestral nucleotide at the position will be chosen with equal probability.</span></p>
<p class="p6"><span class="s3">The target genomes correspond, in order, to the call lines in the MS file.<span class="Apple-converted-space">  </span>In sex-based models that simulate the X or Y chromosome, null genomes in the target vector will be skipped, and will not be used to correspond to any call line; however, care should be taken in this case that the lines in the MS file correspond to the target genomes in the manner desired.</span></p>
<p class="p5"><span class="s3">+ (</span><span class="s6">object</span><span class="s3">&lt;Mutation&gt;)readFromVCF(string$ filePath, [Nio&lt;MutationType&gt;$ mutationType = NULL])</span></p>
<p class="p6"><span class="s3">Read new mutations from the VCF format file at </span><span class="s4">filePath</span><span class="s3"> and add them to the target genomes.<span class="Apple-converted-space">  </span>The number of target genomes must match the number of genomes represented in the VCF file (i.e., two times the number of samples, if each sample is diploid).<span class="Apple-converted-space">  </span>To read into all of the genomes in a given subpopulation </span><span class="s4">pN</span><span class="s3">, simply call </span><span class="s4">pN.genomes.readFromVCF()</span><span class="s3">, assuming the subpopulation’s size matches that of the VCF file taking ploidy into account.<span class="Apple-converted-space">  </span>A vector containing all of the mutations created by </span><span class="s4">readFromVCF()</span><span class="s3"> is returned.</span></p>
<p class="p6"><span class="s3">SLiM’s VCF parsing is quite primitive.<span class="Apple-converted-space">  </span>The header is parsed only inasmuch as SLiM looks to see whether SLiM-specific VCF fields are defined or not; the rest of the header information is ignored.<span class="Apple-converted-space">  </span>Call lines are assumed to follow the format:</span></p>
<p class="p7"><span class="s3">#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT i0...iN</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">CHROM</span><span class="s3">, </span><span class="s4">ID</span><span class="s3">, </span><span class="s4">QUAL</span><span class="s3">, </span><span class="s4">FILTER</span><span class="s3">, and </span><span class="s4">FORMAT</span><span class="s3"> fields are ignored, and information in the genotype fields beyond the </span><span class="s4">GT</span><span class="s3"> genotype subfield are also ignored.<span class="Apple-converted-space">  </span>SLiM’s own VCF annotations are honored; in particular, mutations will be created using the given values of </span><span class="s4">MID</span><span class="s3">, </span><span class="s4">S</span><span class="s3">, </span><span class="s4">PO</span><span class="s3">, </span><span class="s4">GO</span><span class="s3">, and </span><span class="s4">MT</span><span class="s3"> if those subfields are present, and </span><span class="s4">DOM</span><span class="s3">, if it is present, must match the dominance coefficient of the mutation type.<span class="Apple-converted-space">  </span>The parameter </span><span class="s4">mutationType</span><span class="s3"> (a </span><span class="s4">MutationType</span><span class="s3"> object or id) will be used for any mutations that have no supplied mutation type id in the </span><span class="s4">MT</span><span class="s3"> subfield; if </span><span class="s4">mutationType</span><span class="s3"> would be used but is </span><span class="s4">NULL</span><span class="s3"> an error will result.<span class="Apple-converted-space">  </span>Mutation IDs supplied in </span><span class="s4">MID</span><span class="s3"> will be used if no mutation IDs have been used in the simulation so far; if any have been used, it is difficult for SLiM to guarantee that there are no conflicts, so a warning will be emitted and the </span><span class="s4">MID</span><span class="s3"> values will be ignored.<span class="Apple-converted-space">  </span>If selection coefficients are not supplied with the </span><span class="s4">S</span><span class="s3"> subfield, they will be drawn from the mutation type used for the mutation.<span class="Apple-converted-space">  </span>If a population of origin is not supplied with the </span><span class="s4">PO</span><span class="s3"> subfield, </span><span class="s4">-1</span><span class="s3"> will be used.<span class="Apple-converted-space">  </span>If a generation of origin is not supplied with the </span><span class="s4">GO</span><span class="s3"> subfield, the current generation will be used.</span></p>
<p class="p6"><span class="s4">REF</span><span class="s3"> and </span><span class="s4">ALT</span><span class="s3"> must always be comprised of simple nucleotides (</span><span class="s4">A</span><span class="s3">/</span><span class="s4">C</span><span class="s3">/</span><span class="s4">G</span><span class="s3">/</span><span class="s4">T</span><span class="s3">) rather than values representing indels or other complex states.<span class="Apple-converted-space">  </span>Beyond this, the handling of the </span><span class="s4">REF</span><span class="s3"> and </span><span class="s4">ALT</span><span class="s3"> fields depends upon several factors.<span class="Apple-converted-space">  </span>First of all, these fields are ignored in non-nucleotide-based models, although they are still checked for conformance.<span class="Apple-converted-space">  </span>In nucleotide-based models, when a header definition for SLiM’s </span><span class="s4">NONNUC</span><span class="s3"> tag is present (as when nucleotide-based output is generated by SLiM): Second, if a </span><span class="s4">NONNUC</span><span class="s3"> field is present in the </span><span class="s4">INFO</span><span class="s3"> field the call line is taken to represent a non-nucleotide-based mutation, and </span><span class="s4">REF</span><span class="s3"> and </span><span class="s4">ALT</span><span class="s3"> are again ignored.<span class="Apple-converted-space">  </span>In this case the mutation type used must be non-nucleotide-based.<span class="Apple-converted-space">  </span>Third, if </span><span class="s4">NONNUC</span><span class="s3"> is <i>not</i> present the call line is taken to represent a nucleotide-based mutation.<span class="Apple-converted-space">  </span>In this case, the mutation type used must be nucleotide-based.<span class="Apple-converted-space">  </span>Also, in this case, the specified reference nucleotide must match the existing ancestral nucleotide at the given position.<span class="Apple-converted-space">  </span>In nucleotide-based models, when a header definition for SLiM’s </span><span class="s4">NONNUC</span><span class="s3"> tag is not present (as when loading a non-SLiM-generated VCF file): The mutation type will govern the way nucleotides are handled.<span class="Apple-converted-space">  </span>If the mutation type used for a mutation is nucleotide-based, the nucleotide provided in the VCF file for that allele will be used.<span class="Apple-converted-space">  </span>If the mutation type is non-nucleotide-based, the nucleotide provided will be ignored.</span></p>
<p class="p6"><span class="s3">If multiple alleles using the same nucleotide at the same position are specified in the VCF file, a separate mutation will be created for each, mirroring SLiM’s behavior with independent mutational lineages when writing VCF.<span class="Apple-converted-space">  </span>The </span><span class="s4">MULTIALLELIC</span><span class="s3"> flag is ignored by </span><span class="s4">readFromVCF()</span><span class="s3">; call lines for mutations at the same base position in the same genome will result in stacked mutations whether or not </span><span class="s4">MULTIALLELIC</span><span class="s3"> is present.</span></p>
<p class="p6"><span class="s3">The target genomes correspond, in order, to the haploid or diploid calls provided for </span><span class="s4">i0</span><span class="s3">…</span><span class="s4">iN</span><span class="s3"> (the sample IDs) in the VCF file.<span class="Apple-converted-space">  </span>In sex-based models that simulate the X or Y chromosome, null genomes in the target vector will be skipped, and will not be used to correspond to any of </span><span class="s4">i0</span><span class="s3">…</span><span class="s4">iN</span><span class="s3">; however, care should be taken in this case that the genomes in the VCF file correspond to the target genomes in the manner desired.</span></p>
<p class="p5"><span class="s3">+ (void)removeMutations([No&lt;Mutation&gt; mutations = NULL], [logical$ substitute = F])</span></p>
<p class="p6"><span class="s3">Remove the mutations in </span><span class="s4">mutations</span><span class="s3"> from the target genome(s), if they are present (if they are not present, they will be ignored).<span class="Apple-converted-space">  </span>If </span><span class="s4">NULL</span><span class="s3"> is passed for </span><span class="s4">mutations</span><span class="s3"> (which is the default), then all mutations will be removed from the target genomes; in this case, </span><span class="s4">substitute</span><span class="s3"> must be </span><span class="s4">F</span><span class="s3"> (a specific vector of mutations to be substituted is required).<span class="Apple-converted-space">  </span>Note that the </span><span class="s4">Mutation</span><span class="s3"> objects removed remain valid, and will still be in the simulation’s mutation registry (i.e. will be returned by </span><span class="s4">SLiMSim</span><span class="s3">’s </span><span class="s4">mutations</span><span class="s3"> property), until the next generation.</span></p>
<p class="p6"><span class="s3">Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call </span><span class="s4">SLiMSim</span><span class="s3">’s method </span><span class="s4">recalculateFitness()</span><span class="s3"> – but see the documentation of that method for caveats.</span></p>
<p class="p6"><span class="s3">The optional parameter </span><span class="s4">substitute</span><span class="s3"> was added in SLiM 2.2, with a default of </span><span class="s4">F</span><span class="s3"> for backward compatibility.<span class="Apple-converted-space">  </span>If </span><span class="s4">substitute</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">, </span><span class="s4">Substitution</span><span class="s3"> objects will be created for all of the removed mutations so that they are recorded in the simulation as having fixed, just as if they had reached fixation and been removed by SLiM’s own internal machinery.<span class="Apple-converted-space">  </span>This will occur regardless of whether the mutations have in fact fixed, regardless of the </span><span class="s4">convertToSubstitution</span><span class="s3"> property of the relevant mutation types, and regardless of whether all copies of the mutations have even been removed from the simulation (making it possible to create </span><span class="s4">Substitution</span><span class="s3"> objects for mutations that are still segregating).<span class="Apple-converted-space">  </span>It is up to the caller to perform whatever checks are necessary to preserve the integrity of the simulation’s records.<span class="Apple-converted-space">  </span>Typically </span><span class="s4">substitute</span><span class="s3"> will only be set to </span><span class="s4">T</span><span class="s3"> in the context of calls like </span><span class="s4">sim.subpopulations.genomes.removeMutations(muts, T)</span><span class="s3">, such that the substituted mutations are guaranteed to be entirely removed from circulation.<span class="Apple-converted-space">  </span>As mentioned above, </span><span class="s4">substitute</span><span class="s3"> may not be </span><span class="s4">T</span><span class="s3"> if </span><span class="s4">mutations</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3">.</span></p>
<p class="p3">–<span class="s8"> </span>(float$)sumOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the sum of the selection coefficients of all mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the genome.<span class="Apple-converted-space">  </span>This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, <span class="s1">sumOfMutationsOfType()</span> will provide the sum of the additive effects of the QTLs for the given mutation type.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="Apple-converted-space">  </span>Note that this method also exists on <span class="s1">Individual</span>, for cases in which the sum across both genomes of an individual is desired.</p>
<p class="p1"><b>5.4<span class="Apple-converted-space">  </span>Class GenomicElement</b></p>
<p class="p2"><i>5.4.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>GenomicElement</i></span><i> properties</i></p>
<p class="p3">endPosition =&gt; (integer$)</p>
<p class="p4">The last position in the chromosome contained by this genomic element.</p>
<p class="p3">genomicElementType =&gt; (object&lt;GenomicElementType&gt;$)</p>
<p class="p4">The <span class="s1">GenomicElementType</span> object that defines the behavior of this genomic element.</p>
<p class="p3">startPosition =&gt; (integer$)</p>
<p class="p4">The first position in the chromosome contained by this genomic element.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p2"><i>5.4.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>GenomicElement</i></span><i> methods</i></p>
<p class="p3">– (void)setGenomicElementType(io&lt;GenomicElementType&gt;$ genomicElementType)</p>
<p class="p4">Set the genomic element type used for a genomic element.<span class="Apple-converted-space">  </span>The genomicElementType parameter should supply the new genomic element type for the element, either as a <span class="s1">GenomicElementType</span> object or as an <span class="s1">integer</span> identifier.<span class="Apple-converted-space">  </span>The genomic element type for a genomic element is normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p1"><b>5.5<span class="Apple-converted-space">  </span>Class GenomicElementType</b></p>
<p class="p2"><i>5.5.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>GenomicElementType</i></span><i> properties</i></p>
<p class="p3">color &lt;–&gt; (string$)</p>
<p class="p4">The color used to display genomic elements of this type in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">color</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default color scheme is used; this is the default for new <span class="s1">GenomicElementType</span> objects.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this genomic element type; for genomic element type <span class="s1">g3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">mutationFractions =&gt; (float)</p>
<p class="p4">For each <span class="s1">MutationType</span> represented in this genomic element type, this property has the corresponding fraction of all mutations that will be drawn from that <span class="s1">MutationType</span><span class="s2">.</span></p>
<p class="p5"><span class="s3">mutationMatrix =&gt; (float)</span></p>
<p class="p6"><span class="s3">The nucleotide mutation matrix used for this genomic element type, set up by </span><span class="s4">initializeGenomicElementType()</span><span class="s3"> and </span><span class="s4">setMutationMatrix()</span><span class="s3">.<span class="Apple-converted-space">  </span>This property is only defined in nucleotide-based models; it is unavailable otherwise.</span></p>
<p class="p3">mutationTypes =&gt; (object&lt;MutationType&gt;)</p>
<p class="p4">The <span class="s1">MutationType</span> instances used by this genomic element type.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods, for another way of attaching state to genomic element types.</p>
<p class="p8"><span class="s9"><i>5.5.2<span class="Apple-converted-space">  </span></i></span><i>GenomicElementType</i><span class="s9"><i> methods</i></span></p>
<p class="p3">–<span class="s8"> </span>(*)getValue(string$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">GenomicElementType</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">– (void)setMutationFractions(io&lt;MutationType&gt; mutationTypes, numeric proportions)</p>
<p class="p4">Set the mutation type fractions contributing to a genomic element type.<span class="Apple-converted-space">  </span>The <span class="s1">mutationTypes</span> vector should supply the mutation types used by the genomic element (either as <span class="s1">MutationType</span> objects or as <span class="s1">integer</span> identifiers), and the <span class="s1">proportions</span> vector should be of equal length, specifying the relative proportion of mutations that will be drawn from each corresponding type.<span class="Apple-converted-space">  </span>This is normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p5"><span class="s3">– (void)setMutationMatrix(float mutationMatrix)</span></p>
<p class="p6"><span class="s3">Sets a new nucleotide mutation matrix for the genomic element type.<span class="Apple-converted-space">  </span>This replaces the mutation matrix originally set by </span><span class="s4">initializeGenomicElementType()</span><span class="s3">.<span class="Apple-converted-space">  </span>This method may only be called in nucleotide-based models.</span></p>
<p class="p3">–<span class="s8"> </span>(void)setValue(string$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span>.<span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span><span class="s6">If </span><span class="s10">value</span><span class="s6"> is of type </span><span class="s10">object</span><span class="s6">, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only </span><span class="s10">Mutation</span><span class="s6"> and </span><span class="s10">Substitution</span><span class="s6"> presently are (see the Eidos manual’s documentation for </span><span class="s10">defineConstant()</span><span class="s6"> for further discussion).<span class="Apple-converted-space">  </span></span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">GenomicElementType</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p1"><b>5.6<span class="Apple-converted-space">  </span>Class Individual</b></p>
<p class="p2"><i>5.6.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Individual</i></span><i> properties</i></p>
<p class="p3">age <span class="s5">&lt;–&gt;</span> (integer$)</p>
<p class="p6"><span class="s3">The age of the individual, measured in generation “ticks”.<span class="Apple-converted-space">  </span>A newly generated offspring individual will have an age of </span><span class="s4">0</span><span class="s3"> in the same generation in which is was created.<span class="Apple-converted-space">  </span>The age of every individual is incremented by one at the same point that the generation counter is incremented.<span class="Apple-converted-space">  </span>The age of individuals may be changed; usually this only makes sense when setting up the initial state of a model, however.</span></p>
<p class="p3">color &lt;–&gt; (string$)</p>
<p class="p4">The color used to display the individual in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">color</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default (fitness-based) color scheme is used; this is the default for new <span class="s1">Individual</span> objects.</p>
<p class="p5"><span class="s3">fitnessScaling &lt;–&gt; (float$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">float</span><span class="s3"> scaling factor applied to the individual’s fitness (i.e., the fitness value computed for the individual will be multiplied by this value).<span class="Apple-converted-space">  </span>This provides a simple, fast way to modify the fitness of an individual; conceptually it is similar to returning a fitness effect for the individual from a </span><span class="s4">fitness(NULL)</span><span class="s3"> callback, but without the complexity and performance overhead of implementing such a callback.<span class="Apple-converted-space">  </span>To scale the fitness of all individuals in a subpopulation by the same factor, see the </span><span class="s4">fitnessScaling</span><span class="s3"> property of </span><span class="s4">Subpopulation</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The value of </span><span class="s4">fitnessScaling</span><span class="s3"> is reset to </span><span class="s4">1.0</span><span class="s3"> every generation, so that any scaling factor set lasts for only a single generation.<span class="Apple-converted-space">  </span>This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.</span></p>
<p class="p3">genomes =&gt; (object&lt;Genome&gt;)</p>
<p class="p6"><span class="s6">The pair of </span><span class="s10">Genome</span><span class="s6"> objects associated with this individual.</span><span class="s3"><span class="Apple-converted-space">  </span>If only one of the two genomes is desired, the </span><span class="s4">genome1</span><span class="s3"> or </span><span class="s4">genome2</span><span class="s3"> property may be used.</span></p>
<p class="p5"><span class="s3">genome1 =&gt; (object&lt;Genome&gt;$)</span></p>
<p class="p6"><span class="s3">The first </span><span class="s4">Genome</span><span class="s3"> object associated with this individual.<span class="Apple-converted-space">  </span>This property is particularly useful when you want the first genome from each of a vector of individuals, as often arises in haploid models.</span></p>
<p class="p5"><span class="s3">genome2 =&gt; (object&lt;Genome&gt;$)</span></p>
<p class="p6"><span class="s3">The second </span><span class="s4">Genome</span><span class="s3"> object associated with this individual.<span class="Apple-converted-space">  </span>This property is particularly useful when you want the second genome from each of a vector of individuals, as often arises in haploid models.</span></p>
<p class="p3">index =&gt; (integer$)</p>
<p class="p4">The index of the individual in the <span class="s1">individuals</span> vector of its <span class="s1">Subpopulation</span><span class="s2">.</span></p>
<p class="p5"><span class="s3">migrant =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">Set to </span><span class="s4">T</span><span class="s3"> if the individual migrated during the current generation, </span><span class="s4">F</span><span class="s3"> otherwise.</span></p>
<p class="p6"><span class="s3">In WF models, this flag is set at the point when a new child is generated if it is a migrant (i.e., if its source subpopulation is not the same as its subpopulation), and remains valid, with the same value, for the rest of the individual’s lifetime.</span></p>
<p class="p6"><span class="s3">In nonWF models, this flag is </span><span class="s4">F</span><span class="s3"> for all new individuals, is set to </span><span class="s4">F</span><span class="s3"> in all individuals at the end of the reproduction generation cycle stage, and is set to </span><span class="s4">T</span><span class="s3"> on all individuals moved to a new subpopulation by </span><span class="s4">takeMigrants()</span><span class="s3">; the </span><span class="s4">T</span><span class="s3"> value set by </span><span class="s4">takeMigrants()</span><span class="s3"> will remain until it is reset at the end of the next reproduction generation cycle stage.</span></p>
<p class="p3">pedigreeID =&gt; (integer$)</p>
<p class="p6">A unique non-negative identifier for each individual in a simulation, never re-used throughout the duration of the simulation run.</p>
<p class="p3">pedigreeParentIDs =&gt; (integer)</p>
<p class="p6">Contains the values of <span class="s1">pedigreeID</span> that were possessed by the parents of an individual; it is thus a vector of two values.<span class="Apple-converted-space">  </span>Parental values may be <span class="s1">-1</span> if insufficient generations have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).</p>
<p class="p3">pedigreeGrandparentIDs =&gt; (integer)</p>
<p class="p6">Contains the values of <span class="s1">pedigreeID</span> that were possessed by the grandparents of an individual; it is thus a vector of four values.<span class="Apple-converted-space">  </span>Grandparental values may be <span class="s1">-1</span> if insufficient generations have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).</p>
<p class="p3">sex =&gt; (string$)</p>
<p class="p4">The sex of the individual.<span class="Apple-converted-space">  </span>This will be <span class="s1">"H"</span> if sex is not enabled in the simulation (i.e., for hermaphrodites), otherwise <span class="s1">"F"</span> or <span class="s1">"M"</span> as appropriate.</p>
<p class="p3">spatialPosition =&gt; (float)</p>
<p class="p4">The spatial position of the individual.<span class="Apple-converted-space">  </span>The length of the <span class="s1">spatialPosition</span> property (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>If the spatial dimensionality is zero (as it is by default), it is an error to access this property.<span class="Apple-converted-space">  </span>The elements of this property are identical to the values of the <span class="s1">x</span>, <span class="s1">y</span>, and <span class="s1">z</span> properties (if those properties are encompassed by the spatial dimensionality of the simulation).<span class="Apple-converted-space">  </span>In other words, if the declared dimensionality is <span class="s1">"xy"</span><span class="s2">,</span> the <span class="s1">individual.spatialPosition</span> property is equivalent to <span class="s1">c(individual.x, individual.y)</span>; <span class="s1">individual.z</span> is not used since it is not encompassed by the simulation’s dimensionality.</p>
<p class="p3">subpopulation =&gt; (object&lt;Subpopulation&gt;$)</p>
<p class="p4">The <span class="s1">Subpopulation</span> object to which the individual belongs.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value (as opposed to <span class="s1">tagF</span>, which is of type <span class="s1">float</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods, for another way of attaching state to individuals.</p>
<p class="p4">Note that the <span class="s1">Individual</span> objects used by SLiM are (conceptually) new with every generation, so the <span class="s1">tag</span> value of each new offspring generated in each generation will be initially undefined.<span class="Apple-converted-space">  </span>If you set a <span class="s1">tag</span> value for an offspring individual inside a <span class="s1">modifyChild()</span> callback, that <span class="s1">tag</span> value will be preserved as the offspring individual becomes a parent (across the generation boundary, in other words).<span class="Apple-converted-space">  </span>If you take advantage of this, however, you should be careful to set up initial values for the tag values of <i>all</i> offspring, otherwise undefined initial values might happen to match the values that you are trying to use to tag particular individuals.<span class="Apple-converted-space">  </span>A rule of thumb in programming: undefined values should always be assumed to take on the most inconvenient value possible.</p>
<p class="p3">tagF &lt;–&gt; (float$)</p>
<p class="p4">A user-defined <span class="s1">float</span> value (as opposed to <span class="s1">tag</span>, which is of type <span class="s1">integer</span>).<span class="Apple-converted-space">  </span>The value of <span class="s1">tagF</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tagF</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods, for another way of attaching state to individuals.</p>
<p class="p4">Note that at present, although many classes in SLiM have an <span class="s1">integer</span>-type <span class="s1">tag</span> property, only <span class="s1">Individual</span> has a <span class="s1">float</span>-type <span class="s1">tagF</span> property, because attaching model state to individuals seems to be particularly common and useful.<span class="Apple-converted-space">  </span>If a <span class="s1">tagF</span> property would be helpful on another class, it would be easy to add.</p>
<p class="p4">See the description of the <span class="s1">tag</span> property above for additional comments.</p>
<p class="p3">uniqueMutations =&gt; (object&lt;Mutation&gt;)</p>
<p class="p4">All of the <span class="s1">Mutation</span> objects present in this individual.<span class="Apple-converted-space">  </span>Mutations present in both genomes will occur only once in this property, and the mutations will be given in sorted order by <span class="s1">position</span>, so this property is similar to <span class="s1">sortBy(unique(individual.genomes.mutations), "position")</span><span class="s2">.</span><span class="Apple-converted-space">  </span>It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by <span class="s1">sortBy()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is provided primarily for speed; it executes much faster than the Eidos equivalent above.<span class="Apple-converted-space">  </span>Indeed, it is faster than just <span class="s1">individual.genomes.mutations</span>, and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.</p>
<p class="p3">x &lt;–&gt; (float$)</p>
<p class="p4">A user-defined <span class="s1">float</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">x</span> is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>The value of <span class="s1">x</span> is not used by SLiM unless the optional “continuous space” facility is enabled with the <span class="s1">dimensionality</span> parameter to <span class="s1">initializeSLiMOptions()</span>, in which case <span class="s1">x</span> will be understood to represent the <i>x</i> coordinate of the individual in space.<span class="Apple-converted-space">  </span>If continuous space is not enabled, you may use <span class="s1">x</span> as an additional tag value of type <span class="s1">float</span><span class="s2">.</span></p>
<p class="p3">y &lt;–&gt; (float$)</p>
<p class="p4">A user-defined <span class="s1">float</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">y</span> is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>The value of <span class="s1">y</span> is not used by SLiM unless the optional “continuous space” facility is enabled with the <span class="s1">dimensionality</span> parameter to <span class="s1">initializeSLiMOptions()</span>, in which case <span class="s1">y</span> will be understood to represent the <i>y</i> coordinate of the individual in space (if the dimensionality is <span class="s1">"xy"</span> or <span class="s1">"xyz"</span>).<span class="Apple-converted-space">  </span>If continuous space is not enabled, or the dimensionality is not <span class="s1">"xy"</span> or <span class="s1">"xyz"</span>, you may use <span class="s1">y</span> as an additional tag value of type <span class="s1">float</span><span class="s2">.</span></p>
<p class="p3">z &lt;–&gt; (float$)</p>
<p class="p4">A user-defined <span class="s1">float</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">z</span> is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a <span class="s1">modifyChild()</span> callback.<span class="Apple-converted-space">  </span>The value of <span class="s1">z</span> is not used by SLiM unless the optional “continuous space” facility is enabled with the <span class="s1">dimensionality</span> parameter to <span class="s1">initializeSLiMOptions()</span>, in which case <span class="s1">z</span> will be understood to represent the <i>z</i> coordinate of the individual in space (if the dimensionality is <span class="s1">"xyz"</span>).<span class="Apple-converted-space">  </span>If continuous space is not enabled, or the dimensionality is not <span class="s1">"xyz"</span>, you may use <span class="s1">z</span> as an additional tag value of type <span class="s1">float</span><span class="s2">.</span></p>
<p class="p2"><i>5.6.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Individual</i></span><i> methods</i></p>
<p class="p3">– (logical)containsMutations(object&lt;Mutation&gt; mutations)</p>
<p class="p4">Returns a <span class="s1">logical</span> vector indicating whether each of the mutations in <span class="s1">mutations</span> is present in the individual (in either of its genomes); each element in the returned vector indicates whether the corresponding mutation is present (<span class="s1">T</span>) or absent (<span class="s1">F</span>).<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">–<span class="s8"> </span>(integer$)countOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the number of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the individual (in both of its genomes; a mutation that is present in both genomes counts twice).<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just a count, use the <span class="s1">Genome</span> method <span class="s1">-mutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">–<span class="s8"> </span>(*)getValue(string$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">Individual</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">–<span class="s8"> </span>(float)relatedness(object&lt;Individual&gt;<span class="s8"> </span>individuals)</p>
<p class="p6">Returns a vector containing the degrees of relatedness between the receiver and each of the individuals in <span class="s1">individuals</span>.<span class="Apple-converted-space">  </span>The relatedness between <span class="s1">A</span> and <span class="s1">B</span> is always <span class="s1">1.0</span> if <span class="s1">A</span> and <span class="s1">B</span> are actually the same individual.<span class="Apple-converted-space">  </span>Otherwise, this method will use the pedigree information described in section 24.6.1 to construct a relatedness estimate.<span class="Apple-converted-space">  </span>More specifically, if information about the grandparental generation is available, then each grandparent shared by <span class="s1">A</span> and <span class="s1">B</span> contributes <span class="s1">0.125</span> towards the total relatedness, for a maximum value of <span class="s1">0.5</span> with four shared grandparents.<span class="Apple-converted-space">  </span>If grandparental information in unavailable, then if parental information is available it is used, with each parent shared by <span class="s1">A</span> and <span class="s1">B</span> contributing <span class="s1">0.25</span>, again for a maximum of <span class="s1">0.5</span>.<span class="Apple-converted-space">  </span>If even parental information is unavailable, then the relatedness is assumed to be <span class="s1">0.0</span>.<span class="Apple-converted-space">  </span>Again, however, if <span class="s1">A</span> and <span class="s1">B</span> are the same individual, the relatedness will be <span class="s1">1.0</span> in all cases.</p>
<p class="p4">Note that this relatedness is simply pedigree-based relatedness.<span class="Apple-converted-space">  </span>This does not necessarily correspond to genetic relatedness, because of the effects of factors like assortment and recombination.</p>
<p class="p5"><span class="s3">+ (void)setSpatialPosition(float position)</span></p>
<p class="p6"><span class="s3">Sets the spatial position of the individual (as accessed through the </span><span class="s4">spatialPosition</span><span class="s3"> property).<span class="Apple-converted-space">  </span>The length of </span><span class="s4">position</span><span class="s3"> (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.<span class="Apple-converted-space">  </span>If the spatial dimensionality is zero (as it is by default), it is an error to call this method.<span class="Apple-converted-space">  </span>The elements of </span><span class="s4">position</span><span class="s3"> are set into the values of the </span><span class="s4">x</span><span class="s3">, </span><span class="s4">y</span><span class="s3">, and </span><span class="s4">z</span><span class="s3"> properties (if those properties are encompassed by the spatial dimensionality of the simulation).<span class="Apple-converted-space">  </span>In other words, if the declared dimensionality is </span><span class="s4">"xy"</span><span class="s3">, calling </span><span class="s4">individual.setSpatialPosition(c(1.0, 0.5))</span><span class="s3"> property is equivalent to </span><span class="s4">individual.x = 1.0; individual.y = 0.5</span><span class="s3">; </span><span class="s4">individual.z</span><span class="s3"> is not set (even if a third value is supplied in </span><span class="s4">position</span><span class="s3">) since it is not encompassed by the simulation’s dimensionality in this example.</span></p>
<p class="p6"><span class="s3">Note that this is an Eidos class method, somewhat unusually, which allows it to work in a special way when called on a vector of individuals.<span class="Apple-converted-space">  </span>When the target vector of individuals is non-singleton, this method can do one of two things.<span class="Apple-converted-space">  </span>If </span><span class="s4">position</span><span class="s3"> contains just a single point (i.e., is equal in length to the spatial dimensionality of the model), the spatial position of all of the target individuals will be set to the given point.<span class="Apple-converted-space">  </span>Alternatively, if </span><span class="s4">position</span><span class="s3"> contains one point per target individual (i.e., is equal in length to the number of individuals multiplied by the spatial dimensionality of the model), the spatial position of each target individual will be set to the corresponding point from </span><span class="s4">position</span><span class="s3"> (where the point data is concatenated, not interleaved, just as it would be returned by accessing the </span><span class="s4">spatialPosition</span><span class="s3"> property on the vector of target individuals).<span class="Apple-converted-space">  </span>Calling this method with a </span><span class="s4">position</span><span class="s3"> vector of any other length is an error.</span></p>
<p class="p3">–<span class="s8"> </span>(void)setValue(string$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span><span class="s2">.</span><span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span><span class="s6">If </span><span class="s10">value</span><span class="s6"> is of type </span><span class="s10">object</span><span class="s6">, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only </span><span class="s10">Mutation</span><span class="s6"> and </span><span class="s10">Substitution</span><span class="s6"> presently are (see the Eidos manual’s documentation for </span><span class="s10">defineConstant()</span><span class="s6"> for further discussion).<span class="Apple-converted-space">  </span></span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">Individual</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">–<span class="s8"> </span>(float$)sumOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the sum of the selection coefficients of all mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the genomes of the individual.<span class="Apple-converted-space">  </span>This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, <span class="s1">sumOfMutationsOfType()</span> will provide the sum of the additive effects of the QTLs for the given mutation type.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="Apple-converted-space">  </span>Note that this method also exists on <span class="s1">Genome</span>, for cases in which the sum for just one genome is desired.</p>
<p class="p3">–<span class="s8"> </span>(object&lt;Mutation&gt;)uniqueMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns an <span class="s1">object</span> vector of all the mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations in the individual.<span class="Apple-converted-space">  </span>Mutations present in both genomes will occur only once in the result of this method, and the mutations will be given in sorted order by <span class="s1">position</span>, so this method is similar to <span class="s1">sortBy(unique(individual.genomes.mutationsOfType(mutType)), "position")</span><span class="s2">.</span><span class="Apple-converted-space">  </span>It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by <span class="s1">sortBy()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>If you just need a count of the matching <span class="s1">Mutation</span> objects, rather than a vector of the matches, use <span class="s1">-countOfMutationsOfType()</span>.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.<span class="Apple-converted-space">  </span>Indeed, it is faster than just <span class="s1">individual.genomes.mutationsOfType(mutType)</span>, and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.</p>
<p class="p1"><b>17</b><span class="s11"><b>.</b></span><b>7<span class="Apple-converted-space">  </span>Class InteractionType</b></p>
<p class="p2"><i>17</i><span class="s11"><i>.</i></span><i>7.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>InteractionType</i></span><i> properties</i></p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this interaction type; for interaction type <span class="s1">i3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">maxDistance &lt;–&gt; (float$)</p>
<p class="p4">The maximum distance over which this interaction will be evaluated.<span class="Apple-converted-space">  </span>For inter-individual distances greater than <span class="s1">maxDistance</span><span class="s2">,</span> the interaction strength will be zero.</p>
<p class="p3">reciprocal =&gt; (logical$)</p>
<p class="p4">The reciprocality of the interaction, as specified in <span class="s1">initializeInteractionType()</span>.<span class="Apple-converted-space">  </span>This will be <span class="s1">T</span> for reciprocal interactions (those for which the interaction strength of B upon A is equal to the interaction strength of A upon B), and <span class="s1">F</span> otherwise.</p>
<p class="p3">sexSegregation =&gt; (string$)</p>
<p class="p4">The sex-segregation of the interaction, as specified in <span class="s1">initializeInteractionType()</span>.<span class="Apple-converted-space">  </span>For non-sexual simulations, this will be <span class="s1">"**"</span><span class="s2">.</span><span class="Apple-converted-space">  </span>For sexual simulations, this <span class="s1">string</span> value indicates the sex of individuals feeling the interaction, and the sex of individuals exerting the interaction; see <span class="s1">initializeInteractionType()</span> for details.</p>
<p class="p3">spatiality =&gt; (string$)</p>
<p class="p4">The spatial dimensions used by the interaction, as specified in <span class="s1">initializeInteractionType()</span>.<span class="Apple-converted-space">  </span>This will be <span class="s1">""</span> (the empty string) for non-spatial interactions, or <span class="s1">"x"</span>, <span class="s1">"y"</span>, <span class="s1">"z"</span>, <span class="s1">"xy"</span>, <span class="s1">"xz"</span>, <span class="s1">"yz"</span>, or <span class="s1">"xyz"</span>, for interactions using those spatial dimensions respectively.<span class="Apple-converted-space">  </span>The specified dimensions are used to calculate the distances between individuals for this interaction.<span class="Apple-converted-space">  </span>The value of this property is always the same as the value given to <span class="s1">initializeInteractionType()</span><span class="s2">.</span></p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods, for another way of attaching state to interaction types.</p>
<p class="p2"><i>17</i><span class="s11"><i>.</i></span><i>7.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>InteractionType</i></span><i> methods</i></p>
<p class="p3">– (float)distance(object&lt;Individual&gt; individuals1, [No&lt;Individual&gt; individuals2 = NULL])</p>
<p class="p6"><span class="s3">Returns a vector containing distances between individuals in </span><span class="s4">individuals1</span><span class="s3"> and </span><span class="s4">individuals2</span><span class="s3">.<span class="Apple-converted-space">  </span>At least one of </span><span class="s4">individuals1</span><span class="s3"> or </span><span class="s4">individuals2</span><span class="s3"> must be singleton, so that the distances evaluated are either from one individual to many, or from many to one (which are equivalent, in fact); evaluating distances for many to many individuals cannot be done in a single call.<span class="Apple-converted-space">  </span>(There is one exception: if both </span><span class="s4">individuals1</span><span class="s3"> and </span><span class="s4">individuals2</span><span class="s3"> are zero-length or </span><span class="s4">NULL</span><span class="s3">, a zero-length float vector will be returned.)<span class="Apple-converted-space">  </span>If </span><span class="s4">individuals2</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> (the default), then </span><span class="s4">individuals1</span><span class="s3"> must be singleton, and a vector of the distances from that individual to all individuals in its subpopulation (including itself) is returned; this case may be handled differently internally, for greater speed, so supplying </span><span class="s4">NULL</span><span class="s3"> is preferable to supplying the vector of all individuals in the subpopulation explicitly even though that should produce identical results.<span class="Apple-converted-space">  </span>If the </span><span class="s4">InteractionType</span><span class="s3"> is non-spatial, this method may not be called.</span></p>
<p class="p6"><span class="s3">Importantly, distances are calculated according to the spatiality of the </span><span class="s4">InteractionType</span><span class="s3"> (as declared in </span><span class="s4">initializeInteractionType()</span><span class="s3">), not the dimensionality of the model as a whole (as declared in </span><span class="s4">initializeSLiMOptions()</span><span class="s3">).<span class="Apple-converted-space">  </span>The distances returned are therefore the distances that would be used to calculate interaction strengths.<span class="Apple-converted-space">  </span>However, </span><span class="s4">distance()</span><span class="s3"> will return finite distances for all pairs of individuals, even if the individuals are non-interacting; the </span><span class="s4">distance()</span><span class="s3"> between an individual and itself will thus be </span><span class="s4">0</span><span class="s3">.<span class="Apple-converted-space">  </span>See </span><span class="s4">interactionDistance()</span><span class="s3"> for an alternative distance definition.</span></p>
<p class="p3">– (float)distanceToPoint(object&lt;Individual&gt; individuals1, float point)</p>
<p class="p6"><span class="s3">Returns a vector containing distances between individuals in </span><span class="s4">individuals1</span><span class="s3"> and the point given by the spatial coordinates in </span><span class="s4">point</span><span class="s3">.<span class="Apple-converted-space">  </span>The </span><span class="s4">point</span><span class="s3"> vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if the interaction type’s spatiality is </span><span class="s4">"xz"</span><span class="s3">, for example, then </span><span class="s4">point[0]</span><span class="s3"> is assumed to be an <i>x</i> value, and </span><span class="s4">point[1]</span><span class="s3"> is assumed to be a <i>z</i> value.<span class="Apple-converted-space">  </span>Be careful; this means that in general it is not safe to pass an individual’s </span><span class="s4">spatialPosition</span><span class="s3"> property for </span><span class="s4">point</span><span class="s3">, for example (although it is safe if the spatiality of the interaction matches the dimensionality of the simulation).<span class="Apple-converted-space">  </span>A coordinate for a periodic spatial dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic bounds are meaningless (</span><span class="s4">pointPeriodic()</span><span class="s3"> may be used to ensure this); coordinates for non-periodic spatial dimensions are not restricted.</span></p>
<p class="p4">Importantly, distances are calculated according to the spatiality of the <span class="s1">InteractionType</span> (as declared in <span class="s1">initializeInteractionType()</span>) not the dimensionality of the model as a whole (as declared in <span class="s1">initializeSLiMOptions()</span>).<span class="Apple-converted-space">  </span>The distances are therefore interaction distances: the distances that are used to calculate interaction strengths.<span class="Apple-converted-space">  </span>If the <span class="s1">InteractionType</span> is non-spatial, this method may not be called.<span class="Apple-converted-space">  </span>The vector <span class="s1">point</span> must be exactly as long as the spatiality of the <span class="s1">InteractionType</span><span class="s2">.</span></p>
<p class="p3">– (object&lt;Individual&gt;)drawByStrength(object&lt;Individual&gt;$ individual, [integer$ count = 1])</p>
<p class="p6"><span class="s3">Returns up to </span><span class="s4">count</span><span class="s3"> individuals drawn from the subpopulation of </span><span class="s4">individual</span><span class="s3">.<span class="Apple-converted-space">  </span>The probability of drawing particular individuals is proportional to the strength of interaction they exert upon </span><span class="s4">individual</span><span class="s3">.<span class="Apple-converted-space">  </span>This method may be used with either spatial or non-spatial interactions, but will be more efficient with spatial interactions that set a short maximum interaction distance.<span class="Apple-converted-space">  </span>Draws are done with replacement, so the same individual may be drawn more than once; sometimes using </span><span class="s4">unique()</span><span class="s3"> on the result of this call is therefore desirable.<span class="Apple-converted-space">  </span>If more than one draw will be needed, it is much more efficient to use a single call to </span><span class="s4">drawByStrength()</span><span class="s3">, rather than drawing individuals one at a time.<span class="Apple-converted-space">  </span>Note that if no individuals exert a non-zero interaction upon </span><span class="s4">individual</span><span class="s3">, the vector returned will be zero-length; it is important to consider this possibility.</span></p>
<p class="p6"><span class="s3">If the needed interaction strengths have already been calculated, those cached values are simply used.<span class="Apple-converted-space">  </span>Otherwise, calling this method triggers evaluation of the needed interactions, including calls to any applicable </span><span class="s4">interaction()</span><span class="s3"> callbacks.</span></p>
<p class="p3">– (void)evaluate([No&lt;Subpopulation&gt; subpops = NULL], [logical$ immediate = F])</p>
<p class="p4">Triggers evaluation of the interaction for the subpopulations specified by <span class="s1">subpops</span> (or for all subpopulations, if <span class="s1">subpops</span> is <span class="s1">NULL</span>).<span class="Apple-converted-space">  </span>By default, the effects of this may be limited, however, since the underlying implementation may choose to postpone some computations lazily.<span class="Apple-converted-space">  </span>At a minimum, is it guaranteed that this method will discard all previously cached data for the subpopulation(s), and will cache the current spatial positions of all individuals (so that individuals may then move without disturbing the state of the interaction at the moment of evaluation).<span class="Apple-converted-space">  </span>Notably, <span class="s1">interaction()</span> callbacks may not be called in response to this method; instead, their evaluation may be deferred until required to satisfy queries (at which point the generation counter may have advanced by one, so be careful with the generation ranges used in defining such callbacks).</p>
<p class="p6"><span class="s3">If </span><span class="s4">T</span><span class="s3"> is passed for </span><span class="s4">immediate</span><span class="s3">, the interaction will immediately and synchronously evaluate all interactions between all individuals in the subpopulation(s), calling any applicable </span><span class="s4">interaction()</span><span class="s3"> callbacks as necessary – if the interaction is spatial (see below).<span class="Apple-converted-space">  </span>However, depending upon what queries are later executed, this may represent considerable wasted computation.<span class="Apple-converted-space">  </span>Immediate evaluation usually generates only a slight performance improvement even if the interactions between all pairs of individuals are eventually accessed; the main reason to choose immediate evaluation, then, is that deferred calculation of interactions would lead to incorrect results due to changes in model state.<span class="Apple-converted-space">  </span>For non-spatial interactions, distances and interaction strengths are never cached since such caching would require O(N</span><span class="s12"><sup>2</sup></span><span class="s3">) memory and time, which is deemed unacceptable in general; for non-spatial interactions, the </span><span class="s4">immediate</span><span class="s3"> parameter is therefore ignored.</span></p>
<p class="p6"><span class="s3">You must explicitly call </span><span class="s4">evaluate()</span><span class="s3"> at an appropriate time in the life cycle before the interaction is used, but after any relevant changes have been made to the population.<span class="Apple-converted-space">  </span>SLiM will invalidate any existing interactions after any portion of the generation cycle in which new individuals have been born or existing individuals have died.<span class="Apple-converted-space">  </span>In a WF model, these events occur just before </span><span class="s4">late()</span><span class="s3"> events execute (see the WF generation cycle diagram), so </span><span class="s4">late()</span><span class="s3"> events are often the appropriate place to put </span><span class="s4">evaluate()</span><span class="s3"> calls, but </span><span class="s4">early()</span><span class="s3"> events can work too if the interaction is not needed until that point in the generation cycle anyway. In nonWF models, on the other hand, new offspring are produced just before </span><span class="s4">early()</span><span class="s3"> events and then individuals die just before </span><span class="s4">late()</span><span class="s3"> events (see the nonWF generation cycle diagram), so interactions will be invalidated twice during each generation cycle.<span class="Apple-converted-space">  </span>This means that in a nonWF model, an interaction that influences reproduction should usually be evaluated in a </span><span class="s4">late()</span><span class="s3"> event, while an interaction that influences fitness or mortality should usually be evaluated in an </span><span class="s4">early()</span><span class="s3"> event (and an interaction that affects both may need to be evaluated at both times).</span></p>
<p class="p4">If an interaction is never evaluated for a given subpopulation, it is guaranteed that there will be essentially no memory or computational overhead associated with the interaction for that subpopulation.<span class="Apple-converted-space">  </span>Furthermore, attempting to query an interaction for an individual in a subpopulation that has not been evaluated is guaranteed to raise an error.</p>
<p class="p3">–<span class="s8"> </span>(*)getValue(string$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">InteractionType</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p5"><span class="s3">– (integer)interactingNeighborCount(object&lt;Individual&gt; individuals)</span></p>
<p class="p6"><span class="s3">Returns the number of interacting individuals for each individual in </span><span class="s4">individuals</span><span class="s3">, within the maximum interaction distance according to the distance metric of the </span><span class="s4">InteractionType</span><span class="s3">.<span class="Apple-converted-space">  </span>More specifically, this method counts the number of individuals which can <i>exert</i> an interaction <i>upon</i> each focal individual; it does not count individuals which only <i>feel</i> an interaction <i>from</i> a focal individual.<span class="Apple-converted-space">  </span>This method is similar to </span><span class="s4">nearestInteractingNeighbors()</span><span class="s3"> (when passed a large count so as to guarantee that all interacting individuals are returned), but this method returns only a count of the interacting individuals, not a vector containing the individuals.<span class="Apple-converted-space">  </span>This method may also be called in a vectorized fashion, with a non-singleton vector of individuals, unlike </span><span class="s4">nearestInteractingNeighbors()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">Note that this method uses interaction eligibility as a criterion; it will not count neighbors that cannot exert an interaction upon a focal individual (due to sex-segregation, e.g.).<span class="Apple-converted-space">  </span>(It also does not count a focal individual as a neighbor of itself.)</span></p>
<p class="p5"><span class="s3">– (float)interactionDistance(object&lt;Individual&gt;$ receiver, [No&lt;Individual&gt; exerters = NULL])</span></p>
<p class="p6"><span class="s3">Returns a vector containing interaction-dependent distances between </span><span class="s4">receiver</span><span class="s3"> and individuals in </span><span class="s4">exerters</span><span class="s3"> that exert an interaction strength upon </span><span class="s4">receiver</span><span class="s3">.<span class="Apple-converted-space">  </span>If </span><span class="s4">exerters</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> (the default), then a vector of the interaction-dependent distances from </span><span class="s4">receiver</span><span class="s3"> to all individuals in its subpopulation (including </span><span class="s4">receiver</span><span class="s3"> itself) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.<span class="Apple-converted-space">  </span>If the </span><span class="s4">InteractionType</span><span class="s3"> is non-spatial, this method may not be called.</span></p>
<p class="p6"><span class="s3">Importantly, distances are calculated according to the spatiality of the </span><span class="s4">InteractionType</span><span class="s3"> (as declared in </span><span class="s4">initializeInteractionType()</span><span class="s3">), not the dimensionality of the model as a whole (as declared in </span><span class="s4">initializeSLiMOptions()</span><span class="s3">).<span class="Apple-converted-space">  </span>The distances returned are therefore the distances that would be used to calculate interaction strengths.<span class="Apple-converted-space">  </span>In addition, </span><span class="s4">interactionDistance()</span><span class="s3"> will return </span><span class="s4">INF</span><span class="s3"> as the distance between </span><span class="s4">receiver</span><span class="s3"> and any individual which does not exert an interaction upon </span><span class="s4">receiver</span><span class="s3">; the </span><span class="s4">interactionDistance()</span><span class="s3"> between an individual and itself will thus be </span><span class="s4">INF</span><span class="s3">, and likewise for pairs excluded from interacting by the sex segregation or max distance of the interaction type.<span class="Apple-converted-space">  </span>See </span><span class="s4">distance()</span><span class="s3"> for an alternative distance definition.</span></p>
<p class="p5"><span class="s3">– (object&lt;Individual&gt;)nearestInteractingNeighbors(object&lt;Individual&gt;$ individual, [integer$ count = 1])</span></p>
<p class="p6"><span class="s3">Returns up to </span><span class="s4">count</span><span class="s3"> interacting individuals that are spatially closest to </span><span class="s4">individual</span><span class="s3">, according to the distance metric of the </span><span class="s4">InteractionType</span><span class="s3">.<span class="Apple-converted-space">  </span>More specifically, this method returns only individuals which can <i>exert</i> an interaction <i>upon</i> the focal individual; it does not include individuals that only <i>feel</i> an interaction <i>from</i> the focal individual.<span class="Apple-converted-space">  </span>To obtain all of the interacting individuals within the maximum interaction distance of </span><span class="s4">individual</span><span class="s3">, simply pass a value for </span><span class="s4">count</span><span class="s3"> that is greater than or equal to the size of </span><span class="s4">individual</span><span class="s3">’s subpopulation.<span class="Apple-converted-space">  </span>Note that if fewer than </span><span class="s4">count</span><span class="s3"> interacting individuals are within the maximum interaction distance, the vector returned may be shorter than </span><span class="s4">count</span><span class="s3">, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.<span class="Apple-converted-space">  </span>If only the number of interacting individuals is needed, use </span><span class="s4">interactingNeighborCount()</span><span class="s3"> instead.</span></p>
<p class="p6"><span class="s3">Note that this method uses interaction eligibility as a criterion; it will not return neighbors that cannot exert an interaction upon the focal individual (due to sex-segregation, e.g.).<span class="Apple-converted-space">  </span>(It will also never return the focal individual as a neighbor of itself.)<span class="Apple-converted-space">  </span>To find all neighbors of the focal individual, whether they can interact with it or not, use </span><span class="s4">nearestNeighbors()</span><span class="s3">.</span></p>
<p class="p5"><span class="s3">– (object&lt;Individual&gt;)nearestNeighbors(object&lt;Individual&gt;$ individual, [integer$ count = 1])</span></p>
<p class="p6"><span class="s3">Returns up to </span><span class="s4">count</span><span class="s3"> individuals that are spatially closest to </span><span class="s4">individual</span><span class="s3">, according to the distance metric of the </span><span class="s4">InteractionType</span><span class="s3">.<span class="Apple-converted-space">  </span>To obtain all of the individuals within the maximum interaction distance of </span><span class="s4">individual</span><span class="s3">, simply pass a value for </span><span class="s4">count</span><span class="s3"> that is greater than or equal to the size of </span><span class="s4">individual</span><span class="s3">’s subpopulation.<span class="Apple-converted-space">  </span>Note that if fewer than </span><span class="s4">count</span><span class="s3"> individuals are within the maximum interaction distance, the vector returned may be shorter than </span><span class="s4">count</span><span class="s3">, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.</span></p>
<p class="p6"><span class="s3">Note that this method does not use interaction eligibility as a criterion; it will return neighbors that could not interact with the focal individual due to sex-segregation.<span class="Apple-converted-space">  </span>(It will never return the focal individual as a neighbor of itself, however.)<span class="Apple-converted-space">  </span>To find only neighbors that are eligible to exert an interaction upon the focal individual, use </span><span class="s4">nearestInteractingNeighbors()</span><span class="s3">.</span></p>
<p class="p3">– (object&lt;Individual&gt;)nearestNeighborsOfPoint(object&lt;Subpopulation&gt;$ subpop, float point, [integer$ count = 1])</p>
<p class="p4">Returns up to <span class="s1">count</span> individuals in <span class="s1">subpop</span> that are spatially closest to <span class="s1">point</span>, according to the distance metric of the <span class="s1">InteractionType</span><span class="s2">.</span><span class="Apple-converted-space">  </span>To obtain all of the individuals within the maximum interaction distance of <span class="s1">point</span>, simply pass a value for <span class="s1">count</span> that is greater than or equal to the size of <span class="s1">subpop</span>.<span class="Apple-converted-space">  </span>Note that if fewer than <span class="s1">count</span> individuals are within the maximum interaction distance, the vector returned may be shorter than <span class="s1">count</span>, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.</p>
<p class="p3">– (void)setInteractionFunction(string$ functionType, ...)</p>
<p class="p4">Set the function used to translate spatial distances into interaction strengths for an interaction type.<span class="Apple-converted-space">  </span>The <span class="s1">functionType</span> may be <span class="s1">"f"</span>, in which case the ellipsis <span class="s1">...</span> should supply a <span class="s1">numeric$</span> fixed interaction strength; <span class="s1">"l"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> maximum strength for a linear function; <span class="s1">"e"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> maximum strength and a <span class="s1">numeric$</span> lambda (shape) parameter for a negative exponential function; <span class="s5">; </span><span class="s7">"n"</span><span class="s5">, in which case the ellipsis should supply a </span><span class="s7">numeric$</span><span class="s5"> maximum strength and a </span><span class="s7">numeric$</span><span class="s5"> sigma (standard deviation) parameter for a Gaussian function; or </span><span class="s7">"c"</span><span class="s5">, in which case the ellipsis should supply a </span><span class="s7">numeric$</span><span class="s5"> maximum strength and a </span><span class="s7">numeric$</span><span class="s5"> scale parameter for a Cauchy distribution function</span>.<span class="Apple-converted-space">  </span>Non-spatial interactions must use function type <span class="s1">"f"</span>, since no distance values are available in that case.</p>
<p class="p4">The interaction function for an interaction type is normally a constant in simulations; in any case, it cannot be changed when an interaction has already been evaluated for a given generation of individuals.</p>
<p class="p3">–<span class="s8"> </span>(void)setValue(string$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span>.<span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span><span class="s6">If </span><span class="s10">value</span><span class="s6"> is of type </span><span class="s10">object</span><span class="s6">, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only </span><span class="s10">Mutation</span><span class="s6"> and </span><span class="s10">Substitution</span><span class="s6"> presently are (see the Eidos manual’s documentation for </span><span class="s10">defineConstant()</span><span class="s6"> for further discussion).<span class="Apple-converted-space">  </span></span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">InteractionType</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p5"><span class="s3">– (float)strength(object&lt;Individual&gt;$ receiver, [No&lt;Individual&gt; exerters = NULL])</span></p>
<p class="p6"><span class="s3">Returns a vector containing the interaction strengths exerted upon </span><span class="s4">receiver</span><span class="s3"> by the individuals in </span><span class="s4">exerters</span><span class="s3">.<span class="Apple-converted-space">  </span>If </span><span class="s4">exerters</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> (the default), then a vector of the interaction strengths exerted by all individuals in the subpopulation of </span><span class="s4">receiver</span><span class="s3"> (including </span><span class="s4">receiver</span><span class="s3"> itself) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.</span></p>
<p class="p6"><span class="s3">If the strengths of interactions exerted by a single individual upon multiple individuals is needed instead (the inverse of what this method provides), multiple calls to this method will be necessary, one per pairwise interaction queried; the interaction engine is not optimized for the inverse case, and so it will likely be quite slow to compute.<span class="Apple-converted-space">  </span>If the interaction is reciprocal and sex-symmetric, the opposite query should provide identical results in a single efficient call (because then the interactions exerted are equal to the interactions received); otherwise, the best approach might be to define a second interaction type representing the inverse interaction that you wish to be able to query efficiently.</span></p>
<p class="p6"><span class="s3">If the needed interaction strengths have already been calculated, those cached values are simply returned.<span class="Apple-converted-space">  </span>Otherwise, calling this method triggers evaluation of the needed interactions, including calls to any applicable </span><span class="s4">interaction()</span><span class="s3"> callbacks.</span></p>
<p class="p3">– (float)totalOfNeighborStrengths(object&lt;Individual&gt; individuals)</p>
<p class="p4">Returns a vector of the total interaction strength felt by each individual in <span class="s1">individuals</span>, which does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.<span class="Apple-converted-space">  </span>However, all of the individuals in <span class="s1">individuals</span> must be in the same subpopulation.</p>
<p class="p4">For one individual, this is essentially the same as calling <span class="s1">nearestNeighbors()</span> with a large <span class="s1">count</span> so as to obtain the complete vector of all neighbors, calling <span class="s1">strength()</span> for each of those interactions to get each interaction strength, and adding those interaction strengths together with <span class="s1">sum()</span>.<span class="Apple-converted-space">  </span>This method is much faster than that implementation, however, since all of that work is done as a single operation.<span class="Apple-converted-space">  </span>Also, <span class="s1">totalOfNeighborStrengths()</span> can total up interactions for more than one focal individual in a single call.</p>
<p class="p4">Similarly, for one individual this is essentially the same as calling <span class="s1">strength()</span> to get the interaction strengths between the focal individual and all other individuals, and then calling <span class="s1">sum()</span>.<span class="Apple-converted-space">  </span>Again, this method should be much faster, since this algorithm looks only at neighbors, whereas calling <span class="s1">strength()</span> directly assesses interaction strengths with all other individuals.<span class="Apple-converted-space">  </span>This will make a particularly large difference when the subpopulation size is large and the maximum distance of the <span class="s1">InteractionType</span> is small.</p>
<p class="p4">If the needed interaction strengths have already been calculated, those cached values are simply used.<span class="Apple-converted-space">  </span>Otherwise, calling this method triggers evaluation of the needed interactions, including calls to any applicable <span class="s1">interaction()</span> callbacks.</p>
<p class="p3">– (void)unevaluate(void)</p>
<p class="p6"><span class="s3">Discards all evaluation of this interaction, for all subpopulations.<span class="Apple-converted-space">  </span>The state of the </span><span class="s4">InteractionType</span><span class="s3"> is reset to a state prior to evaluation.<span class="Apple-converted-space">  </span>This can be useful if the model state has changed in such a way that the evaluation already conducted is no longer valid.<span class="Apple-converted-space">  </span>For example, if the maximum distance or the interaction function of the </span><span class="s4">InteractionType</span><span class="s3"> need to be changed with immediate effect, or if the data used by an </span><span class="s4">interaction()</span><span class="s3"> callback has changed in such a way that previously calculated interaction strengths are no longer correct, </span><span class="s4">unevaluate()</span><span class="s3"> allows the interaction to begin again from scratch.</span></p>
<p class="p6"><span class="s3">In WF models, all interactions are automatically reset to an unevaluated state at the moment when the new offspring generation becomes the parental generation (at step 4 in the generation cycle).</span></p>
<p class="p6"><span class="s3">In nonWF models, all interactions are automatically reset to an unevaluated state twice per generation: immediately after </span><span class="s4">reproduction()</span><span class="s3"> callbacks have completed (after step 1 in the generation cycle), and immediately before viability/survival selection (before step 4 in the generation cycle).</span></p>
<p class="p6"><span class="s3">Given this automatic invalidation, most simulations have no reason to call </span><span class="s4">unevaluate()</span><span class="s3">.</span></p>
<p class="p1"><b>5.8<span class="Apple-converted-space">  </span>Class Mutation</b></p>
<p class="p2"><i>5.8.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Mutation</i></span><i> properties</i></p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this mutation.<span class="Apple-converted-space">  </span>Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run.<span class="Apple-converted-space">  </span>These identifiers are not re-used during a run, except that if a population file is loaded from disk, the loaded mutations will receive their original identifier values as saved in the population file.</p>
<p class="p5">isFixed =&gt; (logical$)</p>
<p class="p6"><span class="s1">T</span> if the mutation has fixed (in the SLiM sense of having been converted to a <span class="s1">Substitution</span> object), <span class="s1">F</span> otherwise.<span class="Apple-converted-space">  </span>Since fixed/substituted mutations are removed from the simulation, you will only see this flag be <span class="s1">T</span> if you have held onto a mutation beyond its usual lifetime.</p>
<p class="p5">isSegregating =&gt; (logical$)</p>
<p class="p6"><span class="s1">T</span> if the mutation is segregating (in the SLiM sense of not having been either lost or converted to a <span class="s1">Substitution</span> object), <span class="s1">F</span> otherwise.<span class="Apple-converted-space">  </span>Since both lost and fixed/substituted mutations are removed from the simulation, you will only see this flag be <span class="s1">F</span> if you have held onto a mutation beyond its usual lifetime.<span class="Apple-converted-space">  </span>Note that if <span class="s1">isSegregating</span> is <span class="s1">F</span>, <span class="s1">isFixed</span> will let you determine whether the mutation is no longer segregating because it was lost, or because it fixed.</p>
<p class="p3">mutationType =&gt; (object&lt;MutationType&gt;$)</p>
<p class="p4">The <span class="s1">MutationType</span> from which this mutation was drawn.</p>
<p class="p5"><span class="s3">nucleotide &lt;–&gt; (string$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">string</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">.<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p5"><span class="s3">nucleotideValue &lt;–&gt; (integer$)</span></p>
<p class="p6"><span class="s3">An </span><span class="s4">integer</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">0</span><span class="s3"> (A), </span><span class="s4">1</span><span class="s3"> (C), </span><span class="s4">2</span><span class="s3"> (G), or </span><span class="s4">3</span><span class="s3"> (T).<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p3">originGeneration =&gt; (integer$)</p>
<p class="p4">The generation in which this mutation arose.</p>
<p class="p3">position =&gt; (integer$)</p>
<p class="p4">The position in the chromosome of this mutation.</p>
<p class="p3">selectionCoeff =&gt; (float$)</p>
<p class="p6"><span class="s6">The selection coefficient of the mutation, drawn from the distribution of fitness effects of its </span><span class="s10">MutationType</span><span class="s13">.</span><span class="s3"><span class="Apple-converted-space">  </span>If a mutation has a </span><span class="s4">selectionCoeff</span><span class="s3"> of <i>s</i>, the multiplicative fitness effect of the mutation in a homozygote is 1+<i>s</i>; in a heterozygote it is 1+<i>hs</i>, where <i>h</i> is the dominance coefficient kept by the mutation type.</span></p>
<p class="p4">Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.<span class="Apple-converted-space">  </span>This means that if you set a mutation <span class="s1">mut</span>’s selection coefficient to some number <span class="s1">x</span>, <span class="s1">mut.selectionCoeff==x</span> may be <span class="s1">F</span> due to floating-point rounding error.<span class="Apple-converted-space">  </span>Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.<span class="Apple-converted-space">  </span>Instead, it is recommended to use the <span class="s1">id</span> or <span class="s1">tag</span> properties to identify particular mutations.</p>
<p class="p3">subpopID &lt;–&gt; (integer$)</p>
<p class="p4">The identifier of the subpopulation in which this mutation arose.<span class="Apple-converted-space">  </span>This property can be used to track the ancestry of mutations through their subpopulation of origin.</p>
<p class="p4">If you don’t care which subpopulation a mutation originated in, the <span class="s1">subpopID</span> may be used as an arbitrary <span class="s1">integer</span> “tag” value for any purpose you wish; SLiM does not do anything with the value of <span class="s1">subpopID</span> except propagate it to <span class="s1">Substitution</span> objects and report it in output.<span class="Apple-converted-space">  </span>(It must still be <span class="s1">&gt;= 0</span>, however, since SLiM object identifiers are limited to nonnegative integers).</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p2"><i>5.8.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Mutation</i></span><i> methods</i></p>
<p class="p3">–<span class="s8"> </span>(*)getValue(string$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">Mutation</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">– (void)setMutationType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Set the mutation type of the mutation to <span class="s1">mutType</span> (which may be specified as either an <span class="s1">integer</span> identifier or a <span class="s1">MutationType</span> object).<span class="Apple-converted-space">  </span>This implicitly changes the dominance coefficient of the mutation to that of the new mutation type, since the dominance coefficient is a property of the mutation type.<span class="Apple-converted-space">  </span>On the other hand, the selection coefficient of the mutation is not changed, since it is a property of the mutation object itself; it can be changed explicitly using the <span class="s1">setSelectionCoeff()</span> method if so desired.</p>
<p class="p4">The mutation type of a mutation is normally a constant in simulations, so be sure you know what you are doing.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call <span class="s1">SLiMSim</span>’s method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p6"><span class="s3">In nucleotide-based models, a restriction applies: nucleotide-based mutations may not be changed to a non-nucleotide-based mutation type, and non-nucleotide-based mutations may not be changed to a nucleotide-based mutation type.</span></p>
<p class="p3">– (void)setSelectionCoeff(float$ selectionCoeff)</p>
<p class="p4">Set the selection coefficient of the mutation to <span class="s1">selectionCoeff</span>.<span class="Apple-converted-space">  </span>The selection coefficient will be changed for all individuals that possess the mutation, since they all share a single <span class="s1">Mutation</span> object (note that the dominance coefficient will remain unchanged, as it is determined by the mutation type).</p>
<p class="p4">This is normally a constant in simulations, so be sure you know what you are doing; often setting up a <span class="s1">fitness()</span> callback is preferable, in order to modify the selection coefficient in a more limited and controlled fashion.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call <span class="s1">SLiMSim</span>’s method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p3">–<span class="s8"> </span>(void)setValue(string$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span>.<span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span><span class="s6">If </span><span class="s10">value</span><span class="s6"> is of type </span><span class="s10">object</span><span class="s6">, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only </span><span class="s10">Mutation</span><span class="s6"> and </span><span class="s10">Substitution</span><span class="s6"> presently are (see the Eidos manual’s documentation for </span><span class="s10">defineConstant()</span><span class="s6"> for further discussion).<span class="Apple-converted-space">  </span></span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">Mutation</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p1"><b>5.9<span class="Apple-converted-space">  </span>Class MutationType</b></p>
<p class="p2"><i>5.9.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>MutationType</i></span><i> properties</i></p>
<p class="p3">color &lt;–&gt; (string$)</p>
<p class="p4">The color used to display mutations of this type in SLiMgui.<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">color</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default (selection-coefficient–based) color scheme is used; this is the default for new <span class="s1">MutationType</span> objects.</p>
<p class="p3">colorSubstitution &lt;–&gt; (string$)</p>
<p class="p4">The color used to display substitutions of this type in SLiMgui (see the discussion for the <span class="s1">colorSubstitution</span> property of the <span class="s1">Chromosome</span> class for details).<span class="Apple-converted-space">  </span>Outside of SLiMgui, this property still exists, but is not used by SLiM.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s1">"#RRGGBB"</span>.<span class="Apple-converted-space">  </span>If <span class="s1">colorSubstitution</span> is the empty string, <span class="s1">""</span>, SLiMgui’s default (selection-coefficient–based) color scheme is used; this is the default for new <span class="s1">MutationType</span> objects.</p>
<p class="p3">convertToSubstitution &lt;–&gt; (logical$)</p>
<p class="p6"><span class="s3">This property governs whether mutations of this mutation type will be converted to </span><span class="s4">Substitution</span><span class="s3"> objects when they reach fixation.</span></p>
<p class="p6"><span class="s3">In WF models this property is </span><span class="s4">T</span><span class="s3"> by default, since conversion to </span><span class="s4">Substitution</span><span class="s3"> objects provides large speed benefits; it should be set to </span><span class="s4">F</span><span class="s3"> only if necessary, and only on the mutation types for which it is necessary.<span class="Apple-converted-space">  </span>This might be needed, for example, if you are using a </span><span class="s4">fitness()</span><span class="s3"> callback to implement an epistatic relationship between mutations; a mutation epistatically influencing the fitness of other mutations through a </span><span class="s4">fitness()</span><span class="s3"> callback would need to continue having that influence even after reaching fixation, but if the simulation were to replace the fixed mutation with a </span><span class="s4">Substitution</span><span class="s3"> object the mutation would no longer be considered in fitness calculations (unless the callback explicitly consulted the list of </span><span class="s4">Substitution</span><span class="s3"> objects kept by the simulation).<span class="Apple-converted-space">  </span>Other script-defined behaviors in </span><span class="s4">fitness()</span><span class="s3">, </span><span class="s4">interaction()</span><span class="s3">, </span><span class="s4">mateChoice()</span><span class="s3">, </span><span class="s4">modifyChild()</span><span class="s3">, and </span><span class="s4">recombination()</span><span class="s3"> callbacks might also necessitate the disabling of substitution for a given mutation type; this is an important consideration to keep in mind.</span></p>
<p class="p6"><span class="s3">In contrast, for nonWF models this property is </span><span class="s4">F</span><span class="s3"> by default, because even mutations with no epistatis or other indirect fitness effects will continue to influence the survival probabilities of individuals.<span class="Apple-converted-space">  </span>For nonWF models, only neutral mutation types with no epistasis or other side effects can safely be converted to substitutions upon fixation.<span class="Apple-converted-space">  </span>When such a pure-neutral mutation type is defined in a nonWF model, this property should be set to </span><span class="s4">T</span><span class="s3"> to tell SLiM that substitution is allowed; this may have very large positive effects on performance, so it is important to remember when modeling background neutral mutations.</span></p>
<p class="p6"><span class="s3">SLiM consults this flag at the end of each generation when deciding whether to substitute each fixed mutation.<span class="Apple-converted-space">  </span>If this flag is </span><span class="s4">T</span><span class="s3">, all eligible fixed mutations will be converted at the end of the current generation, even if they were previously left unconverted because of the previous value of the flag.<span class="Apple-converted-space">  </span>Setting this flag to </span><span class="s4">F</span><span class="s3"> will prevent future substitutions, but will not cause any existing </span><span class="s4">Substitution</span><span class="s3"> objects to be converted back into </span><span class="s4">Mutation</span><span class="s3"> objects.</span></p>
<p class="p3">distributionParams =&gt; (fs)</p>
<p class="p4">The parameters that configure the chosen distribution of fitness effects.<span class="Apple-converted-space">  </span>This will be of type <span class="s1">string</span> for DFE type <span class="s1">"s"</span>, and type <span class="s1">float</span> for all other DFE types.</p>
<p class="p3">distributionType =&gt; (string$)</p>
<p class="p4">The type of distribution of fitness effects; one of <span class="s1">"f"</span>, <span class="s1">"g"</span><span class="s2">,</span> <span class="s1">"e"</span><span class="s2">,</span> <span class="s1">"n"</span><span class="s2">,</span> <span class="s1">"w"</span><span class="s2">,</span> or <span class="s1">"s"</span><span class="s2">:</span></p>
<p class="p9"><span class="s1">"f"</span> – A <b>f</b>ixed fitness effect.<span class="Apple-converted-space">  </span>This DFE type has a single parameter, the selection coefficient <i>s</i> to be used by all mutations of the mutation type.</p>
<p class="p9"><span class="s1">"g"</span> – A <b>g</b>amma-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by two parameters, a shape parameter and a mean value.<span class="Apple-converted-space">  </span>The gamma distribution from which mutations are drawn is given by the probability density function <span class="s11"><i>P</i>(<i>s</i> | </span><span class="s14"><i>α</i></span><span class="s11">,</span><span class="s14"><i>β</i></span><span class="s11">) </span><span class="s14">= [Γ(<i>α</i></span><span class="s11">)</span><span class="s14"><i>βα</i></span><span class="s11">]<sup>−1</sup>exp(−<i>s</i>/</span><span class="s14"><i>β</i></span><span class="s11">)</span>, where <span class="s14"><i>α</i></span> is the shape parameter, and the specified mean for the distribution is equal to <span class="s14"><i>αβ</i></span>.<span class="Apple-converted-space">  </span>Note that this parameterization is the same as for the Eidos function <span class="s1">rgamma()</span>.<span class="Apple-converted-space">  </span>A gamma distribution is often used to model deleterious mutations at functional sites.</p>
<p class="p9"><span class="s1">"e"</span> – An <b>e</b>xponentially-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by a single parameter, the mean of the distribution.<span class="Apple-converted-space">  </span>The exponential distribution from which mutations are drawn is given by the probability density function <span class="s11"><i>P</i>(<i>s</i> | </span><span class="s14"><i>β</i></span><span class="s11">) = </span><span class="s14"><i>β</i></span><span class="s11"><sup>−1</sup>exp(−<i>s</i>/</span><span class="s14"><i>β</i></span><span class="s11">)</span>, where <span class="s14"><i>β</i></span> is the specified mean for the distribution.<span class="Apple-converted-space">  </span>This parameterization is the same as for the Eidos function <span class="s1">rexp()</span>.<span class="Apple-converted-space">  </span>An exponential distribution is often used to model beneficial mutations.</p>
<p class="p9"><span class="s1">"n"</span> – A <b>n</b>ormally-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by two parameters, a mean and a standard deviation.<span class="Apple-converted-space">  </span>The normal distribution from which mutations are drawn is given by the probability density function <span class="s11"><i>P</i>(<i>s</i> | </span><span class="s14"><i>μ</i></span><span class="s11">,</span><span class="s14"><i>σ</i></span><span class="s11">) = (2</span><span class="s14">π<i>σ</i></span><span class="s11"><sup>2</sup>)<sup>−1/2</sup>exp(−(<i>s</i>−</span><span class="s14"><i>μ</i></span><span class="s11">)<sup>2</sup>/2</span><span class="s14"><i>σ</i></span><span class="s11"><sup>2</sup>)</span>, where <span class="s14"><i>μ</i></span> is the mean and <span class="s14"><i>σ</i></span> is the standard deviation.<span class="Apple-converted-space">  </span>This parameterization is the same as for the Eidos function <span class="s1">rnorm()</span>.<span class="Apple-converted-space">  </span>A normal distribution is often used to model mutations that can be either beneficial or deleterious, since both tails of the distribution are unbounded.</p>
<p class="p9"><span class="s1">"w"</span> – A <b>W</b>eibull-distributed fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by a scale parameter and a shape parameter.<span class="Apple-converted-space">  </span>The Weibull distribution from which mutations are drawn is given by the probability density function <span class="s11"><i>P</i>(<i>s</i> | </span><span class="s14"><i>λ</i></span><span class="s11">,<i>k</i>) = (<i>k</i>/</span><span class="s14"><i>λ</i></span><span class="s11"><i><sup>k</sup></i>)<i>s<sup>k</sup></i><sup>−1</sup>exp(−(<i>s</i>/</span><span class="s14"><i>λ</i></span><span class="s11">)<i><sup>k</sup></i>)</span>, where <span class="s14"><i>λ</i></span> is the scale parameter and <span class="s11"><i>k</i></span> is the shape parameter.<span class="Apple-converted-space">  </span>This parameterization is the same as for the Eidos function <span class="s1">rweibull()</span>.<span class="Apple-converted-space">  </span>A Weibull distribution is often used to model mutations following extreme-value theory.</p>
<p class="p9"><span class="s1">"s"</span> – A <b>s</b>cript-based fitness effect.<span class="Apple-converted-space">  </span>This DFE type is specified by a script parameter of type <span class="s1">string</span>, specifying an Eidos script to be executed to produce each new selection coefficient.<span class="Apple-converted-space">  </span>For example, the script <span class="s1">"return rbinom(1);"</span> could be used to generate selection coefficients drawn from a binomial distribution, using the Eidos function <span class="s1">rbinom()</span>, even though that mutational distribution is not supported by SLiM directly.<span class="Apple-converted-space">  </span>The script must return a singleton float or integer.</p>
<p class="p9">Note that these distributions can in principle produce selection coefficients smaller than <span class="s1">-1.0. </span>In that case<span class="s11">,</span> the mutations will be evaluated as “lethal” by SLiM, and the relative fitness of the individual will be set to <span class="s1">0.0</span><span class="s11">.</span></p>
<p class="p3">dominanceCoeff &lt;–&gt; (float$)</p>
<p class="p4">The dominance coefficient used for mutations of this type when heterozygous.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call <span class="s1">SLiMSim</span>’s method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p4">Note that the dominance coefficient is not bounded.<span class="Apple-converted-space">  </span>A dominance coefficient greater than <span class="s1">1.0</span> may be used to achieve an overdominance effect.<span class="Apple-converted-space">  </span>By making the selection coefficient very small and the dominance coefficient very large, an overdominance scenario in which both homozygotes have the same fitness may be approximated, to a nearly arbitrary degree of precision.</p>
<p class="p4">Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.<span class="Apple-converted-space">  </span>This means that if you set a mutation type <span class="s1">muttype</span>’s dominance coefficient to some number <span class="s1">x</span>, <span class="s1">muttype.dominanceCoeff==x</span> may be <span class="s1">F</span> due to floating-point rounding error.<span class="Apple-converted-space">  </span>Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.<span class="Apple-converted-space">  </span>Instead, it is recommended to use the <span class="s1">id</span> or <span class="s1">tag</span> properties to identify particular mutation types.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this mutation type; for mutation type <span class="s1">m3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">mutationStackGroup &lt;–&gt; (integer$)</p>
<p class="p4">The group into which this mutation type belongs for purposes of mutation stacking policy.<span class="Apple-converted-space">  </span>This is equal to the mutation type’s <span class="s1">id</span> by default.<span class="Apple-converted-space">  </span>See <span class="s1">mutationStackPolicy</span>, below, for discussion.</p>
<p class="p6"><span class="s3">In nucleotide-based models, the stacking group for nucleotide-based mutation types is always </span><span class="s4">-1</span><span class="s3">, and cannot be changed.<span class="Apple-converted-space">  </span>Non-nucleotide-based mutation types may also be set to share the </span><span class="s4">-1</span><span class="s3"> stacking group, if they should participate in the same stacking policy as nucleotide-based mutations, but that would be quite unusual.</span></p>
<p class="p3">mutationStackPolicy &lt;–&gt; (string$)</p>
<p class="p4">This property and the <span class="s1">mutationStackGroup</span> property together govern whether mutations of this mutation type’s stacking group can “stack” – can occupy the same position in a single individual.<span class="Apple-converted-space">  </span>A set of mutation types with the same value for <span class="s1">mutationStackGroup</span> is called a “stacking group”, and all mutation types in a given stacking group must have the same <span class="s1">mutationStackPolicy</span> value, which defines the stacking behavior of all mutations of the mutation types in the stacking group.<span class="Apple-converted-space">  </span>In other words, one stacking group might allow its mutations to stack, while another stacking group might not, but the policy within each stacking group must be unambiguous.</p>
<p class="p6"><span class="s3">This property is </span><span class="s4">"s"</span><span class="s3"> by default, indicating that mutations in this stacking group should be allowed to stack without restriction.<span class="Apple-converted-space">  </span>If the policy is set to </span><span class="s4">"f"</span><span class="s3">, the <i>first</i> mutation of stacking group at a given site is retained; further mutations of this stacking group at the same site are discarded with no effect.<span class="Apple-converted-space">  </span>This can be useful for modeling one-way changes; once a gene is disabled by a premature stop codon, for example, you might wish to assume, for simplicity, that further mutations cannot alter that fact.<span class="Apple-converted-space">  </span>If the policy is set to </span><span class="s4">"l"</span><span class="s3">, the <i>last</i> mutation of this stacking group at a given site is retained; earlier mutation of this stacking group at the same site are discarded.<span class="Apple-converted-space">  </span>This can be useful for modeling an “infinite-alleles” scenario in which every new mutation at a site generates a completely new allele, rather than retaining the previous mutations at the site.</span></p>
<p class="p4">The mutation stacking policy applies only within the given mutation type’s stacking group; mutations of different stacking groups are always allowed to stack in SLiM.<span class="Apple-converted-space">  </span>The policy applies to all mutations added to the model after the policy is set, whether those mutations are introduced by calls such as <span class="s1">addMutation()</span>, <span class="s1">addNewMutation()</span>, or <span class="s1">addNewDrawnMutation()</span>, or are added by SLiM’s own mutation-generation machinery.<span class="Apple-converted-space">  </span>However, no attempt is made to enforce the policy for mutations already existing at the time the policy is set; typically, therefore, the policy is set in an <span class="s1">initialize()</span> callback so that it applies throughout the simulation.<span class="Apple-converted-space">  </span>The policy is also not enforced upon the mutations loaded from a file with <span class="s1">readFromPopulationFile()</span>; such mutations were governed by whatever stacking policy was in effect when the population file was generated.</p>
<p class="p6"><span class="s3">In nucleotide-based models, the stacking policy for nucleotide-based mutation types is always </span><span class="s4">"l"</span><span class="s3">, and cannot be changed.<span class="Apple-converted-space">  </span>This ensures that new nucleotide mutations always replace the previous nucleotide at a site, and that more than one nucleotide mutation is never present at the same position in a single genome.</span></p>
<p class="p5"><span class="s3">nucleotideBased =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">If the mutation type was created with </span><span class="s4">initializeMutationType()</span><span class="s3">, it is not nucleotide-based, and this property is </span><span class="s4">F</span><span class="s3">.<span class="Apple-converted-space">  </span>If it was created with </span><span class="s4">initializeMutationTypeNuc()</span><span class="s3">, it is nucleotide-based, and this property is </span><span class="s4">T</span><span class="s3">.<span class="Apple-converted-space">  </span>See those methods for further discussion.</span></p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods, for another way of attaching state to mutation types.</p>
<p class="p2"><i>5.9.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>MutationType</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (float)drawSelectionCoefficient([integer$ n = 1])</span></p>
<p class="p6"><span class="s3">Draws and returns a vector of </span><span class="s4">n</span><span class="s3"> selection coefficients using the currently defined distribution of fitness effects (DFE) for the target mutation type.<span class="Apple-converted-space">  </span>If the DFE is type </span><span class="s4">"s"</span><span class="s3">, this method will result in synchronous execution of the DFE’s script.</span></p>
<p class="p3">–<span class="s8"> </span>(*)getValue(string$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">MutationType</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">– (void)setDistribution(string$ distributionType, ...)</p>
<p class="p4">Set the distribution of fitness effects for a mutation type.<span class="Apple-converted-space">  </span>The <span class="s1">distributionType</span> may be <span class="s1">"f"</span>, in which case the ellipsis <span class="s1">...</span> should supply a <span class="s1">numeric$</span> fixed selection coefficient; <span class="s1">"e"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> mean selection coefficient for the exponential distribution; <span class="s1">"g"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> mean selection coefficient and a <span class="s1">numeric$</span> alpha shape parameter for a gamma distribution; <span class="s1">"n"</span>, in which case the ellipsis should supply a <span class="s1">numeric$</span> mean selection coefficient and a <span class="s1">numeric$</span> sigma (standard deviation) parameter for a normal distribution<span class="s9">; </span><span class="s1">"w"</span><span class="s9">, in which case the ellipsis should supply a </span><span class="s1">numeric$</span><span class="s9"> </span><span class="s14">λ</span><span class="s9"> scale parameter and a </span><span class="s1">numeric$</span><span class="s9"> k shape parameter for a Weibull distribution; or </span><span class="s1">"s"</span><span class="s9">, in which case the ellipsis should supply a </span><span class="s1">string$</span><span class="s9"> Eidos script parameter.</span><span class="Apple-converted-space">  </span>The DFE for a mutation type is normally a constant in simulations, so be sure you know what you are doing.</p>
<p class="p3">–<span class="s8"> </span>(void)setValue(string$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span>.<span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span><span class="s6">If </span><span class="s10">value</span><span class="s6"> is of type </span><span class="s10">object</span><span class="s6">, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only </span><span class="s10">Mutation</span><span class="s6"> and </span><span class="s10">Substitution</span><span class="s6"> presently are (see the Eidos manual’s documentation for </span><span class="s10">defineConstant()</span><span class="s6"> for further discussion).<span class="Apple-converted-space">  </span></span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">MutationType</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p1"><b>5.10<span class="Apple-converted-space">  </span>Class SLiMEidosBlock</b></p>
<p class="p2"><i>5.10.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMEidosBlock</i></span><i> properties</i></p>
<p class="p3">active &lt;–&gt; (integer$)</p>
<p class="p4">If this evaluates to <span class="s1">logical</span> <span class="s1">F</span> (i.e., is equal to <span class="s1">0</span>), the script block is inactive and will not be called.<span class="Apple-converted-space">  </span>The value of <span class="s1">active</span> for all registered script blocks is reset to <span class="s1">-1</span> at the beginning of each generation, prior to script events being called, thus activating all blocks.<span class="Apple-converted-space">  </span>Any <span class="s1">integer</span> value other than <span class="s1">-1</span> may be used instead of <span class="s1">-1</span> to represent that a block is active; for example, <span class="s1">active</span> may be used as a counter to make a block execute a fixed number of times in each generation.<span class="Apple-converted-space">  </span>This value is not cached by SLiM; if it is changed, the new value takes effect immediately.<span class="Apple-converted-space">  </span>For example, a callback might be activated and inactivated repeatedly during a single generation.</p>
<p class="p3">end =&gt; (integer$)</p>
<p class="p4">The last generation in which the script block is active.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this script block; for script <span class="s1">s3</span>, for example, this is <span class="s1">3</span>.<span class="Apple-converted-space">  </span>A script block for which no <span class="s1">id</span> was given will have an <span class="s1">id</span> of <span class="s1">-1</span><span class="s2">.</span></p>
<p class="p3">source =&gt; (string$)</p>
<p class="p4">The source code string of the script block.</p>
<p class="p3">start =&gt; (integer$)</p>
<p class="p4">The first generation in which the script block is active.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p3">type =&gt; (string$)</p>
<p class="p4">The type of the script block; this will be <span class="s1">"early"</span> or <span class="s1">"late"</span> for the two types of Eidos events, or <span class="s1">"initialize"</span>, <span class="s1">"fitness"</span>, <span class="s1">"mateChoice"</span>, <span class="s1">"modifyChild"</span>, or <span class="s1">"recombination"</span> for the respective types of Eidos callbacks.</p>
<p class="p2"><i>5.10.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMEidosBlock</i></span><i> methods</i></p>
<p class="p10"><br></p>
<p class="p1"><b>5.11<span class="Apple-converted-space">  </span>Class SLiMgui</b></p>
<p class="p2"><i>5.11.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMgui</i></span><i> properties</i></p>
<p class="p5"><span class="s3">pid =&gt; (integer$)</span></p>
<p class="p6"><span class="s3">The Un*x process identifier (commonly called the “pid”) of the running SLiMgui application.<span class="Apple-converted-space">  </span>This can be useful for scripts that wish to use system calls to influence the SLiMgui application.</span></p>
<p class="p2"><i>5.11.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMgui</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (void)openDocument(string$ filePath)</span></p>
<p class="p6">Open the document at <span class="s1">filePath</span> in SLiMgui, if possible.<span class="Apple-converted-space">  </span>Supported document types include SLiM model files (typically with a <span class="s1">.slim</span> path extension), text files (typically with a <span class="s1">.txt</span> path extension, and opened as untitled model files), and PNG, JPG/JPEG, BMP, and GIF image file formats (typically <span class="s1">.png</span> / <span class="s1">.jpg</span> / <span class="s1">.jpeg</span> / <span class="s1">.bmp</span> / <span class="s1">.gif</span>, respectively).<span class="Apple-converted-space">  </span>(Note that in SLiMguiLegacy, PDF files (<span class="s1">.pdf</span>) are supported but these other image file formats are not.)<span class="Apple-converted-space">  </span>This method can be particularly useful for opening images created by the simulation itself, often by sublaunching a plotting process in R or another environment.</p>
<p class="p5"><span class="s3">– (void)pauseExecution(void)</span></p>
<p class="p6"><span class="s3">Pauses a model that is playing in SLiMgui.<span class="Apple-converted-space">  </span>This is essentially equivalent to clicking the “Play” button to stop the execution of the model.<span class="Apple-converted-space">  </span>Execution can be resumed by the user, by clicking the “Play” button again; unlike calling </span><span class="s4">stop()</span><span class="s3"> or </span><span class="s4">simulationFinished()</span><span class="s3">, the simulation is not terminated.<span class="Apple-converted-space">  </span>This method can be useful for debugging or exploratory purposes, to pause the model at a point of interest.<span class="Apple-converted-space">  </span>Execution is paused at the end of the currently executing generation, not mid-generation.</span></p>
<p class="p6"><span class="s3">If the model is being profiled, or is executing forward to a generation number entered in the generation field, </span><span class="s4">pauseExecution()</span><span class="s3"> will do nothing; by design, </span><span class="s4">pauseExecution()</span><span class="s3"> only pauses execution when SLiMgui is doing a simple “Play” of the model.</span></p>
<p class="p1"><b>5.12<span class="Apple-converted-space">  </span>Class SLiMSim</b></p>
<p class="p2"><i>5.12.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMSim</i></span><i> properties</i></p>
<p class="p3">chromosome =&gt; (object&lt;Chromosome&gt;$)</p>
<p class="p4">The <span class="s1">Chromosome</span> <span class="s1">object</span> used by the simulation.</p>
<p class="p3">chromosomeType =&gt; (string$)</p>
<p class="p4">The type of chromosome being simulated; this will be one of <span class="s1">"A"</span>, <span class="s1">"X"</span>, or <span class="s1">"Y"</span><span class="s2">.</span></p>
<p class="p3">dimensionality =&gt; (string$)</p>
<p class="p4">The spatial dimensionality of the simulation, as specified in <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>This will be <span class="s1">""</span> (the empty string) for non-spatial simulations (the default), or <span class="s1">"x"</span>, <span class="s1">"xy"</span>, or <span class="s1">"xyz"</span>, for simulations using those spatial dimensions respectively.</p>
<p class="p3">dominanceCoeffX &lt;–&gt; (float$)</p>
<p class="p4">The dominance coefficient value used to modify the selection coefficients of mutations present on the single X chromosome of an XY male (see the SLiM manual for details).<span class="Apple-converted-space">  </span>Used only when simulating an X chromosome; setting a value for this property in other circumstances is an error.<span class="Apple-converted-space">  </span>Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call <span class="s1">SLiMSim</span>’s method <span class="s1">recalculateFitness()</span> – but see the documentation of that method for caveats.</p>
<p class="p3">generation &lt;–&gt; (integer$)</p>
<p class="p4">The current generation number.</p>
<p class="p3">genomicElementTypes =&gt; (object&lt;GenomicElementType&gt;)</p>
<p class="p4">The <span class="s1">GenomicElementType</span> objects being used in the simulation.</p>
<p class="p3">inSLiMgui =&gt; (logical$)</p>
<p class="p6"><span class="s3"><b>This property has been deprecated, and may be removed in a future release of SLiM.</b><span class="Apple-converted-space">  </span>In SLiM 3.2.1 and later, use </span><span class="s4">exists("slimgui")</span><span class="s3"> instead.</span></p>
<p class="p4">If <span class="s1">T</span>, the simulation is presently running inside SLiMgui; if <span class="s1">F</span>, it is running at the command line.<span class="Apple-converted-space">  </span>In general simulations should not care where they are running, but in special circumstances such as opening plot windows it may be necessary to know the runtime environment.</p>
<p class="p3">interactionTypes =&gt; (object&lt;InteractionType&gt;)</p>
<p class="p4">The <span class="s1">InteractionType</span> objects being used in the simulation.</p>
<p class="p3">modelType =&gt; (string$)</p>
<p class="p6"><span class="s3">The type of model being simulated, as specified in </span><span class="s4">initializeSLiMModelType()</span><span class="s3">.<span class="Apple-converted-space">  </span>This will be </span><span class="s4">"WF"</span><span class="s3"> for WF models (Wright-Fisher models, the default), or </span><span class="s4">"nonWF"</span><span class="s3"> for nonWF models (non-Wright-Fisher models).</span></p>
<p class="p3">mutationTypes =&gt; (object&lt;MutationType&gt;)</p>
<p class="p4">The <span class="s1">MutationType</span> objects being used in the simulation.</p>
<p class="p3">mutations =&gt; (object&lt;Mutation&gt;)</p>
<p class="p4">The <span class="s1">Mutation</span> objects that are currently active in the simulation.</p>
<p class="p5"><span class="s3">nucleotideBased =&gt; (logical$)</span></p>
<p class="p6"><span class="s3">If </span><span class="s4">T</span><span class="s3">, the model is nucleotide-based; if </span><span class="s4">F</span><span class="s3">, it is not.<span class="Apple-converted-space">  </span>See the discussion of the </span><span class="s4">nucleotideBased</span><span class="s3"> parameter to </span><span class="s4">initializeSLiMOptions()</span><span class="s3"> for discussion.</span></p>
<p class="p3">periodicity =&gt; (string$)</p>
<p class="p6"><span class="s3">The spatial periodicity of the simulation, as specified in </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.<span class="Apple-converted-space">  </span>This will be </span><span class="s4">""</span><span class="s3"> (the empty string) for non-spatial simulations and simulations with no periodic spatial dimensions (the default).<span class="Apple-converted-space">  </span>Otherwise, it will be a string representing the subset of spatial dimensions that have been declared to be periodic, as specified to </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p3">scriptBlocks =&gt; (object&lt;SLiMEidosBlock&gt;)</p>
<p class="p4">All registered <span class="s1">SLiMEidosBlock</span> objects in the simulation.</p>
<p class="p3">sexEnabled =&gt; (logical$)</p>
<p class="p4">If <span class="s1">T</span>, sex is enabled in the simulation; if <span class="s1">F</span>, individuals are hermaphroditic.</p>
<p class="p3">subpopulations =&gt; (object&lt;Subpopulation&gt;)</p>
<p class="p4">The <span class="s1">Subpopulation</span> instances currently defined in the simulation.</p>
<p class="p3">substitutions =&gt; (object&lt;Substitution&gt;)</p>
<p class="p4">A vector of <span class="s1">Substitution</span> objects, representing all mutations that have been fixed.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods, for another way of attaching state to the simulation.</p>
<p class="p2"><i>5.12.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>SLiMSim</i></span><i> methods</i></p>
<p class="p3">– (object&lt;Subpopulation&gt;$)addSubpop(is$ subpopID, integer$ size, [float$ sexRatio = 0.5])</p>
<p class="p4">Add a new subpopulation with id <span class="s1">subpopID</span> and <span class="s1">size</span> individuals (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>The <span class="s1">subpopID</span> parameter may be either an <span class="s1">integer</span> giving the ID of the new subpopulation, or a <span class="s1">string</span> giving the name of the new subpopulation (such as <span class="s1">"p5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>Only if sex is enabled in the simulation, the initial sex ratio may optionally be specified as <span class="s1">sexRatio</span><span class="s5"> (as the male fraction, M:M+F)</span>; if it is not specified, a default of <span class="s1">0.5</span> is used.<span class="Apple-converted-space">  </span>The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.<span class="Apple-converted-space">  </span>Subpopulations added by this method will initially consist of individuals with empty genomes. In order to model subpopulations that split from an already existing subpopulation, use <span class="s1">addSubpopSplit()</span><span class="s2">.</span></p>
<p class="p3">– (object&lt;Subpopulation&gt;$)addSubpopSplit(is$ subpopID, integer$ size, io&lt;Subpopulation&gt;$ sourceSubpop, [float$ sexRatio = 0.5])</p>
<p class="p4">Split off a new subpopulation with id <span class="s1">subpopID</span> and <span class="s1">size</span> individuals derived from subpopulation <span class="s1">sourceSubpop</span> (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>The <span class="s1">subpopID</span> parameter may be either an <span class="s1">integer</span> giving the ID of the new subpopulation, or a <span class="s1">string</span> giving the name of the new subpopulation (such as <span class="s1">"p5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>The <span class="s1">sourceSubpop</span> parameter may specify the source subpopulation either as a <span class="s1">Subpopulation</span> object or by <span class="s1">integer</span> identifier.<span class="Apple-converted-space">  </span>Only if sex is enabled in the simulation, the initial sex ratio may optionally be specified as <span class="s1">sexRatio</span><span class="s5"> (as the male fraction, M:M+F)</span>; if it is not specified, a default of <span class="s1">0.5</span> is used.<span class="Apple-converted-space">  </span>The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">–<span class="s8"> </span>(integer$)countOfMutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns the number of mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations that are currently active in the simulation.<span class="Apple-converted-space">  </span>If you need a vector of the matching <span class="s1">Mutation</span> objects, rather than just a count, use <span class="s1">-mutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is often used to determine whether an introduced mutation is still active (as opposed to being either lost or fixed).<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">– (void)deregisterScriptBlock(io&lt;SLiMEidosBlock&gt; scriptBlocks)</p>
<p class="p4">All <span class="s1">SLiMEidosBlock</span> objects specified by <span class="s1">scriptBlocks</span> (either with <span class="s1">SLiMEidosBlock</span> objects or with <span class="s1">integer</span> identifiers) will be scheduled for deregistration.<span class="Apple-converted-space">  </span>The deregistered blocks remain valid, and may even still be executed in the current stage of the current generation; the blocks are not actually deregistered and deallocated until sometime after the currently executing script block has completed.<span class="Apple-converted-space">  </span>To immediately prevent a script block from executing, even when it is scheduled to execute in the current stage of the current generation, use the <span class="s1">active</span> property of the script block.</p>
<p class="p3">–<span class="s8"> </span>(*)getValue(string$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">SLiMSim</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">– (integer)mutationCounts(No&lt;Subpopulation&gt; subpops, [No&lt;Mutation&gt; mutations = NULL])</p>
<p class="p4">Return an <span class="s1">integer</span> vector with the frequency counts of all of the <span class="s1">Mutation</span> objects passed in <span class="s1">mutations</span>, within the <span class="s1">Subpopulation</span> objects in <span class="s1">subpops</span>.<span class="Apple-converted-space">  </span>The <span class="s1">subpops</span> argument is required, but you may pass <span class="s1">NULL</span> to get population-wide frequency counts.<span class="Apple-converted-space">  </span>If the optional <span class="s1">mutations</span> argument is <span class="s1">NULL</span> (the default), frequency counts will be returned for all of the active <span class="s1">Mutation</span> objects in the simulation – the same <span class="s1">Mutation</span> objects, and in the same order, as would be returned by the <span class="s1">mutations</span> property of <span class="s1">sim</span>, in other words.</p>
<p class="p4">See the <span class="s1">-mutationFrequencies()</span> method to obtain <span class="s1">float</span> frequencies instead of <span class="s1">integer</span> counts.</p>
<p class="p3">– (float)mutationFrequencies(No&lt;Subpopulation&gt; subpops, [No&lt;Mutation&gt; mutations = NULL])</p>
<p class="p4">Return a <span class="s1">float</span> vector with the frequencies of all of the <span class="s1">Mutation</span> objects passed in <span class="s1">mutations</span>, within the <span class="s1">Subpopulation</span> objects in <span class="s1">subpops</span>.<span class="Apple-converted-space">  </span>The <span class="s1">subpops</span> argument is required, but you may pass <span class="s1">NULL</span> to get population-wide frequencies.<span class="Apple-converted-space">  </span>If the optional <span class="s1">mutations</span> argument is <span class="s1">NULL</span> (the default), frequencies will be returned for all of the active <span class="s1">Mutation</span> objects in the simulation – the same <span class="s1">Mutation</span> objects, and in the same order, as would be returned by the <span class="s1">mutations</span> property of <span class="s1">sim</span>, in other words.</p>
<p class="p4">See the <span class="s1">-mutationCounts()</span> method to obtain <span class="s1">integer</span> counts instead of <span class="s1">float</span> frequencies.</p>
<p class="p3">–<span class="s8"> </span>(object&lt;Mutation&gt;)mutationsOfType(io&lt;MutationType&gt;$ mutType)</p>
<p class="p4">Returns an <span class="s1">object</span> vector of all the mutations that are of the type specified by <span class="s1">mutType</span>, out of all of the mutations that are currently active in the simulation.<span class="Apple-converted-space">  </span>If you just need a count of the matching <span class="s1">Mutation</span> objects, rather than a vector of the matches, use <span class="s1">-countOfMutationsOfType()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>This method is often used to look up an introduced mutation at a later point in the simulation, since there is no way to keep persistent references to objects in SLiM.<span class="Apple-converted-space">  </span>This method is provided for speed; it is much faster than the corresponding Eidos code.</p>
<p class="p3">– (void)outputFixedMutations([Ns$ filePath = NULL], [logical$ append = F])</p>
<p class="p4">Output all fixed mutations – all <span class="s1">Substitution</span> objects, in other words – in a SLiM native format.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span><span class="Apple-converted-space">  </span>Mutations which have fixed but have not been turned into <span class="s1">Substitution</span> objects – typically because <span class="s1">convertToSubstitution</span> has been set to <span class="s1">F</span> for their mutation type – are not output; they are still considered to be segregating mutations by SLiM.</p>
<p class="p6"><span class="s3">In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations.</span></p>
<p class="p4">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">– (void)outputFull([Ns$ filePath = NULL], [logical$ binary = F], [logical$ append = F], [logical$ spatialPositions = T]<span class="s5">, [logical$ ages = T], [logical$ ancestralNucleotides = T]</span><span class="s6">, [logical$ pedigreeIDs = F]</span>)</p>
<p class="p4">Output the state of the entire population.<span class="Apple-converted-space">  </span>If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span><span class="Apple-converted-space">  </span>When writing to a file, a <span class="s1">logical</span> flag, <span class="s1">binary</span>, may be supplied as well.<span class="Apple-converted-space">  </span>If <span class="s1">binary</span> is <span class="s1">T</span>, the population state will be written as a binary file instead of a text file (binary data cannot be written to the standard output stream).<span class="Apple-converted-space">  </span>The binary file is usually smaller, and in any case will be read much faster than the corresponding text file would be read.<span class="Apple-converted-space">  </span>Binary files are not guaranteed to be portable between platforms; in other words, a binary file written on one machine may not be readable on a different machine (but in practice it usually will be, unless the platforms being used are fairly unusual).<span class="Apple-converted-space">  </span>If <span class="s1">binary</span> is <span class="s1">F</span> (the default), a text file will be written.</p>
<p class="p4">Beginning with SLiM 2.3, the <span class="s1">spatialPositions</span> parameter may be used to control the output of the spatial positions of individuals in simulations for which continuous space has been enabled using the <span class="s1">dimensionality</span> option of <span class="s1">initializeSLiMOptions()</span><span class="s2">.</span><span class="Apple-converted-space">  </span>If <span class="s1">spatialPositions</span> is <span class="s1">F</span>, the output will not contain spatial positions, and will be identical to the output generated by SLiM 2.1 and later.<span class="Apple-converted-space">  </span>If <span class="s1">spatialPositions</span> is <span class="s1">T</span>, spatial position information will be output if it is available.<span class="Apple-converted-space">  </span>If the simulation does not have continuous space enabled, the <span class="s1">spatialPositions</span> parameter will be ignored.<span class="Apple-converted-space">  </span>Positional information may be output for all output destinations – the Eidos output stream, a text file, or a binary file.</p>
<p class="p6"><span class="s3">Beginning with SLiM 3.0, the </span><span class="s4">ages</span><span class="s3"> parameter may be used to control the output of the ages of individuals in nonWF simulations.<span class="Apple-converted-space">  </span>If </span><span class="s4">ages</span><span class="s3"> is </span><span class="s4">F</span><span class="s3">, the output will not contain ages, preserving backward compatibility with the output format of SLiM 2.1 and later.<span class="Apple-converted-space">  </span>If </span><span class="s4">ages</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">, ages will be output for nonWF models.<span class="Apple-converted-space">  </span>In WF simulations, the </span><span class="s4">ages</span><span class="s3"> parameter will be ignored.</span></p>
<p class="p6"><span class="s3">Beginning with SLiM 3.3, the </span><span class="s4">ancestralNucleotides</span><span class="s3"> parameter may be used to control the output of the ancestral nucleotide sequence in nucleotide-based models.<span class="Apple-converted-space">  </span>If </span><span class="s4">ancestralNucleotides</span><span class="s3"> is </span><span class="s4">F</span><span class="s3">, the output will not contain ancestral nucleotide information, and so the ancestral sequence will not be restored correctly if the saved file is loaded with </span><span class="s4">readPopulationFile()</span><span class="s3">.<span class="Apple-converted-space">  </span>This option is provided because the ancestral sequence may be quite large, for models with a long chromosome (e.g., 1 GB if the chromosome is 10</span><span class="s12"><sup>9</sup></span><span class="s3"> bases long, when saved in text format, or 0.25 GB when saved in binary format).<span class="Apple-converted-space">  </span>If the model is not nucleotide-based (as enabled with the </span><span class="s4">nucleotideBased</span><span class="s3"> parameter to </span><span class="s4">initializeSLiMOptions()</span><span class="s3">), the </span><span class="s4">ancestralNucleotides</span><span class="s3"> parameter will be ignored.<span class="Apple-converted-space">  </span>Note that in nucleotide-based models the output format will <i>always</i> include the nucleotides associated with any nucleotide-based mutations; the </span><span class="s4">ancestralNucleotides</span><span class="s3"> flag governs only the ancestral sequence.</span></p>
<p class="p6">Beginning with SLiM 3.5, the <span class="s1">pedigreeIDs</span> parameter may be used to request that pedigree IDs be written out (and read in by <span class="s1">readFromPopulationFile()</span>, subsequently).<span class="Apple-converted-space">  </span>This option is turned off (<span class="s1">F</span>) by default, to preserve backward compatibility; if it is turned on (<span class="s1">T</span>), different file version values will be used, and backward compatibility with previous versions of SLiM will be lost.</p>
<p class="p4">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">– (void)outputMutations(object&lt;Mutation&gt; mutations, [Ns$ filePath = NULL], [logical$ append = F])</p>
<p class="p6"><span class="s6">Output all of the given mutations.<span class="Apple-converted-space">  </span>This can be used to output all mutations of a given mutation type, for example.<span class="Apple-converted-space">  </span></span><span class="s3">If the optional parameter </span><span class="s4">filePath</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by </span><span class="s4">filePath</span><span class="s3">, overwriting that file if </span><span class="s4">append</span><span class="s3"> if </span><span class="s4">F</span><span class="s3">, or appending to the end of it if </span><span class="s4">append</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations.</span></p>
<p class="p4">Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p5"><span class="s3">– (void)outputUsage(void)</span></p>
<p class="p6"><span class="s3">Output the current memory usage of the simulation to Eidos’s output stream.<span class="Apple-converted-space">  </span>The specifics of what is printed, and in what format, should not be relied upon as they may change from version to version of SLiM.<span class="Apple-converted-space">  </span>This method is primarily useful for understanding where the memory usage of a simulation predominantly resides, for debugging or optimization.<span class="Apple-converted-space">  </span>Note that it does not capture <i>all</i> memory usage by the process; rather, it summarizes the memory usage by SLiM and Eidos in directly allocated objects and buffers.<span class="Apple-converted-space">  </span>To get the <i>total</i> memory usage of the running process (either current or peak), use the Eidos function </span><span class="s4">usage()</span><span class="s3">.</span></p>
<p class="p3">– (integer$)readFromPopulationFile(string$ filePath)</p>
<p class="p4">Read from a population initialization file, whether in text or binary format as previously specified to <span class="s1">outputFull()</span><span class="s2">,</span> and return the generation counter value represented by the file’s contents (i.e., the generation at which the file was generated).<span class="Apple-converted-space">  </span>Although this is most commonly used to set up initial populations (often in an Eidos event set to run in generation 1, immediately after simulation initialization), it may be called in any Eidos event; the current state of all populations will be wiped and replaced by the state in the file at <span class="s1">filePath</span>.<span class="Apple-converted-space">  </span>All Eidos variables that are of type <span class="s1">object</span> and have element type <span class="s1">Subpopulation</span>, <span class="s1">Genome</span>, <span class="s1">Mutation</span>, <span class="s1">Individual</span>, or <span class="s1">Substitution</span> will be removed as a side effect of this method, since all such variables would refer to objects that no longer exist in the SLiM simulation; if you want to preserve any of that state, you should output it or save it to a file prior to this call.<span class="Apple-converted-space">  </span>New symbols will be defined to refer to the new <span class="s1">Subpopulation</span> objects loaded from the file.</p>
<p class="p4">If the file being read was written by a version of SLiM prior to 2.3, then for backward compatibility fitness values will be calculated immediately for any new subpopulations created by this call, which will trigger the calling of any activated and applicable <span class="s1">fitness()</span> callbacks.<span class="Apple-converted-space">  </span>When reading files written by SLiM 2.3 or later, fitness values are not calculated as a side effect of this call (because the simulation will often need to evaluate interactions or modify other state prior to doing so).</p>
<p class="p6"><span class="s3">In SLiM 2.3 and later when using the WF model, calling </span><span class="s4">readFromPopulationFile()</span><span class="s3"> from any context other than a </span><span class="s4">late()</span><span class="s3"> event causes a warning; calling from a </span><span class="s4">late()</span><span class="s3"> event is almost always correct in WF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the generation cycle without the need to force their recalculation (see comments on </span><span class="s4">recalculateFitness()</span><span class="s3">).</span></p>
<p class="p6"><span class="s3">In SLiM 3.0 when using the nonWF model, calling </span><span class="s4">readFromPopulationFile()</span><span class="s3"> from any context other than an </span><span class="s4">early()</span><span class="s3"> event causes a warning; calling from an </span><span class="s4">early()</span><span class="s3"> event is almost always correct in nonWF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the generation cycle without the need to force their recalculation (see comments on </span><span class="s4">recalculateFitness()</span><span class="s3">).</span></p>
<p class="p4">As of SLiM 2.1, this method changes the generation counter to the generation read from the file.<span class="Apple-converted-space">  </span>If you do not want the generation counter to be changed, you can change it back after reading, by setting <span class="s1">sim.generation</span> to whatever value you wish.<span class="Apple-converted-space">  </span>Note that restoring a saved past state and running forward again will not yield the same simulation results, because the random number generator’s state will not be the same; to ensure reproducibility from a given time point, <span class="s1">setSeed()</span> can be used to establish a new seed value.<span class="Apple-converted-space">  </span>Any changes made to the simulation’s structure (mutation types, genomic element types, etc.) will not be wiped and re-established by <span class="s1">readFromPopulationFile()</span>; this method loads only the population’s state, not the simulation configuration, so care should be taken to ensure that the simulation structure meshes coherently with the loaded data.</p>
<p class="p4">As of SLiM 2.3, this method will read and restore the spatial positions of individuals if that information is present in the output file and the simulation has enabled continuous space (see <span class="s1">outputFull()</span> for details).<span class="Apple-converted-space">  </span>If spatial positions are present in the output file but the simulation has not enabled continuous space (or the number of spatial dimensions does not match), an error will result.<span class="Apple-converted-space">  </span>If the simulation has enabled continuous space but spatial positions are not present in the output file, the spatial positions of the individuals read will be undefined, but an error is not raised.</p>
<p class="p6"><span class="s3">As of SLiM 3.0, this method will read and restore the ages of individuals if that information is present in the output file and the simulation is based upon the nonWF model.<span class="Apple-converted-space">  </span>If ages are present but the simulation uses a WF model, an error will result; the WF model does not use age information.<span class="Apple-converted-space">  </span>If ages are not present but the simulation uses a nonWF model, an error will also result; the nonWF model requires age information.</span></p>
<p class="p6"><span class="s3">As of SLiM 3.3, this method will restore the nucleotides of nucleotide-based mutations, and will restore the ancestral nucleotide sequence, if that information is present in the output file.<span class="Apple-converted-space">  </span>Loading an output file that contains nucleotide information in a non-nucleotide-based model, and <i>vice versa</i>, will produce an error.</span></p>
<p class="p6">As of SLiM 3.5, this method will read and restore the pedigree IDs of individuals and genomes if that information is present in the output file (as requested with <span class="s1">outputFull(pedigreeIDs=T)</span>).</p>
<p class="p6"><span class="s3">This method can also be used to read tree-sequence (</span><span class="s4">.trees</span><span class="s3">) files saved by </span><span class="s4">treeSeqOutput()</span><span class="s3"> or generated by the Python </span><span class="s4">pyslim</span><span class="s3"> package.<span class="Apple-converted-space">  </span>When loading a tree sequence, a crosscheck of the loaded data will be performed to ensure that the tree sequence was well-formed and was loaded correctly.<span class="Apple-converted-space">  </span>When running a Release build of SLiM, however, this crosscheck will only occur the first time that </span><span class="s4">readFromPopulationFile()</span><span class="s3"> is called to load a tree sequence; subsequent calls will not perform this crosscheck, for greater speed when running models that load saved population state many times (such as models that are conditional on fixation).<span class="Apple-converted-space">  </span>If you suspect that a tree sequence file might be corrupted or read incorrectly, running a Debug build of SLiM enables crosschecks after every load.</span></p>
<p class="p3">– (void)recalculateFitness([Ni$ generation = NULL])</p>
<p class="p4">Force an immediate recalculation of fitness values for all individuals in all subpopulations.<span class="Apple-converted-space">  </span>Normally fitness values are calculated at the end of each generation, and those values are cached and used throughout the following generation.<span class="Apple-converted-space">  </span>If simulation parameters are changed in script in a way that affects fitness calculations, and if you wish those changes to take effect immediately rather than taking effect at the end of the current generation, you may call <span class="s1">recalculateFitness()</span> to force an immediate recalculation and recache.</p>
<p class="p6"><span class="s3">The optional parameter </span><span class="s4">generation</span><span class="s3"> provides the generation for which </span><span class="s4">fitness()</span><span class="s3"> callbacks should be selected; if it is </span><span class="s4">NULL</span><span class="s3"> (the default), the simulation’s current generation value, </span><span class="s4">sim.generation</span><span class="s3">, is used.<span class="Apple-converted-space">  </span>If you call </span><span class="s4">recalculateFitness()</span><span class="s3"> in an </span><span class="s4">early()</span><span class="s3"> event in a WF model, you may wish this to be </span><span class="s4">sim.generation - 1</span><span class="s3"> in order to utilize the </span><span class="s4">fitness()</span><span class="s3"> callbacks for the previous generation, as if the changes that you have made to fitness-influencing parameters were already in effect at the end of the previous generation when the new generation was first created and evaluated (usually it is simpler to just make such changes in a </span><span class="s4">late()</span><span class="s3"> event instead, however, in which case calling </span><span class="s4">recalculateFitness()</span><span class="s3"> is probably not necessary at all since fitness values will be recalculated immediately afterwards).<span class="Apple-converted-space">  </span>Regardless of the value supplied for </span><span class="s4">generation</span><span class="s3"> here, </span><span class="s4">sim.generation</span><span class="s3"> inside </span><span class="s4">fitness()</span><span class="s3"> callbacks will report the true generation number, so if your callbacks consult that parameter in order to create generation-specific fitness effects you will need to handle the discrepancy somehow.<span class="Apple-converted-space">  </span>(Similar considerations apply for nonWF models that call </span><span class="s4">recalculateFitness()</span><span class="s3"> in a </span><span class="s4">late()</span><span class="s3"> event, which is also not advisable in general.)</span></p>
<p class="p4">After this call, the fitness values used for all purposes in SLiM will be the newly calculated values.<span class="Apple-converted-space">  </span>Calling this method will trigger the calling of any enabled and applicable <span class="s1">fitness()</span> callbacks, so this is quite a heavyweight operation; you should think carefully about what side effects might result (which is why fitness recalculation does not just occur automatically after changes that might affect fitness values).</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerEarlyEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">early()</span> event in the current simulation, with optional <span class="s1">start</span> and <span class="s1">end</span> generations limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered event is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerFitnessCallback(Nis$ id, string$ source, Nio&lt;MutationType&gt;$ mutType, [Nio&lt;Subpopulation&gt;$ subpop<span class="s8"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">fitness()</span> callback in the current simulation, with a required mutation type <span class="s1">mutType</span> (which may be an <span class="s1">integer</span> mutation type identifier, or <span class="s1">NULL</span> to indicate a global <span class="s1">fitness()</span> callback), optional subpopulation <span class="s1">subpop</span> (which may also be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations), and optional <span class="s1">start</span> and <span class="s1">end</span> generations all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerInteractionCallback(Nis$ id, string$ source, io&lt;InteractionType&gt;$ intType, [Nio&lt;Subpopulation&gt;$ subpop<span class="s8"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">interaction()</span> callback in the current simulation, with a required interaction type <span class="s1">intType</span> (which may be an <span class="s1">integer</span> identifier), optional subpopulation <span class="s1">subpop</span> (which may also be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations), and optional <span class="s1">start</span> and <span class="s1">end</span> generations all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it will be eligible to execute the next time an <span class="s1">InteractionType</span> is evaluated.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerLateEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">late()</span> event in the current simulation, with optional <span class="s1">start</span> and <span class="s1">end</span> generations limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered event is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerMateChoiceCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">mateChoice()</span> callback in the current simulation, with optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations) and optional <span class="s1">start</span> and <span class="s1">end</span> generations all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerModifyChildCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s8"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">modifyChild()</span> callback in the current simulation, with optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations) and optional <span class="s1">start</span> and <span class="s1">end</span> generations all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerRecombinationCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s8"> </span>= NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p4">Register a block of Eidos source code, represented as the <span class="s1">string</span> singleton <span class="s1">source</span>, as an Eidos <span class="s1">recombination()</span> callback in the current simulation, with optional subpopulation <span class="s1">subpop</span> (which may be an <span class="s1">integer</span> identifier, or <span class="s1">NULL</span>, the default, to indicate all subpopulations) and optional <span class="s1">start</span> and <span class="s1">end</span> generations all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier <span class="s1">id</span> (specified as an <span class="s1">integer</span>, or as a <span class="s1">string</span> symbolic name such as <span class="s1">"s5"</span>); this may be <span class="s1">NULL</span> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered <span class="s1">SLiMEidosBlock</span> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new <span class="s1">SLiMEidosBlock</span> will be defined as a global variable immediately by this method, and will also be returned by this method.</p>
<p class="p5"><span class="s3">– (object&lt;SLiMEidosBlock&gt;$)registerMutationCallback(Nis$ id, string$ source, [Nio&lt;MutationType&gt;$ mutType = NULL], [Nio&lt;Subpopulation&gt;$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</span></p>
<p class="p6"><span class="s3">Register a block of Eidos source code, represented as the </span><span class="s4">string</span><span class="s3"> singleton </span><span class="s4">source</span><span class="s3">, as an Eidos </span><span class="s4">mutation()</span><span class="s3"> callback in the current simulation, with an optional mutation type </span><span class="s4">mutType</span><span class="s3"> (which may be an </span><span class="s4">integer</span><span class="s3"> mutation type identifier, or </span><span class="s4">NULL</span><span class="s3">, the default, to indicate all mutation types), optional subpopulation </span><span class="s4">subpop</span><span class="s3"> (which may also be an </span><span class="s4">integer</span><span class="s3"> identifier, or </span><span class="s4">NULL</span><span class="s3">, the default, to indicate all subpopulations), and optional </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> generations all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier </span><span class="s4">id</span><span class="s3"> (specified as an </span><span class="s4">integer</span><span class="s3">, or as a </span><span class="s4">string</span><span class="s3"> symbolic name such as </span><span class="s4">"s5"</span><span class="s3">); this may be </span><span class="s4">NULL</span><span class="s3"> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered </span><span class="s4">SLiMEidosBlock</span><span class="s3"> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new </span><span class="s4">SLiMEidosBlock</span><span class="s3"> will be defined as a global variable immediately by this method, and will also be returned by this method.</span></p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;$)registerReproductionCallback(Nis$ id, string$ source, [Nio&lt;Subpopulation&gt;$ subpop<span class="s8"> </span>= NULL], <span class="s5">[Ns$ sex = NULL], </span>[Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p6"><span class="s3">Register a block of Eidos source code, represented as the </span><span class="s4">string</span><span class="s3"> singleton </span><span class="s4">source</span><span class="s3">, as an Eidos </span><span class="s4">reproduction()</span><span class="s3"> callback in the current simulation, with optional subpopulation </span><span class="s4">subpop</span><span class="s3"> (which may be an </span><span class="s4">integer</span><span class="s3"> identifier, or </span><span class="s4">NULL</span><span class="s3">, the default, to indicate all subpopulations), optional sex-specificity </span><span class="s4">sex</span><span class="s3"> (which may be </span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3"> in sexual simulations to make the callback specific to males or females respectively, or </span><span class="s4">NULL</span><span class="s3"> for no sex-specificity), and optional </span><span class="s4">start</span><span class="s3"> and </span><span class="s4">end</span><span class="s3"> generations all limiting its applicability.<span class="Apple-converted-space">  </span>The script block will be given identifier </span><span class="s4">id</span><span class="s3"> (specified as an </span><span class="s4">integer</span><span class="s3">, or as a </span><span class="s4">string</span><span class="s3"> symbolic name such as </span><span class="s4">"s5"</span><span class="s3">); this may be </span><span class="s4">NULL</span><span class="s3"> if there is no need to be able to refer to the block later.<span class="Apple-converted-space">  </span>The registered callback is added to the end of the list of registered </span><span class="s4">SLiMEidosBlock</span><span class="s3"> objects, and is active immediately; it <i>may</i> be eligible to execute in the current generation.<span class="Apple-converted-space">  </span>The new </span><span class="s4">SLiMEidosBlock</span><span class="s3"> will be defined as a global variable immediately by this method, and will also be returned by this method.</span></p>
<p class="p3">– (object&lt;SLiMEidosBlock&gt;)rescheduleScriptBlock(object&lt;SLiMEidosBlock&gt;$<span class="s8"> </span>block, [Ni$ start = NULL], [Ni$ end = NULL], [Ni generations = NULL])</p>
<p class="p4">Reschedule the target script block given by <span class="s1">block</span> to execute in a specified set of generations.</p>
<p class="p4">The first way to specify the generation set is with <span class="s1">start</span> and <span class="s1">end</span> parameter values; <span class="s1">block</span> will then execute from <span class="s1">start</span> to <span class="s1">end</span>, inclusive.<span class="Apple-converted-space">  </span>In this case, <span class="s1">block</span> is returned.</p>
<p class="p4">The second way to specify the generation set is using the <span class="s1">generations</span> parameter; this is more flexible but more complicated.<span class="Apple-converted-space">  </span>Since script blocks execute across a contiguous span of generations defined by their <span class="s1">start</span> and <span class="s1">end</span> properties, this may result in the duplication of <span class="s1">block</span>; one script block will be used for each contiguous span of generations in <span class="s1">generations</span><span class="s2">.</span><span class="Apple-converted-space">  </span>The <span class="s1">block</span> object itself will be rescheduled to cover the first such span, whereas duplicates of <span class="s1">block</span> will be created to cover subsequent contiguous spans.<span class="Apple-converted-space">  </span>A vector containing all of the script blocks scheduled by this method, including <span class="s1">block</span>, will be returned; this vector is guaranteed to be sorted by the (ascending) scheduled execution order of the blocks.<span class="Apple-converted-space">  </span>Any duplicates of <span class="s1">block</span> created will be given values for the <span class="s1">active</span>, <span class="s1">source</span>, <span class="s1">tag</span>, and <span class="s1">type</span> properties equal to the current values for <span class="s1">block</span>, but will be given an <span class="s1">id</span> of <span class="s1">-1</span> since script block identifiers must be unique; if it is necessary to find the duplicated blocks again later, their <span class="s1">tag</span> property should be used.<span class="Apple-converted-space">  </span>The vector supplied for <span class="s1">generations</span> does not need to be in sorted order, but it must not contain any duplicates.</p>
<p class="p4">Because this method can create a large number of duplicate script blocks, it can sometimes be better to handle script block scheduling in other ways.<span class="Apple-converted-space">  </span>If an <span class="s1">early()</span> event needs to execute every tenth generation over the whole duration of a long model run, for example, it would not be advisable to use a call like <span class="s1">sim.rescheduleScriptBlock(s1, generations=seq(10, 100000, 10))</span> for that purpose, since that would result in thousands of duplicate script blocks.<span class="Apple-converted-space">  </span>Instead, it would be preferable to add a test such as <span class="s1">if (sim.generation % 10 != 0) return;</span> at the beginning of the event.<span class="Apple-converted-space">  </span>It is legal to reschedule a script block while the block is executing; a call like <span class="s1">sim.rescheduleScriptBlock(self, sim.generation + 10, sim.generation + 10);</span> made inside a given block would therefore also cause the block to execute every tenth generation, although this sort of self-rescheduling code is probably harder to read, maintain, and debug.</p>
<p class="p4">Whichever way of specifying the generation set is used, <span class="s1">block</span> may continue to be executed during the current life cycle stage even after it has been rescheduled, unless it is made inactive using its <span class="s1">active</span> property, and similarly, the block may not execute during the current life cycle stage if it was not already scheduled to do so.<span class="Apple-converted-space">  </span>Rescheduling script blocks during the generation and life cycle stage in which they are executing, or in which they are intended to execute, should be avoided.<span class="s6"><span class="Apple-converted-space">  </span>Also, as mentioned in section 21.7, script blocks which are open-ended (i.e., with no specified end generation), are not used in determining whether the end of the simulation has been reached (because then the simulation would run forever); if you reschedule a block to be open-ended, and to start after the end of the last closed-ended block, the rescheduled block will therefore not run at all (just as such a block would not run at all in other circumstances, too).</span></p>
<p class="p4">Note that new script blocks can also be created and scheduled using the <span class="s1">register...()</span> methods of <span class="s1">SLiMSim</span>; by using the same source as a template script block, the template can be duplicated and scheduled for different generations.<span class="Apple-converted-space">  </span>In fact, <span class="s1">rescheduleScriptBlock()</span> does essentially that internally.</p>
<p class="p3">–<span class="s8"> </span>(void)setValue(string$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span><span class="s2">.</span><span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span><span class="s6">If </span><span class="s10">value</span><span class="s6"> is of type </span><span class="s10">object</span><span class="s6">, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only </span><span class="s10">Mutation</span><span class="s6"> and </span><span class="s10">Substitution</span><span class="s6"> presently are (see the Eidos manual’s documentation for </span><span class="s10">defineConstant()</span><span class="s6"> for further discussion).<span class="Apple-converted-space">  </span></span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">SLiMSim</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">– (void)simulationFinished(void)</p>
<p class="p4">Declare the current simulation finished.<span class="Apple-converted-space">  </span>Normally SLiM ends a simulation when, at the end of a generation, there are no script events or callbacks registered for any future generation (excluding scripts with no declared end generation).<span class="Apple-converted-space">  </span>If you wish to end a simulation before this condition is met, a call to <span class="s1">simulationFinished()</span> will cause the current simulation to end at the end of the current generation.<span class="Apple-converted-space">  </span>For example, a simulation might self-terminate if a test for a dynamic equilibrium condition is satisfied.<span class="Apple-converted-space">  </span>Note that the current generation will finish executing; if you want the simulation to stop immediately, you can use the Eidos method <span class="s1">stop()</span>, which raises an error condition.</p>
<p class="p5">– (object&lt;Mutation&gt;)subsetMutations([No&lt;Mutation&gt;$ exclude = NULL], [Nio&lt;MutationType&gt;$ mutType = NULL], [Ni$ position = NULL], [Nis$ nucleotide = NULL], [Ni$ tag = NULL], [Ni$ id = NULL])</p>
<p class="p6">Returns a vector of mutations subset from the list of all active mutations in the simulation (as would be provided by the <span class="s1">mutations</span> property).<span class="Apple-converted-space">  </span>The parameters specify constraints upon the subset of mutations that will be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">exclude</span>, if non-<span class="s1">NULL</span>, may specify a specific mutation that should not be included (typically the focal mutation in some operation).<span class="Apple-converted-space">  </span>Parameter <span class="s1">mutType</span>, if non-<span class="s1">NULL</span>, may specify a mutation type for the mutations to be returned (as either a <span class="s1">MutationType</span> object or an <span class="s1">integer</span> identifier).<span class="Apple-converted-space">  </span>Parameter <span class="s1">position</span>, if non-<span class="s1">NULL</span>, may specify a base position for the mutations to be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">nucleotide</span>, if non-<span class="s1">NULL</span>, may specify a nucleotide for the mutations to be returned (either as a string, <span class="s1">"A"</span> / <span class="s1">"C"</span> / <span class="s1">"G"</span> / <span class="s1">"T"</span>, or as an integer, <span class="s1">0</span> / <span class="s1">1</span> / <span class="s1">2</span> / <span class="s1">3</span> respectively).<span class="Apple-converted-space">  </span>Parameter <span class="s1">tag</span>, if non-<span class="s1">NULL</span>, may specify a tag value for the mutations to be returned.<span class="Apple-converted-space">  </span>Parameter <span class="s1">id</span>, if non-<span class="s1">NULL</span>, may specify a required value for the <span class="s1">id</span> property of the mutations to be returned.</p>
<p class="p6">This method is shorthand for getting the <span class="s1">mutations</span> property of the subpopulation, and then using operator <span class="s1">[]</span> to select only mutations with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.<span class="Apple-converted-space">  </span>Note that if you only need to select on mutation type, the <span class="s1">mutationsOfType()</span> method will be even faster.</p>
<p class="p5"><span class="s3">– (logical$)treeSeqCoalesced(void)</span></p>
<p class="p6"><span class="s3">Returns the coalescence state for the recorded tree sequence at the last simplification.<span class="Apple-converted-space">  </span>The returned value is a logical singleton flag, </span><span class="s4">T</span><span class="s3"> to indicate that full coalescence was observed at the last tree-sequence simplification (meaning that there is a single ancestral individual that roots all ancestry trees at all sites along the chromosome – although not necessarily the <i>same</i> ancestor at all sites), or </span><span class="s4">F</span><span class="s3"> if full coalescence was not observed.<span class="Apple-converted-space">  </span>For simple models, reaching coalescence may indicate that the model has reached an equilibrium state, but this may not be true in models that modify the dynamics of the model during execution by changing migration rates, introducing new mutations programmatically, dictating non-random mating, etc., so be careful not to attach more meaning to coalescence than it is due; some models may require burn-in beyond coalescence to reach equilibrium, or may not have an equilibrium state at all.<span class="Apple-converted-space">  </span>Also note that some actions by a model, such as adding a new subpopulation, may cause the coalescence state to revert from </span><span class="s4">T</span><span class="s3"> back to </span><span class="s4">F</span><span class="s3"> (at the next simplification), so a return value of </span><span class="s4">T</span><span class="s3"> may not necessarily mean that the model is coalesced at the present moment – only that it <i>was</i> coalesced at the last simplification.</span></p>
<p class="p6"><span class="s3">This method may only be called if tree sequence recording has been turned on with </span><span class="s4">initializeTreeSeq()</span><span class="s3">; in addition, </span><span class="s4">checkCoalescence=T</span><span class="s3"> must have been supplied to </span><span class="s4">initializeTreeSeq()</span><span class="s3">, so that the necessary work is done during each tree-sequence simplification.<span class="Apple-converted-space">  </span>Since this method does not perform coalescence checking itself, but instead simply returns the coalescence state observed at the last simplification, it may be desirable to call </span><span class="s4">treeSeqSimplify()</span><span class="s3"> immediately before </span><span class="s4">treeSeqCoalesced()</span><span class="s3"> to obtain up-to-date information.<span class="Apple-converted-space">  </span>However, the speed penalty of doing this in every generation would be large, and most models do not need this level of precision; usually it is sufficient to know that the model has coalesced, without knowing whether that happened in the current generation or in a recent preceding generation.</span></p>
<p class="p5"><span class="s3">– (void)treeSeqOutput(string$ path, [logical$ simplify = T], [logical$ includeModel = T])</span></p>
<p class="p6"><span class="s3">Outputs the current tree sequence recording tables to the path specified by path.<span class="Apple-converted-space">  </span>This method may only be called if tree sequence recording has been turned on with </span><span class="s4">initializeTreeSeq()</span><span class="s3">.<span class="Apple-converted-space">  </span>If </span><span class="s4">simplify</span><span class="s3"> is </span><span class="s4">T</span><span class="s3"> (the default), simplification will be done immediately prior to output; this is almost always desirable, unless a model wishes to avoid simplification entirely.<span class="Apple-converted-space">  </span>A binary tree sequence file will be written to the specified path; a filename extension of </span><span class="s4">.trees</span><span class="s3"> is suggested for this type of file.</span></p>
<p class="p6"><span class="s3">Normally, the full SLiM script used to generate the tree sequence is written out to the provenance entry of the tree sequence file, to the </span><span class="s4">model</span><span class="s3"> subkey of the </span><span class="s4">parameters</span><span class="s3"> top-level key.<span class="Apple-converted-space">  </span>Supplying </span><span class="s4">F</span><span class="s3"> for </span><span class="s4">includeModel</span><span class="s3"> suppresses output of the full script.</span></p>
<p class="p5"><span class="s3">– (void)treeSeqRememberIndividuals(object&lt;Individual&gt; individuals)</span></p>
<p class="p6"><span class="s3">Permanently adds the individuals specified by </span><span class="s4">individuals</span><span class="s3"> to the sample retained across tree sequence table simplification.<span class="Apple-converted-space">  </span>This method may only be called if tree sequence recording has been turned on with </span><span class="s4">initializeTreeSeq()</span><span class="s3">.<span class="Apple-converted-space">  </span>All currently living individuals are always retained across simplification; this method does not need to be called, and indeed should not be called, for that purpose.<span class="Apple-converted-space">  </span>Instead, </span><span class="s4">treeSeqRememberIndividuals()</span><span class="s3"> is for <i>permanently</i> adding particular individuals to the retained sample.<span class="Apple-converted-space">  </span>Typically this would be used, for example, to retain particular individuals that you wanted to be able to trace ancestry back to in later analysis.<span class="Apple-converted-space">  </span>However, this is not the typical usage pattern for tree sequence recording; most models will not need to call this method.</span></p>
<p class="p6"><span class="s3">The metadata (age, location, etc) that are stored in the resulting tree sequence are those values present at either (a) the final generation, if the individual is alive at the end of the simulation, or (b) the last time that the individual was remembered, if not.<span class="Apple-converted-space">  </span>Calling </span><span class="s4">treeSeqRememberIndividuals()</span><span class="s3"> on an individual that is already remembered will cause the archived information about the remembered individual to be updated to reflect the individual’s current state.<span class="Apple-converted-space">  </span>A case where this is particularly important is for the spatial location of individuals in continuous-space models.<span class="Apple-converted-space">  </span>SLiM automatically remembers the individuals that comprise the first generation of any new subpopulation created with </span><span class="s4">addSubpop()</span><span class="s3">, for easy recapitation and other analysis.<span class="Apple-converted-space">  </span>However, since these first-generation individuals are remembered at the moment they are created, their spatial locations have not yet been set up, and will contain garbage – and those garbage values will be archived in their remembered state.<span class="Apple-converted-space">  </span>If you need correct spatial locations of first-generation individuals for your post-simulation analysis, you should call </span><span class="s4">treeSeqRememberIndividuals()</span><span class="s3"> explicitly on the first generation, after setting spatial locations, to update the archived information with the correct spatial positions.</span></p>
<p class="p5"><span class="s3">– (void)treeSeqSimplify(void)</span></p>
<p class="p6"><span class="s3">Triggers an immediate simplification of the tree sequence recording tables.<span class="Apple-converted-space">  </span>This method may only be called if tree sequence recording has been turned on with </span><span class="s4">initializeTreeSeq()</span><span class="s3">.<span class="Apple-converted-space">  </span>A call to this method will free up memory being used by entries that are no longer in the ancestral path of any individual within the current sample (currently living individuals, in other words, plus those explicitly added to the sample with </span><span class="s4">treeSeqRememberIndividuals()</span><span class="s3">), but it can also take a significant amount of time.<span class="Apple-converted-space">  </span>Typically calling this method is not necessary; the automatic simplification performed occasionally by SLiM should be sufficient for most models.</span></p>
<p class="p1"><b>5.13<span class="Apple-converted-space">  </span>Class Subpopulation</b></p>
<p class="p2"><i>5.13.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Subpopulation</i></span><i> properties</i></p>
<p class="p3">cloningRate =&gt; (float)</p>
<p class="p4">The fraction of children in the next generation that will be produced by cloning (as opposed to biparental mating).<span class="Apple-converted-space">  </span>In non-sexual (i.e. hermaphroditic) simulations, this property is a singleton <span class="s1">float</span> representing the overall subpopulation cloning rate.<span class="Apple-converted-space">  </span>In sexual simulations, this property is a <span class="s1">float</span> vector with two values: the cloning rate for females (at index <span class="s1">0</span>) and for males (at index <span class="s1">1</span>).</p>
<p class="p3">firstMaleIndex =&gt; (integer$)</p>
<p class="p4">The index of the first male individual in the subpopulation.<span class="Apple-converted-space">  </span>The <span class="s1">genomes</span> vector is sorted into females first and males second; <span class="s1">firstMaleIndex</span> gives the position of the boundary between those sections.<span class="Apple-converted-space">  </span>Note, however, that there are two genomes per diploid individual, and the <span class="s1">firstMaleIndex</span> is <i>not</i> premultiplied by <span class="s1">2</span>; you must multiply it by <span class="s1">2</span> before using it to decide whether a given index into <span class="s1">genomes</span> is a genome for a male or a female.<span class="Apple-converted-space">  </span>The <span class="s1">firstMaleIndex</span> property is also the number of females in the subpopulation, given this design.<span class="Apple-converted-space">  </span>For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used.</p>
<p class="p5"><span class="s3">fitnessScaling &lt;–&gt; (float$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">float</span><span class="s3"> scaling factor applied to the fitness of all individuals in this subpopulation (i.e., the fitness value computed for each individual will be multiplied by this value).<span class="Apple-converted-space">  </span>This is primarily of use in nonWF models, where fitness is absolute, rather than in WF models, where fitness is relative (and thus a constant factor multiplied into the fitness of every individual will make no difference); however, it may be used in either type of model.<span class="Apple-converted-space">  </span>This provides a simple, fast way to modify the fitness of all individuals in a subpopulation; conceptually it is similar to returning the same fitness effect for all individuals in the subpopulation from a </span><span class="s4">fitness(NULL)</span><span class="s3"> callback, but without the complexity and performance overhead of implementing such a callback.<span class="Apple-converted-space">  </span>To scale the fitness of individuals by different (individual-specific) factors, see the </span><span class="s4">fitnessScaling</span><span class="s3"> property of </span><span class="s4">Individual</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The value of </span><span class="s4">fitnessScaling</span><span class="s3"> is reset to </span><span class="s4">1.0</span><span class="s3"> every generation, so that any scaling factor set lasts for only a single generation.<span class="Apple-converted-space">  </span>This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.</span></p>
<p class="p3">genomes =&gt; (object&lt;Genome&gt;)</p>
<p class="p4">All of the genomes contained by the subpopulation; there are two genomes per diploid individual.</p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this subpopulation; for subpopulation <span class="s1">p3</span>, for example, this is <span class="s1">3</span><span class="s2">.</span></p>
<p class="p3">immigrantSubpopFractions =&gt; (float)</p>
<p class="p4">The expected value of the fraction of children in the next generation that are immigrants arriving from particular subpopulations.</p>
<p class="p3">immigrantSubpopIDs =&gt; (integer)</p>
<p class="p4">The identifiers of the particular subpopulations from which immigrants will arrive in the next generation.</p>
<p class="p3">individualCount =&gt; (integer$)</p>
<p class="p4">The number of individuals in the subpopulation; one-half of the number of genomes.</p>
<p class="p3">individuals =&gt; (object&lt;Individual&gt;)</p>
<p class="p6"><span class="s6">All of the individuals contained by the subpopulation.<span class="Apple-converted-space">  </span>Each individual is diploid and thus contains two </span><span class="s10">Genome</span><span class="s6"> objects.</span><span class="s3"><span class="Apple-converted-space">  </span>See the </span><span class="s4">sampleIndividuals()</span><span class="s3"> and </span><span class="s4">subsetIndividuals()</span><span class="s3"> for fast ways to get a subset of the individuals in a subpopulation.</span></p>
<p class="p3">selfingRate =&gt; (float$)</p>
<p class="p4">The expected value of the fraction of children in the next generation that will be produced by selfing (as opposed to biparental mating).<span class="Apple-converted-space">  </span>Selfing is only possible in non-sexual (i.e. hermaphroditic) simulations; for sexual simulations this property always has a value of <span class="s1">0.0</span><span class="s2">.</span></p>
<p class="p3">sexRatio =&gt; (float$)</p>
<p class="p4">For sexual simulations, the sex ratio for the subpopulation.<span class="Apple-converted-space">  </span>This is defined, in SLiM, as the fraction of the subpopulation that is male; in other words, it is actually the M:(M+F) ratio.<span class="Apple-converted-space">  </span>For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used.</p>
<p class="p3">spatialBounds =&gt; (float)</p>
<p class="p4">The spatial boundaries of the subpopulation.<span class="Apple-converted-space">  </span>The length of the <span class="s1">spatialBounds</span> property depends upon the spatial dimensionality declared with <span class="s1">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>If the spatial dimensionality is zero (as it is by default), the value of this property is <span class="s1">float(0)</span> (a zero-length <span class="s1">float</span> vector).<span class="Apple-converted-space">  </span>Otherwise, minimums are supplied for each coordinate used by the dimensionality of the simulation, followed by maximums for each.<span class="Apple-converted-space">  </span>In other words, if the declared dimensionality is <span class="s1">"xy"</span>, the <span class="s1">spatialBounds</span> property will contain values <span class="s1">(x0, y0, x1, y1)</span>; bounds for the <i>z</i> coordinate will not be included in that case, since that coordinate is not used in the simulation’s dimensionality.<span class="Apple-converted-space">  </span>This property cannot be set, but the <span class="s1">setSpatialBounds()</span> method may be used to achieve the same thing.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is initially undefined<span class="s5">, and it is an error to try to read it</span>; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.<span class="Apple-converted-space">  </span>See also the <span class="s1">getValue()</span> and <span class="s1">setValue()</span> methods, for another way of attaching state to subpopulations.</p>
<p class="p2"><i>5.13.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Subpopulation</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (No&lt;Individual&gt;$)addCloned(object&lt;Individual&gt;$ parent)</span></p>
<p class="p6"><span class="s3">Generates a new offspring individual from the given parent by clonal reproduction, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.<span class="Apple-converted-space">  </span>The subpopulation of </span><span class="s4">parent</span><span class="s3"> will be used to locate applicable </span><span class="s4">mutation()</span><span class="s3"> and<span class="Apple-converted-space">  </span></span><span class="s4">modifyChild()</span><span class="s3"> callbacks governing the generation of the offspring individual.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See </span><span class="s4">addCrossed()</span><span class="s3"> for further general notes on the addition of new offspring individuals.</span></p>
<p class="p5"><span class="s3">– (No&lt;Individual&gt;$)addCrossed(object&lt;Individual&gt;$ parent1, object&lt;Individual&gt;$ parent2, [Nfs$ sex = NULL])</span></p>
<p class="p6"><span class="s3">Generates a new offspring individual from the given parents by biparental sexual reproduction, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.<span class="Apple-converted-space">  </span>Attempting to use a newly generated offspring individual as a mate, or to reference it as a member of the target subpopulation in any other way, will result in an error.<span class="Apple-converted-space">  </span>In most models the returned individual is not used, but it is provided for maximal generality and flexibility.</span></p>
<p class="p6"><span class="s3">The new offspring individual is generated from </span><span class="s4">parent1</span><span class="s3"> and </span><span class="s4">parent2</span><span class="s3"> by crossing them.<span class="Apple-converted-space">  </span>In sexual models </span><span class="s4">parent1</span><span class="s3"> must be female and </span><span class="s4">parent2</span><span class="s3"> must be male; in hermaphroditic models, </span><span class="s4">parent1</span><span class="s3"> and </span><span class="s4">parent2</span><span class="s3"> are unrestricted.<span class="Apple-converted-space">  </span>If </span><span class="s4">parent1</span><span class="s3"> and </span><span class="s4">parent2</span><span class="s3"> are the same individual in a hermaphroditic model, that parent self-fertilizes, or “selfs”, to generate the offspring sexually (note this is not the same as clonal reproduction).<span class="Apple-converted-space">  </span>Such selfing is considered “incidental” by </span><span class="s4">addCrossed()</span><span class="s3">, however; if the </span><span class="s4">preventIncidentalSelfing</span><span class="s3"> flag of </span><span class="s4">initializeSLiMOptions()</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">, supplying the same individual for </span><span class="s4">parent1</span><span class="s3"> and </span><span class="s4">parent2</span><span class="s3"> is an error (you must check for and prevent incidental selfing if you set that flag in a nonWF model).<span class="Apple-converted-space">  </span>If non-incidental selfing is desired, </span><span class="s4">addSelfed()</span><span class="s3"> should be used instead.</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">sex</span><span class="s3"> parameter specifies the sex of the offspring.<span class="Apple-converted-space">  </span>A value of </span><span class="s4">NULL</span><span class="s3"> means “make the default choice”; in non-sexual models it is the only legal value for </span><span class="s4">sex</span><span class="s3">, and does nothing, whereas in sexual models it causes male or female to be chosen with equal probability.<span class="Apple-converted-space">  </span>A value of </span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3"> for </span><span class="s4">sex</span><span class="s3"> specifies that the offspring should be male or female, respectively.<span class="Apple-converted-space">  </span>Finally, a </span><span class="s4">float</span><span class="s3"> value from </span><span class="s4">0.0</span><span class="s3"> to </span><span class="s4">1.0</span><span class="s3"> for </span><span class="s4">sex</span><span class="s3"> provides the probability that the offspring will be male; a value of </span><span class="s4">0.0</span><span class="s3"> will produce a female, a value of </span><span class="s4">1.0</span><span class="s3"> will produce a male, and for intermediate values SLiM will draw the sex of the offspring randomly according to the specified probability.<span class="Apple-converted-space">  </span>Unless you wish the bias the sex ratio of offspring, the default value of </span><span class="s4">NULL</span><span class="s3"> should generally be used.</span></p>
<p class="p6"><span class="s3">Note that any defined, active, and applicable </span><span class="s4">recombination()</span><span class="s3">, </span><span class="s4">mutation()</span><span class="s3">, and </span><span class="s4">modifyChild()</span><span class="s3"> callbacks will be called as a side effect of calling this method, before this method even returns.<span class="Apple-converted-space">  </span>For </span><span class="s4">recombination()</span><span class="s3"> and </span><span class="s4">mutation()</span><span class="s3"> callbacks, the subpopulation of the parent that is generating a given gamete is used; for </span><span class="s4">modifyChild()</span><span class="s3"> callbacks the situation is more complex.<span class="Apple-converted-space">  </span>In most biparental mating events, </span><span class="s4">parent1</span><span class="s3"> and </span><span class="s4">parent2</span><span class="s3"> will belong to the same subpopulation, and </span><span class="s4">modifyChild()</span><span class="s3"> callbacks for that subpopulation will be used, just as in WF models.<span class="Apple-converted-space">  </span>In certain models (such as models of pollen flow and broadcast spawning), however, biparental mating may occur between parents that are not from the same subpopulation; that is legal in nonWF models, and in that case, </span><span class="s4">modifyChild()</span><span class="s3"> callbacks for the subpopulation of </span><span class="s4">parent1</span><span class="s3"> are used (since that is the maternal parent).</span></p>
<p class="p6"><span class="s3">If the </span><span class="s4">modifyChild()</span><span class="s3"> callback process results in rejection of the proposed child, a new offspring individual will not be generated, and this method will return </span><span class="s4">NULL</span><span class="s3">.<span class="Apple-converted-space">  </span>To force the generation of an offspring individual from a given pair of parents, you could loop until </span><span class="s4">addCrossed()</span><span class="s3"> succeeds, but note that if your </span><span class="s4">modifyChild()</span><span class="s3"> callback rejects all proposed children from those particular parents, your model will then hang, so care must be taken with this approach.<span class="Apple-converted-space">  </span>Usually, nonWF models do not force generation of offspring in this manner; rejection of a proposed offspring by a </span><span class="s4">modifyChild()</span><span class="s3"> callback typically represents a phenomenon such as post-mating reproductive isolation or lethal genetic incompatibilities that would reduce the expected litter size, so the default behavior is typically desirable.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models, in which offspring generation is managed manually by the model script; in such models, </span><span class="s4">addCrossed()</span><span class="s3"> must be called only from </span><span class="s4">reproduce()</span><span class="s3"> callbacks, and may not be called at any other time.<span class="Apple-converted-space">  </span>In WF models, offspring generation is managed automatically by the SLiM core.</span></p>
<p class="p5"><span class="s3">– (No&lt;Individual&gt;$)addEmpty([Nfs$ sex = NULL])</span></p>
<p class="p6"><span class="s3">Generates a new offspring individual with empty genomes (i.e., containing no mutations), queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.<span class="Apple-converted-space">  </span>No </span><span class="s4">recombination()</span><span class="s3"> or </span><span class="s4">mutation()</span><span class="s3"> callbacks will be called.<span class="Apple-converted-space">  </span>The target subpopulation will be used to locate applicable </span><span class="s4">modifyChild()</span><span class="s3"> callbacks governing the generation of the offspring individual (unlike the other </span><span class="s4">addX()</span><span class="s3"> methods, because there is no parental individual to reference).<span class="Apple-converted-space">  </span>The offspring is considered to have no parents for the purposes of pedigree tracking.<span class="Apple-converted-space">  </span>The </span><span class="s4">sex</span><span class="s3"> parameter is treated as in </span><span class="s4">addCrossed()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See </span><span class="s4">addCrossed()</span><span class="s3"> for further general notes on the addition of new offspring individuals.</span></p>
<p class="p5"><span class="s3">– (No&lt;Individual&gt;$)addRecombinant(No&lt;Genome&gt;$ strand1, No&lt;Genome&gt;$ strand2, Ni breaks1, No&lt;Genome&gt;$ strand3, No&lt;Genome&gt;$ strand4, Ni breaks2, [Nfs$ sex = NULL])</span></p>
<p class="p6"><span class="s3">Generates a new offspring individual from the given parental genomes with the specified crossover breakpoints, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.<span class="Apple-converted-space">  </span>The target subpopulation will be used to locate applicable </span><span class="s4">mutation()</span><span class="s3"> and </span><span class="s4">modifyChild()</span><span class="s3"> callbacks governing the generation of the offspring individual (unlike the other </span><span class="s4">addX()</span><span class="s3"> methods, because there are potentially up to four parental individuals to reference); </span><span class="s4">recombination()</span><span class="s3"> callbacks will not be called by this method.<span class="Apple-converted-space">  </span>This method is an advanced feature; most models will use </span><span class="s4">addCrossed()</span><span class="s3">, </span><span class="s4">addSelfed()</span><span class="s3">, or </span><span class="s4">addCloned()</span><span class="s3"> instead.</span></p>
<p class="p6"><span class="s3">This method supports several possible configurations for </span><span class="s4">strand1</span><span class="s3">, </span><span class="s4">strand2</span><span class="s3">, and </span><span class="s4">breaks1</span><span class="s3"> (and the same applies for </span><span class="s4">strand3</span><span class="s3">, </span><span class="s4">strand4</span><span class="s3">, and </span><span class="s4">breaks2</span><span class="s3">).<span class="Apple-converted-space">  </span>If </span><span class="s4">strand1</span><span class="s3"> and </span><span class="s4">strand2</span><span class="s3"> are both </span><span class="s4">NULL</span><span class="s3">, the corresponding genome in the generated offspring will be empty, as from </span><span class="s4">addEmpty()</span><span class="s3">, with no parental genomes and no added mutations; in this case, </span><span class="s4">breaks1</span><span class="s3"> must be </span><span class="s4">NULL</span><span class="s3"> or zero-length.<span class="Apple-converted-space">  </span>If </span><span class="s4">strand1</span><span class="s3"> is non-</span><span class="s4">NULL</span><span class="s3"> but </span><span class="s4">strand2</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3">, the corresponding genome in the generated offspring will be a clonal copy of </span><span class="s4">strand1</span><span class="s3"> with mutations added, as from </span><span class="s4">addCloned()</span><span class="s3">; in this case, </span><span class="s4">breaks1</span><span class="s3"> must similarly be </span><span class="s4">NULL</span><span class="s3"> or zero-length.<span class="Apple-converted-space">  </span>If </span><span class="s4">strand1</span><span class="s3"> and </span><span class="s4">strand2</span><span class="s3"> are both non-</span><span class="s4">NULL</span><span class="s3">, the corresponding genome in the generated offspring will result from recombination between </span><span class="s4">strand1</span><span class="s3"> and </span><span class="s4">strand2</span><span class="s3"> with mutations added, as from </span><span class="s4">addCrossed()</span><span class="s3">, with </span><span class="s4">strand1</span><span class="s3"> being the initial copy strand; copying will switch between strands at each breakpoint in </span><span class="s4">breaks1</span><span class="s3">, which must be non-</span><span class="s4">NULL</span><span class="s3"> but need not be sorted or uniqued (SLiM will sort and unique the supplied breakpoints internally).<span class="Apple-converted-space">  </span>(It is not currently legal for </span><span class="s4">strand1</span><span class="s3"> to be </span><span class="s4">NULL</span><span class="s3"> and </span><span class="s4">strand2</span><span class="s3"> non-</span><span class="s4">NULL</span><span class="s3">; that variant may be assigned some meaning in future.)<span class="Apple-converted-space">  </span>Again, this discussion applies equally to </span><span class="s4">strand3</span><span class="s3">, </span><span class="s4">strand4</span><span class="s3">, and </span><span class="s4">breaks2</span><span class="s3">, <i>mutatis mutandis</i>.<span class="Apple-converted-space">  </span>Note that when new mutations are generated by </span><span class="s4">addRecombinant()</span><span class="s3">, their </span><span class="s4">subpopID</span><span class="s3"> property will be the </span><span class="s4">id</span><span class="s3"> of the offspring’s subpopulation, since the parental subpopulation is ambiguous; this behavior differs from the other </span><span class="s4">add...()</span><span class="s3"> methods.</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">sex</span><span class="s3"> parameter is interpreted exactly as in </span><span class="s4">addCrossed()</span><span class="s3">; see that method for discussion.<span class="Apple-converted-space">  </span>If the offspring sex is specified in any way (i.e., if </span><span class="s4">sex</span><span class="s3"> is non-</span><span class="s4">NULL</span><span class="s3">), the strands provided must be compatible with the sex chosen.<span class="Apple-converted-space">  </span>If the offspring sex is not specified (i.e., if </span><span class="s4">sex</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3">), the sex will be inferred from the strands provided where possible (when modeling an X or Y chromosome), or will be chosen randomly otherwise (when modeling autosomes); it will <i>not</i> be inferred from the sex of the individuals possessing the parental strands, even when the reproductive mode is essentially clonal from a single parent, since such inference would be ambiguous in the general case.<span class="Apple-converted-space">  </span>Similarly, the offspring is considered to have no parents for the purposes of pedigree tracking, since there may be more than two “parents” in the general case.<span class="Apple-converted-space">  </span>When modeling the X or Y, </span><span class="s4">strand1</span><span class="s3"> and </span><span class="s4">strand2</span><span class="s3"> must be X genomes (or </span><span class="s4">NULL</span><span class="s3">), and </span><span class="s4">strand3</span><span class="s3"> and </span><span class="s4">strand4</span><span class="s3"> must both be X genomes or both be Y genomes (or </span><span class="s4">NULL</span><span class="s3">).</span></p>
<p class="p6"><span class="s3">These semantics allow several uses for </span><span class="s4">addRecombinant()</span><span class="s3">.<span class="Apple-converted-space">  </span>When all strands are non-</span><span class="s4">NULL</span><span class="s3">, it is similar to </span><span class="s4">addCrossed()</span><span class="s3"> except that the recombination breakpoints are specified explicitly, allowing very precise offspring generation without having to override SLiM’s breakpoint generation with a </span><span class="s4">recombination()</span><span class="s3"> callback.<span class="Apple-converted-space">  </span>When only </span><span class="s4">strand1</span><span class="s3"> and </span><span class="s4">strand3</span><span class="s3"> are supplied, it is very similar to </span><span class="s4">addCloned()</span><span class="s3">, creating a clonal offspring, except that the two parental genomes need not belong to the same individual (whatever that might mean biologically).<span class="Apple-converted-space">  </span>Supplying only </span><span class="s4">strand1</span><span class="s3"> is useful for modeling clonally reproducing haploids; the second genome of every offspring will be kept empty and will not receive new mutations.<span class="Apple-converted-space">  </span>For a model of clonally reproducing haploids that undergo horizontal gene transfer (HGT), supplying only </span><span class="s4">strand1</span><span class="s3"> and </span><span class="s4">strand2</span><span class="s3"> will allow HGT from </span><span class="s4">strand2</span><span class="s3"> to replace segments of an otherwise clonal copy of </span><span class="s4">strand1</span><span class="s3">, while the second genome of the generated offspring will again be kept empty; this could be useful for modeling bacterial conjugation, for example.<span class="Apple-converted-space">  </span>Other variations are also possible.</span></p>
<p class="p6"><span class="s3">Note that gene conversion tracts are not explicitly supported by this method; the </span><span class="s4">breaks</span><span class="s3"> vectors provide crossover breakpoints, which may be used to implement crossovers or simple gene conversion tracts.<span class="Apple-converted-space">  </span>There is no way to specify complex gene conversion tracts with heteroduplex mismatch repair.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See </span><span class="s4">addCrossed()</span><span class="s3"> for further general notes on the addition of new offspring individuals.</span></p>
<p class="p5"><span class="s3">– (No&lt;Individual&gt;$)addSelfed(object&lt;Individual&gt;$ parent)</span></p>
<p class="p6"><span class="s3">Generates a new offspring individual from the given parent by selfing, queues it for addition to the target subpopulation, and returns it.<span class="Apple-converted-space">  </span>The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.<span class="Apple-converted-space">  </span>The subpopulation of </span><span class="s4">parent</span><span class="s3"> will be used to locate applicable </span><span class="s4">mutation()</span><span class="s3">, </span><span class="s4">recombination()</span><span class="s3">, and </span><span class="s4">modifyChild()</span><span class="s3"> callbacks governing the generation of the offspring individual.</span></p>
<p class="p6"><span class="s3">Since selfing requires that </span><span class="s4">parent</span><span class="s3"> act as a source of both a male and a female gamete, this method may be called only in hermaphroditic models; calling it in sexual models will result in an error.<span class="Apple-converted-space">  </span>This method represents a non-incidental selfing event, so the </span><span class="s4">preventIncidentalSelfing</span><span class="s3"> flag of </span><span class="s4">initializeSLiMOptions()</span><span class="s3"> has no effect on this method (in contrast to the behavior of </span><span class="s4">addCrossed()</span><span class="s3">, where selfing is assumed to be incidental).</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models.<span class="Apple-converted-space">  </span>See </span><span class="s4">addCrossed()</span><span class="s3"> for further general notes on the addition of new offspring individuals.</span></p>
<p class="p3">– (float)cachedFitness(Ni indices)</p>
<p class="p6"><span class="s6">The fitness values calculated for the individuals at the indices given are returned.<span class="Apple-converted-space">  </span>If </span><span class="s10">NULL</span><span class="s6"> is passed, fitness values for all individuals in the subpopulation are returned.<span class="Apple-converted-space">  </span>The fitness values returned are cached values; </span><span class="s10">fitness()</span><span class="s6"> callbacks are therefore not called as a side effect of this method.</span><span class="s3"><span class="Apple-converted-space">  </span>It is always an error to call </span><span class="s4">cachedFitness()</span><span class="s3"> from inside a </span><span class="s4">fitness()</span><span class="s3"> callback, since fitness values are in the middle of being set up.<span class="Apple-converted-space">  </span>In WF models, it is also an error to call </span><span class="s4">cachedFitness()</span><span class="s3"> from a </span><span class="s4">late()</span><span class="s3"> event, because fitness values for the new offspring generation have not yet been calculated and are undefined.<span class="Apple-converted-space">  </span>In nonWF models, the population may be a mixture of new and old individuals, so instead, </span><span class="s4">NAN</span><span class="s3"> will be returned as the fitness of any new individuals whose fitness has not yet been calculated.<span class="Apple-converted-space">  </span>When new subpopulations are first created with </span><span class="s4">addSubpop()</span><span class="s3"> or </span><span class="s4">addSubpopSplit()</span><span class="s3">, the fitness of all of the newly created individuals is considered to be </span><span class="s4">1.0</span><span class="s3"> until fitness values are recalculated.</span></p>
<p class="p5"><span class="s3">– (void)configureDisplay([Nf center = NULL], [Nf$ scale = NULL], [Ns$ color = NULL])</span></p>
<p class="p6"><span class="s3">This method customizes the display of the subpopulation in SLiMgui’s Population Visualization graph.<span class="Apple-converted-space">  </span>When this method is called by a model running outside SLiMgui, it will do nothing except type-checking and bounds-checking its arguments.<span class="Apple-converted-space">  </span>When called by a model running in SLiMgui, the position, size, and color of the subpopulation’s displayed circle can be controlled as specified below.</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">center</span><span class="s3"> parameter sets the coordinates of the center of the subpopulation’s displayed circle; it must be a </span><span class="s4">float</span><span class="s3"> vector of length two, such that </span><span class="s4">center[0]</span><span class="s3"> provides the <i>x</i>-coordinate and </span><span class="s4">center[1]</span><span class="s3"> provides the <i>y</i>-coordinate.<span class="Apple-converted-space">  </span>The square central area of the Population Visualization occupies scaled coordinates in [0,1] for both <i>x</i> and <i>y</i>, so the values in </span><span class="s4">center</span><span class="s3"> must be within those bounds.<span class="Apple-converted-space">  </span>If a value of </span><span class="s4">NULL</span><span class="s3"> is provided, SLiMgui’s default center will be used (which currently arranges subpopulations in a circle).</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">scale</span><span class="s3"> parameter sets a scaling factor to be applied to the radius of the subpopulation’s displayed circle.<span class="Apple-converted-space">  </span>The default radius used by SLiMgui is a function of the subpopulation’s number of individuals; this default radius is then multiplied by </span><span class="s4">scale</span><span class="s3">.<span class="Apple-converted-space">  </span>If a value of </span><span class="s4">NULL</span><span class="s3"> is provided, the default radius will be used; this is equivalent to supplying a </span><span class="s4">scale</span><span class="s3"> of </span><span class="s4">1.0</span><span class="s3">.<span class="Apple-converted-space">  </span>Typically the same </span><span class="s4">scale</span><span class="s3"> value should be used by all subpopulations, to scale all of their circles up or down uniformly, but that is not required.</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">color</span><span class="s3"> parameter sets the color to be used for the displayed subpopulation’s circle.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form </span><span class="s4">"#RRGGBB"</span><span class="s3"> (see the Eidos manual).<span class="Apple-converted-space">  </span>If </span><span class="s4">color</span><span class="s3"> is </span><span class="s4">NULL</span><span class="s3"> or the empty string, </span><span class="s4">""</span><span class="s3">, SLiMgui’s default (fitness-based) color will be used.</span></p>
<p class="p3">– (void)defineSpatialMap(string$ name, string$ spatiality, Ni<span class="s8"> </span>gridSize, numeric values, [logical$ interpolate = F], [Nif valueRange = NULL], [Ns colors = NULL])</p>
<p class="p6"><span class="s3">Defines a spatial map for the subpopulation.<span class="Apple-converted-space">  </span>The map will henceforth be identified by </span><span class="s4">name</span><span class="s3">.<span class="Apple-converted-space">  </span>The map uses the spatial dimensions referenced by spatiality, which must be a subset of the dimensions defined for the simulation in </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.<span class="Apple-converted-space">  </span>Spatiality </span><span class="s4">"x"</span><span class="s3"> is permitted for dimensionality </span><span class="s4">"x"</span><span class="s3">; spatiality </span><span class="s4">"x"</span><span class="s3">, </span><span class="s4">"y"</span><span class="s3">, or </span><span class="s4">"xy"</span><span class="s3"> for dimensionality </span><span class="s4">"xy"</span><span class="s3">; and spatiality </span><span class="s4">"x"</span><span class="s3">, </span><span class="s4">"y"</span><span class="s3">, </span><span class="s4">"z"</span><span class="s3">, </span><span class="s4">"xy"</span><span class="s3">, </span><span class="s4">"yz"</span><span class="s3">, </span><span class="s4">"xz"</span><span class="s3">, or </span><span class="s4">"xyz"</span><span class="s3"> for dimensionality </span><span class="s4">"xyz"</span><span class="s3">.<span class="Apple-converted-space">  </span>The spatial map is defined by a grid of values of a size specified by </span><span class="s4">gridSize</span><span class="s3">, which must have one value per spatial dimension (or </span><span class="s4">gridSize</span><span class="s3"> may be </span><span class="s4">NULL</span><span class="s3">; see below); for a spatiality of </span><span class="s4">"xz"</span><span class="s3">, for example, </span><span class="s4">gridSize</span><span class="s3"> must be of length </span><span class="s4">2</span><span class="s3">, specifying the size of the values grid in the <i>x</i> and <i>z</i> dimensions.<span class="Apple-converted-space">  </span>The parameter </span><span class="s4">values</span><span class="s3"> then gives the values of the grid; it must be of length equal to the product of the </span><span class="s4">gridSize</span><span class="s3"> elements, and specifies values varying first (i.e., fastest) in the <i>x</i> dimension, then in <i>y</i>, then in <i>z</i>.</span></p>
<p class="p6"><span class="s3">Beginning in SLiM 2.6, the </span><span class="s4">values</span><span class="s3"> parameter may be a matrix/array with the number of dimensions appropriate for the declared spatiality of the map; for example, a map with spatiality </span><span class="s4">"xy"</span><span class="s3"> would require a (two-dimensional) matrix, whereas a map with spatiality of </span><span class="s4">"xyz"</span><span class="s3"> would require a three-dimensional array.<span class="Apple-converted-space">  </span>(See the Eidos manual for discussion of matrices and arrays.)<span class="Apple-converted-space">  </span>If a matrix/array argument is supplied for </span><span class="s4">values</span><span class="s3">, </span><span class="s4">gridSize</span><span class="s3"> must either be </span><span class="s4">NULL</span><span class="s3">, or (for backward compatibility) may match the dimensions of </span><span class="s4">values</span><span class="s3"> as they would be given by </span><span class="s4">dim(values)</span><span class="s3">.<span class="Apple-converted-space">  </span>The data in </span><span class="s4">values</span><span class="s3"> is interpreted just as is described above for the vector case: varying first in <i>x</i>, then in <i>y</i>, then in <i>z</i>.<span class="Apple-converted-space">  </span>BEWARE: since the values in Eidos matrices and arrays are stored in column-first order (following the convention established by R), this means that for a map with spatiality </span><span class="s4">"xy"</span><span class="s3"> each column of the </span><span class="s4">values</span><span class="s3"> matrix will provide map data as <i>x</i> varies and <i>y</i> remains constant.<span class="Apple-converted-space">  </span>This will be confusing if you think of matrix columns as being “<i>x</i>” and matrix rows as being “<i>y</i>”, so try not to think that way; the opposite is true.<span class="Apple-converted-space">  </span>This behavior is actually simple, self-consistent, and backward-compatible; if you before created a spatial map with a vector </span><span class="s4">values</span><span class="s3"> before and a </span><span class="s4">gridSize</span><span class="s3"> of </span><span class="s4">c(x, y)</span><span class="s3"> specifying the dimensions of that vector, you can now supply </span><span class="s4">matrix(values, nrow=x)</span><span class="s3"> for </span><span class="s4">values</span><span class="s3"> to get exactly the same spatial map, and you can still supply the same value of </span><span class="s4">c(x, y)</span><span class="s3"> for </span><span class="s4">gridSize</span><span class="s3"> if you wish (or you may supply </span><span class="s4">NULL</span><span class="s3">).<span class="Apple-converted-space">  </span>If, however, you are looking at a matrix as printed in the Eidos console, and want that matrix to be used as a spatial map in SLiM in the same orientation, you should use the transpose of the matrix, as supplied by the </span><span class="s4">t()</span><span class="s3"> function.<span class="Apple-converted-space">  </span>Actually, since matrices are printed in the console with each successive row having a <i>larger</i> index, whereas in Cartesian (<i>x</i>, <i>y</i>) coordinates <i>y</i>-values increase as you go <i>upward</i>, you may also wish to reverse the order of rows in your matrix prior to transposing (or the order of columns after transposing), with an expression such as </span><span class="s4">t(map[(nrow(map)-1):0,])</span><span class="s3">, in order to make the spatial map display in SLiMgui as you expect (since SLiMgui displays everything in Cartesian coordinates).<span class="Apple-converted-space">  </span>Apologies if this is confusing; it would be nice if matrix notation, programming languages, and Descartes all agreed on such things, but they do not, so be very careful that your spatial maps are oriented as you wish them to be!</span></p>
<p class="p6"><span class="s3">Moving on to the other parameters of </span><span class="s4">defineSpatialMap()</span><span class="s3">: if </span><span class="s4">interpolate</span><span class="s3"> is </span><span class="s4">F</span><span class="s3">, values across the spatial map are not interpolated; the value at a given point is equal to the nearest value defined by the grid of values specified.<span class="Apple-converted-space">  </span>If </span><span class="s4">interpolate</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">, values across the spatial map will be interpolated (using linear, bilinear, or trilinear interpolation as appropriate) to produce spatially continuous variation in values.<span class="Apple-converted-space">  </span>In either case, the corners of the value grid are exactly aligned with the corners of the spatial boundaries of the subpopulation as specified by </span><span class="s4">setSpatialBoundary()</span><span class="s3">, and the value grid is then stretched across the spatial extent of the subpopulation in such a manner as to produce equal spacing between the values along each dimension.<span class="Apple-converted-space">  </span>The setting of </span><span class="s4">interpolation</span><span class="s3"> only affects how values between these grid points are calculated: by nearest-neighbor, or by linear interpolation.<span class="Apple-converted-space">  </span>Interpolation of spatial maps with periodic boundaries is not handled specially; to ensure that the edges of a periodic spatial map join smoothly, simply ensure that the grid values at the edges of the map are identical, since they will be coincident after periodic wrapping.</span></p>
<p class="p6"><span class="s3">The </span><span class="s4">valueRange</span><span class="s3"> and </span><span class="s4">colors</span><span class="s3"> parameters travel together; either both are unspecified, or both are specified.<span class="Apple-converted-space">  </span>They control how map values will be transformed into colors, by SLiMgui and by the </span><span class="s4">spatialMapColor()</span><span class="s3"> method.<span class="Apple-converted-space">  </span>The </span><span class="s4">valueRange</span><span class="s3"> parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.<span class="Apple-converted-space">  </span>The </span><span class="s4">colors</span><span class="s3"> parameter then establishes the corresponding colors for values within the interval defined by </span><span class="s4">valueRange</span><span class="s3">: values less than or equal to </span><span class="s4">valueRange[0]</span><span class="s3"> will map to </span><span class="s4">colors[0]</span><span class="s3">, values greater than or equal to </span><span class="s4">valueRange[1]</span><span class="s3"> will map to the last </span><span class="s4">colors</span><span class="s3"> value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.<span class="Apple-converted-space">  </span>This is much simpler than it sounds in this description; see example recipes for an illustration of its use.</span></p>
<p class="p6"><span class="s3">Note that at present, SLiMgui will only display spatial maps of spatiality </span><span class="s4">"x"</span><span class="s3">, </span><span class="s4">"y"</span><span class="s3">, or </span><span class="s4">"xy"</span><span class="s3">; the color-mapping parameters will simply be ignored by SLiMgui for other spatiality values (even if the spatiality is a superset of these values; SLiMgui will not attempt to display an </span><span class="s4">"xyz"</span><span class="s3"> spatial map, for example, since it has no way to choose which 2D slice through the <i>xyz</i> space it ought to display).<span class="Apple-converted-space">  </span>The </span><span class="s4">spatialMapColor()</span><span class="s3"> method will return translated color strings for any spatial map, however, even if SLiMgui is unable to display the spatial map.<span class="Apple-converted-space">  </span>If there are multiple spatial maps with color-mapping parameters defined, SLiMgui will choose just one for display; it will prefer an </span><span class="s4">"xy"</span><span class="s3"> map if one is available, but beyond that heuristic its choice will be arbitrary.</span></p>
<p class="p3">–<span class="s8"> </span>(*)getValue(string$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">Subpopulation</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">– (void)outputMSSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = "*"], [Ns$ filePath = NULL], [logical$ append = F]<span class="s5">, [logical$ filterMonomorphic = F]</span>)</p>
<p class="p4">Output a random sample from the subpopulation in MS format.<span class="Apple-converted-space">  </span>Positions in the output will span the interval [0,1].<span class="Apple-converted-space">  </span>A sample of genomes (not entire individuals, note) of size <span class="s1">sampleSize</span> from the subpopulation will be output.<span class="Apple-converted-space">  </span>The sample may be done either with or without replacement, as specified by <span class="s1">replace</span>; the default is to sample with replacement.<span class="Apple-converted-space">  </span>A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">requestedSex</span>; passing <span class="s1">"*"</span>, the default, indicates that genomes from individuals should be selected randomly, without respect to sex.<span class="Apple-converted-space">  </span>If the sampling options provided by this method are not adequate, see the <span class="s1">outputMS()</span> method of <span class="s1">Genome</span> for a more flexible low-level option.</p>
<p class="p4">If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span></p>
<p class="p6"><span class="s3">If </span><span class="s4">filterMonomorphic</span><span class="s3"> is </span><span class="s4">F</span><span class="s3"> (the default), all mutations that are present in the sample will be included in the output.<span class="Apple-converted-space">  </span>This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in <i>every</i> sampled genome, and are thus apparently fixed).<span class="Apple-converted-space">  </span>These may be filtered out with </span><span class="s4">filterMonomorphic = T</span><span class="s3"> if desired; note that this option means that some mutations that do exist in the sampled genomes might not be included in the output, simply because they exist in every sampled genome.</span></p>
<p class="p4">See <span class="s1">outputSample()</span> and <span class="s1">outputVCFSample()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">– (void)outputSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = "*"], [Ns$ filePath = NULL], [logical$ append = F])</p>
<p class="p4">Output a random sample from the subpopulation in SLiM’s native format.<span class="Apple-converted-space">  </span>A sample of genomes (not entire individuals, note) of size <span class="s1">sampleSize</span> from the subpopulation will be output.<span class="Apple-converted-space">  </span>The sample may be done either with or without replacement, as specified by <span class="s1">replace</span>; the default is to sample with replacement.<span class="Apple-converted-space">  </span>A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">requestedSex</span>; passing <span class="s1">"*"</span>, the default, indicates that genomes from individuals should be selected randomly, without respect to sex.<span class="Apple-converted-space">  </span>If the sampling options provided by this method are not adequate, see the <span class="s1">output()</span> method of <span class="s1">Genome</span> for a more flexible low-level option.</p>
<p class="p4">If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span></p>
<p class="p4">See <span class="s1">outputMSSample()</span> and <span class="s1">outputVCFSample()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">– (void)outputVCFSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = "*"], [logical$ outputMultiallelics = T], [Ns$ filePath = NULL], [logical$ append = F]<span class="s5">, [logical$ simplifyNucleotides = F], [logical$ outputNonnucleotides = T]</span>)</p>
<p class="p4">Output a random sample from the subpopulation in VCF format.<span class="Apple-converted-space">  </span>A sample of individuals (not genomes, note – unlike the <span class="s1">outputSample()</span> and <span class="s1">outputMSSample()</span> methods) of size <span class="s1">sampleSize</span> from the subpopulation will be output.<span class="Apple-converted-space">  </span>The sample may be done either with or without replacement, as specified by <span class="s1">replace</span>; the default is to sample with replacement.<span class="Apple-converted-space">  </span>A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing <span class="s1">"M"</span> or <span class="s1">"F"</span> for <span class="s1">requestedSex</span>; passing <span class="s1">"*"</span>, the default, indicates that genomes from individuals should be selected randomly, without respect to sex.<span class="Apple-converted-space">  </span>If the sampling options provided by this method are not adequate, see the <span class="s1">outputVCF()</span> method of <span class="s1">Genome</span> for a more flexible low-level option.</p>
<p class="p4">If the optional parameter <span class="s1">filePath</span> is <span class="s1">NULL</span> (the default), output will be sent to Eidos’s output stream.<span class="Apple-converted-space">  </span>Otherwise, output will be sent to the filesystem path specified by <span class="s1">filePath</span>, overwriting that file if <span class="s1">append</span> if <span class="s1">F</span>, or appending to the end of it if <span class="s1">append</span> is <span class="s1">T</span><span class="s2">.</span></p>
<p class="p6"><span class="s3">The parameters </span><span class="s4">outputMultiallelics</span><span class="s3">, </span><span class="s4">simplifyNucleotides</span><span class="s3">, and </span><span class="s4">outputNonnucleotides</span><span class="s3"> affect the format of the output produced; see the reference documentation for further discussion.</span></p>
<p class="p4">See <span class="s1">outputMSSample()</span> and <span class="s1">outputSample()</span> for other output formats.<span class="Apple-converted-space">  </span>Output is generally done in a <span class="s1">late()</span> event, so that the output reflects the state of the simulation at the end of a generation.</p>
<p class="p3">– (logical)pointInBounds(float point)</p>
<p class="p6"><span class="s3">Returns </span><span class="s4">T</span><span class="s3"> if </span><span class="s4">point</span><span class="s3"> is inside the spatial boundaries of the subpopulation, </span><span class="s4">F</span><span class="s3"> otherwise.<span class="Apple-converted-space">  </span>For example, for a simulation with </span><span class="s4">"xy"</span><span class="s3"> dimensionality, if </span><span class="s4">point</span><span class="s3"> contains exactly two values constituting an (<i>x</i>,<i>y</i>) point, the result will be </span><span class="s4">T</span><span class="s3"> if and only if </span><span class="s4">((point[0]&gt;=x0) &amp; (point[0]&lt;=x1) &amp; (point[1]&gt;=y0) &amp; (point[1]&lt;=y1))</span><span class="s3"> given spatial bounds </span><span class="s4">(x0, y0, x1, y1)</span><span class="s3">.<span class="Apple-converted-space">  </span>This method is useful for implementing absorbing or reprising boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, a </span><span class="s4">logical</span><span class="s3"> vector will be returned in which each element is </span><span class="s4">T</span><span class="s3"> if the corresponding point in </span><span class="s4">point</span><span class="s3"> is inside the spatial boundaries of the subpopulation, </span><span class="s4">F</span><span class="s3"> otherwise.</span></p>
<p class="p5"><span class="s3">– (float)pointPeriodic(float point)</span></p>
<p class="p6"><span class="s3">Returns a revised version of </span><span class="s4">point</span><span class="s3"> that has been brought inside the periodic spatial boundaries of the subpopulation (as specified by the </span><span class="s4">periodicity</span><span class="s3"> parameter of </span><span class="s4">initializeSLiMOptions()</span><span class="s3">) by wrapping around periodic spatial boundaries.<span class="Apple-converted-space">  </span>In brief, if a coordinate of </span><span class="s4">point</span><span class="s3"> lies beyond a periodic spatial boundary, that coordinate is wrapped around the boundary, so that it lies inside the spatial extent by the same magnitude that it previously lay outside, but on the opposite side of the space; in effect, the two edges of the periodic spatial boundary are seamlessly joined.<span class="Apple-converted-space">  </span>This is done iteratively until all coordinates lie inside the subpopulation’s periodic boundaries.<span class="Apple-converted-space">  </span>Note that non-periodic spatial boundaries are not enforced by this method; they should be enforced using </span><span class="s4">pointReflected()</span><span class="s3">, </span><span class="s4">pointStopped()</span><span class="s3">, or some other means of enforcing boundary constraints (which can be used after </span><span class="s4">pointPeriodic()</span><span class="s3"> to bring the remaining coordinates into bounds; coordinates already brought into bounds by </span><span class="s4">pointPeriodic()</span><span class="s3"> will be unaffected by those calls).<span class="Apple-converted-space">  </span>This method is useful for implementing periodic boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space<span class="Apple-converted-space">  </span>and at least one periodic spatial dimension have been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.</span></p>
<p class="p5"><span class="s3">– (float)pointReflected(float point)</span></p>
<p class="p6"><span class="s3">Returns a revised version of </span><span class="s4">point</span><span class="s3"> that has been brought inside the spatial boundaries of the subpopulation by reflection.<span class="Apple-converted-space">  </span>In brief, if a coordinate of </span><span class="s4">point</span><span class="s3"> lies beyond a spatial boundary, that coordinate is reflected across the boundary, so that it lies inside the boundary by the same magnitude that it previously lay outside the boundary.<span class="Apple-converted-space">  </span>This is done iteratively until all coordinates lie inside the subpopulation’s boundaries.<span class="Apple-converted-space">  </span>This method is useful for implementing reflecting boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.</span></p>
<p class="p5"><span class="s3">– (float)pointStopped(float point)</span></p>
<p class="p6"><span class="s3">Returns a revised version of </span><span class="s4">point</span><span class="s3"> that has been brought inside the spatial boundaries of the subpopulation by clamping.<span class="Apple-converted-space">  </span>In brief, if a coordinate of </span><span class="s4">point</span><span class="s3"> lies beyond a spatial boundary, that coordinate is set to exactly the position of the boundary, so that it lies on the edge of the spatial boundary.<span class="Apple-converted-space">  </span>This method is useful for implementing stopping boundary conditions.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p6"><span class="s3">The length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the dimensionality of the simulation; in other words, </span><span class="s4">point</span><span class="s3"> may contain values comprising more than one point.<span class="Apple-converted-space">  </span>In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.</span></p>
<p class="p5"><span class="s3">– (float)pointUniform([integer$ n = 1])</span></p>
<p class="p6"><span class="s3">Returns a new point (or points, for </span><span class="s4">n</span><span class="s3"> &gt; 1) generated from uniform draws for each coordinate, within the spatial boundaries of the subpopulation.<span class="Apple-converted-space">  </span>The returned vector will contain </span><span class="s4">n</span><span class="s3"> points, each comprised of a number of coordinates equal to the dimensionality of the simulation, so it will be of total length </span><span class="s4">n</span><span class="s3">*dimensionality.<span class="Apple-converted-space">  </span>This may only be called in simulations for which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.</span></p>
<p class="p3">– (void)removeSubpopulation(void)</p>
<p class="p6"><span class="s3">Removes this subpopulation from the model.<span class="Apple-converted-space">  </span>The subpopulation is immediately removed from the list of active subpopulations, and the symbol representing the subpopulation is undefined.<span class="Apple-converted-space">  </span>The subpopulation object itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models, in which there is a distinction between a subpopulation being empty and a subpopulation being removed from the simulation; an empty subpopulation may be re-colonized by migrants, whereas as a removed subpopulation no longer exists at all.<span class="Apple-converted-space">  </span>WF models do not make this distinction; when a subpopulation is empty it is automatically removed.<span class="Apple-converted-space">  </span>WF models should therefore call </span><span class="s4">setSubpopulationSize(0)</span><span class="s3"> instead of this method; </span><span class="s4">setSubpopulationSize()</span><span class="s3"> is the standard way for WF models to change the subpopulation size, including to a size of </span><span class="s4">0</span><span class="s3">.</span></p>
<p class="p5"><span class="s6">– </span><span class="s3">(object&lt;Individual&gt;)sampleIndividuals(integer$ size, [logical$ replace = F], [No&lt;Individual&gt;$ exclude = NULL], [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL])</span></p>
<p class="p6"><span class="s3">Returns a vector of individuals, of size less than or equal to parameter </span><span class="s4">size</span><span class="s3">, sampled from the individuals in the target subpopulation.<span class="Apple-converted-space">  </span>Sampling is done without replacement if </span><span class="s4">replace</span><span class="s3"> is </span><span class="s4">F</span><span class="s3"> (the default), or with replacement if </span><span class="s4">replace</span><span class="s3"> is </span><span class="s4">T</span><span class="s3">.<span class="Apple-converted-space">  </span>The remaining parameters specify constraints upon the pool of individuals that will be considered candidates for the sampling.<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">exclude</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a specific individual that should not be considered a candidate (typically the focal individual in some operation).<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">sex</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a sex (</span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3">) for the individuals to be drawn, in sexual models.<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">tag</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a tag value for the individuals to be drawn.<span class="Apple-converted-space">  </span>Parameters </span><span class="s4">minAge</span><span class="s3"> and </span><span class="s4">maxAge</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a minimum or maximum age for the individuals to be drawn, in nonWF models.<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">migrant</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a required value for the </span><span class="s4">migrant</span><span class="s3"> property of the individuals to be drawn (so </span><span class="s4">T</span><span class="s3"> will require that individuals be migrants, </span><span class="s4">F</span><span class="s3"> will require that they not be).<span class="Apple-converted-space">  </span>If the candidate pool is smaller than the requested sample size, all eligible candidates will be returned (in randomized order); the result will be a zero-length vector if no eligible candidates exist (unlike </span><span class="s4">sample()</span><span class="s3">).</span></p>
<p class="p6"><span class="s3">This method is similar to getting the </span><span class="s4">individuals</span><span class="s3"> property of the subpopulation, using operator </span><span class="s4">[]</span><span class="s3"> to select only individuals with the desired properties, and then using </span><span class="s4">sample()</span><span class="s3"> to sample from that candidate pool.<span class="Apple-converted-space">  </span>However, besides being much simpler than the equivalent Eidos code, it is also much faster, and it does not fail if less than the full sample size is available.<span class="Apple-converted-space">  </span>See </span><span class="s4">subsetIndividuals()</span><span class="s3"> for a similar method that returns a full subset, rather than a sample.</span></p>
<p class="p3">– (void)setCloningRate(numeric rate)</p>
<p class="p4">Set the cloning rate of this subpopulation.<span class="Apple-converted-space">  </span>The rate is changed to <span class="s1">rate</span>, which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>Clonal reproduction can be enabled in both non-sexual (i.e. hermaphroditic) and sexual simulations.<span class="Apple-converted-space">  </span>In non-sexual simulations, <span class="s1">rate</span> must be a singleton value representing the overall clonal reproduction rate for the subpopulation.<span class="Apple-converted-space">  </span>In sexual simulations, <span class="s1">rate</span> may be either a singleton (specifying the clonal reproduction rate for both sexes) or a vector containing two numeric values (the female and male cloning rates specified separately, at indices <span class="s1">0</span> and <span class="s1">1</span> respectively).<span class="Apple-converted-space">  </span>During mating and offspring generation, the probability that any given offspring individual will be generated by cloning – by asexual reproduction without gametes or meiosis – will be equal to the cloning rate (for its sex, in sexual simulations) set in the parental (not the offspring!) subpopulation.</p>
<p class="p3">– (void)setMigrationRates(io&lt;Subpopulation&gt; sourceSubpops, numeric rates)</p>
<p class="p4">Set the migration rates to this subpopulation from the subpopulations in <span class="s1">sourceSubpops</span> to the corresponding rates specified in <span class="s1">rates</span>; in other words, <span class="s1">rates</span> gives the expected fractions of the children in this subpopulation that will subsequently be generated from parents in the subpopulations <span class="s1">sourceSubpops</span> (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>This method will only set the migration fractions from the subpopulations given; migration rates from other subpopulations will be left unchanged (explicitly set a zero rate to turn off migration from a given subpopulation).<span class="Apple-converted-space">  </span>The type of <span class="s1">sourceSubpops</span> may be either <span class="s1">integer</span>, specifying subpopulations by identifier, or <span class="s1">object</span>, specifying subpopulations directly.</p>
<p class="p3">– (void)setSelfingRate(numeric$ rate)</p>
<p class="p4">Set the selfing rate of this subpopulation.<span class="Apple-converted-space">  </span>The rate is changed to <span class="s1">rate</span>, which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>Selfing can only be enabled in non-sexual (i.e. hermaphroditic) simulations.<span class="Apple-converted-space">  </span>During mating and offspring generation, the probability that any given offspring individual will be generated by selfing – by self-fertilization via gametes produced by meiosis by a single parent – will be equal to the selfing rate set in the parental (not the offspring!) subpopulation.</p>
<p class="p3">– (void)setSexRatio(float$ sexRatio)</p>
<p class="p4">Set the sex ratio of this subpopulation to <span class="s1">sexRatio</span>.<span class="Apple-converted-space">  </span>As defined in SLiM, this is actually the fraction of the subpopulation that is male; in other words, the M:(M+F) ratio.<span class="Apple-converted-space">  </span>This will take effect when children are next generated; it does not change the current subpopulation state.<span class="Apple-converted-space">  </span>Unlike the selfing rate, the cloning rate, and migration rates, the sex ratio is deterministic: SLiM will generate offspring that exactly satisfy the requested sex ratio (within integer roundoff limits).</p>
<p class="p3">– (void)setSpatialBounds(numeric bounds)</p>
<p class="p6"><span class="s3">Set the spatial boundaries of the subpopulation to </span><span class="s4">bounds</span><span class="s3">.<span class="Apple-converted-space">  </span>This method may be called only for simulations in which continuous space has been enabled with </span><span class="s4">initializeSLiMOptions()</span><span class="s3">.<span class="Apple-converted-space">  </span>The length of </span><span class="s4">bounds</span><span class="s3"> must be double the spatial dimensionality, so that it supplies both minimum and maximum values for each coordinate.<span class="Apple-converted-space">  </span>More specifically, for a dimensionality of </span><span class="s4">"x"</span><span class="s3">, </span><span class="s4">bounds</span><span class="s3"> should supply </span><span class="s4">(x0, x1)</span><span class="s3"> values; for dimensionality </span><span class="s4">"xy"</span><span class="s3"> it should supply </span><span class="s4">(x0, y0, x1, y1)</span><span class="s3"> values; and for dimensionality </span><span class="s4">"xyz"</span><span class="s3"> it should supply </span><span class="s4">(x0, y0, z0, x1, y1, z1)</span><span class="s3"> (in that order).<span class="Apple-converted-space">  </span>These boundaries will be used by SLiMgui to calibrate the display of the subpopulation, and will be used by methods such as </span><span class="s4">pointInBounds()</span><span class="s3">, </span><span class="s4">pointReflected()</span><span class="s3">, </span><span class="s4">pointStopped()</span><span class="s3">, and </span><span class="s4">pointUniform()</span><span class="s3">.<span class="Apple-converted-space">  </span>The default spatial boundaries for all subpopulations span the interval </span><span class="s4">[0,1]</span><span class="s3"> in each dimension.<span class="Apple-converted-space">  </span>Spatial dimensions that are periodic (as established with the </span><span class="s4">periodicity</span><span class="s3"> parameter to </span><span class="s4">initializeSLiMOptions()</span><span class="s3">) must have a minimum coordinate value of </span><span class="s4">0.0</span><span class="s3"> (a restriction that allows the handling of periodicity to be somewhat more efficient).<span class="Apple-converted-space">  </span>The current spatial bounds for the subpopulation may be obtained through the </span><span class="s4">spatialBounds</span><span class="s3"> property.</span></p>
<p class="p3">– (void)setSubpopulationSize(integer$ size)</p>
<p class="p4">Set the size of this subpopulation to <span class="s1">size</span> individuals (see the SLiM manual for further details).<span class="Apple-converted-space">  </span>This will take effect when children are next generated; it does not change the current subpopulation state.<span class="Apple-converted-space">  </span>Setting a subpopulation to a size of 0 does have some immediate effects that serve to disconnect it from the simulation: the subpopulation is removed from the list of active subpopulations, the subpopulation is removed as a source of migration for all other subpopulations, and the symbol representing the subpopulation is undefined.<span class="Apple-converted-space">  </span>In this case, the subpopulation itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.</p>
<p class="p3">–<span class="s8"> </span>(void)setValue(string$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span><span class="s2">.</span><span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span><span class="s6">If </span><span class="s10">value</span><span class="s6"> is of type </span><span class="s10">object</span><span class="s6">, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only </span><span class="s10">Mutation</span><span class="s6"> and </span><span class="s10">Substitution</span><span class="s6"> presently are (see the Eidos manual’s documentation for </span><span class="s10">defineConstant()</span><span class="s6"> for further discussion).<span class="Apple-converted-space">  </span></span>This dictionary-style functionality is actually provided by the superclass of <span class="s1">Subpopulation</span>, <span class="s1">EidosDictionary</span>, although that fact is not presently visible in Eidos since superclasses are not introspectable.</p>
<p class="p3">–<span class="s8"> </span>(string)spatialMapColor(string$ name, numeric value)</p>
<p class="p4">Looks up the spatial map indicated by <span class="s1">name</span>, and uses its color-translation machinery (as defined by the <span class="s1">valueRange</span> and <span class="s1">colors</span> parameters to <span class="s1">defineSpatialMap()</span>) to translate each element of <span class="s1">value</span> into a corresponding color string.<span class="Apple-converted-space">  </span>If the spatial map does not have color-translation capabilities, an error will result.<span class="Apple-converted-space">  </span>See the documentation for <span class="s1">defineSpatialMap()</span> for information regarding the details of color translation.<span class="Apple-converted-space">  </span>See the Eidos manual for further information on color strings.</p>
<p class="p3">–<span class="s8"> </span>(float)spatialMapValue(string$ name, float point)</p>
<p class="p6"><span class="s3">Looks up the spatial map indicated by </span><span class="s4">name</span><span class="s3">, and uses its mapping machinery (as defined by the </span><span class="s4">gridSize</span><span class="s3">, </span><span class="s4">values</span><span class="s3">, and </span><span class="s4">interpolate</span><span class="s3"> parameters to </span><span class="s4">defineSpatialMap()</span><span class="s3">) to translate the coordinates of </span><span class="s4">point</span><span class="s3"> into a corresponding map value.<span class="Apple-converted-space">  </span>The length of </span><span class="s4">point</span><span class="s3"> must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality </span><span class="s4">"xz"</span><span class="s3">, </span><span class="s4">point</span><span class="s3"> must be of length </span><span class="s4">2</span><span class="s3">, specifying the <i>x</i> and <i>z</i> coordinates of the point to be evaluated.<span class="Apple-converted-space">  </span>Interpolation will automatically be used if it was enabled for the spatial map.<span class="Apple-converted-space">  </span>Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use </span><span class="s4">pointPeriodic()</span><span class="s3"> to wrap the point coordinates first if desired.<span class="Apple-converted-space">  </span>See the documentation for </span><span class="s4">defineSpatialMap()</span><span class="s3"> for information regarding the details of value mapping.</span></p>
<p class="p6"><span class="s3">Beginning in SLiM 3.3, </span><span class="s4">point</span><span class="s3"> may contain more than one point to be looked up.<span class="Apple-converted-space">  </span>In this case, the length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of the spatiality of the spatial map; for a spatial map with spatiality </span><span class="s4">"xz"</span><span class="s3">, for example, the length of </span><span class="s4">point</span><span class="s3"> must be an exact multiple of </span><span class="s4">2</span><span class="s3">, and successive pairs of elements from point (elements </span><span class="s4">0</span><span class="s3"> and </span><span class="s4">1</span><span class="s3">, then elements </span><span class="s4">2</span><span class="s3"> and </span><span class="s4">3</span><span class="s3">, etc.) will be taken as the <i>x</i> and <i>z</i> coordinates of the points to be evaluated.<span class="Apple-converted-space">  </span>This allows </span><span class="s4">spatialMapValue()</span><span class="s3"> to be used in a vectorized fashion.</span></p>
<p class="p5"><span class="s6">– </span><span class="s3">(object&lt;Individual&gt;)subsetIndividuals([No&lt;Individual&gt;$ exclude = NULL], [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL])</span></p>
<p class="p6"><span class="s3">Returns a vector of individuals subset from the individuals in the target subpopulation.<span class="Apple-converted-space">  </span>The parameters specify constraints upon the subset of individuals that will be returned.<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">exclude</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a specific individual that should not be included (typically the focal individual in some operation).<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">sex</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a sex (</span><span class="s4">"M"</span><span class="s3"> or </span><span class="s4">"F"</span><span class="s3">) for the individuals to be returned, in sexual models.<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">tag</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a tag value for the individuals to be returned.<span class="Apple-converted-space">  </span>Parameters </span><span class="s4">minAge</span><span class="s3"> and </span><span class="s4">maxAge</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a minimum or maximum age for the individuals to be returned, in nonWF models.<span class="Apple-converted-space">  </span>Parameter </span><span class="s4">migrant</span><span class="s3">, if non-</span><span class="s4">NULL</span><span class="s3">, may specify a required value for the </span><span class="s4">migrant</span><span class="s3"> property of the individuals to be returned (so </span><span class="s4">T</span><span class="s3"> will require that individuals be migrants, </span><span class="s4">F</span><span class="s3"> will require that they not be).</span></p>
<p class="p6"><span class="s3">This method is shorthand for getting the </span><span class="s4">individuals</span><span class="s3"> property of the subpopulation, and then using operator </span><span class="s4">[]</span><span class="s3"> to select only individuals with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.<span class="Apple-converted-space">  </span>See </span><span class="s4">sampleIndividuals()</span><span class="s3"> for a similar method that returns a sample taken from a chosen subset of individuals.</span></p>
<p class="p5"><span class="s3">– (void)takeMigrants(object&lt;Individual&gt; migrants)</span></p>
<p class="p6"><span class="s3">Immediately moves the individuals in </span><span class="s4">migrants</span><span class="s3"> to the target subpopulation (removing them from their previous subpopulation).<span class="Apple-converted-space">  </span>Individuals in </span><span class="s4">migrants</span><span class="s3"> that are already in the target subpopulation are unaffected.<span class="Apple-converted-space">  </span>Note that the indices and order of individuals and genomes in both the target and source subpopulations will change unpredictably as a side effect of this method.</span></p>
<p class="p6"><span class="s3">Note that this method is only for use in nonWF models, in which migration is managed manually by the model script.<span class="Apple-converted-space">  </span>In WF models, migration is managed automatically by the SLiM core based upon the migration rates set for each subpopulation with </span><span class="s4">setMigrationRates()</span><span class="s3">.</span></p>
<p class="p1"><b>5.14<span class="Apple-converted-space">  </span>Class Substitution</b></p>
<p class="p2"><i>5.14.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Substitution</i></span><i> properties</i></p>
<p class="p3">id =&gt; (integer$)</p>
<p class="p4">The identifier for this mutation.<span class="Apple-converted-space">  </span>Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run, and that identifier is carried over to the <span class="s1">Substitution</span> object when the mutation fixes.</p>
<p class="p3">fixationGeneration =&gt; (integer$)</p>
<p class="p4">The generation in which this mutation fixed.</p>
<p class="p3">mutationType =&gt; (object&lt;MutationType&gt;$)</p>
<p class="p4">The <span class="s1">MutationType</span> from which this mutation was drawn.</p>
<p class="p5"><span class="s3">nucleotide &lt;–&gt; (string$)</span></p>
<p class="p6"><span class="s3">A </span><span class="s4">string</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">"A"</span><span class="s3">, </span><span class="s4">"C"</span><span class="s3">, </span><span class="s4">"G"</span><span class="s3">, or </span><span class="s4">"T"</span><span class="s3">.<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p5"><span class="s3">nucleotideValue &lt;–&gt; (integer$)</span></p>
<p class="p6"><span class="s3">An </span><span class="s4">integer</span><span class="s3"> representing the nucleotide associated with this mutation; this will be </span><span class="s4">0</span><span class="s3"> (A), </span><span class="s4">1</span><span class="s3"> (C), </span><span class="s4">2</span><span class="s3"> (G), or </span><span class="s4">3</span><span class="s3"> (T).<span class="Apple-converted-space">  </span>If the mutation is not nucleotide-based, this property is unavailable.</span></p>
<p class="p3">originGeneration =&gt; (integer$)</p>
<p class="p4">The generation in which this mutation arose.</p>
<p class="p3">position =&gt; (integer$)</p>
<p class="p4">The position in the chromosome of this mutation.</p>
<p class="p3">selectionCoeff =&gt; (float$)</p>
<p class="p4">The selection coefficient of the mutation, drawn from the distribution of fitness effects of its <span class="s1">MutationType</span><span class="s2">.</span></p>
<p class="p3">subpopID &lt;–&gt; (integer$)</p>
<p class="p4">The identifier of the subpopulation in which this mutation arose.<span class="Apple-converted-space">  </span>This value is carried over from the <span class="s1">Mutation</span> object directly; if a “tag” value was used in the <span class="s1">Mutation</span> object, that value will carry over to the corresponding <span class="s1">Substitution</span> object.<span class="Apple-converted-space">  </span>The <span class="s1">subpopID</span> in <span class="s1">Substitution</span> is a read-write property to allow it to be used as a “tag” in the same way, if the origin subpopulation identifier is not needed.</p>
<p class="p3">tag &lt;–&gt; (integer$)</p>
<p class="p4">A user-defined <span class="s1">integer</span> value.<span class="Apple-converted-space">  </span>The value of <span class="s1">tag</span> is carried over automatically from the original <span class="s1">Mutation</span> object.<span class="Apple-converted-space">  </span>Apart from that, the value of <span class="s1">tag</span> is not used by SLiM; it is free for you to use.</p>
<p class="p2"><i>5.14.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Substitution</i></span><i> methods</i></p>
<p class="p5"><span class="s3">– (*)getValue(string$ key)</span></p>
<p class="p6"><span class="s3">Returns the value previously set for the dictionary entry identifier </span><span class="s4">key</span><span class="s3"> using </span><span class="s4">setValue()</span><span class="s3">, or </span><span class="s4">NULL</span><span class="s3"> if no value has been set.<span class="Apple-converted-space">  </span>This dictionary-style functionality is actually provided by the superclass of </span><span class="s4">Substitution</span><span class="s3">, </span><span class="s10">EidosDictionary</span><span class="s3">, although that fact is not presently visible in Eidos since superclasses are not introspectable.</span></p>
<p class="p5"><span class="s3">– (void)setValue(string$ key, * value)</span></p>
<p class="p6"><span class="s3">Sets a value for the dictionary entry identifier </span><span class="s4">key</span><span class="s3">.<span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using </span><span class="s4">getValue()</span><span class="s3">.<span class="Apple-converted-space">  </span></span>If <span class="s1">value</span> is of type <span class="s1">object</span>, the object class must internally be under retain-release memory management; among SLiM’s Eidos classes, only <span class="s1">Mutation</span> and <span class="s1">Substitution</span> presently are (see the Eidos manual’s documentation for <span class="s1">defineConstant()</span> for further discussion).<span class="Apple-converted-space">  </span><span class="s3">This dictionary-style functionality is actually provided by the superclass of </span><span class="s4">Substitution</span><span class="s3">, </span><span class="s10">EidosDictionary</span><span class="s3">, although that fact is not presently visible in Eidos since superclasses are not introspectable.</span></p>
<p class="p10"><br></p>
</body>
</html>
