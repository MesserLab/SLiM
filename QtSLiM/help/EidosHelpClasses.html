<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2299.77">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima; color: #000000}
    p.p2 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima; color: #000000}
    p.p3 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p4 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p5 {margin: 9.0px 0.0px 9.0px 45.4px; font: 9.0px Menlo; color: #000000}
    span.s1 {font: 9.0px Menlo}
  </style>
</head>
<body>
<p class="p1"><b>5.1<span class="Apple-converted-space">  </span>Class Object</b></p>
<p class="p2"><i>5.1.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Object</i></span><i> properties</i></p>
<p class="p2"><i>5.1.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Object</i></span><i> methods</i></p>
<p class="p3">+ (integer$)length(void)</p>
<p class="p4">Returns the size (e.g., length) of the receiving object.<span class="Apple-converted-space">  </span>This is equivalent to the <span class="s1">length()</span> (or <span class="s1">size()</span>) function; in other words, for any <span class="s1">object</span> <span class="s1">x</span>, the return value of the function call <span class="s1">length(x)</span> equals the return value of the class method call <span class="s1">x.length()</span>.<span class="Apple-converted-space">  </span>This method is provided solely for syntactic convenience.<span class="Apple-converted-space">  </span>Note that <span class="s1">+length()</span> is a synonym for <span class="s1">+size()</span>.</p>
<p class="p3">+ (void)methodSignature([Ns$ methodName = NULL])</p>
<p class="p4">Prints the method signature for the method specified by <span class="s1">methodName</span>, or for all methods supported by the receiving object if <span class="s1">methodName</span> is <span class="s1">NULL</span> (the default).</p>
<p class="p3">+ (void)propertySignature([Ns$ propertyName = NULL])</p>
<p class="p4">Prints the property signature for the property specified by <span class="s1">propertyName</span>, or for all properties supported by the receiving object if <span class="s1">propertyName</span> is <span class="s1">NULL</span> (the default).</p>
<p class="p3">+ (integer$)size(void)</p>
<p class="p4">Returns the size of the receiving object.<span class="Apple-converted-space">  </span>This is equivalent to the <span class="s1">size()</span> (or <span class="s1">length()</span>) function; in other words, for any <span class="s1">object</span> <span class="s1">x</span>, the return value of the function call <span class="s1">size(x)</span> equals the return value of the class method call <span class="s1">x.size()</span>.<span class="Apple-converted-space">  </span>This method is provided solely for syntactic convenience.<span class="Apple-converted-space">  </span>Note that <span class="s1">+length()</span> is a synonym for <span class="s1">+size()</span>.</p>
<p class="p3">– (void)str(void)</p>
<p class="p4">Prints the internal property structure of the receiving object; in particular, the element type of the object is printed, followed, on successive lines, by all of the properties supported by the object, their types, and a sample of their values.</p>
<p class="p3">– (string$)stringRepresentation(void)</p>
<p class="p4">Returns a singleton <span class="s1">string</span> value that represents the receiving object.<span class="Apple-converted-space">  </span>By default, this is simply the name of the class of the receiving object; however, many subclasses of <span class="s1">Object</span> provide a different string representation.<span class="Apple-converted-space">  </span>The value returned by <span class="s1">stringRepresentation()</span> is the same string that would be printed by <span class="s1">print()</span> for the object, so <span class="s1">stringRepresentation()</span> allows the same representation to be used in other contexts such as <span class="s1">paste()</span> and <span class="s1">cat()</span>.</p>
<p class="p1"><b>5.2<span class="Apple-converted-space">  </span>Class DataFrame</b></p>
<p class="p3">(object&lt;DataFrame&gt;$)DataFrame(...)</p>
<p class="p4">The <span class="s1">DataFrame</span> constructor can be called in the same ways as the constructor for <span class="s1">Dictionary</span> (its superclass): with no parameters to make an empty <span class="s1">DataFrame</span>, with key-value pairs, with a singleton <span class="s1">Dictionary</span> (or a subclass of <span class="s1">Dictionary</span>, like <span class="s1">DataFrame</span>) to make a copy, or with a string in JSON format.<span class="Apple-converted-space">  </span>See the <span class="s1">Dictionary</span> class for further documentation.<span class="Apple-converted-space">  </span>However, note that <span class="s1">DataFrame</span> can only use <span class="s1">string</span> keys; <span class="s1">integer</span> keys are not allowed.</p>
<p class="p2"><i>5.2.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>DataFrame</i></span><i> properties</i></p>
<p class="p3">colNames =&gt; (string)</p>
<p class="p4">A vector containing all of the <span class="s1">string</span> column names in the <span class="s1">DataFrame</span>, in order.<span class="Apple-converted-space">  </span>This property is currently an alias for the <span class="s1">Dictionary</span> property <span class="s1">allKeys</span>.</p>
<p class="p3">dim =&gt; (integer)</p>
<p class="p4">A two-element vector containing the dimensions of the <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The <span class="s1">0</span>th element is the number of rows (as provided by <span class="s1">nrow</span>), and the <span class="s1">1</span>st element is the number of columns (as provided by <span class="s1">ncol</span>).</p>
<p class="p3">ncol =&gt; (integer$)</p>
<p class="p4">The number of columns in the <span class="s1">DataFrame</span>; this will be equal to the length of <span class="s1">colNames</span>.</p>
<p class="p3">nrow =&gt; (integer$)</p>
<p class="p4">The number of rows in the <span class="s1">DataFrame</span> (i.e., the number of elements in a column).<span class="Apple-converted-space">  </span>This will be the same for every column, by definition.</p>
<p class="p2"><i>5.2.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>DataFrame</i></span><i> methods</i></p>
<p class="p3">– (*)asMatrix(void)</p>
<p class="p4">Returns a matrix representation of the <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The matrix will have the same type as the elements of the <span class="s1">DataFrame</span>; if the <span class="s1">DataFrame</span> contains more than one type of element, an error will be raised.<span class="Apple-converted-space">  </span>The order of the columns of the <span class="s1">DataFrame</span> will be preserved.<span class="Apple-converted-space">  </span>This method is useful, for example, if you wish to read in a text file as a matrix; you can use <span class="s1">readCSV()</span> to read the file as a <span class="s1">DataFrame</span>, and then convert it to a matrix with <span class="s1">asMatrix()</span>.</p>
<p class="p3">– (void)cbind(object&lt;Dictionary&gt; source, ...)</p>
<p class="p4">Adds all of the columns contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span> such as <span class="s1">DataFrame</span>) to the receiver.<span class="Apple-converted-space">  </span>This method makes the target <span class="s1">DataFrame</span> wider, by adding new columns.<span class="Apple-converted-space">  </span>If <span class="s1">source</span> contains a column name that is already defined in the target, an error will result.<span class="Apple-converted-space">  </span>As always for <span class="s1">DataFrame</span>, the columns of the resulting <span class="s1">DataFrame</span> must all be the same length.</p>
<p class="p4">The <span class="s1">source</span> parameter may be a non-singleton vector containing multiple <span class="s1">Dictionary</span> objects, and additional <span class="s1">Dictionary</span> vectors may be supplied (thus the ellipsis in the signature).<span class="Apple-converted-space">  </span>Each <span class="s1">Dictionary</span> supplied will be added to the target, in the order supplied.</p>
<p class="p4">This method is similar to the <span class="s1">Dictionary</span> method <span class="s1">addKeysAndValuesFrom()</span>, which may be used instead if replacement of duplicate columns is desired.</p>
<p class="p3">– (void)rbind(object&lt;Dictionary&gt; source, ...)</p>
<p class="p4">Appends all of the columns contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span> such as <span class="s1">DataFrame</span>) to the receiver.<span class="Apple-converted-space">  </span>This method makes the <span class="s1">DataFrame</span> taller, by adding new rows.<span class="Apple-converted-space">  </span>If the source and target do not contain the same column names in the same order, an error will result.<span class="Apple-converted-space">  </span>As always for <span class="s1">DataFrame</span>, the columns of the resulting <span class="s1">DataFrame</span> must all be the same length.</p>
<p class="p4">The <span class="s1">source</span> parameter may be a non-singleton vector containing multiple <span class="s1">Dictionary</span> objects, and additional <span class="s1">Dictionary</span> vectors may be supplied (thus the ellipsis in the signature).<span class="Apple-converted-space">  </span>Each <span class="s1">Dictionary</span> supplied will be appended to the target, in the order supplied.</p>
<p class="p4">This method is similar to the <span class="s1">Dictionary</span> method <span class="s1">appendKeysAndValuesFrom()</span>, which may be used instead if one wishes the append to work even when the columns are in different orders, or other such situations.</p>
<p class="p3">– (*)subset([Nli rows = NULL], [Nlis cols = NULL])</p>
<p class="p4">Returns the elements in the selected rows and columns of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The selection logic is based upon that for <span class="s1">subsetRows()</span> and <span class="s1">subsetColumns()</span>, respectively; in short, rows may be selected by <span class="s1">integer</span> indices or by a <span class="s1">logical</span> vector, and columns may be selected by <span class="s1">integer</span> indices, by a <span class="s1">logical</span> vector, or by a <span class="s1">string</span> vector of column names.<span class="Apple-converted-space">  </span>In addition, however, <span class="s1">NULL</span> may be passed for either <span class="s1">rows</span> or <span class="s1">cols</span> to select all of the rows or all of the columns, respectively; this is the default for both parameters.<span class="Apple-converted-space">  </span>If you want entire rows (rather than selecting particular columns), pass <span class="s1">NULL</span> for <span class="s1">cols</span>; if you want entire columns (rather than selecting particular rows), pass <span class="s1">NULL</span> for <span class="s1">rows</span>.</p>
<p class="p4">The first step performed by <span class="s1">subset()</span> is to produce a <span class="s1">DataFrame</span> that contains the selected rows and columns.<span class="Apple-converted-space">  </span>If that <span class="s1">DataFrame</span> contains more than one column, it is simply returned, and the behavior of <span class="s1">subset()</span> is identical to calling <span class="s1">subsetRows()</span> and <span class="s1">subsetColumns()</span> in sequence (in either order).<span class="Apple-converted-space">  </span>If, however, the resulting <span class="s1">DataFrame</span> contains only a single column, then <span class="s1">subset()</span> will return a vector containing the elements in that column – unlike the behavior of <span class="s1">subsetRows()</span> and <span class="s1">subsetColumns()</span>, which always return a <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>This method is therefore a convenient way to get a single value, or multiple values from the same column, from a <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>(Note that the <span class="s1">Dictionary</span> method <span class="s1">getValue()</span> can also be used to get all of the values from a given <span class="s1">DataFrame</span> column.)</p>
<p class="p3">– (object&lt;DataFrame&gt;$)subsetColumns(lis index)</p>
<p class="p4">Returns a new <span class="s1">DataFrame</span> containing values for the selected columns of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The selection logic described below is similar to how the subset operator <span class="s1">[]</span> in Eidos works, selecting the columns of the target <span class="s1">DataFrame</span>.</p>
<p class="p4">The index parameter may be either <span class="s1">integer</span>, <span class="s1">logical</span>, or <span class="s1">string</span>; we will discuss the <span class="s1">integer</span> case first.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a singleton <span class="s1">integer</span>, the returned <span class="s1">DataFrame</span> will contain the <span class="s1">index</span>’th column of the target (counting from the left, from <span class="s1">0</span>).<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a non-singleton <span class="s1">integer</span> vector, the returned <span class="s1">DataFrame</span> will contains all of the selected columns, in the order that they are selected by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>If any <span class="s1">index</span> value is out of range for the target <span class="s1">DataFrame</span> (such that the <span class="s1">DataFrame</span> does not have an <span class="s1">index</span>’th column), an error will result.<span class="Apple-converted-space">  </span>If the same column is specified more than once, unique column names will be automatically generated for the additional copies of the column.</p>
<p class="p4">If <span class="s1">index</span> is a <span class="s1">string</span> vector, the returned <span class="s1">DataFrame</span> will contain copies of the columns in the target named by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>As with an <span class="s1">integer</span> vector, it is an error if a given column does not exist in the target; and unique column names will be generated for additional copies of a column.</p>
<p class="p4">Finally, if <span class="s1">index</span> is a <span class="s1">logical</span> vector, the length of <span class="s1">index</span> must be equal to the number of columns in the target.<span class="Apple-converted-space">  </span>In this case, the <span class="s1">T</span> values in <span class="s1">index</span> select the columns which will be included in the returned <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The columns in the returned <span class="s1">DataFrame</span> will be in the same order as in the target.</p>
<p class="p3">– (object&lt;DataFrame&gt;$)subsetRows(li index, [logical$ drop = F])</p>
<p class="p4">Returns a new <span class="s1">DataFrame</span> containing values for selected rows of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The selection logic described below works exactly as the subset operator <span class="s1">[]</span> does in Eidos, selecting the rows of the target <span class="s1">DataFrame</span>.</p>
<p class="p4">The <span class="s1">index</span> parameter may be either <span class="s1">integer</span> or <span class="s1">logical</span>; we will discuss the <span class="s1">integer</span> case first.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a singleton <span class="s1">integer</span>, the returned <span class="s1">DataFrame</span> will contain the <span class="s1">index</span>’th element of the value of each key of the target, under the same keys; this is a single row of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a non-singleton <span class="s1">integer</span> vector, the returned <span class="s1">DataFrame</span> will contain the values for all of the selected rows, in the order that they are selected by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>If any index value in <span class="s1">index</span> is out of range for the target <span class="s1">DataFrame</span> (such that that DataFrame does not have an <span class="s1">index</span>’th row), an error will result.</p>
<p class="p4">If <span class="s1">index</span> is <span class="s1">logical</span>, the length of <span class="s1">index</span> must be equal to the number of rows in the target.<span class="Apple-converted-space">  </span>In this case, the <span class="s1">T</span> values in <span class="s1">index</span> select the rows which will be included in the returned <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The values of each column in the returned <span class="s1">DataFrame</span> will be in the same order as in the target.</p>
<p class="p4">If the values of <span class="s1">index</span> are such that <i>no</i> value for a given key is selected, the <span class="s1">drop</span> parameter controls the resulting behavior.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">F</span> (the default), the key will be included in the returned dictionary with a zero-length value of matching type, such as <span class="s1">integer(0)</span> or <span class="s1">string(0)</span>.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">T</span>, the key will be omitted from the returned dictionary.</p>
<p class="p1"><b>5.3<span class="Apple-converted-space">  </span>Class Dictionary</b></p>
<p class="p3">(object&lt;Dictionary&gt;$)Dictionary(...)</p>
<p class="p4">Creates a new <span class="s1">Dictionary</span> object.<span class="Apple-converted-space">  </span>Called without arguments, as <span class="s1">Dictionary()</span>, this creates a new empty <span class="s1">Dictionary</span>.</p>
<p class="p4">Alternatively, key-value pairs can be passed to set up the initial state of the new <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>These are set, sequentially, on the new <span class="s1">Dictionary</span>, just as <span class="s1">setValue()</span> would do.<span class="Apple-converted-space">  </span>For example, calling <span class="s1">Dictionary("a", 0:3, "b", c("foo", "bar"))</span> is equivalent to calling <span class="s1">Dictionary()</span> and then calling <span class="s1">setValue("a", 0:3)</span> and then <span class="s1">setValue("b", c("foo", "bar"))</span> on it; it is just a shorthand for convenience.<span class="Apple-converted-space">  </span>Keys may be of type <span class="s1">string</span> or <span class="s1">integer</span>, but must all be of the same type; <span class="s1">Dictionary</span> supports using either <span class="s1">string</span> or <span class="s1">integer</span> keys, but they cannot be mixed in a single <span class="s1">Dictionary</span> object.</p>
<p class="p4">Another alternative is to call <span class="s1">Dictionary()</span> with a singleton <span class="s1">Dictionary</span> as its only argument; this creates a new <span class="s1">Dictionary</span> that is a copy of the <span class="s1">Dictionary</span> passed, containing the same keys and values.<span class="Apple-converted-space">  </span>This is equivalent to creating a new empty <span class="s1">Dictionary</span> and then calling <span class="s1">addKeysAndValuesFrom()</span> to copy key-value pairs over; it is just a shorthand for convenience.</p>
<p class="p4">A final alternative is to call <span class="s1">Dictionary()</span> with a <span class="s1">string</span> vector as its only argument; this creates a new <span class="s1">Dictionary</span> from the string, assuming that it is a data archive in JSON format.<span class="Apple-converted-space">  </span>If the <span class="s1">string</span> value is not a singleton, its elements will be joined together by newlines to make a singleton <span class="s1">string</span> value; this allows the result from <span class="s1">readFile()</span> to be passed directly to <span class="s1">Dictionary()</span> even for a multiline (prettyprinted) JSON file.<span class="Apple-converted-space">  </span>Note that a JSON string can be generated from the <span class="s1">serialize()</span> method of <span class="s1">Dictionary</span>; together with this way of creating a <span class="s1">Dictionary</span>, this provides the ability to persist arbitrary information to a string (perhaps a file on disk) and back again.<span class="Apple-converted-space">  </span>The recreated <span class="s1">Dictionary</span> should be identical to the original, except that zero length vectors such as <span class="s1">integer(0)</span>, <span class="s1">float(0)</span>, <span class="s1">logical(0)</span>, and <span class="s1">string(0)</span> will all be serialized as <span class="s1">"[]"</span> and recreated as <span class="s1">integer(0)</span> since JSON does not provide a way to specify the type of a zero-length array.</p>
<p class="p2"><i>5.3.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Dictionary</i></span><i> properties</i></p>
<p class="p3">allKeys =&gt; (is)</p>
<p class="p4">A vector containing all of the <span class="s1">string</span> or <span class="s1">integer</span> keys that have been assigned values using <span class="s1">setValue()</span>, in sorted (ascending alphabetic or numeric) order.</p>
<p class="p2"><i>5.3.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Dictionary</i></span><i> methods</i></p>
<p class="p3">– (void)addKeysAndValuesFrom(object&lt;Dictionary&gt;$ source)</p>
<p class="p4">Adds all of the key-value pairs contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span>) to the receiver.<span class="Apple-converted-space">  </span>If the target already contains a key that is defined in <span class="s1">source</span>, the target’s value for that key will be <i>replaced</i> by the value in <span class="s1">source</span> (contrast this with <span class="s1">appendKeysAndValuesFrom()</span>).</p>
<p class="p3">– (void)appendKeysAndValuesFrom(object&lt;Dictionary&gt; source)</p>
<p class="p4">Appends all of the key-value pairs contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span>) to the receiver.<span class="Apple-converted-space">  </span>If the target already contains a key that is defined in source, the value from source will be <i>appended</i> to the target’s existing value, which must be of the same type (contrast this with <span class="s1">addKeysAndValuesFrom()</span>); if the target does not already contain a key that is defined in source, that key-value pair will simply be added to the target.</p>
<p class="p4">In the current implementation, it is an error for either of the values involved in an append to be a matrix or array; values in these <span class="s1">Dictionary</span> objects should be simple vectors.<span class="Apple-converted-space">  </span>This limitation preserves the future option to expand this method’s functionality to do smart things with matrices and arrays.</p>
<p class="p3">– (void)clearKeysAndValues(void)</p>
<p class="p4">Removes all key-value pairs from the receiver.</p>
<p class="p3">– (integer)compactIndices([logical$ preserveOrder = F])</p>
<p class="p4">Compacts the receiver, which must use <span class="s1">integer</span> keys.<span class="Apple-converted-space">  </span>After this operation, the receiver will contain only values that have a length greater than zero (discarding all key–value pairs for which the value is a zero-length vector).<span class="Apple-converted-space">  </span>In addition, the keys used will be compacted down to begin at <span class="s1">0</span> and count upward sequentially.<span class="Apple-converted-space">  </span>If <span class="s1">preserveOrder</span> is <span class="s1">F</span> (the default), the keys may end up in a different numerical order; this allows the compaction to be performed more efficiently.<span class="Apple-converted-space">  </span>If <span class="s1">preserveOrder</span> is <span class="s1">T</span>, on the other hand, the numerical order of the keys will be preserved.<span class="Apple-converted-space">  </span>The returned <span class="s1">integer</span> vector contains the original keys that were kept across the compaction operation, in the order in which they were used in the compaction; keys that were not kept (because their value was zero-length) are omitted from this result vector.</p>
<p class="p4">For example, with a dictionary that contains key–value pairs <span class="s1">-5="a"</span>, <span class="s1">17="b"</span>, <span class="s1">37="c"</span>, <span class="s1">53=integer(0)</span>, and <span class="s1">82="d"</span>, <span class="s1">compactIndices(preserveOrder=T)</span> will transform the dictionary to contain <span class="s1">0="a"</span>, <span class="s1">1="b"</span>, <span class="s1">2="c"</span>, and <span class="s1">3="d"</span>, while key <span class="s1">53</span> (and its zero-length value) is dropped; the returned vector will be (<span class="s1">5</span>, <span class="s1">17</span>, <span class="s1">37</span>, <span class="s1">82</span>).<span class="Apple-converted-space">  </span>The result from <span class="s1">compactIndices(preserveOrder=F)</span> has a non-deterministic order, but one possibility for the same example inout is that it would transform the dictionary to contain key–value pairs <span class="s1">0="c"</span>, <span class="s1">1="d"</span>, <span class="s1">2="a"</span>, and <span class="s1">3="b"</span>, with a returned vector of (<span class="s1">37</span>, <span class="s1">82</span>, <span class="s1">5</span>, <span class="s1">17</span>); the same key–value pairs are kept, and they are again placed in sequential keys beginning with <span class="s1">0</span>, but their order is no longer preserved across the compaction.</p>
<p class="p4">This method is particularly useful when you have a <span class="s1">Dictionary</span> <span class="s1">d</span> that contains results from some operation on a vector <span class="s1">x</span>, such that each key <span class="s1">n</span> in <span class="s1">d</span> has a value that is the result of processing the <span class="s1">n</span>’th element of <span class="s1">x</span>.<span class="Apple-converted-space">  </span>In this case, <span class="s1">order=d.compactIndices(preserveOrder=F)</span> will transmogrify <span class="s1">d</span> to contain only the non-zero-length results, in sequential indices counting from <span class="s1">0</span>, and <span class="s1">x[order]</span> provides the elements of <span class="s1">x</span> that produced those results, in the same order as in <span class="s1">d</span> after compaction.<span class="Apple-converted-space">  </span>Using <span class="s1">preserveOrder=T</span> additionally keeps <span class="s1">d</span> in the same order as the original order of <span class="s1">x</span>, for cases in which that ordering is important.</p>
<p class="p3">– (object&lt;Dictionary&gt;$)getRowValues(li index, [logical$ drop = F])</p>
<p class="p4">Returns a new <span class="s1">Dictionary</span> containing values for selected “rows” of the target <span class="s1">Dictionary</span>, allowing <span class="s1">Dictionary</span> to act similarly to a <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>See the <span class="s1">subsetRows()</span> method of class <span class="s1">DataFrame</span> for comparison; the main utility of <span class="s1">getRowValues()</span> is that it can be used on a <span class="s1">Dictionary</span> that has ragged “rows”.<span class="Apple-converted-space">  </span>The selection logic described below works similarly to the subset operator <span class="s1">[]</span> in Eidos, selecting the “rows” of the target <span class="s1">Dictionary</span>.</p>
<p class="p4">The <span class="s1">index</span> parameter may be either <span class="s1">integer</span> or <span class="s1">logical</span>; we will discuss the <span class="s1">integer</span> case first.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a singleton <span class="s1">integer</span>, the returned <span class="s1">Dictionary</span> will contain the <span class="s1">index</span>’th element of the value of each key of the target, under the same keys; this is a single “row” of the target <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a non-singleton <span class="s1">integer</span> vector, the returned <span class="s1">Dictionary</span> will contain the values for all of the selected rows, in the order that they are selected by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>If any index value in <span class="s1">index</span> is out of range for any key of the target <span class="s1">Dictionary</span> (such that that key does not have an <span class="s1">index</span>’th value), the returned dictionary will simply not have a value for that “row” of that key.</p>
<p class="p4">If <span class="s1">index</span> is <span class="s1">logical</span>, the <span class="s1">T</span> values in <span class="s1">index</span> select the “rows” which will be included in the returned <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>The values within each column in the returned <span class="s1">Dictionary</span> will be in the same order as in the target.<span class="Apple-converted-space">  </span>The length of <span class="s1">index</span> need not match any column of the <span class="s1">Dictionary</span>; excess “rows” beyond the length of <span class="s1">index</span> will not be selected, and excess values in <span class="s1">index</span> beyond the end of the longest “column” will have no effect.</p>
<p class="p4">If the values of <span class="s1">index</span> are such that <i>no</i> value for a given key is selected, the <span class="s1">drop</span> parameter controls the resulting behavior.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">F</span> (the default), the key will be included in the returned dictionary with a zero-length value of matching type, such as <span class="s1">integer(0)</span> or <span class="s1">string(0)</span>.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">T</span>, the key will be omitted from the returned dictionary.</p>
<p class="p3">– (*)getValue(is$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.</p>
<p class="p3">– (logical$)identicalContents(object&lt;Dictionary&gt;$ x)</p>
<p class="p4">Returns <span class="s1">T</span> if the target <span class="s1">Dictionary</span> is equal to <span class="s1">x</span> in all respects – containing the same keys, with values that are identical in the sense defined by the <span class="s1">identical()</span> function in Eidos – or returns <span class="s1">F</span> otherwise.</p>
<p class="p4">Note that if <span class="s1">Dictionary</span> objects are contained, as values, by the dictionaries being tested for equality, they will be compared according to the standards of <span class="s1">identical()</span>, and must therefore actually be the <i>same</i> <span class="s1">Dictionary</span> object, shared by both dictionaries, for <span class="s1">isEqual()</span> to return <span class="s1">T</span>.</p>
<p class="p3">– (string)serialize([string$ format = "slim"])</p>
<p class="p4">Returns a serialized form of the dictionary’s contents as a <span class="s1">string</span> singleton or vector.<span class="Apple-converted-space">  </span>Five formats are supported at present, as chosen with the <span class="s1">format</span> parameter: <span class="s1">"slim"</span>, <span class="s1">"pretty"</span>, and <span class="s1">"json"</span> produce a singleton string, whereas <span class="s1">"csv"</span> and <span class="s1">"tsv"</span> produce a <span class="s1">string</span> vector.<span class="Apple-converted-space">  </span>These serializations can be written to disk with <span class="s1">writeFile()</span> or <span class="s1">writeTempFile()</span>, written to the output stream with <span class="s1">cat()</span>, or used in any other way.</p>
<p class="p4">The default <span class="s1">"slim"</span> format is intended for simple, informal use where a very easily parseable string is desired.<span class="Apple-converted-space">  </span>For a simple dictionary containing only keys with singleton non-object values, this will be a semicolon-delimited string like <span class="s1">'"string1"=value1;"string2"=value2;'</span> or <span class="s1">'int1=value1;int2=value2;'</span>.<span class="Apple-converted-space">  </span>Values of type <span class="s1">string</span> will be quoted, and will be escaped with backslash escape sequences, including <span class="s1">\\</span>, <span class="s1">\"</span>, <span class="s1">\'</span>, <span class="s1">\t</span>, <span class="s1">\r</span>, and <span class="s1">\n</span>.<span class="Apple-converted-space">  </span>Values that are not singleton will be separated by spaces, such as <span class="s1">'"string1"=1 2 3;'</span>, while values that are themselves dictionaries will be delimited by braces, such as <span class="s1">'"string1"={int1=value1;int2=value2;};'</span>.<span class="Apple-converted-space">  </span>Keys that are of type <span class="s1">string</span> will be quoted (always; note that this is a change in behavior starting in SLiM 4.1) and backslash-escaped (as needed, as for <span class="s1">string</span> values); keys that are of type <span class="s1">integer</span> are not quoted.<span class="Apple-converted-space">  </span>No facility for parsing <span class="s1">"slim"</span> serializations back into Eidos is presently provided.</p>
<p class="p4">For a more extended example, here is an input <span class="s1">Dictionary</span>, assigned into a variable <span class="s1">x</span>:</p>
<p class="p5">x = Dictionary("a", 17, "b", 1:5, "c", c("foo", "bar"),<br>
<span class="Apple-converted-space">                  </span>"d", Dictionary("seq", 1.5:5),<br>
<span class="Apple-converted-space">                  </span>"e", Dictionary());</p>
<p class="p4">and here is the result of <span class="s1">x.serialize("json")</span>, omitting the enclosing quotes that would indicate that this is a <span class="s1">string</span> value:</p>
<p class="p5">"a"=17;"b"=1 2 3 4 5;"c"="foo" "bar";"d"={"seq"=1.5 2.5 3.5 4.5;};"e"={};</p>
<p class="p4">The <span class="s1">"pretty"</span> format is intended for human-readable output, for purposes such as debugging output.<span class="Apple-converted-space">  </span>It is similar to the <span class="s1">"slim"</span> format, but (1) it prints an enclosing set of braces at the top level, (2) it adds newlines inside braces, (3) it tracks an indentation level that increments for nested dictionaries, (4) it adds whitespace it some positions for readability, such as around the equals signs that separate keys from values, and (5) it omits the semicolon at the end of a value, adding a newline instead.<span class="Apple-converted-space">  </span>No facility for parsing <span class="s1">"pretty"</span> serializations back into Eidos is presently provided.</p>
<p class="p4">For the same extended example <span class="s1">Dictionary</span> as above, here is the result of <span class="s1">x.serialize("pretty")</span>, again omitting the enclosing quotes that would indicate that this is a <span class="s1">string</span> value:</p>
<p class="p5">{<br>
<span class="Apple-converted-space">   </span>"a" = 17<br>
<span class="Apple-converted-space">   </span>"b" = 1 2 3 4 5<br>
<span class="Apple-converted-space">   </span>"c" = "foo" "bar"<br>
<span class="Apple-converted-space">   </span>"d" = {<br>
<span class="Apple-converted-space">      </span>"seq" = 1.5 2.5 3.5 4.5<br>
<span class="Apple-converted-space">   </span>}<br>
<span class="Apple-converted-space">   </span>"e" = {}<br>
}</p>
<p class="p4">The <span class="s1">"json"</span> format, introduced in Eidos 2.7 (SLiM 3.7), provides serialization of the <span class="s1">Dictionary</span> into the standard JSON format, which may not be quite as brief or human-readable, but which can be used as a standard interchange format and read by the <span class="s1">Dictionary()</span> constructor in Eidos as well as by many other programs.<span class="Apple-converted-space">  </span>For example, a <span class="s1">Dictionary</span> with a key <span class="s1">"key1"</span> with <span class="s1">integer</span> value <span class="s1">1:3</span> and key <span class="s1">"key2"</span> with <span class="s1">string</span> value <span class="s1">"value2"</span> would produce the JSON serialization <span class="s1">'{"key1":[1,2,3],"key2":["value2"]}'</span>, where the outer single quotes are not part of the serialization itself, but are indicating that the serialization is a <span class="s1">string</span> value.<span class="Apple-converted-space">  </span>Note that since all Eidos values are vectors, even singleton values are serialized into JSON as arrays by Eidos; the hope is that this will make automated parsing of these JSON strings easier, since the singleton case will not have to be special-cased.<span class="Apple-converted-space">  </span>For example, <span class="s1">Dictionary("a", 1, "b", Dictionary("x", 2))</span> would be serialized into JSON as <span class="s1">'{"a":[1],"b":[{"x":[2]}]}'</span>.<span class="Apple-converted-space">  </span>Note that dictionaries that use <span class="s1">integer</span> keys cannot be serialized into JSON, because JSON does not support <span class="s1">integer</span> keys.<span class="Apple-converted-space">  </span>Documentation on the JSON format can be found online.</p>
<p class="p4">The <span class="s1">"csv"</span> and <span class="s1">"tsv"</span> formats produce standard comma-separated value (CSV) or tab-separated value (TSV) data.<span class="Apple-converted-space">  </span>These formats are primarily intended for output from <span class="s1">DataFrame</span>, since that class is used to represent the sort of data tables that CSV/TSV are typically used for; but it may be used with <span class="s1">Dictionary</span> too, particularly if it is being used to represent a data table with ragged columns (missing values will just be skipped over, producing two commas or two tabs in sequence).<span class="Apple-converted-space">  </span>Values of type <span class="s1">string</span> will always be quoted, with double quotes (with a repeated double quote used to indicate the presence of a double quote inside a <span class="s1">string</span> value, as usual in CSV); values of other types never will.<span class="Apple-converted-space">  </span>Decimal points (not decimal commas, regardless of system localization) will always be used for <span class="s1">float</span> values, and will never be used for <span class="s1">integer</span> values.<span class="Apple-converted-space">  </span>Values of logical type will be serialized as <span class="s1">TRUE</span> or <span class="s1">FALSE</span>, without quotes.<span class="Apple-converted-space">  </span>A header line providing the names of the columns (i.e., the keys of the target <span class="s1">Dictionary</span>) will always be generated; those column names will also be quoted (if the keys of the dictionary are type <span class="s1">string</span>; <span class="s1">integer</span> keys are not quoted).<span class="Apple-converted-space">  </span>One <span class="s1">string</span> element will be generated for each row of the target, plus one <span class="s1">string</span> element for the header line; newlines will not be present in the resulting <span class="s1">string</span> vector unless newlines were present within the <span class="s1">string</span> values in the <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>The resulting data, if written to a file, should be readable in Eidos using <span class="s1">readCSV()</span> (as long as there are no ragged columns or missing values), as well as in other software such as R and Excel.</p>
<p class="p3">– (void)setValue(is$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span>.<span class="Apple-converted-space">  </span>The key may be a <span class="s1">string</span> or an <span class="s1">integer</span>; either is allowed, unless the target dictionary has already begun using keys of a given type, in which case it must continue using the same key type (a given dictionary cannot have both <span class="s1">string</span> and <span class="s1">integer</span> keys).<span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span>Setting a key to a value of <span class="s1">NULL</span> removes that key from the dictionary.</p>
<p class="p4">If <span class="s1">value</span> is of type <span class="s1">object</span>, any <span class="s1">object</span> class is allowed; all objects may be added as values to a dictionary.<span class="Apple-converted-space">  </span>However, additional scoping restrictions may apply if the <span class="s1">object</span> class is not under an internal memory-management scheme called “retain-release”; in particular, it may not be legal to keep an object in a dictionary “long term” if it is not under retain-release, where “long term” is a scoping semantic defined by the Context.<span class="Apple-converted-space">  </span>All object classes defined by Eidos itself (<span class="s1">Dictionary</span>, <span class="s1">DataFrame</span>, <span class="s1">Image</span>) are under retain-release, so this restriction does not affect pure Eidos code.<span class="Apple-converted-space">  </span>See the SLiM manual (section “SLiM scoping rules”) for further discussion of this topic.</p>
<p class="p3">+ (void)setValuesVectorized(is$ key, * values)</p>
<p class="p4">This class method sets a singleton value from <span class="s1">values</span> into each target dictionary, using the same dictionary entry identifier <span class="s1">key</span> for each.<span class="Apple-converted-space">  </span>The number of elements in <span class="s1">values</span> must be equal to the number of target dictionaries, so that the 0th element of <span class="s1">values</span> is set as the value for the 0th target object, the 1st element of <span class="s1">values</span> is set as the value for the 1st target object, and so forth.</p>
<p class="p4">This is a vectorized version of <span class="s1">setValue()</span>; <span class="s1">dicts.setValuesVectorized("key", values)</span> is equivalent to <span class="s1">for (dict in dicts, value in values) dict.setValue("key", value)</span>, but is faster since the <span class="s1">for</span> loop is vectorized internally.<span class="Apple-converted-space">  </span>The speedup is not enormous, however; the larger reason for the existence of this method is convenience.</p>
<p class="p4">The values are set into the target dictionaries in exactly the same way as the <span class="s1">setValue()</span> method would do; see that method for details about <span class="s1">string</span> versus <span class="s1">integer</span> keys, scoping restrictions for values of type <span class="s1">object</span>, and so forth.<span class="Apple-converted-space">  </span>Note that it is not possible to remove values from the target dictionaries, however, since it is not possible to pass <span class="s1">NULL</span> as a value here.</p>
<p class="p1"><b>5.4<span class="Apple-converted-space">  </span>Class Image</b></p>
<p class="p3">(object&lt;Image&gt;$)Image(...)</p>
<p class="p4">Creates a new <span class="s1">Image</span> object.<span class="Apple-converted-space">  </span>This can be called in a few different ways.</p>
<p class="p4">Passed a singleton <span class="s1">string</span>, as <span class="s1">Image(string$ filePath)</span>, it creates a new <span class="s1">Image</span> from the PNG file at <span class="s1">filePath</span>.<span class="Apple-converted-space">  </span>If the file represents a grayscale image, an 8-bit grayscale (K) <span class="s1">Image</span> will be created; all other PNG files will yield a 24-bit color (RGB) <span class="s1">Image</span>.</p>
<p class="p4">Passed an <span class="s1">integer</span> or <span class="s1">float</span> vector, as <span class="s1">Image(numeric matrix)</span>, it creates a new grayscale <span class="s1">Image</span> from the values in <span class="s1">matrix</span>, which must be a matrix as its name suggests.<span class="Apple-converted-space">  </span>If <span class="s1">matrix</span> is <span class="s1">integer</span>, its values must be in [<span class="s1">0</span>, <span class="s1">255</span>], and will be used directly as 8-bit pixel values without translation; if <span class="s1">matrix</span> is <span class="s1">float</span>, its values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], and will be translated into 8-bit pixel values.<span class="Apple-converted-space">  </span>The dimensions of the image, in pixels, will be equal to the dimensions of the matrix.<span class="Apple-converted-space">  </span>The orientation of the image will match that of the matrix, in the sense that the image will appear as the matrix does when printed in the Eidos console; internally this requires a transposition of values, as discussed further below.<span class="Apple-converted-space">  </span>For the <span class="s1">integer</span> case, the <span class="s1">integerK</span> property of the resulting image will recover the original matrix exactly; for the <span class="s1">float</span> case, the <span class="s1">floatK</span> property will only approximately recover the original matrix since the translation into 8-bit pixel values involves quantization, but values of <span class="s1">0.0</span> and <span class="s1">1.0</span> will be recovered exactly.</p>
<p class="p2"><i>5.4.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Image</i></span><i> properties</i></p>
<p class="p3">width =&gt; (integer$)</p>
<p class="p4">The width of the image, in pixels.</p>
<p class="p3">height =&gt; (integer$)</p>
<p class="p4">The height of the image, in pixels.</p>
<p class="p3">isGrayscale =&gt; (logical$)</p>
<p class="p4">This flag is <span class="s1">T</span> if the image is grayscale, with only a K channel; it is <span class="s1">F</span> if the image is color, with R/G/B channels.</p>
<p class="p3">bitsPerChannel =&gt; (integer$)</p>
<p class="p4">The number of bits used to represent a single pixel, in one channel of the image.<span class="Apple-converted-space">  </span>At present this is always 8; grayscale (K) images are 8-bit, color (RGB) images are 24-bit.<span class="Apple-converted-space">  </span>It could be extended to support 16-bit channels in future.</p>
<p class="p3">integerR =&gt; (integer)</p>
<p class="p4">The red (R) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatR</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">integerG =&gt; (integer)</p>
<p class="p4">The green (G) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatG</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">integerB =&gt; (integer)</p>
<p class="p4">The blue (R) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatB</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">integerK =&gt; (integer)</p>
<p class="p4">The gray (K) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatK</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is color, this property is unavailable.</p>
<p class="p3">floatR =&gt; (float)</p>
<p class="p4">The red (R) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerR</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerR</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">floatG =&gt; (float)</p>
<p class="p4">The green (G) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerG</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerG</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">floatB =&gt; (float)</p>
<p class="p4">The blue (B) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerB</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerB</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">floatK =&gt; (float)</p>
<p class="p4">The gray (K) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerK</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerK</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is color, this property is unavailable.</p>
<p class="p2"><i>5.4.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Image</i></span><i> methods</i></p>
<p class="p3">– (void)write(string$ filePath)</p>
<p class="p4">Writes the image to the given filesystem path <span class="s1">filePath</span> as PNG data.<span class="Apple-converted-space">  </span>It is suggested, but not required, that <span class="s1">filePath</span> should end in a <span class="s1">.png</span> or <span class="s1">.PNG</span> filename extension.<span class="Apple-converted-space">  </span>If the file cannot be written, an error will result.<span class="Apple-converted-space">  </span>At present, since <span class="s1">bitsPerChannel</span> is always 8, grayscale data will be written as an 8-bit grayscale PNG while color (RGB) data will be written as a 24-bit color PNG without alpha.</p>
</body>
</html>
