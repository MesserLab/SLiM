<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2299.5">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima; color: #000000}
    p.p2 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima; color: #000000}
    p.p3 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p4 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    span.s1 {font: 9.0px Menlo}
  </style>
</head>
<body>
<p class="p1"><b>5.1<span class="Apple-converted-space">  </span>Class Object</b></p>
<p class="p2"><i>5.1.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Object</i></span><i> properties</i></p>
<p class="p2"><i>5.1.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Object</i></span><i> methods</i></p>
<p class="p3">+ (integer$)length(void)</p>
<p class="p4">Returns the size (e.g., length) of the receiving object.<span class="Apple-converted-space">  </span>This is equivalent to the <span class="s1">length()</span> (or <span class="s1">size()</span>) function; in other words, for any <span class="s1">object</span> <span class="s1">x</span>, the return value of the function call <span class="s1">length(x)</span> equals the return value of the class method call <span class="s1">x.length()</span>.<span class="Apple-converted-space">  </span>This method is provided solely for syntactic convenience.<span class="Apple-converted-space">  </span>Note that <span class="s1">+length()</span> is a synonym for <span class="s1">+size()</span>.</p>
<p class="p3">+ (void)methodSignature([Ns$ methodName = NULL])</p>
<p class="p4">Prints the method signature for the method specified by <span class="s1">methodName</span>, or for all methods supported by the receiving object if <span class="s1">methodName</span> is <span class="s1">NULL</span> (the default).</p>
<p class="p3">+ (void)propertySignature([Ns$ propertyName = NULL])</p>
<p class="p4">Prints the property signature for the property specified by <span class="s1">propertyName</span>, or for all properties supported by the receiving object if <span class="s1">propertyName</span> is <span class="s1">NULL</span> (the default).</p>
<p class="p3">+ (integer$)size(void)</p>
<p class="p4">Returns the size of the receiving object.<span class="Apple-converted-space">  </span>This is equivalent to the <span class="s1">size()</span> (or <span class="s1">length()</span>) function; in other words, for any <span class="s1">object</span> <span class="s1">x</span>, the return value of the function call <span class="s1">size(x)</span> equals the return value of the class method call <span class="s1">x.size()</span>.<span class="Apple-converted-space">  </span>This method is provided solely for syntactic convenience.<span class="Apple-converted-space">  </span>Note that <span class="s1">+length()</span> is a synonym for <span class="s1">+size()</span>.</p>
<p class="p3">– (void)str(void)</p>
<p class="p4">Prints the internal property structure of the receiving object; in particular, the element type of the object is printed, followed, on successive lines, by all of the properties supported by the object, their types, and a sample of their values.</p>
<p class="p3">– (string$)stringRepresentation(void)</p>
<p class="p4">Returns a singleton <span class="s1">string</span> value that represents the receiving object.<span class="Apple-converted-space">  </span>By default, this is simply the name of the class of the receiving object; however, many subclasses of <span class="s1">Object</span> provide a different string representation.<span class="Apple-converted-space">  </span>The value returned by <span class="s1">stringRepresentation()</span> is the same string that would be printed by <span class="s1">print()</span> for the object, so <span class="s1">stringRepresentation()</span> allows the same representation to be used in other contexts such as <span class="s1">paste()</span> and <span class="s1">cat()</span>.</p>
<p class="p1"><b>5.2<span class="Apple-converted-space">  </span>Class DataFrame</b></p>
<p class="p3">(object&lt;DataFrame&gt;$)DataFrame(...)</p>
<p class="p4">The <span class="s1">DataFrame</span> constructor can be called in the same ways as the constructor for <span class="s1">Dictionary</span> (its superclass): with no parameters to make an empty <span class="s1">DataFrame</span>, with key-value pairs, with a singleton <span class="s1">Dictionary</span> (or a subclass of <span class="s1">Dictionary</span>, like <span class="s1">DataFrame</span>) to make a copy, or with a singleton string in JSON format.<span class="Apple-converted-space">  </span>See the <span class="s1">Dictionary</span> class for further documentation.<span class="Apple-converted-space">  </span>However, note that <span class="s1">DataFrame</span> can only use <span class="s1">string</span> keys; <span class="s1">integer</span> keys are not allowed.</p>
<p class="p2"><i>5.2.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>DataFrame</i></span><i> properties</i></p>
<p class="p3">colNames =&gt; (string)</p>
<p class="p4">A vector containing all of the <span class="s1">string</span> column names in the <span class="s1">DataFrame</span>, in order.<span class="Apple-converted-space">  </span>This property is currently an alias for the <span class="s1">Dictionary</span> property <span class="s1">allKeys</span>.</p>
<p class="p3">dim =&gt; (integer)</p>
<p class="p4">A two-element vector containing the dimensions of the <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The <span class="s1">0</span>th element is the number of rows (as provided by <span class="s1">nrow</span>), and the <span class="s1">1</span>st element is the number of columns (as provided by <span class="s1">ncol</span>).</p>
<p class="p3">ncol =&gt; (integer$)</p>
<p class="p4">The number of columns in the <span class="s1">DataFrame</span>; this will be equal to the length of <span class="s1">colNames</span>.</p>
<p class="p3">nrow =&gt; (integer$)</p>
<p class="p4">The number of rows in the <span class="s1">DataFrame</span> (i.e., the number of elements in a column).<span class="Apple-converted-space">  </span>This will be the same for every column, by definition.</p>
<p class="p2"><i>5.2.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>DataFrame</i></span><i> methods</i></p>
<p class="p3">– (*)asMatrix(void)</p>
<p class="p4">Returns a matrix representation of the <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The matrix will have the same type as the elements of the <span class="s1">DataFrame</span>; if the <span class="s1">DataFrame</span> contains more than one type of element, an error will be raised.<span class="Apple-converted-space">  </span>The order of the columns of the <span class="s1">DataFrame</span> will be preserved.<span class="Apple-converted-space">  </span>This method is useful, for example, if you wish to read in a text file as a matrix; you can use <span class="s1">readCSV()</span> to read the file as a <span class="s1">DataFrame</span>, and then convert it to a matrix with <span class="s1">asMatrix()</span>.</p>
<p class="p3">– (void)cbind(object source, ...)</p>
<p class="p4">Adds all of the columns contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span> such as <span class="s1">DataFrame</span>) to the receiver.<span class="Apple-converted-space">  </span>This method makes the target <span class="s1">DataFrame</span> wider, by adding new columns.<span class="Apple-converted-space">  </span>If <span class="s1">source</span> contains a column name that is already defined in the target, an error will result.<span class="Apple-converted-space">  </span>As always for <span class="s1">DataFrame</span>, the columns of the resulting <span class="s1">DataFrame</span> must all be the same length.</p>
<p class="p4">The <span class="s1">source</span> parameter may be a non-singleton vector containing multiple <span class="s1">Dictionary</span> objects, and additional <span class="s1">Dictionary</span> vectors may be supplied (thus the ellipsis in the signature).<span class="Apple-converted-space">  </span>Each <span class="s1">Dictionary</span> supplied will be added to the target, in the order supplied.</p>
<p class="p4">This method is similar to the <span class="s1">Dictionary</span> method <span class="s1">addKeysAndValuesFrom()</span>, which may be used instead if replacement of duplicate columns is desired.</p>
<p class="p3">– (void)rbind(object source, ...)</p>
<p class="p4">Appends all of the columns contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span> such as <span class="s1">DataFrame</span>) to the receiver.<span class="Apple-converted-space">  </span>This method makes the <span class="s1">DataFrame</span> taller, by adding new rows.<span class="Apple-converted-space">  </span>If the source and target do not contain the same column names in the same order, an error will result.<span class="Apple-converted-space">  </span>As always for <span class="s1">DataFrame</span>, the columns of the resulting <span class="s1">DataFrame</span> must all be the same length.</p>
<p class="p4">The <span class="s1">source</span> parameter may be a non-singleton vector containing multiple <span class="s1">Dictionary</span> objects, and additional <span class="s1">Dictionary</span> vectors may be supplied (thus the ellipsis in the signature).<span class="Apple-converted-space">  </span>Each <span class="s1">Dictionary</span> supplied will be appended to the target, in the order supplied.</p>
<p class="p4">This method is similar to the <span class="s1">Dictionary</span> method <span class="s1">appendKeysAndValuesFrom()</span>, which may be used instead if one wishes the append to work even when the columns are in different orders, or other such situations.</p>
<p class="p3">– (*)subset([Nli rows = NULL], [Nlis cols = NULL])</p>
<p class="p4">Returns the elements in the selected rows and columns of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The selection logic is based upon that for <span class="s1">subsetRows()</span> and <span class="s1">subsetColumns()</span>, respectively; in short, rows may be selected by <span class="s1">integer</span> indices or by a <span class="s1">logical</span> vector, and columns may be selected by <span class="s1">integer</span> indices, by a <span class="s1">logical</span> vector, or by a <span class="s1">string</span> vector of column names.<span class="Apple-converted-space">  </span>In addition, however, <span class="s1">NULL</span> may be passed for either <span class="s1">rows</span> or <span class="s1">cols</span> to select all of the rows or all of the columns, respectively; this is the default for both parameters.<span class="Apple-converted-space">  </span>If you want entire rows (rather than selecting particular columns), pass <span class="s1">NULL</span> for <span class="s1">cols</span>; if you want entire columns (rather than selecting particular rows), pass <span class="s1">NULL</span> for <span class="s1">rows</span>.</p>
<p class="p4">The first step performed by <span class="s1">subset()</span> is to produce a <span class="s1">DataFrame</span> that contains the selected rows and columns.<span class="Apple-converted-space">  </span>If that <span class="s1">DataFrame</span> contains more than one column, it is simply returned, and the behavior of <span class="s1">subset()</span> is identical to calling <span class="s1">subsetRows()</span> and <span class="s1">subsetColumns()</span> in sequence (in either order).<span class="Apple-converted-space">  </span>If, however, the resulting <span class="s1">DataFrame</span> contains only a single column, then <span class="s1">subset()</span> will return a vector containing the elements in that column – unlike the behavior of <span class="s1">subsetRows()</span> and <span class="s1">subsetColumns()</span>, which always return a <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>This method is therefore a convenient way to get a single value, or multiple values from the same column, from a <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>(Note that the <span class="s1">Dictionary</span> method <span class="s1">getValue()</span> can also be used to get all of the values from a given <span class="s1">DataFrame</span> column.)</p>
<p class="p3">– (object&lt;DataFrame&gt;$)subsetColumns(lis index)</p>
<p class="p4">Returns a new <span class="s1">DataFrame</span> containing values for the selected columns of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The selection logic described below is similar to how the subset operator <span class="s1">[]</span> in Eidos works, selecting the columns of the target <span class="s1">DataFrame</span>.</p>
<p class="p4">The index parameter may be either <span class="s1">integer</span>, <span class="s1">logical</span>, or <span class="s1">string</span>; we will discuss the <span class="s1">integer</span> case first.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a singleton <span class="s1">integer</span>, the returned <span class="s1">DataFrame</span> will contain the <span class="s1">index</span>’th column of the target (counting from the left, from <span class="s1">0</span>).<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a non-singleton <span class="s1">integer</span> vector, the returned <span class="s1">DataFrame</span> will contains all of the selected columns, in the order that they are selected by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>If any <span class="s1">index</span> value is out of range for the target <span class="s1">DataFrame</span> (such that the <span class="s1">DataFrame</span> does not have an <span class="s1">index</span>’th column), an error will result.<span class="Apple-converted-space">  </span>If the same column is specified more than once, unique column names will be automatically generated for the additional copies of the column.</p>
<p class="p4">If <span class="s1">index</span> is a <span class="s1">string</span> vector, the returned <span class="s1">DataFrame</span> will contain copies of the columns in the target named by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>As with an <span class="s1">integer</span> vector, it is an error if a given column does not exist in the target; and unique column names will be generated for additional copies of a column.</p>
<p class="p4">Finally, if <span class="s1">index</span> is a <span class="s1">logical</span> vector, the length of <span class="s1">index</span> must be equal to the number of columns in the target.<span class="Apple-converted-space">  </span>In this case, the <span class="s1">T</span> values in <span class="s1">index</span> select the columns which will be included in the returned <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The columns in the returned <span class="s1">DataFrame</span> will be in the same order as in the target.</p>
<p class="p3">– (object&lt;DataFrame&gt;$)subsetRows(li index, [logical$ drop = F])</p>
<p class="p4">Returns a new <span class="s1">DataFrame</span> containing values for selected rows of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The selection logic described below works exactly as the subset operator <span class="s1">[]</span> does in Eidos, selecting the rows of the target <span class="s1">DataFrame</span>.</p>
<p class="p4">The <span class="s1">index</span> parameter may be either <span class="s1">integer</span> or <span class="s1">logical</span>; we will discuss the <span class="s1">integer</span> case first.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a singleton <span class="s1">integer</span>, the returned <span class="s1">DataFrame</span> will contain the <span class="s1">index</span>’th element of the value of each key of the target, under the same keys; this is a single row of the target <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a non-singleton <span class="s1">integer</span> vector, the returned <span class="s1">DataFrame</span> will contain the values for all of the selected rows, in the order that they are selected by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>If any index value in <span class="s1">index</span> is out of range for the target <span class="s1">DataFrame</span> (such that that DataFrame does not have an <span class="s1">index</span>’th row), an error will result.</p>
<p class="p4">If <span class="s1">index</span> is <span class="s1">logical</span>, the length of <span class="s1">index</span> must be equal to the number of rows in the target.<span class="Apple-converted-space">  </span>In this case, the <span class="s1">T</span> values in <span class="s1">index</span> select the rows which will be included in the returned <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>The values of each column in the returned <span class="s1">DataFrame</span> will be in the same order as in the target.</p>
<p class="p4">If the values of <span class="s1">index</span> are such that <i>no</i> value for a given key is selected, the <span class="s1">drop</span> parameter controls the resulting behavior.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">F</span> (the default), the key will be included in the returned dictionary with a zero-length value of matching type, such as <span class="s1">integer(0)</span> or <span class="s1">string(0)</span>.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">T</span>, the key will be omitted from the returned dictionary.</p>
<p class="p1"><b>5.3<span class="Apple-converted-space">  </span>Class Dictionary</b></p>
<p class="p3">(object&lt;Dictionary&gt;$)Dictionary(...)</p>
<p class="p4">Creates a new <span class="s1">Dictionary</span> object.<span class="Apple-converted-space">  </span>Called without arguments, as <span class="s1">Dictionary()</span>, this creates a new empty <span class="s1">Dictionary</span>.</p>
<p class="p4">Alternatively, key-value pairs can be passed to set up the initial state of the new <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>These are set, sequentially, on the new <span class="s1">Dictionary</span>, just as <span class="s1">setValue()</span> would do.<span class="Apple-converted-space">  </span>For example, calling <span class="s1">Dictionary("a", 0:3, "b", c("foo", "bar"))</span> is equivalent to calling <span class="s1">Dictionary()</span> and then calling <span class="s1">setValue("a", 0:3)</span> and then <span class="s1">setValue("b", c("foo", "bar"))</span> on it; it is just a shorthand for convenience.<span class="Apple-converted-space">  </span>Keys may be of type <span class="s1">string</span> or <span class="s1">integer</span>, but must all be of the same type; <span class="s1">Dictionary</span> supports using either <span class="s1">string</span> or <span class="s1">integer</span> keys, but they cannot be mixed in a single <span class="s1">Dictionary</span> object.</p>
<p class="p4">Another alternative is to call <span class="s1">Dictionary()</span> with a singleton <span class="s1">Dictionary</span> as its only argument; this creates a new <span class="s1">Dictionary</span> that is a copy of the <span class="s1">Dictionary</span> passed, containing the same keys and values.<span class="Apple-converted-space">  </span>This is equivalent to creating a new empty <span class="s1">Dictionary</span> and then calling <span class="s1">addKeysAndValuesFrom()</span> to copy key-value pairs over; it is just a shorthand for convenience.</p>
<p class="p4">A final alternative is to call <span class="s1">Dictionary()</span> with a singleton <span class="s1">string</span> as its only argument; this creates a new <span class="s1">Dictionary</span> from the string, assuming that it is a data archive in JSON format.<span class="Apple-converted-space">  </span>Note that a JSON string can be generated from the <span class="s1">serialize()</span> method of <span class="s1">Dictionary</span>; together with this way of creating a <span class="s1">Dictionary</span>, this provides the ability to persist arbitrary information to a string (perhaps a file on disk) and back again.<span class="Apple-converted-space">  </span>The recreated <span class="s1">Dictionary</span> should be identical to the original, except that zero length vectors such as <span class="s1">integer(0)</span>, <span class="s1">float(0)</span>, <span class="s1">logical(0)</span>, and <span class="s1">string(0)</span> will all be serialized as <span class="s1">"[]"</span> and recreated as <span class="s1">integer(0)</span> since JSON does not provide a way to specify the type of a zero-length array.</p>
<p class="p2"><i>5.3.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Dictionary</i></span><i> properties</i></p>
<p class="p3">allKeys =&gt; (is)</p>
<p class="p4">A vector containing all of the <span class="s1">string</span> or <span class="s1">integer</span> keys that have been assigned values using <span class="s1">setValue()</span>, in sorted (ascending alphabetic or numeric) order.</p>
<p class="p2"><i>5.3.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Dictionary</i></span><i> methods</i></p>
<p class="p3">– (void)addKeysAndValuesFrom(object$ source)</p>
<p class="p4">Adds all of the key-value pairs contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span>) to the receiver.<span class="Apple-converted-space">  </span>If the target already contains a key that is defined in <span class="s1">source</span>, the target’s value for that key will be <i>replaced</i> by the value in <span class="s1">source</span> (contrast this with <span class="s1">appendKeysAndValuesFrom()</span>).</p>
<p class="p3">– (void)appendKeysAndValuesFrom(object source)</p>
<p class="p4">Appends all of the key-value pairs contained by <span class="s1">source</span> (which must be a <span class="s1">Dictionary</span> or a subclass of <span class="s1">Dictionary</span>) to the receiver.<span class="Apple-converted-space">  </span>If the target already contains a key that is defined in source, the value from source will be <i>appended</i> to the target’s existing value, which must be of the same type (contrast this with <span class="s1">addKeysAndValuesFrom()</span>); if the target does not already contain a key that is defined in source, that key-value pair will simply be added to the target.</p>
<p class="p4">In the current implementation, it is an error for either of the values involved in an append to be a matrix or array; values in these <span class="s1">Dictionary</span> objects should be simple vectors.<span class="Apple-converted-space">  </span>This limitation preserves the future option to expand this method’s functionality to do smart things with matrices and arrays.</p>
<p class="p3">– (void)clearKeysAndValues(void)</p>
<p class="p4">Removes all key-value pairs from the receiver.</p>
<p class="p3">– (integer)compactIndices([logical$ preserveOrder = F])</p>
<p class="p4">Compacts the receiver, which must use <span class="s1">integer</span> keys.<span class="Apple-converted-space">  </span>After this operation, the receiver will contain only values that have a length greater than zero (discarding all key–value pairs for which the value is a zero-length vector).<span class="Apple-converted-space">  </span>In addition, the keys used will be compacted down to begin at <span class="s1">0</span> and count upward sequentially.<span class="Apple-converted-space">  </span>If <span class="s1">preserveOrder</span> is <span class="s1">F</span> (the default), the keys may end up in a different numerical order; this allows the compaction to be performed more efficiently.<span class="Apple-converted-space">  </span>If <span class="s1">preserveOrder</span> is <span class="s1">T</span>, on the other hand, the numerical order of the keys will be preserved.<span class="Apple-converted-space">  </span>The returned <span class="s1">integer</span> vector contains the original keys that were kept across the compaction operation, in the order in which they were used in the compaction; keys that were not kept (because their value was zero-length) are omitted from this result vector.</p>
<p class="p4">For example, with a dictionary that contains key–value pairs <span class="s1">-5="a"</span>, <span class="s1">17="b"</span>, <span class="s1">37="c"</span>, <span class="s1">53=integer(0)</span>, and <span class="s1">82="d"</span>, <span class="s1">compactIndices(preserveOrder=T)</span> will transform the dictionary to contain <span class="s1">0="a"</span>, <span class="s1">1="b"</span>, <span class="s1">2="c"</span>, and <span class="s1">3="d"</span>, while key <span class="s1">53</span> (and its zero-length value) is dropped; the returned vector will be (<span class="s1">5</span>, <span class="s1">17</span>, <span class="s1">37</span>, <span class="s1">82</span>).<span class="Apple-converted-space">  </span>The result from <span class="s1">compactIndices(preserveOrder=F)</span> has a non-deterministic order, but one possibility for the same example inout is that it would transform the dictionary to contain key–value pairs <span class="s1">0="c"</span>, <span class="s1">1="d"</span>, <span class="s1">2="a"</span>, and <span class="s1">3="b"</span>, with a returned vector of (<span class="s1">37</span>, <span class="s1">82</span>, <span class="s1">5</span>, <span class="s1">17</span>); the same key–value pairs are kept, and they are again placed in sequential keys beginning with <span class="s1">0</span>, but their order is no longer preserved across the compaction.</p>
<p class="p4">This method is particularly useful when you have a <span class="s1">Dictionary</span> <span class="s1">d</span> that contains results from some operation on a vector <span class="s1">x</span>, such that each key <span class="s1">n</span> in <span class="s1">d</span> has a value that is the result of processing the <span class="s1">n</span>’th element of <span class="s1">x</span>.<span class="Apple-converted-space">  </span>In this case, <span class="s1">order=d.compactIndices(preserveOrder=F)</span> will transmogrify <span class="s1">d</span> to contain only the non-zero-length results, in sequential indices counting from <span class="s1">0</span>, and <span class="s1">x[order]</span> provides the elements of <span class="s1">x</span> that produced those results, in the same order as in <span class="s1">d</span> after compaction.<span class="Apple-converted-space">  </span>Using <span class="s1">preserveOrder=T</span> additionally keeps <span class="s1">d</span> in the same order as the original order of <span class="s1">x</span>, for cases in which that ordering is important.</p>
<p class="p3">– (object&lt;Dictionary&gt;$)getRowValues(li index, [logical$ drop = F])</p>
<p class="p4">Returns a new <span class="s1">Dictionary</span> containing values for selected “rows” of the target <span class="s1">Dictionary</span>, allowing <span class="s1">Dictionary</span> to act similarly to a <span class="s1">DataFrame</span>.<span class="Apple-converted-space">  </span>See the <span class="s1">subsetRows()</span> method of class <span class="s1">DataFrame</span> for comparison; the main utility of <span class="s1">getRowValues()</span> is that it can be used on a <span class="s1">Dictionary</span> that has ragged “rows”.<span class="Apple-converted-space">  </span>The selection logic described below works similarly to the subset operator <span class="s1">[]</span> in Eidos, selecting the “rows” of the target <span class="s1">Dictionary</span>.</p>
<p class="p4">The <span class="s1">index</span> parameter may be either <span class="s1">integer</span> or <span class="s1">logical</span>; we will discuss the <span class="s1">integer</span> case first.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a singleton <span class="s1">integer</span>, the returned <span class="s1">Dictionary</span> will contain the <span class="s1">index</span>’th element of the value of each key of the target, under the same keys; this is a single “row” of the target <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>If <span class="s1">index</span> is a non-singleton <span class="s1">integer</span> vector, the returned <span class="s1">Dictionary</span> will contain the values for all of the selected rows, in the order that they are selected by <span class="s1">index</span>.<span class="Apple-converted-space">  </span>If any index value in <span class="s1">index</span> is out of range for any key of the target <span class="s1">Dictionary</span> (such that that key does not have an <span class="s1">index</span>’th value), the returned dictionary will simply not have a value for that “row” of that key.</p>
<p class="p4">If <span class="s1">index</span> is <span class="s1">logical</span>, the <span class="s1">T</span> values in <span class="s1">index</span> select the “rows” which will be included in the returned <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>The values within each column in the returned <span class="s1">Dictionary</span> will be in the same order as in the target.<span class="Apple-converted-space">  </span>The length of <span class="s1">index</span> need not match any column of the <span class="s1">Dictionary</span>; excess “rows” beyond the length of <span class="s1">index</span> will not be selected, and excess values in <span class="s1">index</span> beyond the end of the longest “column” will have no effect.</p>
<p class="p4">If the values of <span class="s1">index</span> are such that <i>no</i> value for a given key is selected, the <span class="s1">drop</span> parameter controls the resulting behavior.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">F</span> (the default), the key will be included in the returned dictionary with a zero-length value of matching type, such as <span class="s1">integer(0)</span> or <span class="s1">string(0)</span>.<span class="Apple-converted-space">  </span>If <span class="s1">drop</span> is <span class="s1">T</span>, the key will be omitted from the returned dictionary.</p>
<p class="p3">– (*)getValue(is$ key)</p>
<p class="p4">Returns the value previously set for the dictionary entry identifier <span class="s1">key</span> using <span class="s1">setValue()</span>, or <span class="s1">NULL</span> if no value has been set.</p>
<p class="p3">– (logical$)identicalContents(object$ x)</p>
<p class="p4">Returns <span class="s1">T</span> if the target <span class="s1">Dictionary</span> is equal to <span class="s1">x</span> in all respects – containing the same keys, with values that are identical in the sense defined by the <span class="s1">identical()</span> function in Eidos – or returns <span class="s1">F</span> otherwise.</p>
<p class="p4">Note that if <span class="s1">Dictionary</span> objects are contained, as values, by the dictionaries being tested for equality, they will be compared according to the standards of <span class="s1">identical()</span>, and must therefore actually be the <i>same</i> <span class="s1">Dictionary</span> object, shared by both dictionaries, for <span class="s1">isEqual()</span> to return <span class="s1">T</span>.</p>
<p class="p3">– (string)serialize([string$ format = "slim"])</p>
<p class="p4">Returns a serialized form of the dictionary’s contents as a <span class="s1">string</span> singleton or vector.<span class="Apple-converted-space">  </span>Four formats are supported at present, as chosen with the <span class="s1">format</span> parameter: <span class="s1">"slim"</span> and <span class="s1">“json"</span> produce a singleton string, whereas <span class="s1">"csv"</span> and <span class="s1">"tsv"</span> produce a <span class="s1">string</span> vector.<span class="Apple-converted-space">  </span>These serializations can be written to disk with <span class="s1">writeFile()</span> or <span class="s1">writeTempFile()</span>, written to the output stream with <span class="s1">cat()</span>, or used in any other way.</p>
<p class="p4">The default <span class="s1">"slim"</span> format is intended for simple, informal use where a very easily parseable string is desired.<span class="Apple-converted-space">  </span>For a simple dictionary containing only keys with singleton non-object values, this will be a semicolon-delimited string like <span class="s1">'"string1"=value1;"string2"=value2;'</span> or <span class="s1">'int1=value1;int2=value2;'</span>.<span class="Apple-converted-space">  </span>Values of type <span class="s1">string</span> will be quoted, and will be escaped with backslash escape sequences, including <span class="s1">\\</span>, <span class="s1">\"</span>, <span class="s1">\'</span>, <span class="s1">\t</span>, <span class="s1">\r</span>, and <span class="s1">\n</span>.<span class="Apple-converted-space">  </span>Values that are not singleton will be separated by spaces, such as <span class="s1">'"string1"=1 2 3;'</span>, while values that are themselves dictionaries will be delimited by braces, such as <span class="s1">'"string1"={int1=value1;int2=value2;};'</span>.<span class="Apple-converted-space">  </span>Keys that are of type <span class="s1">string</span> will be quoted (always; note that this is a change in behavior starting in SLiM 4.1) and backslash-escaped (as needed, as for <span class="s1">string</span> values); keys that are of type <span class="s1">integer</span> are not quoted.<span class="Apple-converted-space">  </span>No facility for parsing <span class="s1">"slim"</span> serializations back into Eidos is presently provided.</p>
<p class="p4">The <span class="s1">"json"</span> format, introduced in Eidos 2.7 (SLiM 3.7), provides serialization of the <span class="s1">Dictionary</span> into the standard JSON format, which may not be quite as brief or human-readable, but which can be used as a standard interchange format and read by the <span class="s1">Dictionary()</span> constructor in Eidos as well as by many other programs.<span class="Apple-converted-space">  </span>For example, a <span class="s1">Dictionary</span> with a key <span class="s1">"key1"</span> with <span class="s1">integer</span> value <span class="s1">1:3</span> and key <span class="s1">"key2"</span> with <span class="s1">string</span> value <span class="s1">"value2"</span> would produce the JSON serialization <span class="s1">'{"key1":[1,2,3],"key2":["value2"]}'</span>, where the outer single quotes are not part of the serialization itself, but are indicating that the serialization is a <span class="s1">string</span> value.<span class="Apple-converted-space">  </span>Note that since all Eidos values are vectors, even singleton values are serialized into JSON as arrays by Eidos; the hope is that this will make automated parsing of these JSON strings easier, since the singleton case will not have to be special-cased.<span class="Apple-converted-space">  </span>For example, <span class="s1">Dictionary("a", 1, "b", Dictionary("x", 2))</span> would be serialized into JSON as <span class="s1">'{"a":[1],"b":[{"x":[2]}]}'</span>.<span class="Apple-converted-space">  </span>Note that dictionaries that use <span class="s1">integer</span> keys cannot be serialized into JSON, because JSON does not support <span class="s1">integer</span> keys.<span class="Apple-converted-space">  </span>Documentation on the JSON format can be found online.</p>
<p class="p4">The <span class="s1">"csv"</span> and <span class="s1">"tsv"</span> formats produce standard comma-separated value (CSV) or tab-separated value (TSV) data.<span class="Apple-converted-space">  </span>These formats are primarily intended for output from <span class="s1">DataFrame</span>, since that class is used to represent the sort of data tables that CSV/TSV are typically used for; but it may be used with <span class="s1">Dictionary</span> too, particularly if it is being used to represent a data table with ragged columns (missing values will just be skipped over, producing two commas or two tabs in sequence).<span class="Apple-converted-space">  </span>Values of type <span class="s1">string</span> will always be quoted, with double quotes (with a repeated double quote used to indicate the presence of a double quote inside a <span class="s1">string</span> value, as usual in CSV); values of other types never will.<span class="Apple-converted-space">  </span>Decimal points (not decimal commas, regardless of system localization) will always be used for <span class="s1">float</span> values, and will never be used for <span class="s1">integer</span> values.<span class="Apple-converted-space">  </span>Values of logical type will be serialized as <span class="s1">TRUE</span> or <span class="s1">FALSE</span>, without quotes.<span class="Apple-converted-space">  </span>A header line providing the names of the columns (i.e., the keys of the target <span class="s1">Dictionary</span>) will always be generated; those column names will also be quoted (if the keys of the dictionary are type <span class="s1">string</span>; <span class="s1">integer</span> keys are not quoted).<span class="Apple-converted-space">  </span>One <span class="s1">string</span> element will be generated for each row of the target, plus one <span class="s1">string</span> element for the header line; newlines will not be present in the resulting <span class="s1">string</span> vector unless newlines were present within the <span class="s1">string</span> values in the <span class="s1">Dictionary</span>.<span class="Apple-converted-space">  </span>The resulting data, if written to a file, should be readable in Eidos using <span class="s1">readCSV()</span> (as long as there are no ragged columns or missing values), as well as in other software such as R and Excel.</p>
<p class="p3">– (void)setValue(is$ key, * value)</p>
<p class="p4">Sets a value for the dictionary entry identifier <span class="s1">key</span>.<span class="Apple-converted-space">  </span>The key may be a <span class="s1">string</span> or an <span class="s1">integer</span>; either is allowed, unless the target dictionary has already begun using keys of a given type, in which case it must continue using the same key type (a given dictionary cannot have both <span class="s1">string</span> and <span class="s1">integer</span> keys).<span class="Apple-converted-space">  </span>The value, which may be of any type, can be fetched later using <span class="s1">getValue()</span>.<span class="Apple-converted-space">  </span>Setting a key to a value of <span class="s1">NULL</span> removes that key from the dictionary.</p>
<p class="p4">If <span class="s1">value</span> is of type <span class="s1">object</span>, any <span class="s1">object</span> class is allowed; all objects may be added as values to a dictionary.<span class="Apple-converted-space">  </span>However, additional scoping restrictions may apply if the <span class="s1">object</span> class is not under an internal memory-management scheme called “retain-release”; in particular, it may not be legal to keep an object in a dictionary “long term” if it is not under retain-release, where “long term” is a scoping semantic defined by the Context.<span class="Apple-converted-space">  </span>All object classes defined by Eidos itself (<span class="s1">Dictionary</span>, <span class="s1">DataFrame</span>, <span class="s1">Image</span>) are under retain-release, so this restriction does not affect pure Eidos code.<span class="Apple-converted-space">  </span>See the SLiM manual (section “SLiM scoping rules”) for further discussion of this topic.</p>
<p class="p1"><b>5.4<span class="Apple-converted-space">  </span>Class Image</b></p>
<p class="p3">(object&lt;Image&gt;$)Image(...)</p>
<p class="p4">Creates a new <span class="s1">Image</span> object.<span class="Apple-converted-space">  </span>This can be called in a few different ways.</p>
<p class="p4">Passed a singleton <span class="s1">string</span>, as <span class="s1">Image(string$ filePath)</span>, it creates a new <span class="s1">Image</span> from the PNG file at <span class="s1">filePath</span>.<span class="Apple-converted-space">  </span>If the file represents a grayscale image, an 8-bit grayscale (K) <span class="s1">Image</span> will be created; all other PNG files will yield a 24-bit color (RGB) <span class="s1">Image</span>.</p>
<p class="p4">Passed an <span class="s1">integer</span> or <span class="s1">float</span> vector, as <span class="s1">Image(numeric matrix)</span>, it creates a new grayscale <span class="s1">Image</span> from the values in <span class="s1">matrix</span>, which must be a matrix as its name suggests.<span class="Apple-converted-space">  </span>If <span class="s1">matrix</span> is <span class="s1">integer</span>, its values must be in [<span class="s1">0</span>, <span class="s1">255</span>], and will be used directly as 8-bit pixel values without translation; if <span class="s1">matrix</span> is <span class="s1">float</span>, its values must be in [<span class="s1">0.0</span>, <span class="s1">1.0</span>], and will be translated into 8-bit pixel values.<span class="Apple-converted-space">  </span>The dimensions of the image, in pixels, will be equal to the dimensions of the matrix.<span class="Apple-converted-space">  </span>The orientation of the image will match that of the matrix, in the sense that the image will appear as the matrix does when printed in the Eidos console; internally this requires a transposition of values, as discussed further below.<span class="Apple-converted-space">  </span>For the <span class="s1">integer</span> case, the <span class="s1">integerK</span> property of the resulting image will recover the original matrix exactly; for the <span class="s1">float</span> case, the <span class="s1">floatK</span> property will only approximately recover the original matrix since the translation into 8-bit pixel values involves quantization, but values of <span class="s1">0.0</span> and <span class="s1">1.0</span> will be recovered exactly.</p>
<p class="p2"><i>5.4.1<span class="Apple-converted-space">  </span></i><span class="s1"><i>Image</i></span><i> properties</i></p>
<p class="p3">width =&gt; (integer$)</p>
<p class="p4">The width of the image, in pixels.</p>
<p class="p3">height =&gt; (integer$)</p>
<p class="p4">The height of the image, in pixels.</p>
<p class="p3">isGrayscale =&gt; (logical$)</p>
<p class="p4">This flag is <span class="s1">T</span> if the image is grayscale, with only a K channel; it is <span class="s1">F</span> if the image is color, with R/G/B channels.</p>
<p class="p3">bitsPerChannel =&gt; (integer$)</p>
<p class="p4">The number of bits used to represent a single pixel, in one channel of the image.<span class="Apple-converted-space">  </span>At present this is always 8; grayscale (K) images are 8-bit, color (RGB) images are 24-bit.<span class="Apple-converted-space">  </span>It could be extended to support 16-bit channels in future.</p>
<p class="p3">integerR =&gt; (integer)</p>
<p class="p4">The red (R) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatR</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">integerG =&gt; (integer)</p>
<p class="p4">The green (G) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatG</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">integerB =&gt; (integer)</p>
<p class="p4">The blue (R) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatB</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">integerK =&gt; (integer)</p>
<p class="p4">The gray (K) channel of the image, represented as a 2D <span class="s1">integer</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,255].<span class="Apple-converted-space">  </span>See the <span class="s1">floatK</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is color, this property is unavailable.</p>
<p class="p3">floatR =&gt; (float)</p>
<p class="p4">The red (R) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerR</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerR</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">floatG =&gt; (float)</p>
<p class="p4">The green (G) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerG</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerG</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">floatB =&gt; (float)</p>
<p class="p4">The blue (B) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerB</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerB</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is grayscale, this property is unavailable.</p>
<p class="p3">floatK =&gt; (float)</p>
<p class="p4">The gray (K) channel of the image, represented as a 2D <span class="s1">float</span> matrix.<span class="Apple-converted-space">  </span>Values will be in [0,1], obtained by dividing the <span class="s1">integerK</span> layer by 255.<span class="Apple-converted-space">  </span>See the <span class="s1">integerK</span> property for an alternative representation.<span class="Apple-converted-space">  </span>If the image is color, this property is unavailable.</p>
<p class="p2"><i>5.4.2<span class="Apple-converted-space">  </span></i><span class="s1"><i>Image</i></span><i> methods</i></p>
<p class="p3">– (void)write(string$ filePath)</p>
<p class="p4">Writes the image to the given filesystem path <span class="s1">filePath</span> as PNG data.<span class="Apple-converted-space">  </span>It is suggested, but not required, that <span class="s1">filePath</span> should end in a <span class="s1">.png</span> or <span class="s1">.PNG</span> filename extension.<span class="Apple-converted-space">  </span>If the file cannot be written, an error will result.<span class="Apple-converted-space">  </span>At present, since <span class="s1">bitsPerChannel</span> is always 8, grayscale data will be written as an 8-bit grayscale PNG while color (RGB) data will be written as a 24-bit color PNG without alpha.</p>
</body>
</html>
