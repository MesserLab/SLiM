<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p1 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px Optima}
    p.p3 {margin: 9.0px 0.0px 9.0px 0.0px; text-indent: 27.4px; font: 9.0px Menlo}
    p.p4 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px Optima; color: #000000}
    p.p5 {margin: 9.0px 0.0px 9.0px 27.4px; font: 9.0px Menlo; color: #000000}
    p.p6 {margin: 2.0px 0.0px 2.0px 70.5px; text-indent: -43.2px; font: 11.0px Optima; color: #000000}
    p.p7 {margin: 9.0px 0.0px 9.0px 0.0px; text-indent: 27.4px; font: 11.0px Optima; color: #000000}
    p.p8 {margin: 9.0px 0.0px 9.0px 0.0px; text-indent: 27.4px; font: 9.0px Menlo; color: #000000}
    p.p9 {margin: 2.0px 0.0px 2.0px 144.0px; text-indent: -116.7px; font: 11.0px Optima; color: #000000}
    p.p10 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px Optima; color: #000000; min-height: 13.0px}
    span.s1 {font: 9.0px Menlo}
    span.s2 {font-kerning: none}
    span.s3 {font: 9.0px Menlo; font-kerning: none}
    span.s4 {font-kerning: none; color: #1c00cf}
    span.s5 {font-kerning: none; color: #3f6e74}
    span.s6 {font-kerning: none; color: #1400c4}
    span.s7 {font-kerning: none; color: #b50013}
    span.s8 {font: 7.3px Optima; font-kerning: none}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><i>5.13.0<span class="Apple-converted-space">  </span>ITEM: 1. </i><span class="s1"><i>initialize()</i></span><i> callbacks</i></p>
<p class="p2">Before a SLiM simulation can be run, the various classes underlying the simulation need to be set up with an initial configuration.<span class="Apple-converted-space">  </span>In SLiM 1.8 and earlier, this was done by means of <span class="s1">#</span> directives in the simulation’s input file.<span class="Apple-converted-space">  </span>In SLiM 2.0, simulation parameters are instead configured using Eidos.</p>
<p class="p2">Configuration in Eidos is done in <span class="s1"><i>initialize()</i></span><i> callbacks</i> that run prior to the beginning of simulation execution.<span class="Apple-converted-space">  </span>In your input file, you can simply write something like this:</p>
<p class="p3"><span class="Apple-converted-space">   </span>initialize() { ... }</p>
<p class="p2">The <span class="s1">initialize()</span> specifies that the script block is to be executed as an <span class="s1">initialize()</span> callback before the simulation starts.<span class="Apple-converted-space">  </span>The script between the braces <span class="s1">{}</span> would set up various aspects of the simulation by calling <i>initialization functions</i>.<span class="Apple-converted-space">  </span>These are SLiM functions that may be called only in an <span class="s1">initialize()</span> callback, and their names begin with <span class="s1">initialize</span> to mark them clearly as such.<span class="Apple-converted-space">  </span>You may also use other Eidos functionality, of course; for example, you might automate generating a large number of subpopulations with complex migration patterns by using a <span class="s1">for</span> loop.</p>
<p class="p2">One thing worth mentioning is that in the context of an <span class="s1">initialize()</span> callback, none of SLiM’s globals are defined – not even the <span class="s1">sim</span> global for the simulation itself.<span class="Apple-converted-space">  </span>This is because the state of the simulation is not yet constructed fully, and accessing partially constructed state would not be safe.<span class="Apple-converted-space">  </span>New subpopulations, new genomic element types, etc., that you define in your callback by calling initialization functions will also not be available through globals during your callback; those globals will become visible once simulation execution begins.</p>
<p class="p2">Once all <span class="s1">initialize()</span> callbacks have executed, in the order in which they are specified in the SLiM input file, the simulation will begin.<span class="Apple-converted-space">  </span>The generation number at which it starts is determined by the Eidos events you have defined; the first generation in which an Eidos event is scheduled to execute is the generation at which the simulation starts.<span class="Apple-converted-space">  </span>Similarly, the simulation will terminate after the last generation for which a script block (either an event or a callback) is registered to execute, unless the <span class="s1">stop()</span> function is called to end the simulation earlier.</p>
<p class="p1"><i>5.13.1<span class="Apple-converted-space">  </span>ITEM: 2. Eidos events</i></p>
<p class="p4"><span class="s2">An Eidos event is a block of Eidos code that is executed every generation, within a generation range, to perform a desired task.<span class="Apple-converted-space">  </span>The syntax of an Eidos event declaration looks like one of these:</span></p>
<p class="p5"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] { ... }<br>
<span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] early() { ... }<br>
<span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] late() { ... }</span></p>
<p class="p4"><span class="s2">The first two declarations are exactly equivalent, and declare an </span><span class="s3">early()</span><span class="s2"> event that executes relatively early in the generation cycle; the </span><span class="s3">early()</span><span class="s2"> designation is optional.<span class="Apple-converted-space">  </span>The third declaration declares a </span><span class="s3">late()</span><span class="s2"> event that executes near the end of the generation cycle.<span class="Apple-converted-space">  </span>Exactly when these events run depends upon whether the model is a WF model or a nonWF model.</span></p>
<p class="p4"><span class="s2">The </span><span class="s3">id</span><span class="s2"> is an optional identifier like </span><span class="s3">s1</span><span class="s2"> (or more generally, </span><span class="s3">sX</span><span class="s2">, where </span><span class="s3">X</span><span class="s2"> is an integer greater than or equal to </span><span class="s3">0</span><span class="s2">) that defines an identifier that can be used to refer to the script block.<span class="Apple-converted-space">  </span>In most situations it can be omitted, in which case the id is implicitly defined as </span><span class="s3">-1</span><span class="s2">, a placeholder value that essentially represents the lack of an identifier value.<span class="Apple-converted-space">  </span>Supplying an </span><span class="s3">id</span><span class="s2"> is only useful if you wish to manipulate your script blocks programmatically.</span></p>
<p class="p4"><span class="s2">Then comes a generation or a range of generations, and then a block of Eidos code enclosed in braces to form a compound statement.<span class="Apple-converted-space">  </span>A trivial example might look like this:</span></p>
<p class="p5"><span class="s4"><span class="Apple-converted-space">   </span>1000</span><span class="s2">:</span><span class="s4">5000</span><span class="s2"> {<br>
<span class="Apple-converted-space">      </span>catn(</span><span class="s5">sim</span><span class="s2">.generation);<br>
<span class="Apple-converted-space">   </span>}</span></p>
<p class="p4"><span class="s2">This would print the generation number in every generation in the specified range, which is obviously not very exciting.<span class="Apple-converted-space">  </span>The broader point is that the Eidos code in the braces </span><span class="s3">{}</span><span class="s2"> is executed early in every generation within the specified range of generations.<span class="Apple-converted-space">  </span>In this case, the generation range is </span><span class="s3">1000</span><span class="s2"> to </span><span class="s3">5000</span><span class="s2">, and so the Eidos event will be executed 4001 times.<span class="Apple-converted-space">  </span>A range of generations can be given, as in the example above, or a single generation can be given with a single integer:</span></p>
<p class="p5"><span class="s6"><span class="Apple-converted-space">   </span>100</span><span class="s2"> late() {<br>
<span class="Apple-converted-space">      </span>print(</span><span class="s7">"Finished generation 100!"</span><span class="s2">);<br>
<span class="Apple-converted-space">   </span>}</span></p>
<p class="p4"><span class="s2">In fact, you can omit specifying a generation altogether, in which case the Eidos event runs every generation.<span class="Apple-converted-space">  </span>Since it takes a little time to set up the Eidos interpreter and interpret a script, it is advisable to use the narrowest range of generations possible; however, that is more of a concern with the callbacks we will look at later in this chapter, since they might be called many time in every generation, whereas </span><span class="s3">early()</span><span class="s2"> and </span><span class="s3">late()</span><span class="s2"> events will just be called once per generation.</span></p>
<p class="p4"><span class="s2">The generations specified for a Eidos event block can be any positive integer.<span class="Apple-converted-space">  </span>All scripts that apply to a given time point will be run in the order in which they are given; scripts specified higher in the input file will run before those specified lower.<span class="Apple-converted-space">  </span>Sometimes it is desirable to have a script block execute in a generation which is not fixed, but instead depends upon some parameter, defined constant, or calculation; this may be achieved by rescheduling the script block with the </span><span class="s3">SLiMSim</span><span class="s2"> method </span><span class="s3">rescheduleScriptBlock()</span><span class="s2">.</span></p>
<p class="p4"><span class="s2">When Eidos events are executed, several global variables are defined by SLiM for use by the Eidos code.<span class="Apple-converted-space">  </span>Here is a summary of those SLiM globals:</span></p>
<p class="p6"><span class="s3"><span class="Apple-converted-space">   </span>sim</span><span class="s2"><span class="Apple-tab-span">	</span>A </span><span class="s3">SLiMSim</span><span class="s2"> object representing the current SLiM simulation</span></p>
<p class="p6"><span class="s3"><span class="Apple-converted-space">   </span>g1, ...</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">GenomicElementType</span><span class="s2"> objects representing the genomic element types defined</span></p>
<p class="p6"><span class="s3"><span class="Apple-converted-space">   </span>i1, ...</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">InteractionType</span><span class="s2"> objects representing the interaction types defined</span></p>
<p class="p6"><span class="s3"><span class="Apple-converted-space">   </span>m1, ...</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">MutationType</span><span class="s2"> objects representing the mutation types defined</span></p>
<p class="p6"><span class="s3"><span class="Apple-converted-space">   </span>p1, ...</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">Subpopulation</span><span class="s2"> objects representing the subpopulations that exist</span></p>
<p class="p6"><span class="s3"><span class="Apple-converted-space">   </span>s1, ...</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">SLiMEidosBlock</span><span class="s2"> objects representing the named events and callbacks defined</span></p>
<p class="p6"><span class="s3"><span class="Apple-converted-space">   </span>self</span><span class="s2"><span class="Apple-tab-span">	</span>A </span><span class="s3">SLiMEidosBlock</span><span class="s2"> object representing the script block currently executing</span></p>
<p class="p4"><span class="s2">Note that the </span><span class="s3">sim</span><span class="s2"> global is <i>not</i> available in </span><span class="s3">initialize()</span><span class="s2"> callbacks, since the simulation has not yet been initialized.<span class="Apple-converted-space">  </span>Similarly, the globals for subpopulations, mutation types, and genomic element types are only available after the point at which those objects have been defined by an </span><span class="s3">initialize()</span><span class="s2"> callback.</span></p>
<p class="p1"><i>5.13.2<span class="Apple-converted-space">  </span>ITEM: 3. </i><span class="s1"><i>fitness()</i></span><i> callbacks</i></p>
<p class="p4"><span class="s2">A </span><span class="s3">fitness()</span><span class="s2"> callback is called by SLiM when it is determining the fitness effect of a mutation carried by an individual.<span class="Apple-converted-space">  </span>Normally, the fitness effect of a mutation is determined by the selection coefficient <i>s</i> of the mutation and the dominance coefficient <i>h</i> of the mutation (the latter used only if the individual is heterozygous for the mutation).<span class="Apple-converted-space">  </span>More specifically, the standard calculation for the fitness effect of a mutation takes one of two forms.<span class="Apple-converted-space">  </span>If the individual is homozygous, then the fitness effect is (1+<i>s</i>), or:</span></p>
<p class="p7"><span class="s2"><i><span class="Apple-converted-space">   </span>w</i> = <i>w</i> * (1.0 + selectionCoefficient),</span></p>
<p class="p4"><span class="s2">where <i>w</i> is the relative fitness of the individual carrying the mutation.<span class="Apple-converted-space">  </span>This equation is also used if the chromosome being simulated has no homologue – when the Y sex chromosome is being simulated.<span class="Apple-converted-space">  </span>If the individual is heterozygous, then the dominance coefficient enters the picture, and the fitness effect is (1+<i>hs</i>) or:</span></p>
<p class="p7"><span class="s2"><i><span class="Apple-converted-space">   </span>w</i> = <i>w</i> * (1.0 + dominanceCoeff * selectionCoeff).</span></p>
<p class="p4"><span class="s2">For simulations of autosomes, the dominance coefficient is defined by the mutation type; for simulations of X sex chromosomes, the mutation type’s dominance coefficient is used for XX females that are heterozygous, whereas XY males that are “heterozygous” for the mutation because they possess only one X chromosome use a global dominance coefficient (see </span><span class="s3">initializeSex()</span><span class="s2"> and the </span><span class="s3">dominanceCoeffX</span><span class="s2"> property of </span><span class="s3">SLiMSim</span><span class="s2">).</span></p>
<p class="p4"><span class="s2">That is the standard behavior of SLiM, reviewed here to provide a conceptual baseline.<span class="Apple-converted-space">  </span>Supplying a </span><span class="s3">fitness()</span><span class="s2"> callback allows you to substitute any calculation you wish for the relative fitness effect of a mutation; the new relative fitness effect computation becomes:</span></p>
<p class="p7"><span class="s2"><i><span class="Apple-converted-space">   </span>w</i> = <i>w</i> * </span><span class="s3">fitness()</span></p>
<p class="p4"><span class="s2">where </span><span class="s3">fitness()</span><span class="s2"> is the value returned by your callback.<span class="Apple-converted-space">  </span>This value is a multiplicative fitness effect, so </span><span class="s3">1.0</span><span class="s2"> is neutral, unlike the selection coefficient scale where </span><span class="s3">0.0</span><span class="s2"> is neutral; be careful with this distinction!</span></p>
<p class="p4"><span class="s2">Like Eidos events, </span><span class="s3">fitness()</span><span class="s2"> callbacks are defined as script blocks in the input file, but they use a variation of the syntax for defining an Eidos event:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] fitness(&lt;mut-type-id&gt; [, &lt;subpop-id&gt;]) { ... }</span></p>
<p class="p4"><span class="s2">For example, if the callback were defined as:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>1000:2000 fitness(m2, p3) { 1.0; }</span></p>
<p class="p4"><span class="s2">then a relative fitness of </span><span class="s3">1.0</span><span class="s2"> (i.e. neutral) would be used for all mutations of mutation type </span><span class="s3">m2</span><span class="s2"> in subpopulation </span><span class="s3">p3</span><span class="s2"> from generation </span><span class="s3">1000</span><span class="s2"> to generation </span><span class="s3">2000</span><span class="s2">.<span class="Apple-converted-space">  </span>The very same mutations, if also present in individuals in other subpopulations, would preserve their normal selection coefficient and dominance coefficient in those other subpopulations; this callback would therefore establish spatial heterogeneity in selection, in which mutation type </span><span class="s3">m2</span><span class="s2"> was neutral in subpopulation </span><span class="s3">p3</span><span class="s2"> but under selection in other subpopulations, for the range of generations given.</span></p>
<p class="p4"><span class="s2">In addition to standard SLiM globals, a </span><span class="s3">fitness()</span><span class="s2"> callback is supplied with some additional information passed through “pseudo-parameters”, variables that are defined by SLiM within the context of the callback’s code to supply the callback with relevant information:</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>mut</span><span class="s2"><span class="Apple-tab-span">	</span>A </span><span class="s3">Mutation</span><span class="s2"> object, the mutation whose relative fitness is being evaluated</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>homozygous</span><span class="s2"><span class="Apple-tab-span">	</span>A value of </span><span class="s3">T</span><span class="s2"> (the mutation is homozygous), </span><span class="s3">F</span><span class="s2"> (heterozygous), or </span><span class="s3">NULL</span><span class="s2"> (it is<br>
paired with a null chromosome, which can occur with sex chromosomes)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>relFitness</span><span class="s2"><span class="Apple-tab-span">	</span>The default relative fitness value calculated by SLiM</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>individual</span><span class="s2"><span class="Apple-tab-span">	</span>The individual carrying this mutation (an object of class </span><span class="s3">Individual</span><span class="s2">)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome1</span><span class="s2"><span class="Apple-tab-span">	</span>One genome of the individual carrying this mutation</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome2</span><span class="s2"><span class="Apple-tab-span">	</span>The other genome of that individual</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>subpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation in which that individual lives</span></p>
<p class="p4"><span class="s2">These may be used in the </span><span class="s3">fitness()</span><span class="s2"> callback to compute a fitness value.<span class="Apple-converted-space">  </span>To implement the standard fitness functions used by SLiM for an autosomal simulation, for example, you could do something like this:</span></p>
<p class="p5"><span class="s2"><span class="Apple-converted-space">   </span>fitness(m1) {<br>
<span class="Apple-converted-space">      </span>if (homozygous)<br>
<span class="Apple-converted-space">         </span>return 1.0 + mut.selectionCoeff;<br>
<span class="Apple-converted-space">      </span>else<br>
<span class="Apple-converted-space">         </span>return 1.0 + mut.mutationType.dominanceCoeff * mut.selectionCoeff;<br>
<span class="Apple-converted-space">   </span>}</span></p>
<p class="p4"><span class="s2">As mentioned above, a relative fitness of </span><span class="s3">1.0</span><span class="s2"> is neutral (whereas a selection coefficient of </span><span class="s3">0.0</span><span class="s2"> is neutral); the </span><span class="s3">1.0 +</span><span class="s2"> in these calculations converts between the selection coefficient scale and the relative fitness scale, and is therefore essential.<span class="Apple-converted-space">  </span>However, the </span><span class="s3">relFitness</span><span class="s2"> global variable mentioned above would already contain this value, precomputed by SLiM, so you could simply return </span><span class="s3">relFitness</span><span class="s2"> to get that behavior when you want it:</span></p>
<p class="p5"><span class="s2"><span class="Apple-converted-space">   </span>fitness(m1) {<br>
<span class="Apple-converted-space">      </span>if (&lt;conditions&gt;)<br>
<span class="Apple-converted-space">         </span>&lt;custom fitness calculations...&gt;;<br>
<span class="Apple-converted-space">      </span>else<br>
<span class="Apple-converted-space">         </span>return relFitness;<br>
<span class="Apple-converted-space">   </span>}</span></p>
<p class="p4"><span class="s2">This would return a modified fitness value in certain conditions, but would return the standard fitness value otherwise.</span></p>
<p class="p4"><span class="s2">More than one </span><span class="s3">fitness()</span><span class="s2"> callback may be defined to operate in the same generation.<span class="Apple-converted-space">  </span>As with Eidos events, multiple callbacks will be called in the order in which they were defined in the input file.<span class="Apple-converted-space">  </span>Furthermore, each callback will be given the </span><span class="s3">relFitness</span><span class="s2"> value returned by the previous callback – so the value of </span><span class="s3">relFitness</span><span class="s2"> is not necessarily the default value, in fact, but is the result of all previous </span><span class="s3">fitness()</span><span class="s2"> callbacks for that individual in that generation.<span class="Apple-converted-space">  </span>In this way, the effects of multiple callbacks can “stack”.</span></p>
<p class="p4"><span class="s2">In SLiM version 2.3 and later, it is possible to define <i>global</i> </span><span class="s3">fitness()</span><span class="s2"> callbacks, which are applied exactly once to every individual (within a given subpopulation, if the </span><span class="s3">fitness()</span><span class="s2"> callback is declared to be limited to one subpopulation, as usual).<span class="Apple-converted-space">  </span>Global </span><span class="s3">fitness()</span><span class="s2"> callbacks do not reference a particular mutation type, and are not called in reference to any specific mutation in the individual; instead, they provide an opportunity for the model script to define fitness effects that are independent of specific mutations (although their fitness effects may still depend upon some aggregate genetic state).<span class="Apple-converted-space">  </span>For example, they are useful for defining the fitness effect of an individual’s overall phenotype (perhaps determined by multiple loci, and perhaps by developmental noise, phenotypic plasticity, etc.), or for defining the fitness effects of behavioral interactions between individuals such as competition or altruism.<span class="Apple-converted-space">  </span>A global </span><span class="s3">fitness()</span><span class="s2"> callback is defined by giving </span><span class="s3">NULL</span><span class="s2"> as the mutation type identifier in the callback’s declaration.<span class="Apple-converted-space">  </span>These callbacks will generally be called once per individual in each generation, in an order that is formally undefined.<span class="Apple-converted-space">  </span>When a global </span><span class="s3">fitness()</span><span class="s2"> callback is running, the </span><span class="s3">mut</span><span class="s2"> and </span><span class="s3">homozygous</span><span class="s2"> variables are defined to be </span><span class="s3">NULL</span><span class="s2"> (since there is no focal mutation), and </span><span class="s3">relFitness</span><span class="s2"> is defined to be </span><span class="s3">1.0</span><span class="s2">.<span class="Apple-converted-space">  </span>The fitness effect for the callback is simply returned as a singleton </span><span class="s3">float</span><span class="s2"> value, as usual.</span></p>
<p class="p4"><span class="s2">Beginning in SLiM 3.0, it is also possible to set the </span><span class="s3">fitnessScaling</span><span class="s2"> property on a subpopulation to scale the fitness values of every individual in the subpopulation by the same constant amount, or to set the </span><span class="s3">fitnessScaling</span><span class="s2"> property on an individual to scale the fitness value of that specific individual.<span class="Apple-converted-space">  </span>These scaling factors are multiplied together with all other fitness effects for an individual to produce the individual’s final fitness value.<span class="Apple-converted-space">  </span>The </span><span class="s3">fitnessScaling</span><span class="s2"> properties of </span><span class="s3">Subpopulation</span><span class="s2"> and </span><span class="s3">Individual</span><span class="s2"> can often provide similar functionality to </span><span class="s3">fitness(NULL)</span><span class="s2"> callbacks with greater efficiency and simplicity.<span class="Apple-converted-space">  </span>They are reset to </span><span class="s3">1.0</span><span class="s2"> in every generation, immediately after fitness values are calculated, so they only need to be set when a value other than </span><span class="s3">1.0</span><span class="s2"> is desired.</span></p>
<p class="p4"><span class="s2">One caveat to be aware of in WF models is that </span><span class="s3">fitness()</span><span class="s2"> callbacks are called at the end of each generation, just before the next generation begins.<span class="Apple-converted-space">  </span>If you have a </span><span class="s3">fitness()</span><span class="s2"> callback defined for generation </span><span class="s3">10</span><span class="s2">, for example, it will actually be called at the very end of generation </span><span class="s3">10</span><span class="s2">, after child generation has finished, after the new children have been promoted to be the next parental generation, and after </span><span class="s3">late()</span><span class="s2"> events have been executed.<span class="Apple-converted-space">  </span>The fitness values calculated will thus be used during generation </span><span class="s3">11</span><span class="s2">; the fitness values used in generation </span><span class="s3">10</span><span class="s2"> were calculated at the end of generation </span><span class="s3">9</span><span class="s2">.<span class="Apple-converted-space">  </span>(This is primarily so that SLiMgui, which refreshes its display in between generations, has computed fitness values at hand that it can use to display the new parental individuals in the proper colors.)<span class="Apple-converted-space">  </span>This is not an issue in nonWF models, since fitness values are used in the same generation in which they are calculated.</span></p>
<p class="p4"><span class="s2">Many other possibilities can be implemented with a </span><span class="s3">fitness()</span><span class="s2"> callback, and/or with the </span><span class="s3">fitnessScaling</span><span class="s2"> properties of </span><span class="s3">Subpopulation</span><span class="s2"> and </span><span class="s3">Individual</span><span class="s2">.<span class="Apple-converted-space">  </span>However, since </span><span class="s3">fitness()</span><span class="s2"> callbacks involve Eidos code being executed for the evaluation of fitness of every mutation of every individual (within the generation range, mutation type, and subpopulation specified), they can slow down a simulation considerably, so use them as sparingly as possible.</span></p>
<p class="p1"><i>5.13.3<span class="Apple-converted-space">  </span>ITEM: 4. </i><span class="s1"><i>mateChoice()</i></span><i> callbacks</i></p>
<p class="p4"><span class="s2">Normally, WF models in SLiM regulate mate choice according to fitness; individuals of higher fitness are more likely to be chosen as mates.<span class="Apple-converted-space">  </span>However, one might wish to simulate more complex mate-choice dynamics such as assortative or disassortative mating, mate search algorithms, and so forth.<span class="Apple-converted-space">  </span>Such dynamics can be handled in WF models with the </span><span class="s3">mateChoice()</span><span class="s2"> callback mechanism.<span class="Apple-converted-space">  </span>(In nonWF models mating is arranged by the script, so there is no need for a callback).</span></p>
<p class="p4"><span class="s2">A </span><span class="s3">mateChoice()</span><span class="s2"> callback is established in the input file with a syntax very similar to that of </span><span class="s3">fitness()</span><span class="s2"> callbacks:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] mateChoice([&lt;subpop-id&gt;]) { ... }</span></p>
<p class="p4"><span class="s2">The only difference between the two declarations is that the </span><span class="s3">mateChoice()</span><span class="s2"> callback does not allow you to specify a mutation type to which the callback applies, since that makes no sense.</span></p>
<p class="p4"><span class="s2">Note that if a subpopulation is given to which the </span><span class="s3">mateChoice()</span><span class="s2"> callback is to apply, the callback is used for all matings that will generate a <i>child</i> in the stated subpopulation (as opposed to all matings of <i>parents</i> in the stated subpopulation); this distinction is important when migration causes children in one subpopulation to be generated by matings of parents in a different subpopulation.</span></p>
<p class="p4"><span class="s2">When a </span><span class="s3">mateChoice()</span><span class="s2"> callback is defined, the first parent in a mating is still chosen proportionally according to fitness (if you wish to influence that choice, you can use a </span><span class="s3">fitness()</span><span class="s2"> callback).<span class="Apple-converted-space">  </span>In a sexual (rather than hermaphroditic) simulation, this will be the female parent; SLiM does not currently support males as the choosy sex.<span class="Apple-converted-space">  </span>The second parent – the male parent, in a sexual simulation – will then be chosen based upon the results of the </span><span class="s3">mateChoice()</span><span class="s2"> callback.</span></p>
<p class="p4"><span class="s2">More specifically, the callback must return a vector of weights, one for each individual in the subpopulation; SLiM will then choose a parent with probability proportional to weight.<span class="Apple-converted-space">  </span>The </span><span class="s3">mateChoice()</span><span class="s2"> callback could therefore modify or replace the standard fitness-based weights depending upon some other criterion such as assortativeness.<span class="Apple-converted-space">  </span>A singleton object of type </span><span class="s3">Individual</span><span class="s2"> may be returned instead of a weights vector to indicate that that specific individual has been chosen as the mate (beginning in SLiM 2.3); this could also be achieved by returned a vector of weights in which the chosen mate has a non-zero weight and all other weights are zero, but returning the chosen individual directly is much more efficient.<span class="Apple-converted-space">  </span>A zero-length return vector – as generated by </span><span class="s3">float(0)</span><span class="s2">, for example – indicates that a suitable mate was not found; in that event, a new first parent will be drawn from the subpopulation.<span class="Apple-converted-space">  </span>Finally, if the callback returns </span><span class="s3">NULL</span><span class="s2">, that signifies that SLiM should use the standard fitness-based weights to choose a mate; the </span><span class="s3">mateChoice()</span><span class="s2"> callback did not wish to alter the standard behavior for the current mating (this is equivalent to returning the unmodified vector of weights, but returning </span><span class="s3">NULL</span><span class="s2"> is much faster since it allows SLiM to drop into an optimized case).<span class="Apple-converted-space">  </span>Apart from the special cases described above – a singleton </span><span class="s3">Individual</span><span class="s2">, </span><span class="s3">float(0)</span><span class="s2">, and </span><span class="s3">NULL</span><span class="s2"> – the returned vector of weights must contain the same number of values as the size of the subpopulation, and all weights must be non-negative.<span class="Apple-converted-space">  </span>Note that the vector of weights is not required to sum to </span><span class="s3">1</span><span class="s2">, however; SLiM will convert relative weights on any scale to probabilities for you.</span></p>
<p class="p4"><span class="s2">If the sum of the returned weights vector is zero, SLiM treats it as meaning the same thing as a return of </span><span class="s3">float(0)</span><span class="s2"> – a suitable mate could not be found, and a new first parent will thus be drawn.<span class="Apple-converted-space">  </span>(This is a change in policy beginning in SLiM 2.3; prior to that, returning a vector of sum zero was considered a runtime error.)<span class="Apple-converted-space">  </span>There is a subtle difference in semantics between this and a return of </span><span class="s3">float(0)</span><span class="s2">: returning </span><span class="s3">float(0)</span><span class="s2"> immediately short-circuits mate choice for the current first parent, whereas returning a vector of zeros allows further applicable </span><span class="s3">mateChoice()</span><span class="s2"> callbacks to be called, one of which might “rescue” the first parent by returning a non-zero weights vector or an individual.<span class="Apple-converted-space">  </span>In most models this distinction is irrelevant, since chaining </span><span class="s3">mateChoice()</span><span class="s2"> callbacks is uncommon.<span class="Apple-converted-space">  </span>When the choice is otherwise unimportant, returning </span><span class="s3">float(0)</span><span class="s2"> will be handled more quickly by SLiM.</span></p>
<p class="p4"><span class="s2">In addition to the standard SLiM globals, a </span><span class="s3">mateChoice()</span><span class="s2"> callback is supplied with some additional information passed through “pseudo-parameters”:</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>individual</span><span class="s2"><span class="Apple-tab-span">	</span>The parent already chosen (the female, in sexual simulations)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome1</span><span class="s2"><span class="Apple-tab-span">	</span>One genome of the parent already chosen</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome2</span><span class="s2"><span class="Apple-tab-span">	</span>The other genome of the parent already chosen</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>subpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation into which the offspring will be placed</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>sourceSubpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation from which the parents are being chosen</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>weights</span><span class="s2"><span class="Apple-tab-span">	</span>The standard fitness-based weights for all individuals</span></p>
<p class="p4"><span class="s2">If sex is enabled, the </span><span class="s3">mateChoice()</span><span class="s2"> callback must ensure that the appropriate weights are zero and nonzero to guarantee that all eligible mates are male (since the first parent chosen is always female, as explained above).<span class="Apple-converted-space">  </span>In other words, weights for females must be </span><span class="s3">0</span><span class="s2">.<span class="Apple-converted-space">  </span>The </span><span class="s3">weights</span><span class="s2"> vector given to the callback is guaranteed to satisfy this constraint.<span class="Apple-converted-space">  </span>If sex is not enabled – in a hermaphroditic simulation, in other words – this constraint does not apply.</span></p>
<p class="p4"><span class="s2">For example, a simple </span><span class="s3">mateChoice()</span><span class="s2"> callback might look like this:</span></p>
<p class="p5"><span class="s2"><span class="Apple-converted-space">   </span>1000:2000 mateChoice(p2) {<br>
<span class="Apple-converted-space">      </span>return weights ^ 2;<br>
<span class="Apple-converted-space">   </span>}</span></p>
<p class="p4"><span class="s2">This defines a </span><span class="s3">mateChoice()</span><span class="s2"> callback for generations </span><span class="s3">1000</span><span class="s2"> to </span><span class="s3">2000</span><span class="s2"> for subpopulation </span><span class="s3">p2</span><span class="s2">.<span class="Apple-converted-space">  </span>The callback simply transforms the standard fitness-based probabilities by squaring them.<span class="Apple-converted-space">  </span>Code like this could represent a situation in which fitness and mate choice proceed normally in one subpopulation (</span><span class="s3">p1</span><span class="s2">, here, presumably), but are altered by the effects of a social dominance hierarchy or male-male competition in another subpopulation (</span><span class="s3">p2</span><span class="s2">, here), such that the highest-fitness individuals tend to be chosen as mates more often than their (perhaps survival-based) fitness values would otherwise suggest.<span class="Apple-converted-space">  </span>Note that by basing the returned weights on the </span><span class="s3">weights</span><span class="s2"> vector supplied by SLiM, the requirement that females be given weights of </span><span class="s3">0</span><span class="s2"> is finessed; in other situations, care would need to be taken to ensure that.</span></p>
<p class="p4"><span class="s2">More than one </span><span class="s3">mateChoice()</span><span class="s2"> callback may be defined to operate in the same generation.<span class="Apple-converted-space">  </span>As with Eidos events, multiple callbacks will be called in the order in which they were defined.<span class="Apple-converted-space">  </span>Furthermore, each callback will be given the </span><span class="s3">weights</span><span class="s2"> vector returned by the previous callback – so the value of </span><span class="s3">weights</span><span class="s2"> is not necessarily the default fitness-based weights, in fact, but is the result of all previous </span><span class="s3">weights()</span><span class="s2"> callbacks for the current mate-choice event.<span class="Apple-converted-space">  </span>In this way, the effects of multiple callbacks can “stack”.<span class="Apple-converted-space">  </span>If any </span><span class="s3">mateChoice()</span><span class="s2"> callback returns </span><span class="s3">float(0)</span><span class="s2">, however – indicating that no eligible mates exist, as described above – then the remainder of the callback chain will be short-circuited and a new first parent will immediately be chosen.</span></p>
<p class="p4"><span class="s2">Note that matings in SLiM do not proceed in random order.<span class="Apple-converted-space">  </span>Offspring are generated for each subpopulation in turn, and within each subpopulation the order of offspring generation is also non-random with respect to both the source subpopulation and the sex of the offspring.<span class="Apple-converted-space">  </span>It is important, therefore, that </span><span class="s3">mateChoice()</span><span class="s2"> callbacks are not in any way biased by the offspring generation order; they should not treat matings early in the process any differently than matings late in the process.<span class="Apple-converted-space">  </span>Any failure to guarantee such invariance could lead to large biases in the simulation outcome.<span class="Apple-converted-space">  </span>In particular, it is usually dangerous to activate or deactivate </span><span class="s3">mateChoice()</span><span class="s2"> callbacks while offspring generation is in progress.</span></p>
<p class="p4"><span class="s2">A wide variety of mate choice algorithms can easily be implemented with </span><span class="s3">mateChoice()</span><span class="s2"> callbacks.<span class="Apple-converted-space">  </span>However, </span><span class="s3">mateChoice()</span><span class="s2"> callbacks can be particularly slow since they are called for every proposed mating, and the vector of mating weights can be large and slow to process.</span></p>
<p class="p1"><i>5.13.4<span class="Apple-converted-space">  </span>ITEM: 5. </i><span class="s1"><i>modifyChild()</i></span><i> callbacks</i></p>
<p class="p4"><span class="s2">Normally, a SLiM simulation defines child generation with its rules regarding selfing versus crossing, recombination, mutation, and so forth.<span class="Apple-converted-space">  </span>However, one might wish to modify these rules in particular circumstances – by preventing particular children from being generated, by modifying the generated children in particular ways, or by generating children oneself.<span class="Apple-converted-space">  </span>All of these dynamics can be handled in SLiM with the </span><span class="s3">modifyChild()</span><span class="s2"> callback mechanism.</span></p>
<p class="p4"><span class="s2">A </span><span class="s3">modifyChild()</span><span class="s2"> callback is established in the input file with a syntax very similar to that of other callbacks:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] modifyChild([&lt;subpop-id&gt;]) { ... }</span></p>
<p class="p4"><span class="s2">The </span><span class="s3">modifyChild()</span><span class="s2"> callback may optionally be restricted to the children generated to occupy a specified subpopulation.</span></p>
<p class="p4"><span class="s2">When a </span><span class="s3">modifyChild()</span><span class="s2"> callback is called, a parent or parents have already been chosen, and a candidate child has already been generated.<span class="Apple-converted-space">  </span>The parent or parents, and their genomes, are provided to the callback, as is the generated child and its genomes.<span class="Apple-converted-space">  </span>The callback may accept the generated child, modify it, substitute completely different genomic information for it, or reject it (causing a new parent or parents to be selected and a new child to be generated, which will again be passed to the callback).</span></p>
<p class="p4"><span class="s2">In addition to the standard SLiM globals, a </span><span class="s3">modifyChild()</span><span class="s2"> callback is supplied with additional information passed through “pseudo-parameters”:</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>child</span><span class="s2"><span class="Apple-tab-span">	</span>The generated child (an object of class </span><span class="s3">Individual</span><span class="s2">)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>childGenome1</span><span class="s2"><span class="Apple-tab-span">	</span>One genome of the generated child</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>childGenome2</span><span class="s2"><span class="Apple-tab-span">	</span>The other genome of the generated child</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>childIsFemale</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">T</span><span class="s2"> if the child will be female, </span><span class="s3">F</span><span class="s2"> if male (defined only if sex is enabled)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>parent1</span><span class="s2"><span class="Apple-tab-span">	</span>The first parent (an object of class </span><span class="s3">Individual</span><span class="s2">)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>parent1Genome1</span><span class="s2"><span class="Apple-tab-span">	</span>One genome of the first parent</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>parent1Genome2</span><span class="s2"><span class="Apple-tab-span">	</span>The other genome of the first parent</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>isCloning</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">T</span><span class="s2"> if the child is the result of cloning</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>isSelfing</span><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s3">T</span><span class="s2"> if the child is the result of selfing (but see note below)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>parent2</span><span class="s2"><span class="Apple-tab-span">	</span>The second parent (an object of class </span><span class="s3">Individual</span><span class="s2">)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>parent2Genome1</span><span class="s2"><span class="Apple-tab-span">	</span>One genome of the second parent</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>parent2Genome2</span><span class="s2"><span class="Apple-tab-span">	</span>The other genome of the second parent</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>subpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation in which the child will live</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>sourceSubpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation of the parents (</span><span class="s3">==subpop</span><span class="s2"> if not a migration mating)</span></p>
<p class="p4"><span class="s2">These may be used in the </span><span class="s3">modifyChild()</span><span class="s2"> callback to decide upon a course of action.<span class="Apple-converted-space">  </span>The </span><span class="s3">childGenome1</span><span class="s2"> and </span><span class="s3">childGenome2</span><span class="s2"> variables may be modified by the callback; whatever mutations they contain on exit will be used for the new child.<span class="Apple-converted-space">  </span>Alternatively, they may be left unmodified (to accept the generated child as is).<span class="Apple-converted-space">  </span>These variables may be thought of as the two gametes that will fuse to produce the fertilized egg that results in a new offspring; </span><span class="s3">childGenome1</span><span class="s2"> is the gamete contributed by the first parent (the female, if sex is turned on), and </span><span class="s3">childGenome2</span><span class="s2"> is the gamete contributed by the second parent (the male, if sex is turned on).<span class="Apple-converted-space">  </span>The </span><span class="s3">child</span><span class="s2"> object itself may also be modified – for example, to set the spatial position of the child.</span></p>
<p class="p4"><span class="s2">Importantly, a </span><span class="s3">logical</span><span class="s2"> singleton return value is required from </span><span class="s3">modifyChild()</span><span class="s2"> callbacks.<span class="Apple-converted-space">  </span>Normally this should be </span><span class="s3">T</span><span class="s2">, indicating that generation of the child may proceed (with whatever modifications might have been made to the child’s genomes).<span class="Apple-converted-space">  </span>A return value of </span><span class="s3">F</span><span class="s2"> indicates that generation of this child should not continue; this will cause new parent(s) to be drawn, a new child to be generated, and a new call to the </span><span class="s3">modifyChild()</span><span class="s2"> callback.<span class="Apple-converted-space">  </span>A </span><span class="s3">modifyChild()</span><span class="s2"> callback that always returns </span><span class="s3">F</span><span class="s2"> can cause SLiM to hang, so be careful that it is guaranteed that your callback has a nonzero probability of returning </span><span class="s3">T</span><span class="s2"> for every state your simulation can reach.</span></p>
<p class="p4"><span class="s2">Note that </span><span class="s3">isSelfing</span><span class="s2"> is </span><span class="s3">T</span><span class="s2"> only when a mating was explicitly set up to be a selfing event by SLiM; an individual may also mate with itself by chance (by drawing itself as a mate) even when SLiM did not explicitly set up a selfing event, which one might term <i>de facto</i> selfing.<span class="Apple-converted-space">  </span>If you need to know whether a mating event was a <i>de facto</i> selfing event, you can compare the parents; self-fertilization will always entail </span><span class="s3">parent1==parent2</span><span class="s2">, even when </span><span class="s3">isSelfing</span><span class="s2"> is </span><span class="s3">F</span><span class="s2">.<span class="Apple-converted-space">  </span>Since selfing is enabled only in non-sexual simulations, </span><span class="s3">isSelfing</span><span class="s2"> will always be </span><span class="s3">F</span><span class="s2"> in sexual simulations (and <i>de facto</i> selfing is also impossible in sexual simulations).</span></p>
<p class="p4"><span class="s2">Note that matings in SLiM do not proceed in random order.<span class="Apple-converted-space">  </span>Offspring are generated for each subpopulation in turn, and within each subpopulation the order of offspring generation is also non-random with respect to the source subpopulation, the sex of the offspring, and the reproductive mode (selfing, cloning, or autogamy).<span class="Apple-converted-space">  </span>It is important, therefore, that </span><span class="s3">modifyChild()</span><span class="s2"> callbacks are not in any way biased by the offspring generation order; they should not treat offspring generated early in the process any differently than offspring generated late in the process.<span class="Apple-converted-space">  </span>Similar to </span><span class="s3">mateChoice()</span><span class="s2"> callbacks, any failure to guarantee such invariance could lead to large biases in the simulation outcome.<span class="Apple-converted-space">  </span>In particular, it is usually dangerous to activate or deactivate </span><span class="s3">modifyChild()</span><span class="s2"> callbacks while offspring generation is in progress.<span class="Apple-converted-space">  </span>When SLiM sees that </span><span class="s3">mateChoice()</span><span class="s2"> or </span><span class="s3">modifyChild()</span><span class="s2"> callbacks are defined, it randomizes the order of child generation within each subpopulation, so this issue is mitigated somewhat.<span class="Apple-converted-space">  </span>However, offspring are still generated for each subpopulation in turn.<span class="Apple-converted-space">  </span>Furthermore, in generations without active callbacks offspring generation order will not be randomized (making the order of parents nonrandom in the next generation), with possible side effects.<span class="Apple-converted-space">  </span>In short, order-dependency issues are still possible and must be handled very carefully.</span></p>
<p class="p4"><span class="s2">As with the other callback types, multiple </span><span class="s3">modifyChild()</span><span class="s2"> callbacks may be registered and active.<span class="Apple-converted-space">  </span>In this case, all registered and active callbacks will be called for each child generated, in the order that the callbacks were registered.<span class="Apple-converted-space">  </span>If a </span><span class="s3">modifyChild()</span><span class="s2"> callback returns </span><span class="s3">F</span><span class="s2">, however, indicating that the child should not be generated, the remaining callbacks in the chain will not be called.</span></p>
<p class="p4"><span class="s2">There are many different ways in which a </span><span class="s3">modifyChild()</span><span class="s2"> callback could be used in a simulation; see the recipes in chapter 12 for illustrations of the power of this technique.<span class="Apple-converted-space">  </span>In nonWF models, </span><span class="s3">modifyChild()</span><span class="s2"> callbacks are often unnecessary since each generated child is available to the script in the models’ </span><span class="s3">reproduction()</span><span class="s2"> callback anyway; but they may be used if desired.</span></p>
<p class="p1"><i>5.13.5<span class="Apple-converted-space">  </span>ITEM: 6. </i><span class="s1"><i>recombination()</i></span><i> callbacks</i></p>
<p class="p4"><span class="s2">Typically, a simulation sets up a recombination map at the beginning of the run with </span><span class="s3">initializeRecombinationRate()</span><span class="s2">, and that map is used for the duration of the run.<span class="Apple-converted-space">  </span>Less commonly, the recombination map is changed dynamically from generation to generation, with </span><span class="s3">Chromosome</span><span class="s2">’s method </span><span class="s3">setRecombinationRate()</span><span class="s2">; but still, a single recombination map applies for all individuals in a given generation.<span class="Apple-converted-space">  </span>However, in unusual circumstances a simulation may need to modify the way that recombination works on an individual basis; for this, the </span><span class="s3">recombination()</span><span class="s2"> callback mechanism is provided.<span class="Apple-converted-space">  </span>This can be useful for models involving chromosomal inversions that prevent recombination within a region for some individuals, for example, or for models of the evolution of recombination.</span></p>
<p class="p4"><span class="s2">A </span><span class="s3">recombination()</span><span class="s2"> callback is defined with a syntax much like that of other callbacks:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] recombination([&lt;subpop-id&gt;]) { ... }</span></p>
<p class="p4"><span class="s2">The </span><span class="s3">recombination()</span><span class="s2"> callback will be called during the generation of every gamete during the generation(s) in which it is active.<span class="Apple-converted-space">  </span>It may optionally be restricted to apply only to gametes generated by parents in a specified subpopulation, using the </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2"> specifier.</span></p>
<p class="p4"><span class="s2">When a </span><span class="s3">recombination()</span><span class="s2"> callback is called, a parent has already been chosen to generate a gamete, and candidate recombination breakpoints for use in recombining the parental genomes have been drawn.<span class="Apple-converted-space">  </span>The genomes of the focal parent are provided to the callback, as is the focal parent itself (as an </span><span class="s3">Individual</span><span class="s2"> object) and the subpopulation in which it resides.<span class="Apple-converted-space">  </span>Furthermore, the proposed breakpoints are provided to the callback.<span class="Apple-converted-space">  </span>The callback may modify these breakpoints in order to change the breakpoints used, in which case it must return </span><span class="s3">T</span><span class="s2"> to indicate that changes were made, or it may leave the proposed breakpoints unmodified, in which case it must return </span><span class="s3">F</span><span class="s2">.<span class="Apple-converted-space">  </span>(The behavior of SLiM is undefined if the callback returns the wrong </span><span class="s3">logical</span><span class="s2"> value.)</span></p>
<p class="p4"><span class="s2">In addition to the standard SLiM globals, then, a </span><span class="s3">recombination()</span><span class="s2"> callback is supplied with additional information passed through “pseudo-parameters”:</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>individual</span><span class="s2"><span class="Apple-tab-span">	</span>The focal parent that is generating a gamete</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome1</span><span class="s2"><span class="Apple-tab-span">	</span>One genome of the focal parent; this is the initial copy strand</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome2</span><span class="s2"><span class="Apple-tab-span">	</span>The other genome of the focal parent</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>subpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation to which the focal parent belongs</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>breakpoints</span><span class="s2"><span class="Apple-tab-span">	</span>An </span><span class="s3">integer</span><span class="s2"> vector of crossover breakpoints</span></p>
<p class="p4"><span class="s2">These may be used in the </span><span class="s3">recombination()</span><span class="s2"> callback to determine the final recombination breakpoints used by SLiM.<span class="Apple-converted-space">  </span>If values are set into </span><span class="s3">breakpoints</span><span class="s2">, the new values must be of type </span><span class="s3">integer</span><span class="s2">.<span class="Apple-converted-space">  </span>If </span><span class="s3">breakpoints</span><span class="s2"> is modified by the callback, </span><span class="s3">T</span><span class="s2"> should be returned, otherwise </span><span class="s3">F</span><span class="s2"> should be returned (this is a speed optimization, so that SLiM does not have to spend time checking for changes when no changes have been made).</span></p>
<p class="p4"><span class="s2">The positions specified in </span><span class="s3">breakpoints</span><span class="s2"> mean that a crossover will occur immediately <i>before</i> the specified base position (between the preceding base and the specified base, in other words).<span class="Apple-converted-space">  </span>The genome specified by </span><span class="s3">genome1</span><span class="s2"> will be used as the initial copy strand when SLiM executes the recombination; this cannot presently be changed by the callback.</span></p>
<p class="p4"><span class="s2">In this design, the recombination callback does not specify a custom recombination map.<span class="Apple-converted-space">  </span>Instead, the callback can add or remove breakpoints at specific locations.<span class="Apple-converted-space">  </span>To implement a chromosomal inversion, for example, if the parent is heterozygous for the inversion mutation then crossovers within the inversion region are removed by the callback.<span class="Apple-converted-space">  </span>As another example, to implement a model of the evolution of the overall recombination rate, a model could (1) set the global recombination rate to the highest rate attainable in the simulation, (2) for each individual, within the </span><span class="s3">recombination()</span><span class="s2"> callback, calculate the fraction of that maximum rate that the focal individual would experience based upon its genetics, and (3) probabilistically remove proposed crossover points based upon random uniform draws compared to that threshold fraction, thus achieving the individual effective recombination rate desired.<span class="Apple-converted-space">  </span>Other similar treatments could actually vary the effective recombination map, not just the overall rate, by removing proposed crossovers with probabilities that depend upon their position, allowing for the evolution of localized recombination hot-spots and cold-spots.<span class="Apple-converted-space">  </span>Crossovers may also be added, not just removed, by </span><span class="s3">recombination()</span><span class="s2"> callbacks.</span></p>
<p class="p4"><span class="s2">In SLiM 3.3 the recombination model in SLiM was redesigned.<span class="Apple-converted-space">  </span>This required a corresponding redesign of </span><span class="s3">recombination()</span><span class="s2"> callbacks.<span class="Apple-converted-space">  </span>In particular, the </span><span class="s3">gcStarts</span><span class="s2"> and </span><span class="s3">gcEnds</span><span class="s2"> pseudo-parameters to </span><span class="s3">recombination()</span><span class="s2"> callbacks were removed.<span class="Apple-converted-space">  </span>In the present design, the callback receives “crossover breakpoints” information only, in the </span><span class="s3">breakpoints</span><span class="s2"> pseudo-parameter; it receives no information about gene conversion.<span class="Apple-converted-space">  </span>However, </span><span class="s3">recombination()</span><span class="s2"> callbacks can still be used with the “DSB” recombination model; at the point when the callback is called, the pattern of gene conversion tracts will have been simplified down to a vector of crossover breakpoints.<span class="Apple-converted-space">  </span>“Complex” gene conversion tracts, however, involving heteroduplex mismatch repair, are not compatible with </span><span class="s3">recombination()</span><span class="s2"> callbacks, since there is presently no way for them to be specified to the callback.</span></p>
<p class="p4"><span class="s2">Note that the positions in </span><span class="s3">breakpoints</span><span class="s2"> are not, in the general case, guaranteed to be sorted or uniqued; in other words, positions may appear out of order, and the same position may appear more than once.<span class="Apple-converted-space">  </span>After all </span><span class="s3">recombination()</span><span class="s2"> callbacks have completed, the positions from </span><span class="s3">breakpoints</span><span class="s2"> will be sorted, uniqued, and used as the crossover points in generating the prospective gamete genome.<span class="Apple-converted-space">  </span>The essential point here is that if the same position occurs more than once, across </span><span class="s3">breakpoints</span><span class="s2">, the multiple occurrences of the position do not cancel; SLiM does not cross over and then “cross back over” given a pair of identical positions.<span class="Apple-converted-space">  </span>Instead, the multiple occurrences of the position will simply be uniqued down to a single occurrence.</span></p>
<p class="p4"><span class="s2">As with the other callback types, multiple </span><span class="s3">recombination()</span><span class="s2"> callbacks may be registered and active.<span class="Apple-converted-space">  </span>In this case, all registered and active callbacks will be called for each gamete generated, in the order that the callbacks were registered.</span></p>
<p class="p1"><i>5.13.6<span class="Apple-converted-space">  </span>ITEM: 7. </i><span class="s1"><i>interaction()</i></span><i> callbacks</i></p>
<p class="p4"><span class="s2">The </span><span class="s3">InteractionType</span><span class="s2"> class provides various built-in interaction functions that translate from distances to interaction strengths.<span class="Apple-converted-space">  </span>However, it may sometimes be useful to define a custom function for that purpose; for that reason, SLiM allows </span><span class="s3">interaction()</span><span class="s2"> callbacks to be defined that modify the standard interaction strength calculated by </span><span class="s3">InteractionType</span><span class="s2">.<span class="Apple-converted-space">  </span>In particular, this mechanism allows the strength of interactions to depend upon not only the distance between individuals, but also the genetics and other state of the individuals, the spatial position of the individuals, and other environmental variables.</span></p>
<p class="p4"><span class="s2">An </span><span class="s3">interaction()</span><span class="s2"> callback is called by SLiM when it is determining the strength of the interaction between one individual (the receiver of the interaction) and another individual (the exerter of the interaction).<span class="Apple-converted-space">  </span>This may occur when the </span><span class="s3">evaluate()</span><span class="s2"> method of </span><span class="s3">InteractionType</span><span class="s2"> is called, if immediate evaluation is requested; or it may occur at some point after evaluation of the </span><span class="s3">InteractionType</span><span class="s2">, when the interaction strength is needed, if immediate evaluation was not requested.<span class="Apple-converted-space">  </span>This means that </span><span class="s3">interaction()</span><span class="s2"> callbacks may be called at a variety of points in the generation cycle, unlike the other callback types in SLiM, which are each called at a specific point.<span class="Apple-converted-space">  </span>If you write an </span><span class="s3">interaction()</span><span class="s2"> callback, you need to take this into account; assuming that the generation cycle is at a particular stage, or even that the generation count is the same as it was when </span><span class="s3">evaluate()</span><span class="s2"> was called, may be dangerous.</span></p>
<p class="p4"><span class="s2">When an interaction strength is needed, the first thing SLiM does is calculate the default interaction strength using the interaction function that has been defined for the InteractionType.<span class="Apple-converted-space">  </span>If the receiver is the same as the exerter, the interaction strength is always zero; and in spatial simulations if the distance between the receiver and the exerter is greater than the maximum distance set for the </span><span class="s3">InteractionType</span><span class="s2">, the interaction strength is also always zero.<span class="Apple-converted-space">  </span>In these cases, </span><span class="s3">interaction()</span><span class="s2"> callbacks will not be called, and there is no way to redefine these interaction strengths.</span></p>
<p class="p4"><span class="s2">Otherwise, SLiM will then call </span><span class="s3">interaction()</span><span class="s2"> callbacks that apply to the interaction type and subpopulation for the interaction being evaluated.<span class="Apple-converted-space">  </span>An </span><span class="s3">interaction()</span><span class="s2"> callback is defined with a variation of the syntax used for other callbacks:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] interaction(&lt;int-type-id&gt; [, &lt;subpop-id&gt;]) { ... }</span></p>
<p class="p4"><span class="s2">For example, if the callback were defined as:</span></p>
<p class="p5"><span class="s2"><span class="Apple-converted-space">   </span>1000:2000 interaction(i2, p3) { 1.0; }</span></p>
<p class="p4"><span class="s2">then an interaction strength of </span><span class="s3">1.0</span><span class="s2"> would be used for all interactions of interaction type </span><span class="s3">i2</span><span class="s2"> in subpopulation </span><span class="s3">p3</span><span class="s2"> from generation </span><span class="s3">1000</span><span class="s2"> to generation </span><span class="s3">2000</span><span class="s2">.</span></p>
<p class="p4"><span class="s2">In addition to the standard SLiM globals, an </span><span class="s3">interaction()</span><span class="s2"> callback is supplied with some additional information passed through “pseudo-parameters”:</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>distance</span><span class="s2"><span class="Apple-tab-span">	</span>The distance from receiver to exerter, in spatial simulations; </span><span class="s3">NAN</span><span class="s2"> otherwise</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>strength</span><span class="s2"><span class="Apple-tab-span">	</span>The default interaction strength calculated by the interaction function</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>receiver</span><span class="s2"><span class="Apple-tab-span">	</span>The individual receiving the interaction (an object of class </span><span class="s3">Individual</span><span class="s2">)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>exerter</span><span class="s2"><span class="Apple-tab-span">	</span>The individual exerting the interaction (an object of class </span><span class="s3">Individual</span><span class="s2">)</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>subpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation in which the receiver and exerter live</span></p>
<p class="p4"><span class="s2">These may be used in the </span><span class="s3">interaction()</span><span class="s2"> callback to compute an interaction strength.<span class="Apple-converted-space">  </span>To simply use the default interaction strength that SLiM would use if a callback had not been defined for interaction type </span><span class="s3">i1</span><span class="s2">, for example, you could do this:</span></p>
<p class="p5"><span class="s2"><span class="Apple-converted-space">   </span>interaction(i1) {<br>
<span class="Apple-converted-space">      </span>return strength;<br>
<span class="Apple-converted-space">   </span>}</span></p>
<p class="p4"><span class="s2">Usually an </span><span class="s3">interaction()</span><span class="s2"> callback will modify that default strength based upon factors such as the genetics of the receiver and/or the exerter, the spatial positions of the two individuals, or some other simulation state.<span class="Apple-converted-space">  </span>Any finite </span><span class="s3">float</span><span class="s2"> value greater than or equal to </span><span class="s3">0.0</span><span class="s2"> may be returned.<span class="Apple-converted-space">  </span>The value returned will be cached by SLiM; if the interaction strength between the same two individuals is needed again later, the </span><span class="s3">interaction()</span><span class="s2"> callback will not be called again until the interaction is next evaluated (something to keep in mind if the interaction strength includes a stochastic component).</span></p>
<p class="p4"><span class="s2">More than one </span><span class="s3">interaction()</span><span class="s2"> callback may be defined to operate in the same generation.<span class="Apple-converted-space">  </span>As with other callbacks, multiple callbacks will be called in the order in which they were defined in the input file.<span class="Apple-converted-space">  </span>Furthermore, each callback will be given the </span><span class="s3">strength</span><span class="s2"> value returned by the previous callback – so the value of </span><span class="s3">strength</span><span class="s2"> is not necessarily the default value, in fact, but is the result of all previous </span><span class="s3">interaction()</span><span class="s2"> callbacks for the interaction in question.<span class="Apple-converted-space">  </span>In this way, the effects of multiple callbacks can “stack”.</span></p>
<p class="p4"><span class="s2">The </span><span class="s3">interaction()</span><span class="s2"> callback mechanism is extremely powerful and flexible, allowing any sort of user-defined interactions whatsoever to be queried dynamically using the methods of </span><span class="s3">InteractionType</span><span class="s2">.<span class="Apple-converted-space">  </span>However, in the general case a simulation may call for the evaluation of the interaction strength between each individual and every other individual, making the computation of the full interaction network an O(<i>N</i></span><span class="s8"><sup>2</sup></span><span class="s2">) problem.<span class="Apple-converted-space">  </span>Since </span><span class="s3">interaction()</span><span class="s2"> callbacks may be called for each of those <i>N</i></span><span class="s8"><sup>2</sup></span><span class="s2"> interaction evaluations, they can slow down a simulation considerably, so it is recommended that they be used sparingly.<span class="Apple-converted-space">  </span>This is the reason that the various interaction functions of </span><span class="s3">InteractionType</span><span class="s2"> were provided; when an interaction does not depend upon individual state, the intention is to avoid the necessity of an </span><span class="s3">interaction()</span><span class="s2"> callback altogether.<span class="Apple-converted-space">  </span>Furthermore, constraining the number of cases in which interaction strengths need to be calculated – using a short maximum interaction distance, querying the nearest neighbors of the focal individual rather than querying all possible interactions with that individual, and specifying the reciprocality and sex segregation of the </span><span class="s3">InteractionType</span><span class="s2">, for example – may greatly decrease the computational overhead of interaction evaluation.</span></p>
<p class="p1"><i>5.13.7<span class="Apple-converted-space">  </span>ITEM: 8. </i><span class="s1"><i>reproduction()</i></span><i> callbacks</i></p>
<p class="p4"><span class="s2">In WF models (the default model type in SLiM), the SLiM core manages the reproduction of individuals in each generation.<span class="Apple-converted-space">  </span>In nonWF models, however, reproduction is managed by the model script, in </span><span class="s3">reproduction()</span><span class="s2"> callbacks.<span class="Apple-converted-space">  </span>These callbacks may only be defined in nonWF models.</span></p>
<p class="p4"><span class="s2">A </span><span class="s3">reproduction()</span><span class="s2"> callback is defined with a syntax much like that of other callbacks:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] reproduction([&lt;subpop-id&gt; [, &lt;sex&gt;]]) { ... }</span></p>
<p class="p4"><span class="s2">The </span><span class="s3">reproduction()</span><span class="s2"> callback will be called once for each individual during the generation(s) in which it is active.<span class="Apple-converted-space">  </span>It may optionally be restricted to apply only to individuals in a specified subpopulation, using the </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2"> specifier; this may be a subpopulation specifier such as </span><span class="s3">p1</span><span class="s2">, or </span><span class="s3">NULL</span><span class="s2"> indicating no restriction.<span class="Apple-converted-space">  </span>It may also optionally be restricted to apply only to individuals of a specified sex (in sexual models), using the </span><span class="s3">&lt;sex&gt;</span><span class="s2"> specifier; this may be </span><span class="s3">"M"</span><span class="s2"> or </span><span class="s3">"F"</span><span class="s2">, or </span><span class="s3">NULL</span><span class="s2"> indicating no restriction.</span></p>
<p class="p4"><span class="s2">When a </span><span class="s3">reproduction()</span><span class="s2"> callback is called, SLiM’s expectation is that the callback will trigger the reproduction of a focal individual by making method calls to add new offspring individuals.<span class="Apple-converted-space">  </span>Typically the offspring added are the offspring of the focal individual, and typically they are added to the subpopulation to which the focal individual belongs, but neither of these is required; a </span><span class="s3">reproduction()</span><span class="s2"> callback may add offspring generated by any parent(s), to any subpopulation.<span class="Apple-converted-space">  </span>The focal individual is provided to the callback (as an </span><span class="s3">Individual</span><span class="s2"> object), as are its genomes and the subpopulation in which it resides.</span></p>
<p class="p4"><span class="s2">A common alternative pattern is for a </span><span class="s3">reproduction()</span><span class="s2"> callback to ignore the focal individual and generate all of the offspring for the current generation, from all parents.<span class="Apple-converted-space">  </span>The callback then sets </span><span class="s3">self-active</span><span class="s2"> to </span><span class="s3">0</span><span class="s2">, preventing itself from being called again in the current generation; this callback design therefore executes once per generation.<span class="Apple-converted-space">  </span>This can be useful if individuals influence each other’s offspring generation (as in a monogamous-mating model, for example); it can also simply be more efficient when producing offspring in bulk.</span></p>
<p class="p4"><span class="s2">In addition to the standard SLiM globals, then, a </span><span class="s3">reproduction()</span><span class="s2"> callback is supplied with additional information passed through global variables:</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>individual</span><span class="s2"><span class="Apple-tab-span">	</span>The focal individual that is expected to reproduce</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome1</span><span class="s2"><span class="Apple-tab-span">	</span>One genome of the focal individual</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome2</span><span class="s2"><span class="Apple-tab-span">	</span>The other genome of the focal individual</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>subpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation to which the focal individual belongs</span></p>
<p class="p4"><span class="s2">At present, the return value from </span><span class="s3">reproduction()</span><span class="s2"> callbacks is not used, and must be </span><span class="s3">void</span><span class="s2"> (i.e., a value may not be returned).<span class="Apple-converted-space">  </span>It is possible that other return values will be defined in future.</span></p>
<p class="p4"><span class="s2">It is possible, of course, to do actions unrelated to reproduction inside </span><span class="s3">reproduction()</span><span class="s2"> callbacks, but it is not recommended.<span class="Apple-converted-space">  </span>The </span><span class="s3">late()</span><span class="s2"> event phase of the previous generation provides an opportunity for actions immediately before reproduction, and the </span><span class="s3">early()</span><span class="s2"> event phase of the current generation provides an opportunity for actions immediately after reproduction, so only actions that are intertwined with reproduction itself should occur in </span><span class="s3">reproduction()</span><span class="s2"> callbacks.<span class="Apple-converted-space">  </span>Besides providing conceptual clarity, following this design principle will also decrease the probability of bugs, since actions that are unrelated to reproduction should not influence or be influenced by the dynamics of reproduction.</span></p>
<p class="p4"><span class="s2">As with the other callback types, multiple </span><span class="s3">reproduction()</span><span class="s2"> callbacks may be registered and active.<span class="Apple-converted-space">  </span>In this case, all registered and active callbacks will be called for each individual, in the order that the callbacks were registered.</span></p>
<p class="p1"><i>5.13.8<span class="Apple-converted-space">  </span>ITEM: 9. mutation() callbacks</i></p>
<p class="p4"><span class="s2">SLiM auto-generates new mutations according to the current mutation rate (or rate map) and the genetic structure defined by genomic elements, their genomic element types, the mutation types those genomic element types draw from, and the distribution of fitness effects defined by those mutation types.<span class="Apple-converted-space">  </span>In nucleotide-based models, the nucleotide sequence and the mutation matrix also play a role in determining both the rate of mutation and the nucleotide mutated to.<span class="Apple-converted-space">  </span></span>In some models it can be desirable to modify these dynamics in some way – altering the selection coefficients of new mutations in some way, changing the mutation type used, dictating the nucleotide to be used, replacing the proposed mutation with a pre-existing mutation at the same position, or even suppressing the proposed mutation altogether.<span class="s2"><span class="Apple-converted-space">  </span>To achieve this, one may define a </span><span class="s3">mutation()</span><span class="s2"> callback.</span></p>
<p class="p4"><span class="s2">A </span><span class="s3">mutation()</span><span class="s2"> callback is defined as:</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">   </span>[id] [gen1 [: gen2]] mutation([&lt;mut-type-id&gt; [, &lt;subpop-id&gt;]]) { ... }</span></p>
<p class="p4"><span class="s2">The </span><span class="s3">mutation()</span><span class="s2"> callback will be called once for each new auto-generated mutation during the generation(s) in which the callback is active.<span class="Apple-converted-space">  </span>It may optionally be restricted to apply only to mutations of a particular mutation type, using the </span><span class="s3">&lt;mut-type-id&gt;</span><span class="s2"> specifier; this may be a mutation type specifier such as </span><span class="s3">m1</span><span class="s2">, or </span><span class="s3">NULL</span><span class="s2"> indicating no restriction.<span class="Apple-converted-space">  </span>It may also optionally be restricted to individuals generated by a specified subpopulation (usually – see below for discussion), using the </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2"> specifier; this should be a subpopulation specifier such as </span><span class="s3">p1</span><span class="s2">.</span></p>
<p class="p4"><span class="s2">When a </span><span class="s3">mutation()</span><span class="s2"> callback is called, a focal mutation (provided to the callback as an object of type </span><span class="s3">Mutation</span><span class="s2">) has just been created by SLiM, referencing a particular position in a parental genome (also provided, as an object of type </span><span class="s3">Genome</span><span class="s2">).<span class="Apple-converted-space">  </span>The mutation will not be added to that parental genome; rather, the parental genome is being copied, during reproduction, to make a gamete or an offspring genome, and the mutation is, conceptually, a copying error made during that process.<span class="Apple-converted-space">  </span>It will be added to the offspring genome that is the end result of the copying process (which may also involve recombination with another genome).<span class="Apple-converted-space">  </span>At the point that the </span><span class="s3">mutation()</span><span class="s2"> callback is called, the offspring genome is not yet created, however, and so it cannot be accessed from within the </span><span class="s3">mutation()</span><span class="s2"> callback; the </span><span class="s3">mutation()</span><span class="s2"> callback can affect only the mutation itself, not the genome to which the mutation will be added.</span></p>
<p class="p4"><span class="s2">In addition to the standard SLiM globals, then, a </span><span class="s3">mutation()</span><span class="s2"> callback is supplied with additional information passed through global variables:</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>mut</span><span class="s2"><span class="Apple-tab-span">	</span>The focal mutation that is being modified or reviewed</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>genome</span><span class="s2"><span class="Apple-tab-span">	</span>The parental genome that is being copied</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>element</span><span class="s2"><span class="Apple-tab-span">	</span>The genomic element that controls the mutation site</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>originalNuc</span><span class="s2"><span class="Apple-tab-span">	</span>The nucleotide (</span><span class="s3">0</span><span class="s2">/</span><span class="s3">1</span><span class="s2">/</span><span class="s3">2</span><span class="s2">/</span><span class="s3">3</span><span class="s2"> for </span><span class="s3">A</span><span class="s2">/</span><span class="s3">C</span><span class="s2">/</span><span class="s3">G</span><span class="s2">/</span><span class="s3">T</span><span class="s2">) originally at the mutating position</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>parent</span><span class="s2"><span class="Apple-tab-span">	</span>The parent which is generating the offspring genome</span></p>
<p class="p9"><span class="s3"><span class="Apple-converted-space">   </span>subpop</span><span class="s2"><span class="Apple-tab-span">	</span>The subpopulation to which the parent belongs</span></p>
<p class="p4">The <span class="s1">mutation()</span> callback has three possible returns: <span class="s1">T</span>, <span class="s1">F</span>, or (beginning in SLiM 3.5) a singleton object of type <span class="s1">Mutation</span>.<span class="Apple-converted-space">  </span>A return of <span class="s1">T</span> indicates that the proposed mutation should be used in generating the offspring genome (perhaps with modifications made by the callback).<span class="Apple-converted-space">  </span>Conversely, a return of <span class="s1">F</span> indicates that the proposed mutation should be suppressed.<span class="Apple-converted-space">  </span>If a proposed mutation is suppressed, SLiM will not try again; one fewer mutations will be generated during reproduction than would otherwise have been true.<span class="Apple-converted-space">  </span>Returning <span class="s1">F</span> will therefore mean that the realized mutation rate in the model will be lower than the expected mutation rate.<span class="Apple-converted-space">  </span>Finally, a return of an object of type <span class="s1">Mutation</span> replaces the proposed mutation (<span class="s1">mut</span>) with the mutation returned; the offspring genomes being generated will contain the returned mutation.<span class="Apple-converted-space">  </span>The position of the returned mutation must match that of the proposed mutation.<span class="Apple-converted-space">  </span>This provides a mechanism for a <span class="s1">mutation()</span> callback to make SLiM re-use existing mutations instead of generating new mutations, which can be useful.</p>
<p class="p4"><span class="s2">The callback may perform a variety of actions related to the generated mutation.<span class="Apple-converted-space">  </span>The selection coefficient of the mutation can be changed with </span><span class="s3">setSelectionCoefficient()</span><span class="s2">, and the mutation type of the mutation can be changed with </span><span class="s3">setMutationType()</span><span class="s2">; the </span><span class="s3">drawSelectionCoefficient()</span><span class="s2"> method of </span><span class="s3">MutationType</span><span class="s2"> may also be useful here.<span class="Apple-converted-space">  </span>A </span><span class="s3">tag</span><span class="s2"> property value may be set for the mutation, and named values may be attached to the mutation with </span><span class="s3">setValue()</span><span class="s2">.<span class="Apple-converted-space">  </span>In nucleotide-based models, the </span><span class="s3">nucleotide</span><span class="s2"> (or </span><span class="s3">nucleotideValue</span><span class="s2">) property of the mutation may also be changed; note that the original nucleotide at the focal position in the parental genome is provided through </span><span class="s3">originalNuc</span><span class="s2"> (it could be retrieved with </span><span class="s3">genome.nucleotides()</span><span class="s2">, but SLiM already has it at hand anyway).<span class="Apple-converted-space">  </span>All of these modifications to the new mutation may be based upon the state of the parent, including its genetic state, or upon any other model state.</span></p>
<p class="p4"><span class="s2">It is possible, of course, to do actions unrelated to mutation inside </span><span class="s3">mutation()</span><span class="s2"> callbacks, but it is not recommended; </span><span class="s3">early()</span><span class="s2"> and </span><span class="s3">late()</span><span class="s2"> events should be used for general-purpose scripting.<span class="Apple-converted-space">  </span>Besides providing conceptual clarity, following this design principle will also decrease the probability of bugs, since actions that are unrelated to mutation should not influence or be influenced by the dynamics of mutation.</span></p>
<p class="p4"><span class="s2">The proposed mutation will not appear in the </span><span class="s3">sim.mutations</span><span class="s2"> vector of segregating mutations until it has been added to a genome; it will therefore not be visible in that vector within its own </span><span class="s3">mutation()</span><span class="s2"> callback invocation, and indeed, may not be visible in subsequent callbacks during the reproduction generation cycle stage until such time as the offspring individual being generated has been completed.<span class="Apple-converted-space">  </span>If that offspring is ultimately rejected, in particular by a </span><span class="s3">modifyChild()</span><span class="s2"> callback, the proposed mutation may not be used by SLiM at all.<span class="Apple-converted-space">  </span>It may therefore be unwise to assume, in a </span><span class="s3">mutation()</span><span class="s2"> callback, that the focal mutation will ultimately be added to the simulation, depending upon the rest of the model’s script.</span></p>
<p class="p4"><span class="s2">There is one subtlety to be mentioned here, having to do with subpopulations.<span class="Apple-converted-space">  </span>The </span><span class="s3">subpop</span><span class="s2"> pseudo-parameter discussed above is always the subpopulation of the parent which possesses the genome that is being copied and is mutating; there is no ambiguity about that whatsoever.<span class="Apple-converted-space">  </span>The </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2"> specified in the </span><span class="s3">mutation()</span><span class="s2"> callback declaration, however, is a bit more subtle; above it was said that it restricts the callback “to individuals generated by a specified subpopulation”, and that is usually true but requires some explanation.<span class="Apple-converted-space">  </span>In WF models, recall that migrants are generated in a source subpopulation and placed in a target subpopulation, as a model of juvenile migration; in that context, the </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2"> specifies the <i>source</i> subpopulation to which the </span><span class="s3">mutation()</span><span class="s2"> callback will be restricted.<span class="Apple-converted-space">  </span>In nonWF models, offspring are generated by the </span><span class="s3">add...()</span><span class="s2"> family of </span><span class="s3">Subpopulation</span><span class="s2"> methods, which can cross individuals from two different subpopulations and place the result in a third target subpopulation; in that context, in general, the </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2"> specifies the source subpopulation that is generating the particular <i>gamete</i> that is sustaining a mutation during its production.<span class="Apple-converted-space">  </span>The exception to this rule is </span><span class="s3">addRecombinant()</span><span class="s2">; since there are four different source subpopulations potentially in play there, it was deemed simpler in that case for the </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2"> to specify the <i>target</i> subpopulation to which the </span><span class="s3">mutation()</span><span class="s2"> callback will be restricted.<span class="Apple-converted-space">  </span>If restriction to the source subpopulation is needed with </span><span class="s3">addRecombinant()</span><span class="s2">, the </span><span class="s3">subpop</span><span class="s2"> pseudo-parameter may be consulted rather than using </span><span class="s3">&lt;subpop-id&gt;</span><span class="s2">.</span></p>
<p class="p4"><span class="s2">Note that </span><span class="s3">mutation()</span><span class="s2"> callbacks are only called for mutations that are auto-generated by SLiM, as a consequence of the mutation rate and the genetic structure defined.<span class="Apple-converted-space">  </span>Mutations that are created in script, using </span><span class="s3">addNewMutation()</span><span class="s2"> or </span><span class="s3">addNewDrawnMutation()</span><span class="s2">, will not trigger </span><span class="s3">mutation()</span><span class="s2"> callbacks; but of course the script may modify or tailor such added mutations in whatever way is desired, so there is no need for callbacks in that situation.</span></p>
<p class="p4"><span class="s2">As with the other callback types, multiple </span><span class="s3">mutation()</span><span class="s2"> callbacks may be registered and active.<span class="Apple-converted-space">  </span>In this case, all registered and active callbacks will be called for each generated mutation to which they apply, in the order that the callbacks were registered.</span></p>
<p class="p10"><span class="s2"></span><br></p>
</body>
</html>
