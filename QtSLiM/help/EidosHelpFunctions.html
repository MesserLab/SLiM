<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.3">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo}
    p.p3 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima}
    p.p4 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p5 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p7 {margin: 3.0px 0.0px 3.0px 27.4px; font: 9.0px Menlo}
    p.p8 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #d50005}
    p.p9 {margin: 3.0px 0.0px 3.0px 27.4px; font: 9.0px Menlo; color: #000000}
    p.p10 {margin: 9.0px 0.0px 9.0px 45.0px; font: 9.0px Menlo}
    li.li6 {margin: 3.0px 0.0px 3.0px 0.0px; font: 10.0px Optima}
    span.s1 {font: 9.0px 'Times New Roman'}
    span.s2 {font: 9.0px Menlo}
    span.s3 {font: 10.0px 'Times New Roman'}
    span.s4 {font: 10.0px 'Apple Symbols'}
    span.s5 {font-kerning: none}
    span.s6 {font: 9.0px Menlo; font-kerning: none}
    span.s7 {color: #000000}
    span.s8 {font: 9.0px Menlo; color: #000000}
    span.s9 {font: 10.0px 'Times New Roman'; color: #000000}
    span.s10 {font: 10.0px 'Times New Roman'; font-kerning: none}
    span.s11 {font: 6.7px 'Times New Roman'; font-kerning: none}
    span.s12 {font: 10.0px Helvetica}
    span.s13 {font-kerning: none; color: #000000}
    span.s14 {font: 9.0px Menlo; font-kerning: none; color: #000000}
    span.s15 {font: 9.0px Symbol}
    span.s16 {font: 10.0px Symbol}
    span.s17 {font: 10.0px Optima}
    span.s18 {font: 6.7px Optima; font-kerning: none}
    span.Apple-tab-span {white-space:pre}
    ul.ul1 {list-style-type: disc}
  </style>
</head>
<body>
<p class="p1"><b>3.1.<span class="Apple-converted-space">  </span>Math functions</b></p>
<p class="p2">(numeric)abs(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>absolute value</b> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">integer</span>, the C++ function <span class="s2">llabs()</span> is used and an <span class="s2">integer</span> vector is returned; if <span class="s2">x</span> is <span class="s2">float</span>, the C++ function <span class="s2">fabs()</span> is used and a <span class="s2">float</span> vector is returned.</p>
<p class="p2">(float)acos(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>arc cosine</b> of <span class="s2">x</span> using the C++ function <span class="s2">acos()</span><span class="s3">.</span></p>
<p class="p2">(float)asin(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>arc sine</b> of <span class="s2">x</span> using the C++ function <span class="s2">asin()</span><span class="s3">.</span></p>
<p class="p2">(float)atan(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>arc tangent</b> of <span class="s2">x</span> using the C++ function <span class="s2">atan()</span><span class="s3">.</span></p>
<p class="p2">(float)atan2(numeric<span class="s1"> </span>x, numeric<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>arc tangent</b> of <span class="s2">y/x</span> using the C++ function <span class="s2">atan2()</span>, which uses the signs of both x and y to determine the correct quadrant for the result.</p>
<p class="p2">(float)ceil(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>ceiling</b> of <span class="s2">x</span>: the smallest integral value greater than or equal to <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p2">(float)cos(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>cosine</b> of <span class="s2">x</span> using the C++ function <span class="s2">cos()</span><span class="s3">.</span></p>
<p class="p2">(numeric)cumProduct(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>cumulative product</b> of <span class="s2">x</span>: a vector of equal length as <span class="s2">x</span>, in which the element at index <span class="s2">i</span> is equal to the product of the elements of <span class="s2">x</span> across the range <span class="s2">0:i</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The return type will match the type of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">integer</span>, but all of the values of the cumulative product vector cannot be represented in that type, an error condition will result.</p>
<p class="p2">(numeric)cumSum(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>cumulative sum</b> of <span class="s2">x</span>: a vector of equal length as <span class="s2">x</span>, in which the element at index <span class="s2">i</span> is equal to the sum of the elements of <span class="s2">x</span> across the range <span class="s2">0:i</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The return type will match the type of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">integer</span>, but all of the values of the cumulative sum vector cannot be represented in that type, an error condition will result.</p>
<p class="p2">(float)exp(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-<i>e</i> exponential</b> of <span class="s2">x, <i>e</i><sup>x</sup></span>,<span class="Apple-converted-space">  </span>using the C++ function <span class="s2">exp()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>This may be somewhat faster than <span class="s2">E^x</span> for large vectors.</p>
<p class="p2">(float)floor(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>floor</b> of <span class="s2">x</span>: the largest integral value less than or equal to <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p2">(integer)integerDiv(integer x, integer y)</p>
<p class="p3">Returns the result of <b>integer division</b> of <span class="s2">x</span> by <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The <span class="s2">/</span> operator in Eidos always produces a <span class="s2">float</span> result; if you want an <span class="s2">integer</span> result you may use this function instead.<span class="Apple-converted-space">  </span>If any value of <span class="s2">y</span> is <span class="s2">0</span>, an error will result.<span class="Apple-converted-space">  </span>The parameters <span class="s2">x</span> and <span class="s2">y</span> must either be of equal length, or one of the two must be a singleton.<span class="Apple-converted-space">  </span>The precise behavior of <span class="s2">integer</span> division, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of <span class="s2">integer</span> division is on the given platform.<span class="Apple-converted-space">  </span>Eidos does not guarantee any particular behavior, so use this function with caution.</p>
<p class="p2">(integer)integerMod(integer x<span class="s1">,</span> integer y)</p>
<p class="p3">Returns the result of <b>integer modulo</b> of <span class="s2">x</span> by <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The <span class="s2">%</span> operator in Eidos always produces a <span class="s2">float</span> result; if you want an <span class="s2">integer</span> result you may use this function instead.<span class="Apple-converted-space">  </span>If any value of <span class="s2">y</span> is <span class="s2">0</span>, an error will result.<span class="Apple-converted-space">  </span>The parameters <span class="s2">x</span> and <span class="s2">y</span> must either be of equal length, or one of the two must be a singleton.<span class="Apple-converted-space">  </span>The precise behavior of <span class="s2">integer</span> modulo, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of <span class="s2">integer</span> modulo is on the given platform.<span class="Apple-converted-space">  </span>Eidos does not guarantee any particular behavior, so use this function with caution.</p>
<p class="p2">(logical)isFinite(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>finiteness</b> of <span class="s2">x</span>: <span class="s2">T</span> if <span class="s2">x</span> is not <span class="s2">INF</span> or <span class="s2">NAN</span>, <span class="s2">F</span> if <span class="s2">x</span> is <span class="s2">INF</span> or <span class="s2">NAN</span><span class="s3">.</span><span class="Apple-converted-space">  </span><span class="s2">INF</span> and <span class="s2">NAN</span> are defined only for type <span class="s2">float</span>, so x is required to be a <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that <span class="s2">isFinite()</span> is not the opposite of <span class="s2">isInfinite()</span>, because <span class="s2">NAN</span> is considered to be neither finite nor infinite.</p>
<p class="p2">(logical)isInfinite(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>infiniteness</b> of <span class="s2">x</span>: <span class="s2">T</span> if <span class="s2">x</span> is <span class="s2">INF</span>, <span class="s2">F</span> otherwise.<span class="Apple-converted-space">  </span><span class="s2">INF</span> is defined only for type <span class="s2">float</span>, so x is required to be a <span class="s2">float</span>.<span class="Apple-converted-space">  </span>Note that <span class="s2">isInfinite()</span> is not the opposite of <span class="s2">isFinite()</span>, because <span class="s2">NAN</span> is considered to be neither finite nor infinite.</p>
<p class="p2">(logical)isNAN(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>undefinedness</b> of <span class="s2">x</span>: <span class="s2">T</span> if <span class="s2">x</span> is not <span class="s2">NAN</span>, <span class="s2">F</span> if <span class="s2">x</span> is <span class="s2">NAN</span><span class="s3">.</span><span class="Apple-converted-space">  </span><span class="s2">NAN</span> is defined only for type <span class="s2">float</span>, so x is required to be a <span class="s2">float</span><span class="s3">.</span></p>
<p class="p2">(float)log(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-<i>e</i> logarithm</b> of <span class="s2">x</span> using the C++ function <span class="s2">log()</span><span class="s3">.</span></p>
<p class="p2">(float)log10(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-10 logarithm</b> of <span class="s2">x</span> using the C++ function <span class="s2">log10()</span><span class="s3">.</span></p>
<p class="p2">(float)log2(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-2 logarithm</b> of <span class="s2">x</span> using the C++ function <span class="s2">log2()</span><span class="s3">.</span></p>
<p class="p2">(numeric$)product(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>product</b> of <span class="s2">x</span>: the result of multiplying all of the elements of <span class="s2">x</span> together.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">float</span>, the result will be <span class="s2">float</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">integer</span>, things are a bit more complex; the result will be <span class="s2">integer</span> if it can fit into the <span class="s2">integer</span> type without overflow issues (including during intermediate stages of the computation), otherwise it will be <span class="s2">float</span><span class="s3">.</span></p>
<p class="p2">(float)round(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>round</b> of <span class="s2">x</span>: the integral value nearest to <span class="s2">x</span>, rounding half-way cases away from <span class="s2">0</span> (different from the rounding policy of R, which rounds halfway cases toward the nearest even number).<span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p2">(*)setDifference(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic (asymmetric) difference</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∖</span> <span class="s2">y</span>: a vector containing all elements that are in <span class="s2">x</span> but are not in <span class="s2">y</span>.<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p2">(*)setIntersection(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic intersection</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∩</span> <span class="s2">y</span>: a vector containing all elements that are in both <span class="s2">x</span> and <span class="s2">y</span> (but not in <i>only</i> <span class="s2">x</span> or <span class="s2">y</span>).<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p2">(*)setSymmetricDifference(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic symmetric difference</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∆</span> <span class="s2">y</span>: a vector containing all elements that are in <span class="s2">x</span> or <span class="s2">y</span>, but not in both.<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p2">(*)setUnion(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic union</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∪</span> <span class="s2">y</span>: a vector containing all elements that are in <span class="s2">x</span> and/or <span class="s2">y</span>.<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>This function is therefore roughly equivalent to <span class="s2">unique(c(x, y))</span>, but this function will probably be faster.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p2">(float)sin(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>sine</b> of <span class="s2">x</span> using the C++ function <span class="s2">sin()</span><span class="s3">.</span></p>
<p class="p2">(float)sqrt(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>square root</b> of <span class="s2">x</span> using the C++ function <span class="s2">sqrt()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>This may be somewhat faster than <span class="s2">x^0.5</span> for large vectors.</p>
<p class="p2">(numeric$)sum(lif x)</p>
<p class="p3">Returns the <b>sum</b> of <span class="s2">x</span>: the result of adding all of the elements of <span class="s2">x</span> together.<span class="Apple-converted-space">  </span>The unusual parameter type signature <span class="s2">lif</span> indicates that <span class="s2">x</span> can be <span class="s2">logical</span>, <span class="s2">integer</span>, or <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">float</span>, the result will be <span class="s2">float</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">logical</span>, the result will be <span class="s2">integer</span> (the number of <span class="s2">T</span> values in <span class="s2">x</span>, since the <span class="s2">integer</span> values of <span class="s2">T</span> and <span class="s2">F</span> are <span class="s2">1</span> and <span class="s2">0</span> respectively).<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">integer</span>, things are a bit more complex; in this case, the result will be <span class="s2">integer</span> if it can fit into the <span class="s2">integer</span> type without overflow issues (including during intermediate stages of the computation), otherwise it will be <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that floating-point roundoff issues can cause this function to return inexact results when <span class="s2">x</span> is <span class="s2">float</span> type; this is rarely an issue, but see the <span class="s2">sumExact()</span> function for an alternative.</p>
<p class="p2">(float$)sumExact(float x)</p>
<p class="p3">Returns the <b>exact sum</b> of <span class="s2">x</span>: the exact result of adding all of the elements of <span class="s2">x</span> together.<span class="Apple-converted-space">  </span>Unlike the <span class="s2">sum()</span> function, <span class="s2">sumExact()</span> accepts only type <span class="s2">float</span>, since the <span class="s2">sum()</span> function is already exact for other types.<span class="Apple-converted-space">  </span>When summing floating-point values – particularly values that vary across many orders of magnitude – the precision limits of floating-point numbers can lead to roundoff errors that cause the <span class="s2">sum()</span> function to return an inexact result.<span class="Apple-converted-space">  </span>This function does additional work to ensure that the final result is exact within the possible limits of the <span class="s2">float</span> type; some roundoff may still inevitably occur, in other words, but a more exact result could not be represented with a value of type <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The disadvantage of using this function instead of <span class="s2">sum()</span> is that it is much slower – about 35 times slower, according to one test on Mac OS X 10.2.5, but that will vary across operating systems and hardware.<span class="Apple-converted-space">  </span>This function is rarely truly needed, but apart from the performance consequences there is no disadvantage to using it.</p>
<p class="p2">(float)tan(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>tangent</b> of <span class="s2">x</span> using the C++ function <span class="s2">tan()</span><span class="s3">.</span></p>
<p class="p2">(float)trunc(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>truncation</b> of <span class="s2">x</span>: the integral value nearest to, but no larger in magnitude than, <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p1"><b>3.2.<span class="Apple-converted-space">  </span>Statistics functions</b></p>
<p class="p4"><span class="s5">(float$)cor(numeric x, numeric y)</span></p>
<p class="p5"><span class="s5">Returns the <b>sample Pearson’s correlation coefficient</b> between </span><span class="s6">x</span><span class="s5"> and </span><span class="s6">y</span><span class="s5">, usually denoted <i>r</i>.<span class="Apple-converted-space">  </span>The sizes of </span><span class="s6">x</span><span class="s5"> and </span><span class="s6">y</span><span class="s5"> must be identical.<span class="Apple-converted-space">  </span>If </span><span class="s6">x</span><span class="s5"> and </span><span class="s6">y</span><span class="s5"> have a size of </span><span class="s6">0</span><span class="s5"> or </span><span class="s6">1</span><span class="s5">, the return value will be </span><span class="s6">NULL</span><span class="s5">.<span class="Apple-converted-space">  </span>At present it is illegal to call </span><span class="s6">cor()</span><span class="s5"> with a matrix or array argument, because the desired behavior in that case has not yet been implemented.</span></p>
<p class="p4"><span class="s5">(float$)cov(numeric x, numeric y)</span></p>
<p class="p5"><span class="s5">Returns the <b>corrected sample covariance</b> between </span><span class="s6">x</span><span class="s5"> and </span><span class="s6">y</span><span class="s5">.<span class="Apple-converted-space">  </span>The sizes of </span><span class="s6">x</span><span class="s5"> and </span><span class="s6">y</span><span class="s5"> must be identical.<span class="Apple-converted-space">  </span>If </span><span class="s6">x</span><span class="s5"> and </span><span class="s6">y</span><span class="s5"> have a size of </span><span class="s6">0</span><span class="s5"> or </span><span class="s6">1</span><span class="s5">, the return value will be </span><span class="s6">NULL</span><span class="s5">.<span class="Apple-converted-space">  </span>At present it is illegal to call </span><span class="s6">cov()</span><span class="s5"> with a matrix or array argument, because the desired behavior in that case has not yet been implemented.</span></p>
<p class="p2">(+$)max(+ x, ...)</p>
<p class="p3">Returns the <b>maximum</b> of <span class="s2">x</span> and the other arguments supplied: the single greatest value contained by all of them.<span class="Apple-converted-space">  </span>All of the arguments must be the same type as <span class="s2">x</span>, and the return type will match that of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If all of the arguments have a size of <span class="s2">0</span>, the return value will be <span class="s2">NULL</span>; note that this means that <span class="s2">max(x, max(y))</span> may produce an error, if <span class="s2">max(y)</span> is <span class="s2">NULL</span>, in cases where <span class="s2">max(x, y)</span> does not.</p>
<p class="p2">(float$)mean(lif<span class="s1"> </span>x)</p>
<p class="p5"><span class="s7">Returns the <b>arithmetic mean</b> of </span><span class="s8">x</span><span class="s7">: the sum of </span><span class="s8">x</span><span class="s7"> divided by the number of values in </span><span class="s8">x</span><span class="s9">.</span><span class="s7"><span class="Apple-converted-space">  </span>If </span><span class="s8">x</span><span class="s7"> has a size of </span><span class="s8">0</span><span class="s7">, the return value will be </span><span class="s8">NULL</span><span class="s9">.</span><span class="s5"><span class="Apple-converted-space">  </span>The unusual parameter type signature </span><span class="s6">lif</span><span class="s5"> indicates that </span><span class="s6">x</span><span class="s5"> can be </span><span class="s6">logical</span><span class="s5">, </span><span class="s6">integer</span><span class="s5">, or </span><span class="s6">float</span><span class="s5">; if </span><span class="s6">x</span><span class="s5"> is </span><span class="s6">logical</span><span class="s5">, it is coerced to </span><span class="s6">integer</span><span class="s5"> internally (with </span><span class="s6">F</span><span class="s5"> being </span><span class="s6">0</span><span class="s5"> and </span><span class="s6">T</span><span class="s5"> being </span><span class="s6">1</span><span class="s5">, as always), allowing </span><span class="s6">mean()</span><span class="s5"> to calculate the average truth value of a </span><span class="s6">logical</span><span class="s5"> vector.</span></p>
<p class="p2">(+$)min(+ x, ...)</p>
<p class="p3">Returns the <b>minimum</b> of <span class="s2">x</span> and the other arguments supplied: the single smallest value contained by all of them.<span class="Apple-converted-space">  </span>All of the arguments must be the same type as <span class="s2">x</span>, and the return type will match that of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If all of the arguments have a size of <span class="s2">0</span>, the return value will be <span class="s2">NULL</span>; note that this means that <span class="s2">min(x, min(y))</span> may produce an error, if <span class="s2">min(y)</span> is <span class="s2">NULL</span>, in cases where <span class="s2">min(x, y)</span> does not.</p>
<p class="p2">(+)pmax(+ x, + y)</p>
<p class="p3">Returns the <b>parallel maximum</b> of <span class="s2">x</span> and <span class="s2">y</span>: the element-wise maximum for each corresponding pair of elements in <span class="s2">x</span> and <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The type of <span class="s2">x</span> and <span class="s2">y</span> must match, and the returned value will have the same type.<span class="Apple-converted-space">  </span>In one usage pattern the size of <span class="s2">x</span> and <span class="s2">y</span> match, in which case the returned value will have the same size.<span class="Apple-converted-space">  </span>In the other usage pattern either <span class="s2">x</span> and <span class="s2">y</span> is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton’s element and each of the elements in the non-singleton.</p>
<p class="p2">(+)pmin(+ x, + y)</p>
<p class="p3">Returns the <b>parallel minimum</b> of <span class="s2">x</span> and <span class="s2">y</span>: the element-wise minimum for each corresponding pair of elements in <span class="s2">x</span> and <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The type of <span class="s2">x</span> and <span class="s2">y</span> must match, and the returned value will have the same type.<span class="Apple-converted-space">  </span>In one usage pattern the size of <span class="s2">x</span> and <span class="s2">y</span> match, in which case the returned value will have the same size.<span class="Apple-converted-space">  </span>In the other usage pattern either <span class="s2">x</span> and <span class="s2">y</span> is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton’s element and each of the elements in the non-singleton.</p>
<p class="p2">(numeric)range(numeric<span class="s1"> </span>x, ...)</p>
<p class="p3">Returns the <b>range</b> of <span class="s2">x</span> and the other arguments supplied: a vector of length <span class="s2">2</span> composed of the minimum and maximum values contained by all of them, at indices <span class="s2">0</span> and <span class="s2">1</span> respectively.<span class="Apple-converted-space">  </span>All of the arguments must be the same type as <span class="s2">x</span>, and the return type will match that of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If all of the arguments have a size of <span class="s2">0</span>, the return value will be <span class="s2">NULL</span>; note that this means that <span class="s2">range(x, range(y))</span> may produce an error, if <span class="s2">range(y)</span> is <span class="s2">NULL</span>, in cases where <span class="s2">range(x, y)</span> does not.</p>
<p class="p2">(float$)sd(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>corrected sample standard deviation</b> of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If <span class="s2">x</span> has a size of <span class="s2">0</span> or <span class="s2">1</span><span class="s3">,</span> the return value will be <span class="s2">NULL</span><span class="s3">.</span></p>
<p class="p2">(float$)ttest(float<span class="s1"> </span>x, [Nf y = NULL], [Nf$ mu = NULL])</p>
<p class="p3">Returns the <i>p</i>-value resulting from running a <i>t</i>-test with the supplied data.<span class="Apple-converted-space">  </span>Two types of <i>t</i><span class="s3">-</span>tests can be performed.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">y</span> are supplied (i.e., <span class="s2">y</span> is non-<span class="s2">NULL</span>), a two-sample unpaired two-sided Welch’s <i>t</i>-test is conducted using the samples in <span class="s2">x</span> and <span class="s2">y</span>, each of which must contain at least two elements.<span class="Apple-converted-space">  </span>The null hypothesis for this test is that the two samples are drawn from populations with the same mean.<span class="Apple-converted-space">  </span>Other options, such as pooled-variance <i>t</i>-tests, paired <i>t</i>-tests, and one-sided <i>t</i>-tests, are not presently available.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">mu</span> are supplied (i.e., <span class="s2">mu</span> is non-<span class="s2">NULL</span>), a one-sample <i>t</i>-test is conducted in which the null hypothesis is that the sample is drawn from a population with mean <span class="s2">mu</span><span class="s3">.</span></p>
<p class="p3">Note that the results from this function are substantially different from those produced by R.<span class="Apple-converted-space">  </span>The Eidos <span class="s2">ttest() </span>function uses uncorrected sample statistics, which means they will be biased for small sample sizes, whereas R probably uses corrected, unbiased sample statistics.<span class="Apple-converted-space">  </span>This is an Eidos bug, and might be fixed if anyone complains.<span class="Apple-converted-space">  </span>If large sample sizes are used, however, the bias is likely to be small, and uncorrected statistics are simpler and faster to compute.</p>
<p class="p4"><span class="s5">(float$)var(numeric x)</span></p>
<p class="p5"><span class="s5">Returns the <b>corrected sample variance</b> of </span><span class="s6">x</span><span class="s5">.<span class="Apple-converted-space">  </span>If </span><span class="s6">x</span><span class="s5"> has a size of </span><span class="s6">0</span><span class="s5"> or </span><span class="s6">1</span><span class="s5">, the return value will be </span><span class="s6">NULL</span><span class="s5">.<span class="Apple-converted-space">  </span>This is the square of the standard deviation calculated by </span><span class="s6">sd()</span><span class="s5">.<span class="Apple-converted-space">  </span>At present it is illegal to call </span><span class="s6">var()</span><span class="s5"> with a matrix or array argument, because the desired behavior in that case has not yet been implemented.</span></p>
<p class="p1"><b>3.3.<span class="Apple-converted-space">  </span>Distribution drawing and density functions</b></p>
<p class="p4"><span class="s5">(float)dmvnorm(float x, numeric mu, numeric sigma)</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for a <i>k</i>-dimensional multivariate normal distribution</b> with a length <i>k</i> mean vector </span><span class="s6">mu</span><span class="s5"> and a <i>k</i> × <i>k</i> variance-covariance matrix </span><span class="s6">sigma</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">mu</span><span class="s5"> and </span><span class="s6">sigma</span><span class="s5"> parameters are used for all densities.<span class="Apple-converted-space">  </span>The quantile values, </span><span class="s6">x</span><span class="s5">, should be supplied as a matrix with one row per vector of quantile values and <i>k</i> columns (one column per dimension); for convenience, a single quantile may be supplied as a vector rather than a matrix with just one row.<span class="Apple-converted-space">  </span>The number of dimensions <i>k</i> must be at least two; for <i>k</i>=1, use </span><span class="s6">dnorm()</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Cholesky decomposition of the variance-covariance matrix </span><span class="s6">sigma</span><span class="s5"> is involved as an internal step, and this requires that </span><span class="s6">sigma</span><span class="s5"> be positive-definite; if it is not, an error will result.<span class="Apple-converted-space">  </span>When more than one density is needed, it is much more efficient to call </span><span class="s6">dmvnorm()</span><span class="s5"> once to generate all of the densities, since the Cholesky decomposition of </span><span class="s6">sigma</span><span class="s5"> can then be done just once.</span></p>
<p class="p4"><span class="s5">(float)dbeta(float x, numeric alpha, numeric beta)</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for a beta distribution</b> at quantiles </span><span class="s6">x</span><span class="s5"> with parameters </span><span class="s6">alpha</span><span class="s5"> and </span><span class="s6">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">alpha</span><span class="s5"> and </span><span class="s6">beta</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of the same length as </span><span class="s6">x</span><span class="s5">, specifying a value for each density computation.<span class="Apple-converted-space">  </span>The probability density function is </span><span class="s10"><i>P</i>(<i>s</i> | <i>α</i>,<i>β</i>) = [Γ(<i>α</i>+<i>β</i>)/Γ(<i>α</i>)Γ(<i>β</i>)]<i>s</i></span><span class="s11"><i><sup>α</sup></i><sup>−1</sup></span><span class="s10">(1−<i>s</i>)</span><span class="s11"><i><sup>β</sup></i><sup>−1</sup></span><span class="s5">, where </span><span class="s10"><i>α</i></span><span class="s5"> is </span><span class="s6">alpha</span><span class="s5"> and </span><span class="s10"><i>β</i></span><span class="s5"> is </span><span class="s6">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>Both parameters must be greater than </span><span class="s6">0</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(float)dexp(float x, [numeric mu = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for an exponential distribution</b> at quantiles </span><span class="s6">x</span><span class="s5"> with mean </span><span class="s6">mu</span><span class="s5"> (i.e. rate </span><span class="s6">1/mu</span><span class="s5">).<span class="Apple-converted-space">  </span>The </span><span class="s6">mu</span><span class="s5"> parameter may either be a singleton, specifying a single value to be used for all of the draws, or they may be vectors of the same length as </span><span class="s6">x</span><span class="s5">, specifying a value for each density computation.</span></p>
<p class="p4"><span class="s5">(float)dgamma(float x, numeric mean, numeric shape)</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for a gamma distribution</b> at quantiles </span><span class="s6">x</span><span class="s5"> with mean </span><span class="s6">mean</span><span class="s5"> and shape parameter </span><span class="s6">shape</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">mean</span><span class="s5"> and </span><span class="s6">shape</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of the same length as </span><span class="s6">x</span><span class="s5">, specifying a value for each density computation.<span class="Apple-converted-space">  </span>The probability density function is </span><span class="s10"><i>P</i>(<i>s</i> | <i>α</i>,<i>β</i>) = [Γ(<i>α</i>)<i>β</i></span><span class="s11"><i><sup>α</sup></i></span><span class="s10">]</span><span class="s11"><sup>−1</sup></span><span class="s10"><i>s</i></span><span class="s11"><i><sup>α</sup></i><sup>−1</sup></span><span class="s10">exp(−<i>s</i>/<i>β</i>)</span><span class="s5">, where </span><span class="s10"><i>α</i></span><span class="s5"> is the shape parameter </span><span class="s6">shape</span><span class="s5">, and the mean of the distribution given by </span><span class="s6">mean</span><span class="s5"> is equal to </span><span class="s10"><i>αβ</i></span><span class="s5">.</span></p>
<p class="p2">(float)dnorm(float x, [numeric mean = 0], [numeric sd = 1])</p>
<p class="p3">Returns a vector of <b>probability densities for a normal distribution</b> at quantiles <span class="s2">x</span> with mean <span class="s2">mean</span> and standard deviation <span class="s2">sd</span>.<span class="Apple-converted-space">  </span>The <span class="s2">mean</span> and <span class="s2">sd</span> parameters may either be singletons, specifying a single value to be used for all of the densities, or they may be vectors of the same length as <span class="s2">x</span>, specifying a value for each density computation.</p>
<p class="p4"><span class="s5">(float)pnorm(float q, [numeric mean = 0], [numeric sd = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>cumulative distribution function values for a normal distribution</b> at quantiles </span><span class="s6">q</span><span class="s5"> with mean </span><span class="s6">mean</span><span class="s5"> and standard deviation </span><span class="s6">sd</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">mean</span><span class="s5"> and </span><span class="s6">sd</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the quantiles, or they may be vectors of the same length as </span><span class="s6">q</span><span class="s5">, specifying a value for each quantile.</span></p>
<p class="p4"><span class="s5">(float)qnorm(float p, [numeric mean = 0], [numeric sd = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>quantiles for a normal distribution</b> with lower tail probabilities less than </span><span class="s6">p</span><span class="s5">, with mean </span><span class="s6">mean</span><span class="s5"> and standard deviation </span><span class="s6">sd</span><span class="s5">. The </span><span class="s6">mean</span><span class="s5"> and </span><span class="s6">sd</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the quantiles, or they may be vectors of the same length as </span><span class="s6">p</span><span class="s5">, specifying a value for each quantile computation.</span></p>
<p class="p4"><span class="s5">(float)rbeta(integer$ n, numeric alpha, numeric beta)</span></p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s6">n</span><span class="s5"> <b>random draws from a beta distribution</b> with parameters </span><span class="s6">alpha</span><span class="s5"> and </span><span class="s6">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">alpha</span><span class="s5"> and </span><span class="s6">beta</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s6">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>Draws are made from a beta distribution with probability density </span><span class="s10"><i>P</i>(<i>s</i> | <i>α</i>,<i>β</i>) = [Γ(<i>α</i>+<i>β</i>)/Γ(<i>α</i>)Γ(<i>β</i>)]<i>s</i></span><span class="s11"><i><sup>α</sup></i><sup>−1</sup></span><span class="s10">(1−<i>s</i>)</span><span class="s11"><i><sup>β</sup></i><sup>−1</sup></span><span class="s5">, where </span><span class="s10"><i>α</i></span><span class="s5"> is </span><span class="s6">alpha</span><span class="s5"> and </span><span class="s10"><i>β</i></span><span class="s5"> is </span><span class="s6">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>Both parameters must be greater than </span><span class="s6">0</span><span class="s5">.<span class="Apple-converted-space">  </span>The values drawn are in the interval [0, 1].</span></p>
<p class="p2">(integer)rbinom(integer$<span class="s1"> </span>n, integer size, float prob)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a binomial distribution</b> with a number of trials specified by <span class="s2">size</span> and a probability of success specified by <span class="s2">prob</span>.<span class="Apple-converted-space">  </span>The <span class="s2">size</span> and <span class="s2">prob</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p4"><span class="s5">(float)rcauchy(integer$ n, [numeric location = 0], [numeric scale = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s6">n</span><span class="s5"> <b>random draws from a Cauchy distribution</b> with location </span><span class="s6">location</span><span class="s5"> and scale </span><span class="s6">scale</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">location</span><span class="s5"> and </span><span class="s6">scale</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s6">n</span><span class="s5">, specifying a value for each draw.</span></p>
<p class="p2">(integer)rdunif(integer$ n, [integer min = 0], [integer max<span class="s1"> </span>= 1])</p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s6">n</span><span class="s5"> <b>random draws from a discrete uniform distribution</b> from </span><span class="s6">min</span><span class="s5"> to </span><span class="s6">max</span><span class="s5">, inclusive.<span class="Apple-converted-space">  </span>The </span><span class="s6">min</span><span class="s5"> and </span><span class="s6">max</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s6">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>See </span><span class="s6">runif()</span><span class="s5"> for draws from a continuous uniform distribution.</span></p>
<p class="p2">(float)rexp(integer$<span class="s1"> </span>n, [numeric mu = 1])</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from an exponential distribution</b> with mean <span class="s2">mu</span> (i.e. rate <span class="s2">1/mu</span>).<span class="Apple-converted-space">  </span>The <span class="s2">mu</span> parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p2">(float)rgamma(integer$<span class="s1"> </span>n, numeric mean, numeric shape)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a gamma distribution</b> with mean <span class="s2">mean</span> and shape parameter <span class="s2">shape</span>.<span class="Apple-converted-space">  </span>The <span class="s2">mean</span> and <span class="s2">shape</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.<span class="Apple-converted-space">  </span>Draws are made from a gamma distribution with probability density <span class="s3"><i>P</i>(<i>s</i> | </span><span class="s12"><i>α</i></span><span class="s3">,</span><span class="s12"><i>β</i></span><span class="s3">) = [</span><span class="s12">Γ</span><span class="s3">(</span><span class="s12"><i>α</i></span><span class="s3">)</span><span class="s12"><i>βα</i></span><span class="s3">]<sup>−1</sup>exp(−<i>s</i>/</span><span class="s12"><i>β</i></span><span class="s3">)</span>, where <span class="s12"><i>α</i></span> is the shape parameter <span class="s2">shape</span>, and the mean of the distribution given by <span class="s2">mean</span> is equal to <span class="s12"><i>αβ</i></span><span class="s3">.</span><span class="Apple-converted-space">  </span>Values of <span class="s2">mean</span> less than zero are allowed, and are equivalent (in principle) to the negation of a draw from a gamma distribution with the same <span class="s2">shape</span> parameter and the negation of the <span class="s2">mean</span> parameter.</p>
<p class="p4"><span class="s5">(integer)rgeom(integer$ n, float p)</span></p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s6">n</span><span class="s5"> <b>random draws from a geometric distribution</b> with parameter </span><span class="s6">p</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">p</span><span class="s5"> parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length </span><span class="s6">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>Eidos follows R in using the geometric distribution with support on the set {0, 1, 2, …}, where the drawn value indicates the number of failures prior to success.<span class="Apple-converted-space">  </span>There is an alternative definition, based upon the number of trial required to get one success, so beware.</span></p>
<p class="p2">(float)rlnorm(integer$<span class="s1"> </span>n, [numeric meanlog = 0], [numeric sdlog = 1])</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a lognormal distribution</b> with mean <span class="s2">meanlog</span> and standard deviation <span class="s2">sdlog</span>, specified on the log scale.<span class="Apple-converted-space">  </span>The <span class="s2">meanlog</span> and <span class="s2">sdlog</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p4"><span class="s5">(float)rmvnorm(integer$ n, numeric mu, numeric sigma)</span></p>
<p class="p5"><span class="s5">Returns a matrix of </span><span class="s6">n</span><span class="s5"> <b>random draws from a <i>k</i>-dimensional multivariate normal distribution</b> with a length <i>k</i> mean vector </span><span class="s6">mu</span><span class="s5"> and a <i>k</i> × <i>k</i> variance-covariance matrix </span><span class="s6">sigma</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">mu</span><span class="s5"> and </span><span class="s6">sigma</span><span class="s5"> parameters are used for all </span><span class="s6">n</span><span class="s5"> draws.<span class="Apple-converted-space">  </span>The draws are returned as a matrix with </span><span class="s6">n</span><span class="s5"> rows (one row per draw) and <i>k</i> columns (one column per dimension).<span class="Apple-converted-space">  </span>The number of dimensions <i>k</i> must be at least two; for <i>k</i>=1, use </span><span class="s6">rnorm()</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Cholesky decomposition of the variance-covariance matrix </span><span class="s6">sigma</span><span class="s5"> is involved as an internal step, and this requires that </span><span class="s6">sigma</span><span class="s5"> be positive-definite; if it is not, an error will result.<span class="Apple-converted-space">  </span>When more than one draw is needed, it is much more efficient to call </span><span class="s6">rmvnorm()</span><span class="s5"> once to generate all of the draws, since the Cholesky decomposition of </span><span class="s6">sigma</span><span class="s5"> can then be done just once.</span></p>
<p class="p2">(float)rnorm(integer$<span class="s1"> </span>n, [numeric mean = 0], [numeric sd = 1])</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a normal distribution</b> with mean <span class="s2">mean</span> and standard deviation <span class="s2">sd</span>.<span class="Apple-converted-space">  </span>The <span class="s2">mean</span> and <span class="s2">sd</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p2">(integer)rpois(integer$<span class="s1"> </span>n, numeric lambda)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a Poisson distribution</b> with parameter <span class="s2">lambda</span> (not to be confused with the language concept of a “lambda”; <span class="s2">lambda</span> here is just the name of a parameter, because the symbol typically used for the parameter of a Poisson distribution is the Greek letter <span class="s12">λ</span>).<span class="Apple-converted-space">  </span>The <span class="s2">lambda</span> parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p2">(float)runif(integer$ n, [numeric min = 0], [numeric max<span class="s1"> </span>= 1])</p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s6">n</span><span class="s5"> <b>random draws from a continuous uniform distribution</b> from </span><span class="s6">min</span><span class="s5"> to </span><span class="s6">max</span><span class="s5">, inclusive.<span class="Apple-converted-space">  </span>The </span><span class="s6">min</span><span class="s5"> and </span><span class="s6">max</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s6">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>See </span><span class="s6">rdunif()</span><span class="s5"> for draws from a discrete uniform distribution.</span></p>
<p class="p2">(float)rweibull(integer$<span class="s1"> </span>n, numeric lambda, numeric k)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a Weibull distribution</b> with scale parameter <span class="s2">lambda</span> and shape parameter <span class="s2">k</span>, both greater than zero.<span class="Apple-converted-space">  </span>The <span class="s2">lambda</span> and <span class="s2">k</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.<span class="Apple-converted-space">  </span>Draws are made from a Weibull distribution with probability distribution <span class="s3"><i>P</i>(<i>s</i> | </span><span class="s12"><i>λ</i></span><span class="s3">,<i>k</i>) = (<i>k</i> / </span><span class="s12"><i>λ</i></span><span class="s3"><i><sup>k</sup></i>) <i>s<sup>k</sup></i><sup>−1</sup> exp(-(<i>s</i>/</span><span class="s12"><i>λ</i></span><span class="s3">)<i><sup>k</sup></i>).</span></p>
<p class="p1"><b>3.4.<span class="Apple-converted-space">  </span>Vector construction functions</b></p>
<p class="p2">(*)c(...)</p>
<p class="p3">Returns the <b>concatenation</b> of all of its parameters into a single vector<span class="s13">, stripped of all matrix/array dimensions (see </span><span class="s14">rbind()</span><span class="s13"> and </span><span class="s14">cbind()</span><span class="s13"> for concatenation that does not strip this information)</span>.<span class="Apple-converted-space">  </span>The parameters will be promoted to the highest type represented among them, and that type will be the return type.<span class="Apple-converted-space">  </span><span class="s2">NULL</span> values are ignored; they have no effect on the result.</p>
<p class="p2">(float)float(integer$<span class="s1"> </span>length)</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>float</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">0.0</span> values.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p2">(integer)integer(integer$<span class="s1"> </span>length, [integer$ fill1 = 0], [integer$ fill2 = 1], [Ni fill2Indices = NULL])</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>integer</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">0</span> values by default.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p3">If a value is supplied for <span class="s2">fill1</span>, the new vector will be filled with that value instead of the default of <span class="s2">0</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Additionally, if a non-<span class="s2">NULL</span> vector is supplied for <span class="s2">fill2Indices</span>, the indices specified by <span class="s2">fill2Indices</span> will be filled with the value provided by <span class="s2">fill2</span><span class="s3">.</span><span class="Apple-converted-space">  </span>For example, given the default values of <span class="s2">0</span> and <span class="s2">1</span> for <span class="s2">fill1</span> and <span class="s2">fill2</span>, the returned vector will contain <span class="s2">1</span> at all positions specified by <span class="s2">fill2Indices</span>, and will contain <span class="s2">0</span> at all other positions.</p>
<p class="p2">(logical)logical(integer$<span class="s1"> </span>length)</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>logical</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">F</span> values.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p2">(object&lt;undefined&gt;)object(void)</p>
<p class="p3">Returns a <b>new empty </b><span class="s2"><b>object</b></span><b> vector</b>.<span class="Apple-converted-space">  </span>Unlike <span class="s2">float()</span>, <span class="s2">integer()</span>, <span class="s2">logical()</span>, and <span class="s2">string()</span>, a length cannot be specified and the new vector contains no elements.<span class="Apple-converted-space">  </span>This is because there is no default value for the object type.<span class="Apple-converted-space">  </span>Adding to such a vector is typically done with <span class="s2">c()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that the return value is of type <span class="s2">object&lt;undefined&gt;</span>; this method creates an <span class="s2">object</span> vector that does not know what element type it contains.<span class="Apple-converted-space">  </span>Such <span class="s2">object</span> vectors may be mixed freely with other <span class="s2">object</span> vectors in <span class="s2">c()</span> and similar contexts; the result of such mixing will take its <span class="s2">object</span>-element type from the <span class="s2">object</span> vector with a defined <span class="s2">object</span>-element type (if any).</p>
<p class="p2">(*)rep(*<span class="s1"> </span>x, integer$<span class="s1"> </span>count)</p>
<p class="p3">Returns the <b>repetition</b> of <span class="s2">x</span>: the entirety of <span class="s2">x</span> is repeated <span class="s2">count</span> times.<span class="Apple-converted-space">  </span>The return type matches the type of <span class="s2">x</span><span class="s3">.</span></p>
<p class="p2">(*)repEach(*<span class="s1"> </span>x, integer<span class="s1"> </span>count)</p>
<p class="p3">Returns the <b>repetition of elements</b> of <span class="s2">x</span>: each element of <span class="s2">x</span> is repeated.<span class="Apple-converted-space">  </span>If <span class="s2">count</span> is a singleton, it specifies the number of times that each element of <span class="s2">x</span> will be repeated.<span class="Apple-converted-space">  </span>Otherwise, the length of <span class="s2">count</span> must be equal to the length of <span class="s2">x</span>; in this case, each element of <span class="s2">x</span> is repeated a number of times specified by the corresponding value of <span class="s2">count</span><span class="s3">.</span></p>
<p class="p2">(*)sample(* x, integer$ size, [logical$<span class="s1"> </span>replace = F], [Nif weights = NULL])</p>
<p class="p3">Returns a vector of <span class="s2">size</span> containing a <b>sample from the elements of </b><span class="s2"><b>x</b></span>.<span class="Apple-converted-space">  </span>If <span class="s2">replace</span> is <span class="s2">T</span>, sampling is conducted with replacement (the same element may be drawn more than once); if it is <span class="s2">F</span> (the default), then sampling is done without replacement.<span class="Apple-converted-space">  </span>A vector of weights may be supplied in the optional parameter <span class="s2">weights</span>; if not <span class="s2">NULL</span>, it must be equal in size to <span class="s2">x</span>, all weights must be non-negative, and the sum of the weights must be greater than <span class="s2">0</span>.<span class="Apple-converted-space">  </span>If <span class="s2">weights</span> is <span class="s2">NULL</span> (the default), then equal weights are used for all elements of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>An error occurs if <span class="s2">sample()</span> runs out of viable elements from which to draw; most notably, if sampling is done without replacement then <span class="s2">size</span> must be at most equal to the size of <span class="s2">x</span>, but if weights of zero are supplied then the restriction on <span class="s2">size</span> will be even more stringent.<span class="Apple-converted-space">  </span>The draws are obtained from the standard Eidos random number generator, which might be shared with the Context.</p>
<p class="p2">(numeric)seq(numeric$<span class="s1"> </span>from, numeric$<span class="s1"> </span>to, [Nif$<span class="s1"> </span>by<span class="s1"> </span>= NULL], [Ni$<span class="s1"> </span>length = NULL])</p>
<p class="p3">Returns a <b>sequence</b>, starting at <span class="s2">from</span> and proceeding in the direction of <span class="s2">to</span> until the next value in the sequence would fall beyond <span class="s2">to</span>.<span class="Apple-converted-space">  </span>If the optional parameters <span class="s2">by</span> and <span class="s2">length</span> are both <span class="s2">NULL</span> (the default), the sequence steps by values of <span class="s2">1</span> or <span class="s2">-1</span> (as needed to proceed in the direction of <span class="s2">to</span>).<span class="Apple-converted-space">  </span>A different step value may be supplied with <span class="s2">by</span>, but must have the necessary sign.<span class="Apple-converted-space">  </span>Alternatively, a sequence length may be supplied in <span class="s2">length</span>, in which case the step magnitude will be chosen to produce a sequence of the requested length (with the necessary sign, as before).<span class="Apple-converted-space">  </span>If <span class="s2">from</span> and <span class="s2">to</span> are both <span class="s2">integer</span> then the return type will be <span class="s2">integer</span> when possible (but this may not be possible, depending upon values supplied for <span class="s2">by</span> or <span class="s2">length</span>), otherwise it will be <span class="s2">float</span><span class="s3">.</span></p>
<p class="p4"><span class="s5">(integer)seqAlong(* x)</span></p>
<p class="p5"><span class="s5">Returns an <b>index sequence along </b></span><span class="s6"><b>x</b></span><span class="s5">, from </span><span class="s6">0</span><span class="s5"> to </span><span class="s6">size(x) - 1</span><span class="s5">, with a step of </span><span class="s6">1</span><span class="s5">.<span class="Apple-converted-space">  </span>This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.<span class="Apple-converted-space">  </span>Any matrix/array dimension information is ignored; the index sequence is suitable for indexing into </span><span class="s6">x</span><span class="s5"> as a vector.</span></p>
<p class="p4"><span class="s5">(integer)seqLen(integer$ length)</span></p>
<p class="p5"><span class="s5">Returns an <b>index sequence of </b></span><span class="s6"><b>length</b></span><span class="s5">, from </span><span class="s6">0</span><span class="s5"> to </span><span class="s6">length - 1</span><span class="s5">, with a step of </span><span class="s6">1</span><span class="s5">; if </span><span class="s6">length</span><span class="s5"> is </span><span class="s6">0</span><span class="s5"> the sequence will be zero-length.<span class="Apple-converted-space">  </span>This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.<span class="Apple-converted-space">  </span>Note that when </span><span class="s6">length</span><span class="s5"> is </span><span class="s6">0</span><span class="s5">, using the sequence operator with </span><span class="s6">0:(length-1)</span><span class="s5"> will produce </span><span class="s6">0 -1</span><span class="s5">, and calling </span><span class="s6">seq(a, b, length=length)</span><span class="s5"> will raise an error, but </span><span class="s6">seqLen(length)</span><span class="s5"> will return </span><span class="s6">integer(0)</span><span class="s5">, making </span><span class="s6">seqLen()</span><span class="s5"> particularly useful for generating a sequence of a given length that might be zero.</span></p>
<p class="p2">(string)string(integer$<span class="s1"> </span>length)</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>string</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">""</span> values.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p1"><b>3.5.<span class="Apple-converted-space">  </span>Value inspection &amp; manipulation functions</b></p>
<p class="p2">(logical$)all(logical<span class="s1"> </span>x, ...)</p>
<p class="p3">Returns <span class="s2">T</span> if <b>all values are </b><span class="s2"><b>T</b></span> in <span class="s2">x</span> and in any other arguments supplied; if any value is <span class="s2">F</span>, returns <span class="s2">F</span><span class="s3">.</span><span class="Apple-converted-space">  </span>All arguments must be of <span class="s2">logical</span> type.<span class="Apple-converted-space">  </span>If all arguments are zero-length, <span class="s2">T</span> is returned.</p>
<p class="p2">(logical$)any(logical<span class="s1"> </span>x, ...)</p>
<p class="p3">Returns <span class="s2">T</span> if <b>any value is </b><span class="s2"><b>T</b></span> in <span class="s2">x</span> or in any other arguments supplied; if all values are <span class="s2">F</span>, returns <span class="s2">F</span><span class="s3">.</span><span class="Apple-converted-space">  </span>All arguments must be of <span class="s2">logical</span> type.<span class="Apple-converted-space">  </span>If all arguments are zero-length, <span class="s2">F</span> is returned.</p>
<p class="p2">(void)cat(*<span class="s1"> </span>x, [string$<span class="s1"> </span>sep<span class="s1"> </span>= " "])</p>
<p class="p3"><b>Concatenates output</b> to Eidos’s output stream, joined together by <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>The value <span class="s2">x</span> that is output may be of any type.<span class="Apple-converted-space">  </span>A newline is not appended to the output, unlike the behavior of <span class="s2">print()</span>; if a trailing newline is desired, you can use <span class="s2">"\n"</span> (or use the <span class="s2">catn()</span> function).<span class="Apple-converted-space">  </span>Also unlike <span class="s2">print()</span>, <span class="s2">cat()</span> tends to emit very literal output; <span class="s2">print(logical(0))</span> will emit “<span class="s2">logical(0)</span>”, for example – showing a semantic interpretation of the value – whereas <span class="s2">cat(logical(0))</span> will emit nothing at all, since there are no elements in the value (it is zero-length).<span class="Apple-converted-space">  </span>Similarly, <span class="s2">print(NULL)</span> will emit “<span class="s2">NULL</span>”, but <span class="s2">cat(NULL)</span> will emit nothing.</p>
<p class="p2">(void)catn([*<span class="s1"> </span>x<span class="s1"> </span>= ""], [string$<span class="s1"> </span>sep<span class="s1"> </span>= " "])</p>
<p class="p3"><b>Concatenates output (with a trailing newline)</b> to Eidos’s output stream, joined together by <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>The behavior of <span class="s2">catn()</span> is identical to that of <span class="s2">cat()</span>, except that a final newline character is appended to the output for convenience.<span class="Apple-converted-space">  </span>For <span class="s2">catn()</span> a default value of <span class="s2">""</span> is supplied for <span class="s2">x</span>, to allow a simple <span class="s2">catn()</span> call with no parameters to emit a newline.</p>
<p class="p2">(string)format(string$<span class="s1"> </span>format, numeric x)</p>
<p class="p3">Returns a vector of <b>formatted strings</b> generated from <span class="s2">x</span>, based upon the formatting string <span class="s2">format</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The <span class="s2">format</span> parameter may be any <span class="s2">string</span> value, but must contain exactly one escape sequence beginning with the <span class="s2">%</span> character.<span class="Apple-converted-space">  </span>This escape sequence specifies how to format a single value from the vector <span class="s2">x</span>.<span class="Apple-converted-space">  </span>The returned vector contains one <span class="s2">string</span> value for each element of <span class="s2">x</span>; each <span class="s2">string</span> value is identical to the string supplied in <span class="s2">format</span>, except with a formatted version of the corresponding value from <span class="s2">x</span> substituted in place of the escape sequence.</p>
<p class="p3">The syntax for <span class="s2">format</span> is a subset of the standard C/C++ <span class="s2">printf()</span>-style format strings (e.g., http://en.cppreference.com/w/c/io/fprintf).<span class="Apple-converted-space">  </span>The escape sequence used to format each value of x is composed of several elements:</p>
<ul class="ul1">
  <li class="li6">–<span class="Apple-converted-space">  </span>A <span class="s2">%</span> character at the beginning, initiating the escape sequence (if an actual <span class="s2">%</span> character is desired, rather than an escape sequence, <span class="s2">%%</span> may be used)</li>
  <li class="li6">–<span class="Apple-converted-space">  </span>Optional flags that modify the style of formatting:</li>
</ul>
<ul class="ul1">
  <li class="li6"><span class="s15">•<span class="Apple-tab-span">	</span></span><span class="s2">-</span> :<span class="Apple-tab-span">	</span>The value is left-justified with the field (as opposed to the default of right-justification).</li>
  <li class="li6"><span class="s15">•<span class="Apple-tab-span">	</span></span><span class="s2">+</span> :<span class="Apple-tab-span">	</span>The sign of the value is always prepended, even if the value is positive (as opposed to the default of appending the sign only if the value is negative).</li>
  <li class="li6"><span class="s16">•<span class="Apple-tab-span">	</span></span><i>space</i> :<span class="Apple-tab-span">	</span>The value is prepended by a space when a sign is not prepended.<span class="Apple-converted-space">  </span>This is ignored if the <span class="s2">+</span> flag is present, since values are then always prepended by a sign.</li>
  <li class="li6"><span class="s15">•<span class="Apple-tab-span">	</span></span><span class="s2">#</span> :<span class="Apple-tab-span">	</span>An alternative format is used.<span class="Apple-converted-space">  </span>For <span class="s2">%o</span>, at least one leading zero is always produced.<span class="Apple-converted-space">  </span>For <span class="s2">%x</span> and <span class="s2">%X</span>, <span class="s2">0x</span> or <span class="s2">0X</span> (respectively) is prepended if the value is nonzero.<span class="Apple-converted-space">  </span>For <span class="s2">%f</span>, <span class="s2">%F</span>, <span class="s2">%e</span>, <span class="s2">%E</span>, <span class="s2">%g</span>, and <span class="s2">%G</span>, a decimal point is forced even if no zeros follow.</li>
  <li class="li6"><span class="s15">•<span class="Apple-tab-span">	</span></span><span class="s2">0</span> :<span class="Apple-tab-span">	</span>The value is left-justified with the field (as opposed to the default of right-justification)</li>
</ul>
<ul class="ul1">
  <li class="li6">–<span class="Apple-converted-space">  </span>An optional minimum field width, specified as an integer value.<span class="Apple-converted-space">  </span>Fields will be padded out to this minimum width.<span class="Apple-converted-space">  </span>Padding will be done with space characters by default (or with zeros, if the <span class="s2">0</span> flag is used), on the left by default (or on the right, if the <span class="s2">-</span> flag is used).</li>
  <li class="li6">–<span class="Apple-converted-space">  </span>An optional precision, given as an integer value preceded by a <span class="s2">.</span> character.<span class="Apple-converted-space">  </span>If no integer value follows the <span class="s2">.</span> character, a precision of zero will be used.<span class="Apple-converted-space">  </span>For integer values of <span class="s2">x</span> (formatted with <span class="s2">%d</span>, <span class="s2">%i</span>, <span class="s2">%o</span>, <span class="s2">%x</span>, or <span class="s2">%X</span>) the precision specifies the minimum number of digits that will appear (with extra zeros on the left if necessary), with a default precision of <span class="s2">1</span><span class="s3">.</span><span class="Apple-converted-space">  </span>For float values of <span class="s2">x</span> formatted with <span class="s2">%f</span>, <span class="s2">%F</span>, <span class="s2">%e</span>, <span class="s2">%E</span>, <span class="s2">%g</span>, or <span class="s2">%G</span>, the precision specifies the minimum number of digits that will appear to the right of the decimal point (with extra zeros on the right if necessary), with a default precision of <span class="s2">6</span><span class="s3">.</span></li>
  <li class="li6">–<span class="Apple-converted-space">  </span>A format specifier.<span class="Apple-converted-space">  </span>For <span class="s2">integer</span> values, this may be <span class="s2">%d</span> or <span class="s2">%i</span> (producing base-10 output; there is no difference between the two), <span class="s2">%o</span> (producing base-8 or octal output), <span class="s2">%x</span> (producing base-16 hexadecimal output using lowercase letters), or <span class="s2">%X</span> (producing base-16 hexadecimal output using uppercase letters).<span class="Apple-converted-space">  </span>For <span class="s2">float</span> values, this may be <span class="s2">%f</span> or <span class="s2">%F</span> to produce decimal notation (of the form <span class="s2">[−]ddd.ddd</span>; there is no difference between the two), <span class="s2">%e</span> or <span class="s2">%E</span> to produce scientific notation (of the form <span class="s2">[−]d.ddde±dd</span> or <span class="s2">[−]d.dddE±dd</span>, respectively), or <span class="s2">%g</span> or <span class="s2">%G</span> to produce either decimal notation or scientific notation (using the formatting of <span class="s2">%f</span> / <span class="s2">%e</span> or <span class="s2">%F</span> / <span class="s2">%E</span>, respectively) on a per-value basis, depending upon the range of the value.</li>
</ul>
<p class="p3">Note that relative to the standard C/C++ <span class="s2">printf()</span>-style behavior, there are a few differences: (1) only a single escape sequence may be present in the format string, (2) the use of <span class="s2">*</span> to defer field width and precision values to a passed parameter is not supported, (3) only <span class="s2">integer</span> and <span class="s2">float</span> values of <span class="s2">x</span> are supported, (4) only the <span class="s2">%d</span>, <span class="s2">%i</span>, <span class="s2">%o</span>, <span class="s2">%x</span>, <span class="s2">%X</span>, <span class="s2">%f</span>, <span class="s2">%F</span>, <span class="s2">%e</span>, <span class="s2">%E</span>, <span class="s2">%g</span>, and <span class="s2">%G</span> format specifiers are supported, and (5) no length modifiers may be supplied, since Eidos does not support different sizes of the <span class="s2">integer</span> and <span class="s2">float</span> types.<span class="Apple-converted-space">  </span>Note also that the Eidos conventions of emitting <span class="s2">INF</span> and <span class="s2">NAN</span> for infinities and Not-A-Number values respectively is not honored by this function; the strings generated for such values are platform-dependent, following the implementation definition of the C++ compiler used to build Eidos, since <span class="s2">format()</span> calls through to <span class="s2">snprintf()</span> to assemble the final string values.</p>
<p class="p3">For example, <span class="s2">format("A number: %+7.2f", c(-4.1, 15.375, 8))</span> will produce a vector with three elements: <span class="s2">"A number: <span class="Apple-converted-space">  </span>-4.10" "A number:<span class="Apple-converted-space">  </span>+15.38" "A number: <span class="Apple-converted-space">  </span>+8.00"</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The precision of <span class="s2">.2</span> results in two digits after the decimal point, the minimum field width of <span class="s2">7</span> results in padding of the values on the left (with spaces) to a minimum of seven characters, the flag <span class="s2">+</span> causes a sign to be shown on positive values as well as negative values, and the format specifier <span class="s2">f</span> leads to the <span class="s2">float</span> values of <span class="s2">x</span> being formatted in base-10 decimal.<span class="Apple-converted-space">  </span>One <span class="s2">string</span> value is produced in the result vector for each value in the parameter <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>These values could then be merged into a single string with <span class="s2">paste()</span>, for example, or printed with <span class="s2">print()</span> or <span class="s2">cat()</span><span class="s3">.</span></p>
<p class="p2">(logical$)identical(* x, * y)</p>
<p class="p3">Returns a <span class="s2">logical</span> value indicating <b>whether two values are identical</b>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">y</span> have exactly the same type and size, and all of their corresponding elements are exactly the same, <span class="s13">and (for matrices and arrays) their dimensions are identical, </span>this will return <span class="s2">T</span>, otherwise it will return <span class="s2">F</span>.<span class="Apple-converted-space">  </span>The test here is for <i>exact</i> equality; an <span class="s2">integer</span> value of <span class="s2">1</span> is not considered identical to a <span class="s2">float</span> value of <span class="s2">1.0</span>, for example.<span class="Apple-converted-space">  </span>Elements in <span class="s2">object</span> values must be literally the same element, not simply identical in all of their properties.<span class="Apple-converted-space">  </span>Type promotion is never done.<span class="Apple-converted-space">  </span>For testing whether two values are the same, this is generally preferable to the use of operator <span class="s2">==</span> or operator <span class="s2">!=</span>.<span class="Apple-converted-space">  </span>Note that <span class="s2">identical(NULL,NULL)</span> is <span class="s2">T</span><span class="s3">.</span></p>
<p class="p2">(*)ifelse(logical test, * trueValues, * falseValues)</p>
<p class="p3">Returns the result of a <b>vector conditional</b> operation: a vector composed of values from <span class="s2">trueValues</span>, for indices where <span class="s2">test</span> is <span class="s2">T</span>, and values from <span class="s2">falseValues</span>, for indices where <span class="s2">test</span> is <span class="s2">F</span>.<span class="Apple-converted-space">  </span>The lengths of <span class="s2">trueValues</span> and <span class="s2">falseValues</span> must either be equal to <span class="s2">1</span> or to the length of <span class="s2">test</span>; however, <span class="s2">trueValues</span> and <span class="s2">falseValues</span> don’t need to be the same length as each other.<span class="Apple-converted-space">  </span>Furthermore, the type of <span class="s2">trueValues</span> and <span class="s2">falseValues</span> must be the same (including, if they are <span class="s2">object</span> type, their element type).<span class="Apple-converted-space">  </span>The return will be of the same length as <span class="s2">test</span>, and of the same type as <span class="s2">trueValues</span> and <span class="s2">falseValues</span>.<span class="Apple-converted-space">  </span>Each element of the return vector will be taken from the corresponding element of <span class="s2">trueValues</span> if the corresponding element of <span class="s2">test</span> is <span class="s2">T</span>, or from the corresponding element of <span class="s2">falseValues</span> if the corresponding element of <span class="s2">test</span> is <span class="s2">F</span>; if the vector from which the value is to be taken (i.e., <span class="s2">trueValues</span> or <span class="s2">falseValues</span>) has a length of <span class="s2">1</span>, that single value is used repeatedly, recycling the vector.<span class="s13"><span class="Apple-converted-space">  </span>If </span><span class="s14">test</span><span class="s13">, </span><span class="s14">trueValues</span><span class="s13">, and/or </span><span class="s14">falseValues</span><span class="s13"> are matrices or arrays, that will be ignored by </span><span class="s14">ifelse()</span><span class="s13"> <i>except</i> that the result will be of the same dimensionality as </span><span class="s14">test</span><span class="s13">.</span></p>
<p class="p3">This is quite similar to a function in R of the same name; note, however, that Eidos evaluates all arguments to functions calls immediately, so <span class="s2">trueValues</span> and <span class="s2">falseValues</span> will be evaluated fully regardless of the values in <span class="s2">test</span>, unlike in R.<span class="Apple-converted-space">  </span>Value expressions without side effects are therefore recommended.</p>
<p class="p4"><span class="s5">(integer$)length(* x)</span></p>
<p class="p5"><span class="s5">Returns the <b>size</b> (e.g., length) of </span><span class="s6">x</span><span class="s5">: the number of elements contained in </span><span class="s6">x</span><span class="s5">.<span class="Apple-converted-space">  </span>Note that </span><span class="s6">length()</span><span class="s5"> is a synonym for </span><span class="s6">size()</span><span class="s5">.</span></p>
<p class="p2">(integer)match(* x, * table)</p>
<p class="p3">Returns a vector of the <b>positions of (first) matches</b> of <span class="s2">x</span> in <span class="s2">table</span>.<span class="Apple-converted-space">  </span>Type promotion is not performed; x and <span class="s2">table</span> must be of the same type.<span class="Apple-converted-space">  </span>For each element of <span class="s2">x</span>, the corresponding element in the result will give the position of the first match for that element of <span class="s2">x</span> in <span class="s2">table</span>; if the element has no match in <span class="s2">table</span>, the element in the result vector will be <span class="s2">-1</span>.<span class="Apple-converted-space">  </span>The result is therefore a vector of the same length as <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If a <span class="s2">logical</span> result is desired, with <span class="s2">T</span> indicating that a match was found for the corresponding element of <span class="s2">x</span>, use <span class="s2">(match(x, table) &gt;= 0)</span><span class="s3">.</span></p>
<p class="p2">(integer)nchar(string<span class="s1"> </span>x)</p>
<p class="p3">Returns a vector of the <b>number of characters</b> in the string-elements of <span class="s2">x</span><span class="s3">.</span></p>
<p class="p2">(integer)order(+ x, [logical$<span class="s1"> </span>ascending<span class="s1"> </span>= T])</p>
<p class="p3">Returns a <b>vector of sorting indices</b> for <span class="s2">x</span>: a new <span class="s2">integer</span> vector of the same length as <span class="s2">x</span>, containing the indices into <span class="s2">x</span> that would sort <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, <span class="s2">x[order(x)]==sort(x)</span>.<span class="Apple-converted-space">  </span>This can be useful for more complex sorting problems, such as sorting several vectors in parallel by a sort order determined by one of the vectors.<span class="Apple-converted-space">  </span>If the optional <span class="s2">logical</span> parameter <span class="s2">ascending</span> is <span class="s2">T</span> (the default), then the sorted order will be ascending; if it is <span class="s2">F</span>, the sorted order will be descending.<span class="Apple-converted-space">  </span>The ordering is determined according to the same logic as the <span class="s2">&lt;</span> and <span class="s2">&gt;</span> operators in Eidos.<span class="Apple-converted-space">  </span>To easily sort vectors in a single step, use <span class="s2">sort()</span> or <span class="s2">sortBy()</span>, for non-<span class="s2">object</span> and <span class="s2">object</span> vectors respectively.</p>
<p class="p2">(string$)paste(* x, [string$<span class="s1"> </span>sep<span class="s1"> </span>= " "])</p>
<p class="p3">Returns a <b>joined string</b> composed from the <span class="s2">string</span> representations of the elements of <span class="s2">x</span>, joined together by <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>Although this function is based upon the R function of the same name, note that it is much simpler and less powerful; in particular, only the elements of a single vector may be joined, rather than the var-args functionality of the R <span class="s2">paste()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The string representation used by <span class="s2">paste()</span> is the same as that emitted by <span class="s2">cat()</span><span class="s3">.</span></p>
<p class="p2">(string$)paste<span class="s1">0</span>(* x)</p>
<p class="p3">Returns a <b>joined string</b> composed from the <span class="s2">string</span> representations of the elements of <span class="s2">x</span>, joined together with no separator.<span class="Apple-converted-space">  </span>This function is identical to <span class="s2">paste()</span>, except that no separator is used.</p>
<p class="p2">(void)print(*<span class="s1"> </span>x)</p>
<p class="p3"><b>Prints output</b> to Eidos’s output stream.<span class="Apple-converted-space">  </span>The value <span class="s2">x</span> that is output may be of any type.<span class="Apple-converted-space">  </span>A newline is appended to the output.<span class="Apple-converted-space">  </span>See <span class="s2">cat()</span> for a discussion of the differences between <span class="s2">print()</span> and <span class="s2">cat()</span><span class="s3">.</span></p>
<p class="p2">(*)rev(*<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>reverse</b> of <span class="s2">x</span>: a new vector with the same elements as <span class="s2">x</span>, but in the opposite order.</p>
<p class="p2">(integer$)size(*<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>size</b> of <span class="s2">x</span>: the number of elements contained in <span class="s2">x</span><span class="s3">.</span><span class="s13"><span class="Apple-converted-space">  </span>Note that </span><span class="s14">length()</span><span class="s13"> is a synonym for </span><span class="s14">size()</span><span class="s13">.</span></p>
<p class="p2">(+)sort(+ x, [logical$<span class="s1"> </span>ascending<span class="s1"> </span>= T])</p>
<p class="p3">Returns a <b>sorted copy</b> of <span class="s2">x</span>: a new vector with the same elements as <span class="s2">x</span>, but in sorted order.<span class="Apple-converted-space">  </span>If the optional <span class="s2">logical</span> parameter <span class="s2">ascending</span> is <span class="s2">T</span> (the default), then the sorted order will be ascending; if it is <span class="s2">F</span>, the sorted order will be descending.<span class="Apple-converted-space">  </span>The ordering is determined according to the same logic as the <span class="s2">&lt;</span> and <span class="s2">&gt;</span> operators in Eidos.<span class="Apple-converted-space">  </span>To sort an <span class="s2">object</span> vector, use <span class="s2">sortBy()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>To obtain indices for sorting, use <span class="s2">order()</span><span class="s3">.</span></p>
<p class="p2">(object)sortBy(object x, string$<span class="s1"> </span>property, [logical$<span class="s1"> </span>ascending<span class="s1"> </span>= T])</p>
<p class="p3">Returns a <b>sorted copy</b> of <span class="s2">x</span>: a new vector with the same elements as <span class="s2">x</span>, but in sorted order.<span class="Apple-converted-space">  </span>If the optional <span class="s2">logical</span> parameter <span class="s2">ascending</span> is <span class="s2">T</span> (the default), then the sorted order will be ascending; if it is <span class="s2">F</span>, the sorted order will be descending.<span class="Apple-converted-space">  </span>The ordering is determined according to the same logic as the <span class="s2">&lt;</span> and <span class="s2">&gt;</span> operators in Eidos.<span class="Apple-converted-space">  </span>The <span class="s2">property</span> argument gives the name of the property within the elements of <span class="s2">x</span> according to which sorting should be done.<span class="Apple-converted-space">  </span>This must be a simple property name; it cannot be a property path.<span class="Apple-converted-space">  </span>For example, to sort a <span class="s2">Mutation</span> vector by the selection coefficients of the mutations, you would simply pass <span class="s2">"selectionCoeff"</span>, including the quotes, for <span class="s2">property</span><span class="s3">.</span><span class="Apple-converted-space">  </span>To sort a non-<span class="s2">object</span> vector, use <span class="s2">sort()</span>.<span class="Apple-converted-space">  </span>To obtain indices for sorting, use <span class="s2">order()</span><span class="s3">.</span></p>
<p class="p2">(void)str(*<span class="s1"> </span>x)</p>
<p class="p3"><b>Prints the structure</b> of <span class="s2">x</span>: a summary of its type and the values it contains.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is an <span class="s2">object</span><span class="s3">,</span> note that <span class="s2">str()</span> produces different results from the <span class="s2">str()</span> method of <span class="s2">x</span>; the <span class="s2">str()</span> function prints the external structure of <span class="s2">x</span> (the fact that it is an object, and the number and type of its elements), whereas the <span class="s2">str()</span> method prints the internal structure of <span class="s2">x</span> (the external structure of all the properties contained by <span class="s2">x</span>).</p>
<p class="p2">(string)strsplit(string$<span class="s1"> </span>x, [string$<span class="s1"> </span>sep<span class="s1"> </span>= " "])</p>
<p class="p3">Returns <b>substrings</b> of <span class="s2">x</span> that were separated by the separator string <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>Every substring defined by an occurrence of the separator is included, and thus zero-length substrings may be returned.<span class="Apple-converted-space">  </span>For example, <span class="s2">strsplit(".foo..bar.", ".")</span> returns a string vector containing <span class="s2">""</span>, <span class="s2">"foo"</span>, <span class="s2">""</span>, <span class="s2">"bar"</span>, <span class="s2">""</span>.<span class="Apple-converted-space">  </span>In that example, the empty string between <span class="s2">"foo"</span> and <span class="s2">"bar"</span> in the returned vector is present because there were two periods between <span class="s2">foo</span> and <span class="s2">bar</span> in the input string – the empty string is the substring between those two separators.<span class="Apple-converted-space">  </span>Note that <span class="s2">paste()</span> performs the inverse operation of <span class="s2">strsplit()</span><span class="s3">.</span></p>
<p class="p2">(string)substr(string x, integer first, [Ni last = NULL])</p>
<p class="p3">Returns <b>substrings</b> extracted from the elements of <span class="s2">x,</span> spanning character position <span class="s2">first</span> to character position <span class="s2">last</span> (inclusive).<span class="Apple-converted-space">  </span>Character positions are numbered from <span class="s2">0</span> to <span class="s2">nchar(x)-1</span>.<span class="Apple-converted-space">  </span>Positions that fall outside of that range are legal; a substring range that encompasses no characters will produce an empty string.<span class="Apple-converted-space">  </span>If <span class="s2">first</span> is greater than <span class="s2">last</span>, an empty string will also result.<span class="Apple-converted-space">  </span>If <span class="s2">last</span> is NULL (the default), then the substring will extend to the end of the string.<span class="Apple-converted-space">  </span>The parameters <span class="s2">first</span> and <span class="s2">last</span> may either be singletons, specifying a single value to be used for all of the substrings, or they may be vectors of the same length as <span class="s2">x</span>, specifying a value for each substring.</p>
<p class="p2">(*)unique(* x, [logical$ preserveOrder = T])</p>
<p class="p3">Returns the <b>unique values</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, for each value <span class="s2">k</span> in <span class="s2">x</span> that occurs at least once, the vector returned will contain <span class="s2">k</span> exactly once.<span class="Apple-converted-space">  </span>If <span class="s2">preserveOrder</span> is <span class="s2">T</span> (the default), the order of values in <span class="s2">x</span> is preserved, taking the first instance of each value; this is relatively slow, with O(<i>n</i>^2) performance.<span class="Apple-converted-space">  </span>If <span class="s2">preserveOrder</span> if <span class="s2">F</span> instead, the order of values in <span class="s2">x</span> is not preserved, and no particular ordering should be relied upon; this is relatively fast, with O(<i>n</i> log <i>n</i>) performance.<span class="Apple-converted-space">  </span>This performance difference will only matter for large vectors, however; for most applications the default behavior can be retained whether the order of the result matters or not.</p>
<p class="p2">(integer)which(logical<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>indices of </b><span class="s2"><b>T</b></span><b> values</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, if an index <span class="s2">k</span> in <span class="s2">x</span> is <span class="s2">T</span>, then the vector returned will contain <span class="s2">k</span>; if index <span class="s2">k</span> in <span class="s2">x</span> is <span class="s2">F</span>, the vector returned will omit <span class="s2">k</span>.<span class="Apple-converted-space">  </span>One way to look at this is that it converts from a <span class="s2">logical</span> subsetting vector to an <span class="s2">integer</span> (index-based) subsetting vector, without changing which subset positions would be selected.</p>
<p class="p2">(integer$)whichMax(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>index of the (first) maximum value</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, if <span class="s2">k</span> is equal to the maximum value in <span class="s2">x</span>, then the vector returned will contain the index of the first occurrence of <span class="s2">k</span> in <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If the maximum value is unique, the result is the same as (but more efficient than) the expression <span class="s2">which(x==max(x))</span>, which returns the indices of <i>all</i> of the occurrences of the maximum value in <span class="s2">x</span><span class="s3">.</span></p>
<p class="p2">(integer$)whichMin(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>index of the (first) minimum value</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, if <span class="s2">k</span> is equal to the minimum value in <span class="s2">x</span>, then the vector returned will contain the index of the first occurrence of <span class="s2">k</span> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If the minimum value is unique, the result is the same as (but more efficient than) the expression <span class="s2">which(x==min(x))</span>, which returns the indices of <i>all</i> of the occurrences of the minimum value in <span class="s2">x</span><span class="s3">.</span></p>
<p class="p1"><b>3.6.<span class="Apple-converted-space">  </span>Value type testing and coercion functions</b></p>
<p class="p2">(float)asFloat(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>conversion to </b><span class="s2"><b>float</b></span> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">string</span> and cannot be converted to <span class="s2">float</span>, Eidos will throw an error.</p>
<p class="p2">(integer)asInteger(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>conversion to </b><span class="s2"><b>integer</b></span> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">string</span> or <span class="s2">float</span> and cannot be converted to <span class="s2">integer</span>, Eidos will throw an error.</p>
<p class="p2">(logical)asLogical(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>conversion to </b><span class="s2"><b>logical</b></span> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Recall that in Eidos the empty <span class="s2">string</span> <span class="s2">""</span> is considered <span class="s2">F</span>, and all other <span class="s2">string</span> values are considered <span class="s2">T</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Converting <span class="s2">INF</span> or <span class="s2">-INF</span> to <span class="s2">logical</span> yields <span class="s2">T</span> (since those values are not equal to zero); converting <span class="s2">NAN</span> to <span class="s2">logical</span> throws an error.</p>
<p class="p2">(string)asString(+<span class="s1"> </span>x)</p>
<p class="p5"><span class="s7">Returns the <b>conversion to </b></span><span class="s8"><b>string</b></span><span class="s7"> of </span><span class="s8">x</span><span class="s9">.</span><span class="s5"><span class="Apple-converted-space">  </span>Note that </span><span class="s6">asString(NULL)</span><span class="s5"> returns </span><span class="s6">"NULL"</span><span class="s5"> even though </span><span class="s6">NULL</span><span class="s5"> is zero-length.</span></p>
<p class="p2">(string$)elementType(*<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>element type</b> of <span class="s2">x</span>, as a <span class="s2">string</span>.<span class="Apple-converted-space">  </span>For the non-<span class="s2">object</span> types, the element type is the same as the type: <span class="s2">"NULL"</span>, <span class="s2">"logical"</span>, <span class="s2">"integer"</span>, <span class="s2">"float"</span>, or <span class="s2">"string"</span>.<span class="Apple-converted-space">  </span>For <span class="s2">object</span> type, however, <span class="s2">elementType()</span> returns the name of the type of element contained by the object, such as <span class="s2">"SLiMSim"</span> or <span class="s2">"Mutation"</span> in the Context of SLiM.<span class="Apple-converted-space">  </span>Contrast this with <span class="s2">type()</span><span class="s3">.</span></p>
<p class="p2">(logical$)isFloat(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>float</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isInteger(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>integer</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isLogical(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>logical</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isNULL(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>NULL</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isObject(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>object</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isString(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>string</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(string$)type(*<span class="s1"> </span>x)</p>
<p class="p7"><span class="s17">Returns the <b>type</b> of </span>x<span class="s17">, as a </span>string<span class="s17">: </span>"NULL"<span class="s17">, </span>"logical"<span class="s17">, </span>"integer"<span class="s17">, </span>"float"<span class="s17">, </span>"string"<span class="s17">, or </span>"object"<span class="s17">.<span class="Apple-converted-space">  </span>Contrast this with </span>elementType()<span class="s3">.</span></p>
<p class="p1"><b>3.7.<span class="Apple-converted-space">  </span>Matrix and array functions</b></p>
<p class="p2">(*)apply(* x, integer margin, string$ lambdaSource)</p>
<p class="p8"><span class="s5"><i>Prior to Eidos 1.6 / SLiM 2.6, </i></span><span class="s6"><i>sapply()</i></span><span class="s5"><i> was named </i></span><span class="s6"><i>apply()</i></span><span class="s5"><i>, and this function did not yet exist</i></span></p>
<p class="p5"><span class="s5"><b>Applies a block of Eidos code to margins of x</b>.<span class="Apple-converted-space">  </span>This function is essentially an extension of </span><span class="s6">sapply()</span><span class="s5"> for use with matrices and arrays; it is recommended that you fully understand </span><span class="s6">sapply()</span><span class="s5"> before tackling this function.<span class="Apple-converted-space">  </span>As with </span><span class="s6">sapply()</span><span class="s5">, the lambda specified by </span><span class="s6">lambdaSource</span><span class="s5"> will be executed for subsets of </span><span class="s6">x</span><span class="s5">, and the results will be concatenated together with type-promotion in the style of </span><span class="s6">c()</span><span class="s5"> to produce a result.<span class="Apple-converted-space">  </span>Unlike </span><span class="s6">sapply()</span><span class="s5">, however, the subsets of </span><span class="s6">x</span><span class="s5"> used might be rows, columns, or higher-dimensional slices of </span><span class="s6">x</span><span class="s5">, rather than just single elements, depending upon the value of </span><span class="s6">margin</span><span class="s5">.<span class="Apple-converted-space">  </span>For </span><span class="s6">apply()</span><span class="s5">, </span><span class="s6">x</span><span class="s5"> must be a matrix or array.<span class="Apple-converted-space">  </span>The </span><span class="s6">apply()</span><span class="s5"> function in Eidos is patterned directly after the </span><span class="s6">apply()</span><span class="s5"> function in R, and should behave identically, except that dimension indices in Eidos are zero-based whereas in R they are one-based.</span></p>
<p class="p5"><span class="s5">The </span><span class="s6">margin</span><span class="s5"> parameter gives the indices of dimensions of </span><span class="s6">x</span><span class="s5"> that will be iterated over when assembling values to supply to lambdaSource.<span class="Apple-converted-space">  </span>If </span><span class="s6">x</span><span class="s5"> is a matrix it has two dimensions: rows, of dimension index </span><span class="s6">0</span><span class="s5">, and columns, of dimension index </span><span class="s6">1</span><span class="s5">.<span class="Apple-converted-space">  </span>These are the indices of the dimension sizes returned by </span><span class="s6">dim()</span><span class="s5">; </span><span class="s6">dim(x)[0]</span><span class="s5"> gives the number of rows of </span><span class="s6">x</span><span class="s5">, and </span><span class="s6">dim(x)[1]</span><span class="s5"> gives the number of columns.<span class="Apple-converted-space">  </span>These dimension indices are also apparent when subsetting </span><span class="s6">x</span><span class="s5">; a subset index in position </span><span class="s6">0</span><span class="s5">, such as </span><span class="s6">x[m,]</span><span class="s5">, gives row </span><span class="s6">m</span><span class="s5"> of </span><span class="s6">x</span><span class="s5">, whereas a subset index in position </span><span class="s6">1</span><span class="s5">, such as </span><span class="s6">x[,n]</span><span class="s5">, gives column </span><span class="s6">n</span><span class="s5"> of </span><span class="s6">x</span><span class="s5">.<span class="Apple-converted-space">  </span>In the same manner, supplying </span><span class="s6">0</span><span class="s5"> for </span><span class="s6">margin</span><span class="s5"> specifies that subsets of </span><span class="s6">x</span><span class="s5"> from </span><span class="s6">x[0,]</span><span class="s5"> to </span><span class="s6">x[m,]</span><span class="s5"> should be “passed” to </span><span class="s6">lambdaSource</span><span class="s5">, through the </span><span class="s6">applyValue</span><span class="s5"> “parameter”; dimension </span><span class="s6">0</span><span class="s5"> is iterated over, whereas dimension </span><span class="s6">1</span><span class="s5"> is taken in aggregate since it is not included in </span><span class="s6">margin</span><span class="s5">.<span class="Apple-converted-space">  </span>The final effect of this is that whole rows of </span><span class="s6">x</span><span class="s5"> are passed to </span><span class="s6">lambdaSource</span><span class="s5"> through </span><span class="s6">applyValue</span><span class="s5">.<span class="Apple-converted-space">  </span>Similarly, </span><span class="s6">margin=1</span><span class="s5"> would specify that subsets of </span><span class="s6">x</span><span class="s5"> from </span><span class="s6">x[,0]</span><span class="s5"> to </span><span class="s6">x[,n]</span><span class="s5"> should be passed to </span><span class="s6">lambdaSource</span><span class="s5">, resulting in whole columns being passed.<span class="Apple-converted-space">  </span>Specifying </span><span class="s6">margin=c(0,1)</span><span class="s5"> would indicate that dimensions </span><span class="s6">0</span><span class="s5"> and </span><span class="s6">1</span><span class="s5"> should both be iterated over (dimension </span><span class="s6">0</span><span class="s5"> more rapidly), so for a matrix each each individual value of </span><span class="s6">x</span><span class="s5"> would be passed to l</span><span class="s6">ambdaSource</span><span class="s5">.<span class="Apple-converted-space">  </span>Specifying </span><span class="s6">margin=c(1,0)</span><span class="s5"> would similarly iterate over both dimensions, but dimension </span><span class="s6">1</span><span class="s5"> more rapidly; the traversal order would therefore be different, and the dimensionality of the result would also differ (see below).<span class="Apple-converted-space">  </span>For higher-dimensional arrays dimension indices beyond </span><span class="s6">1</span><span class="s5"> exist, and so </span><span class="s6">margin=c(0,1)</span><span class="s5"> or </span><span class="s6">margin=c(1,0)</span><span class="s5"> would provide slices of </span><span class="s6">x</span><span class="s5"> to </span><span class="s6">lambdaSource</span><span class="s5">, each slice having a specific row and column index.<span class="Apple-converted-space">  </span>Slices are generated by subsetting in the same way as operator </span><span class="s6">[]</span><span class="s5">, but additionally, redundant dimensions are dropped as by </span><span class="s6">drop()</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">The return value from </span><span class="s6">apply()</span><span class="s5"> is built up from the type-promoted concatenated results, as if by the </span><span class="s6">c()</span><span class="s5"> function, from the iterated execution of </span><span class="s6">lambdaSource</span><span class="s5">; the only question is what dimensional structure is imposed upon that vector of values.<span class="Apple-converted-space">  </span>If the results from </span><span class="s6">lambdaSource</span><span class="s5"> are not of a consistent length, or are of length zero, then the concatenated results are returned as a plain vector.<span class="Apple-converted-space">  </span>If all results are of length </span><span class="s6">n &gt; 1</span><span class="s5">, the return value is an array of dimensions </span><span class="s6">c(n, dim(x)[margin]);</span><span class="s5"> in other words, each </span><span class="s6">n</span><span class="s5">-vector provides the lowest dimension of the result, and the sizes of the marginal dimensions are imposed upon the data above that.<span class="Apple-converted-space">  </span>If all results are of length </span><span class="s6">n == 1</span><span class="s5">, then if a single margin was specified the result is a vector (of length equal to the size of that marginal dimension), or if more than one margin was specified the result is an array of dimension </span><span class="s6">dim(x)[margin]</span><span class="s5">; in other words, the sizes of the marginal dimensions are imposed upon the data.<span class="Apple-converted-space">  </span>Since </span><span class="s6">apply()</span><span class="s5"> iterates over the marginal dimensions in the same manner, these structures follows the structure of the data.</span></p>
<p class="p5"><span class="s5">The above explanation may not be entirely clear, so let’s look at an example.<span class="Apple-converted-space">  </span>If </span><span class="s6">x</span><span class="s5"> is a matrix with two rows and three columns, such as defined by </span><span class="s6">x = matrix(1:6, nrow=2);</span><span class="s5">, then executing </span><span class="s6">apply(x, 0, "sum(applyValue);");</span><span class="s5"> would cause each row of </span><span class="s6">x</span><span class="s5"> to be supplied to the lambda through </span><span class="s6">applyValue</span><span class="s5">, and the values in each row would thus be summed to produce </span><span class="s6">9 12</span><span class="s5"> as a result.<span class="Apple-converted-space">  </span>The call </span><span class="s6">apply(x, 1, "sum(applyValue);");</span><span class="s5"> would instead sum columns of </span><span class="s6">x</span><span class="s5">, producing </span><span class="s6">3 7 11</span><span class="s5"> as a result.<span class="Apple-converted-space">  </span>Now consider using </span><span class="s6">range()</span><span class="s5"> rather than </span><span class="s6">sum()</span><span class="s5"> in the lambda, thus producing two values for each row or column.<span class="Apple-converted-space">  </span>The call </span><span class="s6">apply(x, 0, "range(applyValue);");</span><span class="s5"> produces a result of </span><span class="s6">matrix(c(1,5,2,6), nrow=2)</span><span class="s5">, with the range of the first row of </span><span class="s6">x</span><span class="s5">, 1–5, in the first column of the result, and the range of the second row of </span><span class="s6">x</span><span class="s5">, 2–6, in the second column.<span class="Apple-converted-space">  </span>Although visualization becomes more difficult, these same patterns extend to higher dimensions and arbitrary margins of </span><span class="s6">x</span><span class="s5">.</span></p>
<p class="p2">(*)array(* data, integer dim)</p>
<p class="p5"><span class="s5"><b>Creates a new array</b> from the data specified by </span><span class="s6">data</span><span class="s5">, with the dimension sizes specified by </span><span class="s6">dim</span><span class="s5">.<span class="Apple-converted-space">  </span>The first dimension size in </span><span class="s6">dim</span><span class="s5"> is the number of rows, and the second is the number of columns; further entries specify the sizes of higher-order dimensions.<span class="Apple-converted-space">  </span>As many dimensions may be specified as desired, but with a minimum of two dimensions.<span class="Apple-converted-space">  </span>An array with two dimensions is a matrix (by definition); note that </span><span class="s6">matrix()</span><span class="s5"> may provide a more convenient way to make a new matrix.<span class="Apple-converted-space">  </span>Each dimension must be of size </span><span class="s6">1</span><span class="s5"> or greater; </span><span class="s6">0</span><span class="s5">-size dimensions are not allowed.</span></p>
<p class="p5"><span class="s5">The elements of </span><span class="s6">data</span><span class="s5"> are used to populate the new array; the size of </span><span class="s6">data</span><span class="s5"> must therefore be equal to the size of the new array, which is the product of all the values in </span><span class="s6">dim</span><span class="s5">.<span class="Apple-converted-space">  </span>The new array will be filled in dimension order: one element in each row until a column is filled, then on to the next column in the same manner until all columns are filled, and then onward into the higher-order dimensions in the same manner.</span></p>
<p class="p2">(*)cbind(...)</p>
<p class="p5"><span class="s5"><b>Combines vectors or matrices by column</b> to produce a single matrix.<span class="Apple-converted-space">  </span>The parameters must be vectors (which are interpreted by </span><span class="s6">cbind()</span><span class="s5"> as if they were one-column matrices) or matrices.<span class="Apple-converted-space">  </span>They must be of the same type, of the same class if they are of type </span><span class="s6">object</span><span class="s5">, and have the same number of rows.<span class="Apple-converted-space">  </span>If these conditions are met, the result is a single matrix with the parameters joined together, left to right.<span class="Apple-converted-space">  </span>Parameters may instead be </span><span class="s6">NULL</span><span class="s5">, in which case they are ignored; or if all parameters are </span><span class="s6">NULL</span><span class="s5">, the result is </span><span class="s6">NULL</span><span class="s5">.<span class="Apple-converted-space">  </span>A sequence of vectors, matrices, and </span><span class="s6">NULL</span><span class="s5">s may thus be concatenated with the </span><span class="s6">NULL</span><span class="s5"> values removed, analogous to </span><span class="s6">c()</span><span class="s5">.<span class="Apple-converted-space">  </span>Calling </span><span class="s6">cbind(x)</span><span class="s5"> is an easy way to create a one-column matrix from a vector.</span></p>
<p class="p5"><span class="s5">To combine vectors or matrices by row instead, see </span><span class="s6">rbind()</span><span class="s5">.</span></p>
<p class="p2">(integer)dim(* x)</p>
<p class="p5"><span class="s5"><b>Returns the dimensions</b> of matrix or array </span><span class="s6">x</span><span class="s5">.<span class="Apple-converted-space">  </span>The first dimension value is the number of rows, the second is the number of columns, and further values indicate the sizes of higher-order dimensions, identically to how dimensions are supplied to </span><span class="s6">array()</span><span class="s5">.<span class="Apple-converted-space">  </span></span><span class="s6">NULL</span><span class="s5"> is returned if </span><span class="s6">x</span><span class="s5"> is not a matrix or array.</span></p>
<p class="p2">(*)drop(* x)</p>
<p class="p5"><span class="s5"><b>Returns the result of dropping redundant dimensions</b> from matrix or array </span><span class="s6">x</span><span class="s5">.<span class="Apple-converted-space">  </span>Redundant dimensions are those with a size of exactly 1.<span class="Apple-converted-space">  </span>Non-redundant dimensions are retained.<span class="Apple-converted-space">  </span>If only one non-redundant dimension is present, the result is a vector; if more than one non-redundant dimension is present, the result will be a matrix or array.<span class="Apple-converted-space">  </span>If </span><span class="s6">x</span><span class="s5"> is not a matrix or array, it is returned unmodified.</span></p>
<p class="p2">(*)matrix(* data, [Ni$ nrow = NULL], [Ni$ ncol = NULL], [logical$ byrow = F])</p>
<p class="p5"><span class="s5"><b>Creates a new matrix</b> from the data specified by </span><span class="s6">data</span><span class="s5">.<span class="Apple-converted-space">  </span>By default this creates a one-column matrix.<span class="Apple-converted-space">  </span>If non-</span><span class="s6">NULL</span><span class="s5"> values are supplied for </span><span class="s6">nrow</span><span class="s5"> and/or </span><span class="s6">ncol</span><span class="s5">, a matrix will be made with the requested number of rows and/or columns if possible; if the length of </span><span class="s6">data</span><span class="s5"> is not compatible with the requested dimensions, an error will result.<span class="Apple-converted-space">  </span>By default, values from data will populate the matrix by columns, filling each column sequentially before moving on to the next column; if </span><span class="s6">byrow</span><span class="s5"> is </span><span class="s6">T</span><span class="s5"> the matrix will be populated by rows instead.</span></p>
<p class="p2">(numeric)matrixMult(numeric x, numeric y)</p>
<p class="p5"><span class="s5"><b>Returns the result of matrix multiplication</b> of </span><span class="s6">x</span><span class="s5"> with </span><span class="s6">y</span><span class="s5">.<span class="Apple-converted-space">  </span>In Eidos (as in R), with two matrices </span><span class="s6">A</span><span class="s5"> and </span><span class="s6">B</span><span class="s5"> the simple product </span><span class="s6">A * B</span><span class="s5"> multiplies the corresponding elements of the matrices; in other words, if </span><span class="s6">X</span><span class="s5"> is the result of </span><span class="s6">A * B</span><span class="s5">, then </span><span class="s6">X</span><span class="s18"><i><sub>ij</sub></i></span><span class="s5"> = </span><span class="s6">A</span><span class="s18"><i><sub>ij</sub></i></span><span class="s5"> * </span><span class="s6">B</span><span class="s18"><i><sub>ij</sub></i></span><span class="s5">.<span class="Apple-converted-space">  </span>This is parallel to the definition of other operators; A + B adds the corresponding elements of the matrices (</span><span class="s6">X</span><span class="s18"><i><sub>ij</sub></i></span><span class="s5"> = </span><span class="s6">A</span><span class="s18"><i><sub>ij</sub></i></span><span class="s5"> + </span><span class="s6">B</span><span class="s18"><i><sub>ij</sub></i></span><span class="s5">), etc.<span class="Apple-converted-space">  </span>In R, true matrix multiplication is achieved with a special operator, </span><span class="s6">%*%</span><span class="s5">; in Eidos, the </span><span class="s6">matrixMult()</span><span class="s5"> function is used instead.</span></p>
<p class="p5"><span class="s5">Both </span><span class="s6">x</span><span class="s5"> and </span><span class="s6">y</span><span class="s5"> must be matrices, and must be conformable according to the standard definition of matrix multiplication (i.e., if </span><span class="s6">x</span><span class="s5"> is an <i>n</i> × <i>m</i> matrix then </span><span class="s6">y</span><span class="s5"> must be a <i>m</i> × <i>p</i> matrix, and the result will be a <i>n</i> × <i>p</i> matrix).<span class="Apple-converted-space">  </span>Vectors will not be promoted to matrices by this function, even if such promotion would lead to a conformable matrix.</span></p>
<p class="p2">(integer$)nrow(* x)</p>
<p class="p5"><span class="s5"><b>Returns the number of rows</b> in matrix or array </span><span class="s6">x</span><span class="s5">.<span class="Apple-converted-space">  </span>For vector </span><span class="s6">x</span><span class="s5">, </span><span class="s6">nrow()</span><span class="s5"> returns </span><span class="s6">NULL</span><span class="s5">; </span><span class="s6">size()</span><span class="s5"> should be used.<span class="Apple-converted-space">  </span>An equivalent of R’s </span><span class="s6">NROW()</span><span class="s5"> function, which treats vectors as </span><span class="s6">1</span><span class="s5">-column matrices, is not provided but would be trivial to implement as a user-defined function.</span></p>
<p class="p2">(integer$)ncol(* x)</p>
<p class="p5"><span class="s5"><b>Returns the number of columns</b> in matrix or array </span><span class="s6">x</span><span class="s5">.<span class="Apple-converted-space">  </span>For vector </span><span class="s6">x</span><span class="s5">, </span><span class="s6">ncol()</span><span class="s5"> returns </span><span class="s6">NULL</span><span class="s5">; </span><span class="s6">size()</span><span class="s5"> should be used.<span class="Apple-converted-space">  </span>An equivalent of R’s </span><span class="s6">NCOL()</span><span class="s5"> function, which treats vectors as </span><span class="s6">1</span><span class="s5">-column matrices, is not provided but would be trivial to implement as a user-defined function.</span></p>
<p class="p2">(*)rbind(...)</p>
<p class="p5"><span class="s5"><b>Combines vectors or matrices by row</b> to produce a single matrix.<span class="Apple-converted-space">  </span>The parameters must be vectors (which are interpreted by </span><span class="s6">rbind()</span><span class="s5"> as if they were one-row matrices) or matrices.<span class="Apple-converted-space">  </span>They must be of the same type, of the same class if they are of type </span><span class="s6">object</span><span class="s5">, and have the same number of columns.<span class="Apple-converted-space">  </span>If these conditions are met, the result is a single matrix with the parameters joined together, top to bottom.<span class="Apple-converted-space">  </span>Parameters may instead be </span><span class="s6">NULL</span><span class="s5">, in which case they are ignored; or if all parameters are </span><span class="s6">NULL</span><span class="s5">, the result is </span><span class="s6">NULL</span><span class="s5">.<span class="Apple-converted-space">  </span>A sequence of vectors, matrices, and </span><span class="s6">NULL</span><span class="s5">s may thus be concatenated with the </span><span class="s6">NULL</span><span class="s5"> values removed, analogous to </span><span class="s6">c()</span><span class="s5">.<span class="Apple-converted-space">  </span>Calling </span><span class="s6">rbind(x)</span><span class="s5"> is an easy way to create a one-row matrix from a vector.</span></p>
<p class="p5"><span class="s5">To combine vectors or matrices by column instead, see </span><span class="s6">cbind()</span><span class="s5">.</span></p>
<p class="p2">(*)t(* x)</p>
<p class="p5"><span class="s5"><b>Returns the transpose</b> of </span><span class="s6">x</span><span class="s5">, which must be a matrix.<span class="Apple-converted-space">  </span>This is the matrix reflected across its diagonal; or alternatively, the matrix with its columns written out instead as rows in the same order.</span></p>
<p class="p1"><b>3.8.<span class="Apple-converted-space">  </span>Filesystem access functions</b></p>
<p class="p2">(logical$)createDirectory(string$ path)</p>
<p class="p3"><b>Creates a new filesystem directory</b> at the path specified by <span class="s2">path</span> and returns a <span class="s2">logical</span> value indicating if the creation succeeded (<span class="s2">T</span>) or failed (<span class="s2">F</span>).<span class="Apple-converted-space">  </span>If the path already exists, <span class="s2">createDirectory()</span> will do nothing to the filesystem, will emit a warning, and will return <span class="s2">T</span> to indicate success if the existing path is a directory, or <span class="s2">F</span> to indicate failure if the existing path is not a directory.</p>
<p class="p2">(logical$)deleteFile(string$ filePath)</p>
<p class="p3"><b>Deletes the file</b> specified by <span class="s2">filePath</span> and returns a <span class="s2">logical</span> value indicating if the deletion succeeded (<span class="s2">T</span>) or failed (<span class="s2">F</span>).</p>
<p class="p4"><span class="s5">(logical$)fileExists(string$ filePath)</span></p>
<p class="p5"><span class="s5"><b>Checks the existence of the file</b> specified by </span><span class="s6">filePath</span><span class="s5"> and returns a </span><span class="s6">logical</span><span class="s5"> value indicating if it exists (</span><span class="s6">T</span><span class="s5">) or does not exist (</span><span class="s6">F</span><span class="s5">).<span class="Apple-converted-space">  </span>This also works for directories.</span></p>
<p class="p2">(string)filesAtPath(string$ path, [logical$ fullPaths = F])</p>
<p class="p3">Returns a <span class="s2">string</span> vector containing the <b>names of all files in a directory</b> specified by <span class="s2">path</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If the optional parameter <span class="s2">fullPaths</span> is <span class="s2">T</span>, full filesystem paths are returned for each file; if <span class="s2">fullPaths</span> is <span class="s2">F</span> (the default), then only the filenames relative to the specified directory are returned.<span class="Apple-converted-space">  </span>This list includes directories (i.e. subfolders), including the <span class="s2">"."</span> and <span class="s2">".."</span> directories on Un*x systems.<span class="Apple-converted-space">  </span>The list also includes invisible files, such as those that begin with a <span class="s2">"."</span> on Un*x systems.<span class="Apple-converted-space">  </span>This function does not descend recursively into subdirectories.<span class="Apple-converted-space">  </span>If an error occurs during the read, <span class="s2">NULL</span> will be returned.</p>
<p class="p4"><span class="s5">(string$)getwd(void)</span></p>
<p class="p5"><span class="s5"><b>Gets the current filesystem working directory</b>.<span class="Apple-converted-space">  </span>The filesystem working directory is the directory which will be used as a base path for relative filesystem paths.<span class="Apple-converted-space">  </span>For example, if the working directory is </span><span class="s6">"~/Desktop"</span><span class="s5"> (the </span><span class="s6">Desktop</span><span class="s5"> subdirectory within the current user’s home directory, as represented by </span><span class="s6">~</span><span class="s5">), then the filename </span><span class="s6">"foo.txt"</span><span class="s5"> would correspond to the filesystem path </span><span class="s6">"~/Desktop/foo.txt"</span><span class="s5">, and the relative path </span><span class="s6">"bar/baz/"</span><span class="s5"> would correspond to the filesystem path </span><span class="s6">“~/Desktop/bar/baz/“</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Note that the path returned may not be identical to the path previously set with </span><span class="s6">setwd()</span><span class="s5">, if for example symbolic links are involved; but it ought to refer to the same actual directory in the filesystem.</span></p>
<p class="p5"><span class="s5">The initial working directory is – as is generally the case on Un*x – simply the directory given to the running Eidos process by its parent process (the operating system, a shell, a job scheduler, a debugger, or whatever the case may be).<span class="Apple-converted-space">  </span>If you launch Eidos (or SLiM) from the command line in a Un*x shell, it is typically the current directory in that shell.<span class="Apple-converted-space">  </span>Before relative filesystem paths are used, you may therefore wish check what the initial working directory is on your platform, with </span><span class="s6">getwd()</span><span class="s5">, if you are not sure.<span class="Apple-converted-space">  </span>Alternatively, you can simply use </span><span class="s6">setwd()</span><span class="s5"> to set the working directory to a known path.</span></p>
<p class="p2">(string)readFile(string$ filePath)</p>
<p class="p3"><b>Reads in the contents of a file</b> specified by <span class="s2">filePath</span> and returns a <span class="s2">string</span> vector containing the lines (separated by <span class="s2">\n</span> and <span class="s2">\r</span> characters) of the file.<span class="Apple-converted-space">  </span>Reading files other than text files is not presently supported.<span class="Apple-converted-space">  </span>If an error occurs during the read, <span class="s2">NULL</span> will be returned.</p>
<p class="p4"><span class="s5">(string$)setwd(string$ path)</span></p>
<p class="p5"><span class="s5"><b>Sets the current filesystem working directory</b>.<span class="Apple-converted-space">  </span>The filesystem working directory is the directory which will be used as a base path for relative filesystem paths (see </span><span class="s6">getwd()</span><span class="s5"> for further discussion).<span class="Apple-converted-space">  </span>An error will result if the working directory cannot be set to the given path.</span></p>
<p class="p5"><span class="s5">The current working directory prior to the change will be returned as an invisible </span><span class="s6">string</span><span class="s5"> value; the value returned is identical to the value that would have been returned by </span><span class="s6">getwd()</span><span class="s5">, apart from its invisibility.</span></p>
<p class="p5"><span class="s5">See </span><span class="s6">getwd()</span><span class="s5"> for discussion regarding the initial working directory, before it is set with </span><span class="s6">setwd()</span><span class="s5">.</span></p>
<p class="p2">(logical$)writeFile(string$ filePath, string contents, [logical$ append = F], [logical$ compress = F])</p>
<p class="p3"><b>Writes or appends to a file</b> specified by <span class="s2">filePath</span> with contents specified by <span class="s2">contents</span>, a <span class="s2">string</span> vector of lines.<span class="Apple-converted-space">  </span>If <span class="s2">append</span> is <span class="s2">T</span>, the write will be appended to the existing file (if any) at <span class="s2">filePath</span>; if it is <span class="s2">F</span> (the default), then the write will replace an existing file at that path.<span class="Apple-converted-space">  </span>If the write is successful, <span class="s2">T</span> will be returned; if not, <span class="s2">F</span> will be returned.</p>
<p class="p5"><span class="s5">If </span><span class="s6">compress</span><span class="s5"> is </span><span class="s6">T</span><span class="s5">, the contents will be compressed with </span><span class="s6">zlib</span><span class="s5"> as they are written, and the standard </span><span class="s6">.gz</span><span class="s5"> extension for </span><span class="s6">gzip</span><span class="s5">-compressed files will be appended to the filename in </span><span class="s6">filePath</span><span class="s5"> if it is not already present.<span class="Apple-converted-space">  </span>If the </span><span class="s6">compress</span><span class="s5"> option is used in conjunction with </span><span class="s6">append==T</span><span class="s5">, Eidos will accumulate data to append and flush it to the file in a delayed fashion (for performance reasons), and so appended data may not be visible in the file until later – potentially not until the process ends (i.e., the end of the SLiM simulation, for example).<span class="Apple-converted-space">  </span>The </span><span class="s6">compress</span><span class="s5"> option was added in Eidos 2.4 (SLiM 3.4).<span class="Apple-converted-space">  </span>Note that </span><span class="s6">readFile()</span><span class="s5"> does not currently support reading in compressed data.</span></p>
<p class="p3">Note that newline characters will be added at the ends of the lines in <span class="s2">contents</span>.<span class="Apple-converted-space">  </span>If you do not wish to have newlines added, you should use <span class="s2">paste()</span> to assemble the elements of <span class="s2">contents</span> together into a singleton <span class="s2">string</span><span class="s3">.</span></p>
<p class="p2">(string$)writeTempFile(string$ prefix, string$ suffix, string contents, [logical$ compress = F])</p>
<p class="p3"><b>Writes to a unique temporary file</b> with contents specified by <span class="s2">contents</span>, a <span class="s2">string</span> vector of lines.<span class="Apple-converted-space">  </span>The filename used will begin with <span class="s2">prefix</span> and end with <span class="s2">suffix</span>, and will contain six random characters in between; for example, if <span class="s2">prefix</span> is <span class="s2">"plot1_"</span> and <span class="s2">suffix</span> is <span class="s2">".pdf"</span>, the generated filename might look like <span class="s2">"plot1_r5Mq0t.pdf"</span>.<span class="Apple-converted-space">  </span>It is legal for <span class="s2">prefix</span>, <span class="s2">suffix</span>, or both to be the empty string, <span class="s2">""</span>, but supplying a file extension is usually advisable at minimum.<span class="Apple-converted-space">  </span>The file will be created inside the <span class="s2">/tmp/</span> directory of the system, which is provided by Un*x systems as a standard location for temporary files; the <span class="s2">/tmp/</span> directory should not be specified as part of prefix (nor should any other directory information).<span class="Apple-converted-space">  </span>The filename generated is guaranteed not to already exist in <span class="s2">/tmp/</span>.<span class="Apple-converted-space">  </span>The file is created with Un*x permissions <span class="s2">0600</span>, allowing reading and writing only by the user for security.<span class="Apple-converted-space">  </span>If the write is successful, the full path to the temporary file will be returned; if not, <span class="s2">""</span> will be returned.</p>
<p class="p5"><span class="s5">If </span><span class="s6">compress</span><span class="s5"> is </span><span class="s6">T</span><span class="s5">, the contents will be compressed with </span><span class="s6">zlib</span><span class="s5"> as they are written, and the standard </span><span class="s6">.gz</span><span class="s5"> extension for </span><span class="s6">gzip</span><span class="s5">-compressed files will be appended to the filename suffix in </span><span class="s6">suffix</span><span class="s5"> if it is not already present.<span class="Apple-converted-space">  </span>The </span><span class="s6">compress</span><span class="s5"> option was added in Eidos 2.4 (SLiM 3.4).<span class="Apple-converted-space">  </span>Note that </span><span class="s6">readFile()</span><span class="s5"> does not currently support reading in compressed data.</span></p>
<p class="p3">Note that newline characters will be added at the ends of the lines in <span class="s2">contents</span>.<span class="Apple-converted-space">  </span>If you do not wish to have newlines added, you should use <span class="s2">paste()</span> to assemble the elements of <span class="s2">contents</span> together into a singleton <span class="s2">string</span><span class="s3">.</span></p>
<p class="p1"><b>3.9.<span class="Apple-converted-space">  </span>Color manipulation functions</b></p>
<p class="p4"><span class="s5">(string)cmColors(integer$ n)</span></p>
<p class="p5"><span class="s5"><b>Generate colors in a “cyan-magenta” color palette</b>.<span class="Apple-converted-space">  </span>The number of colors desired is passed in </span><span class="s6">n</span><span class="s5">, and the returned vector will contain </span><span class="s6">n</span><span class="s5"> color strings.<span class="Apple-converted-space">  </span>The color sequence begins with cyan, passes through white, and then ramps to magenta.<span class="Apple-converted-space">  </span>See </span><span class="s6">rainbow()</span><span class="s5">, </span><span class="s6">heatColors()</span><span class="s5">, and </span><span class="s6">terrainColors()</span><span class="s5"> for other color palettes.</span></p>
<p class="p2">(float)color2rgb(string color)</p>
<p class="p5"><span class="s5"><b>Converts a color string to RGB</b>.<span class="Apple-converted-space">  </span>The color string specified in </span><span class="s6">color</span><span class="s5"> may be either a named color or a color in hexadecimal format such as </span><span class="s6">"#007FC0"</span><span class="s5">.<span class="Apple-converted-space">  </span>The equivalent RGB color is returned as a </span><span class="s6">float</span><span class="s5"> vector of length three (red, green, blue).<span class="Apple-converted-space">  </span>Returned RGB values will be in the interval [0, 1].</span></p>
<p class="p5"><span class="s5">This function can also be called with a non-singleton vector of color strings in </span><span class="s6">color</span><span class="s5">.<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s6">float</span><span class="s5"> value will be a matrix of RGB values, with three columns (red, green, blue) and one row per element of </span><span class="s6">color</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(string)heatColors(integer$ n)</span></p>
<p class="p5"><span class="s5"><b>Generate colors in a “heat map” color palette</b>.<span class="Apple-converted-space">  </span>The number of colors desired is passed in </span><span class="s6">n</span><span class="s5">, and the returned vector will contain </span><span class="s6">n</span><span class="s5"> color strings.<span class="Apple-converted-space">  </span>The color sequence begins with red, passes through orange to yellow, and then fades up to white.<span class="Apple-converted-space">  </span>See </span><span class="s6">rainbow()</span><span class="s5">, </span><span class="s6">cmColors()</span><span class="s5">, and </span><span class="s6">terrainColors()</span><span class="s5"> for other color palettes.</span></p>
<p class="p2">(float)hsv2rgb(float hsv)</p>
<p class="p3"><b>Converts an HSV color to RGB</b><span class="s3">.</span><span class="Apple-converted-space">  </span>The HSV color is specified in <span class="s2">hsv</span> as a <span class="s2">float</span> vector of length three (hue, saturation, value), and the equivalent RGB color is returned as a <span class="s2">float</span> vector of length three (red, green, blue).<span class="Apple-converted-space">  </span>HSV values will be clamped to the interval [0, 1], and returned RGB values will also be in the interval [0, 1].</p>
<p class="p5"><span class="s5">This function can also be called with a matrix of HSV values, with three columns (hue, saturation, value).<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s6">float</span><span class="s5"> value will be a matrix of RGB values, with three columns (red, green, blue) and one row per row of </span><span class="s6">hsv</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(string)rainbow(integer$ n, [float$ s = 1], [float$ v = 1], [float$ start = 0], [Nf$ end = NULL], [logical$ ccw = T])</span></p>
<p class="p5"><span class="s5"><b>Generate colors in a “rainbow” color palette</b>.<span class="Apple-converted-space">  </span>The number of colors desired is passed in </span><span class="s6">n</span><span class="s5">, and the returned vector will contain </span><span class="s6">n</span><span class="s5"> color strings.<span class="Apple-converted-space">  </span>Parameters </span><span class="s6">s</span><span class="s5"> and </span><span class="s6">v</span><span class="s5"> control the saturation and value of the rainbow colors generated.<span class="Apple-converted-space">  </span>The color sequence begins with the hue </span><span class="s6">start</span><span class="s5">, and ramps to the hue </span><span class="s6">end</span><span class="s5">, in a counter-clockwise direction around the standard HSV color wheel if </span><span class="s6">ccw</span><span class="s5"> is </span><span class="s6">T</span><span class="s5"> (the default, following R), otherwise in a clockwise direction.<span class="Apple-converted-space">  </span>If </span><span class="s6">end</span><span class="s5"> is </span><span class="s6">NULL</span><span class="s5"> (the default), a value of </span><span class="s6">(n-1)/n</span><span class="s5"> is used, producing a complete rainbow around the color wheel when </span><span class="s6">start</span><span class="s5"> is also the default value of </span><span class="s6">0</span><span class="s5">.<span class="Apple-converted-space">  </span>See </span><span class="s6">cmColors()</span><span class="s5">, </span><span class="s6">heatColors()</span><span class="s5">, and </span><span class="s6">terrainColors()</span><span class="s5"> for other color palettes.</span></p>
<p class="p2">(string)rgb2color(float rgb)</p>
<p class="p3"><b>Converts an RGB color to a color string</b><span class="s3">.</span><span class="Apple-converted-space">  </span>The RGB color is specified in <span class="s2">rgb</span> as a <span class="s2">float</span> vector of length three (red, green, blue).<span class="Apple-converted-space">  </span>The equivalent color string is returned as singleton <span class="s2">string</span> specifying the color in the format <span class="s2">"#RRGGBB"</span>, such as <span class="s2">"#007FC0"</span><span class="s3">.</span><span class="Apple-converted-space">  </span>RGB values will be clamped to the interval [0, 1].</p>
<p class="p5"><span class="s5">This function can also be called with a matrix of RGB values, with three columns (red, green, blue).<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s6">string</span><span class="s5"> value will be a vector of color strings, with one element per row of </span><span class="s6">rgb</span><span class="s5">.</span></p>
<p class="p2">(float)rgb2hsv(float rgb)</p>
<p class="p3"><b>Converts an RGB color to HSV</b><span class="s3">.</span><span class="Apple-converted-space">  </span>The RGB color is specified in <span class="s2">rgb</span> as a <span class="s2">float</span> vector of length three (red, green, blue), and the equivalent HSV color is returned as a <span class="s2">float</span> vector of length three (hue, saturation, value).<span class="Apple-converted-space">  </span>RGB values will be clamped to the interval [0, 1], and returned HSV values will also be in the interval [0, 1].</p>
<p class="p5"><span class="s5">This function can also be called with a matrix of RGB values, with three columns (red, green, blue).<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s6">float</span><span class="s5"> value will be a matrix of HSV values, with three columns (hue, saturation, value) and one row per row of </span><span class="s6">rgb</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(string)terrainColors(integer$ n)</span></p>
<p class="p5"><span class="s5"><b>Generate colors in a “terrain” color palette</b>.<span class="Apple-converted-space">  </span>The number of colors desired is passed in </span><span class="s6">n</span><span class="s5">, and the returned vector will contain </span><span class="s6">n</span><span class="s5"> color strings.<span class="Apple-converted-space">  </span>The color sequence begins with forest green, passes through dark orange, and then ramps to off-white.<span class="Apple-converted-space">  </span>See </span><span class="s6">rainbow()</span><span class="s5">, </span><span class="s6">cmColors()</span><span class="s5">, and </span><span class="s6">heatColors()</span><span class="s5"> for other color palettes.</span></p>
<p class="p1"><b>3.10.<span class="Apple-converted-space">  </span>Miscellaneous functions</b></p>
<p class="p2">(void)beep([Ns$ soundName = NULL])</p>
<p class="p3"><b>Plays a sound or beeps.</b><span class="Apple-converted-space">  </span>On Mac OS X in a GUI environment (i.e., in EidosScribe or SLiMgui), the optional parameter <span class="s2">soundName</span> can be the name of a sound file to play; in other cases (if <span class="s2">soundName</span> is <span class="s2">NULL</span>, or at the command line, or on platforms other than OS X) <span class="s2">soundName</span> is ignored and a standard system beep is played.</p>
<p class="p3">When <span class="s2">soundName</span> is not <span class="s2">NULL</span><span class="s3">,</span> a sound file in a supported format (such as <span class="s2">.aiff</span> or <span class="s2">.mp3</span>) is searched for sequentially in four standard locations, in this order: <span class="s2">~/Library/Sounds</span>, <span class="s2">/Library/Sounds</span>, <span class="s2">/Network/Library/Sounds</span>, and finally <span class="s2">/System/Library/Sounds</span>.<span class="Apple-converted-space">  </span>Standard OS X sounds located in <span class="s14">/System/Library/Sounds</span> include <span class="s2">"Basso"</span><span class="s3">,</span> <span class="s2">"Blow"</span><span class="s3">,</span> <span class="s2">"Bottle"</span><span class="s3">,</span> <span class="s2">"Frog"</span><span class="s3">,</span> <span class="s2">"Funk"</span><span class="s3">,</span> <span class="s2">"Glass"</span><span class="s3">,</span> <span class="s2">"Hero"</span><span class="s3">,</span> <span class="s2">"Morse"</span><span class="s3">,</span> <span class="s2">"Ping"</span><span class="s3">,</span> <span class="s2">"Pop"</span><span class="s3">,</span> <span class="s2">"Purr"</span><span class="s3">,</span> <span class="s2">"Sosumi"</span><span class="s3">,</span> <span class="s2">"Submarine"</span>, and <span class="s2">"Tink"</span>.<span class="Apple-converted-space">  </span>Do not include the file extension, such as <span class="s2">.aiff</span> or <span class="s2">.mp3</span>, in <span class="s2">soundName</span><span class="s3">.</span></p>
<p class="p3"><b>CAUTION:</b> When not running in EidosScribe or SLiMgui, it is often the case that the only simple means available to play a beep is to send a <span class="s2">BEL</span> character (ASCII 7) to the standard output.<span class="Apple-converted-space">  </span>Unfortunately, when this is the case, it means that (1) no beep will be audible if output is being redirected into a file, and (2) a control character, <span class="s2">^G</span>, will occur in the output at the point when the beep was requested.<span class="Apple-converted-space">  </span>It is therefore recommended that <span class="s2">beep()</span> be used only when doing interactive work in a terminal shell (or in a GUI, on OS X), not when producing output files.<span class="Apple-converted-space">  </span>However, this issue is platform-specific; on some platforms <span class="s2">beep()</span> may result in a beep, and no emitted <span class="s2">^G</span>, even when output is redirected.<span class="Apple-converted-space">  </span>When a <span class="s2">^G</span> must be emitted to the standard output to generate the beep, a warning message will also be emitted to make any associated problems easier to diagnose.</p>
<p class="p2">(void)citation(void)</p>
<p class="p3"><b>Prints citation information for Eidos</b> to Eidos’s output stream.</p>
<p class="p4"><span class="s5">(float$)clock([string$ type = "cpu"])</span></p>
<p class="p5"><span class="s5">Returns the value of a <b>system clock</b>.<span class="Apple-converted-space">  </span>If </span><span class="s6">type</span><span class="s5"> is </span><span class="s6">"cpu"</span><span class="s5">, this returns the current value of the CPU usage clock.<span class="Apple-converted-space">  </span>This is the amount of CPU time used by the current process, in seconds; it is unrelated to the current time of day (for that, see the </span><span class="s6">time()</span><span class="s5"> function).<span class="Apple-converted-space">  </span>This is useful mainly for determining how much processor time a given section of code takes; </span><span class="s6">clock()</span><span class="s5"> can be called before and after a block of code, and the end clock minus the start clock gives the elapsed CPU time consumed in the execution of the block of code.<span class="Apple-converted-space">  </span>See also the </span><span class="s6">timed</span><span class="s5"> parameter of </span><span class="s6">executeLambda()</span><span class="s5">, which automates this procedure.<span class="Apple-converted-space">  </span>Note that if multiple cores are utilized by the process, the CPU usage clock will be the sum of the CPU usage across all cores, and may therefore run faster than the wall clock.</span></p>
<p class="p5"><span class="s5">If </span><span class="s6">type</span><span class="s5"> is </span><span class="s6">"mono"</span><span class="s5">, this returns the value of the system’s monotonic clock.<span class="Apple-converted-space">  </span>This represents user-perceived (“wall clock”) elapsed time from some arbitrary timebase (which will not change during the execution of the program), but it will not jump if the time zone or the wall clock time are changed for the system.<span class="Apple-converted-space">  </span>This clock is useful for measuring user-perceived elapsed time, as described above, and may provide a more useful metric for performance than CPU time if multiple cores are being utilized.</span></p>
<p class="p2">(string$)date(void)</p>
<p class="p3">Returns a <b>standard date string</b> for the current date in the local time of the executing machine.<span class="Apple-converted-space">  </span>The format is <span class="s2">%d-%m-%Y</span> (day in two digits, then month in two digits, then year in four digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.</p>
<p class="p2">(void)defineConstant(string$ symbol, + value)</p>
<p class="p3"><b>Defines a new constant</b> with the name <span class="s2">symbol</span> and the value specified by <span class="s2">value</span>.<span class="Apple-converted-space">  </span>The value may be any non-object value at all.<span class="Apple-converted-space">  </span>The name cannot previously be defined in any way (i.e., as either a variable or a constant).<span class="Apple-converted-space">  </span>The defined constant acts identically to intrinsic Eidos constants such as <span class="s2">T</span>, <span class="s2">NAN</span>, and <span class="s2">PI</span>, and will remain defined for as long as the Eidos context lives even if it is defined inside a block being executed by <span class="s2">executeLambda()</span>, <span class="s2">sapply()</span>, or a Context-defined script block.</p>
<p class="p2">(<span class="s13">vNlifso</span>)doCall(string$ functionName, ...)</p>
<p class="p3">Returns the results from a <b>call to a specified function</b>.<span class="Apple-converted-space">  </span>The function named by the parameter <span class="s2">functionName</span> is called, and the remaining parameters to <span class="s2">doCall()</span> are forwarded on to that function verbatim.<span class="Apple-converted-space">  </span>This can be useful for calling one of a set of similar functions, such as <span class="s2">sin()</span>, <span class="s2">cos()</span>, etc., to perform a math function determined at runtime, or one of the <span class="s2">as...()</span> family of functions to convert to a type determined at runtime.<span class="Apple-converted-space">  </span>Note that named arguments and default arguments, beyond the <span class="s2">functionName</span> argument, are not supported by <span class="s2">doCall()</span>; all arguments to the target function must be specified explicitly, without names.</p>
<p class="p2">(<span class="s13">vNlifso</span>)executeLambda(string$ lambdaSource, [ls$ timed = F])</p>
<p class="p5"><span class="s5"><b>Executes a block of Eidos code</b> defined by </span><span class="s6">lambdaSource</span><span class="s5">.<span class="Apple-converted-space">  </span>Eidos allows you to execute <i>lambdas</i>: blocks of Eidos code which can be called directly within the same scope as the caller.<span class="Apple-converted-space">  </span>Eidos lambdas do not take arguments; for this reason, they are not first-class functions.<span class="Apple-converted-space">  </span>(Since they share the scope of the caller, however, you may effectively pass values in and out of a lambda using global variables.)<span class="Apple-converted-space">  </span>The </span><span class="s6">string</span><span class="s5"> argument </span><span class="s6">lambdaSource</span><span class="s5"> may contain one or many Eidos statements as a single </span><span class="s6">string</span><span class="s5"> value.<span class="Apple-converted-space">  </span>Lambdas are represented, to the caller, only as the source code </span><span class="s6">string</span><span class="s5"> </span><span class="s6">lambdaSource</span><span class="s5">; the executable code is not made available programmatically.<span class="Apple-converted-space">  </span>If an error occurs during the tokenization, parsing, or execution of the lambda, that error is raised as usual; executing code inside a lambda does not provide any additional protection against exceptions raised.<span class="Apple-converted-space">  </span>The return value produced by the code in the lambda is returned by </span><span class="s6">executeLambda()</span><span class="s5">.<span class="Apple-converted-space">  </span>If the optional parameter </span><span class="s6">timed</span><span class="s5"> is </span><span class="s6">T</span><span class="s5">, the total (CPU clock) execution time for the lambda will be printed after the lambda has completed (see </span><span class="s6">clock()</span><span class="s5">); if it is </span><span class="s6">F</span><span class="s5"> (the default), no timing information will be printed.<span class="Apple-converted-space">  </span>The </span><span class="s6">timed</span><span class="s5"> parameter may also be </span><span class="s6">"cpu"</span><span class="s5"> or </span><span class="s6">"mono"</span><span class="s5"> to specifically request timing with the CPU clock (which will count the usage across all cores, and may thus run faster than wall clock time if multiple cores are being utilized) or the monotonic clock (which will correspond, more or less, to elapsed wall clock time regardless of multithreading); see the documentation for </span><span class="s6">clock()</span><span class="s5"> for further discussion of these timing options.</span></p>
<p class="p3">The current implementation of <span class="s2">executeLambda()</span> caches a tokenized and parsed version of <span class="s2">lambdaSource</span>, so calling <span class="s2">executeLambda()</span> repeatedly on a single source <span class="s2">string</span> is much more efficient than calling <span class="s2">executeLambda()</span> with a newly constructed <span class="s2">string</span> each time.<span class="Apple-converted-space">  </span>If you can use a <span class="s2">string</span> literal for <span class="s2">lambdaSource</span>, or reuse a constructed source <span class="s2">string</span> stored in a variable, that will improve performance considerably.</p>
<p class="p2">(logical)exists(string symbol)</p>
<p class="p5"><span class="s5">Returns a </span><span class="s6">logical</span><span class="s5"> vector indicating <b>whether symbols exist</b>.<span class="Apple-converted-space">  </span>If a symbol has been defined as an intrinsic Eidos constant like </span><span class="s6">T</span><span class="s5">, </span><span class="s6">INF</span><span class="s5">, and </span><span class="s6">PI</span><span class="s5">, or as a Context-defined constant like </span><span class="s6">sim</span><span class="s5"> in SLiM, or as a user-defined constant using </span><span class="s6">defineConstant()</span><span class="s5">, or as a variable by assignment, this function returns </span><span class="s6">T</span><span class="s5">.<span class="Apple-converted-space">  </span>Otherwise, the symbol has not been defined, and </span><span class="s6">exists()</span><span class="s5"> returns </span><span class="s6">F</span><span class="s5">.<span class="Apple-converted-space">  </span>This is commonly used to check whether a user-defined constant already exists, with the intention of defining the constant if it has not already been defined.<span class="Apple-converted-space">  </span>A vector of symbols may be passed, producing a vector of corresponding results.</span></p>
<p class="p2">(void)functionSignature([Ns$<span class="s1"> </span>functionName<span class="s1"> </span>= NULL])</p>
<p class="p3"><b>Prints function signatures</b> for all functions (if <span class="s2">functionName</span> is <span class="s2">NULL</span>, the default), or for the function named by <span class="s2">functionName</span>, to Eidos’s output stream.</p>
<p class="p2">(integer$)getSeed(void)</p>
<p class="p3">Returns the <b>random number seed</b>.<span class="Apple-converted-space">  </span>This is the last seed value set using <span class="s2">setSeed()</span>; if <span class="s2">setSeed()</span> has not been called, it will be a seed value chosen based on the process-id and the current time when Eidos was initialized, unless the Context has set a different seed value.</p>
<p class="p2">(void)license(void)</p>
<p class="p3"><b>Prints Eidos’s license terms</b> to Eidos’s output stream.</p>
<p class="p2">(void)ls(void)</p>
<p class="p3"><b>Prints all currently defined variables</b> to Eidos’s output stream.</p>
<p class="p2">(void)rm([Ns variableNames<span class="s1"> </span>= NULL], [logical$ removeConstants = F])</p>
<p class="p3"><b>Removes global variables</b> from the Eidos namespace; in other words, it causes the variables to become undefined.<span class="Apple-converted-space">  </span>Variables are specified by their <span class="s2">string</span> name in the <span class="s2">variableNames</span> parameter.<span class="Apple-converted-space">  </span>If the optional <span class="s2">variableNames</span> parameter is <span class="s2">NULL</span> (the default), <i>all</i> variables will be removed (be careful!).<span class="Apple-converted-space">  </span>If the optional parameter <span class="s2">removeConstants</span> is <span class="s2">F</span> (the default), then attempting to remove a constant is an error; if <span class="s2">removeConstants</span> is <span class="s2">T</span>, constants defined with <span class="s2">defineConstant()</span> may be removed, but attempting to remove intrinsic Eidos constants is still an error.</p>
<p class="p2">(*)sapply(* x, string$ lambdaSource, [string$ simplify = "vector"])</p>
<p class="p8"><span class="s5"><i>Named </i></span><span class="s6"><i>apply()</i></span><span class="s5"><i> prior to Eidos 1.6 / SLiM 2.6</i></span></p>
<p class="p5"><span class="s5"><b>Applies a block of Eidos code to the elements of x</b>.<span class="Apple-converted-space">  </span>This function is sort of a hybrid between </span><span class="s6">c()</span><span class="s5"> and </span><span class="s6">executeLambda()</span><span class="s5">; it might be useful to consult the documentation for both of those functions to better understand what </span><span class="s6">sapply()</span><span class="s5"> does.<span class="Apple-converted-space">  </span>For each element in </span><span class="s6">x</span><span class="s5">, the lambda defined by </span><span class="s6">lambdaSource</span><span class="s5"> will be called.<span class="Apple-converted-space">  </span>For the duration of that callout, a variable named </span><span class="s6">applyValue</span><span class="s5"> will be defined to have as its value the element of </span><span class="s6">x</span><span class="s5"> currently being processed.<span class="Apple-converted-space">  </span>The expectation is that the lambda will use </span><span class="s6">applyValue</span><span class="s5"> in some way, and will return either </span><span class="s6">NULL</span><span class="s5"> or a new value (which need not be a singleton, and need not be of the same type as </span><span class="s6">x</span><span class="s5">).<span class="Apple-converted-space">  </span>The return value of </span><span class="s6">sapply()</span><span class="s5"> is generated by concatenating together all of the individual vectors returned by the lambda, in exactly the same manner as the </span><span class="s6">c()</span><span class="s5"> function (including the possibility of type promotion).</span></p>
<p class="p5"><span class="s5">Since this function can be hard to understand at first, here is an example:</span></p>
<p class="p9"><span class="s5">sapply(1:10, "if (applyValue % 2) applyValue ^ 2;");</span></p>
<p class="p5"><span class="s5">This produces the output </span><span class="s6">1 9 25 49 81</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s6">sapply()</span><span class="s5"> operation begins with the vector </span><span class="s6">1:10</span><span class="s5">.<span class="Apple-converted-space">  </span>For each element of that vector, the lambda is called and </span><span class="s6">applyValue</span><span class="s5"> is defined with the element value.<span class="Apple-converted-space">  </span>In this respect, </span><span class="s6">sapply()</span><span class="s5"> is actually very much like a </span><span class="s6">for</span><span class="s5"> loop.<span class="Apple-converted-space">  </span>If </span><span class="s6">applyValue</span><span class="s5"> is even (as evaluated by the modulo operator, </span><span class="s6">%</span><span class="s5">), the condition of the </span><span class="s6">if</span><span class="s5"> statement is </span><span class="s6">F</span><span class="s5"> and so </span><span class="s6">NULL</span><span class="s5"> is implicitly returned by the lambda (since the </span><span class="s6">if</span><span class="s5"> has no </span><span class="s6">else</span><span class="s5"> clause).<span class="Apple-converted-space">  </span>If </span><span class="s6">applyValue</span><span class="s5"> is odd, on the other hand, the lambda returns its square (as calculated by the exponential operator, </span><span class="s6">^</span><span class="s5">).<span class="Apple-converted-space">  </span>Just as with the </span><span class="s6">c()</span><span class="s5"> function, </span><span class="s6">NULL</span><span class="s5"> values are dropped during concatenation, so the final result contains only the squares of the odd values.</span></p>
<p class="p5"><span class="s5">This example illustrates that the lambda can “drop” values by returning </span><span class="s6">NULL</span><span class="s5">, so </span><span class="s6">sapply()</span><span class="s5"> can be used to select particular elements of a vector that satisfy some condition, much like the subscript operator, </span><span class="s6">[]</span><span class="s5">.<span class="Apple-converted-space">  </span>The example also illustrates that input and result types do not have to match; the vector passed in is </span><span class="s6">integer</span><span class="s5">, whereas the result vector is </span><span class="s6">float</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Beginning in Eidos 1.6, a new optional parameter named </span><span class="s6">simplify</span><span class="s5"> allows the result of </span><span class="s6">sapply()</span><span class="s5"> to be a matrix or array in certain cases, better organizing the elements of the result.<span class="Apple-converted-space">  </span>If the </span><span class="s6">simplify</span><span class="s5"> parameter is </span><span class="s6">"vector"</span><span class="s5">, the concatenated result value is returned as a plain vector in all cases; this is the default behavior, for backward compatibility.<span class="Apple-converted-space">  </span>Two other possible values for </span><span class="s6">simplify</span><span class="s5"> are presently supported.<span class="Apple-converted-space">  </span>If </span><span class="s6">simplify</span><span class="s5"> is </span><span class="s6">"matrix"</span><span class="s5">, the concatenated result value will be turned into a matrix with one column for each non-</span><span class="s6">NULL</span><span class="s5"> value returned by the lambda, as if the values were joined together with </span><span class="s6">cbind()</span><span class="s5">, as long as all of the lambda’s return values are either (a) </span><span class="s6">NULL</span><span class="s5"> or (b) the same length as the other non-</span><span class="s6">NULL</span><span class="s5"> values returned.<span class="Apple-converted-space">  </span>If </span><span class="s6">simplify</span><span class="s5"> is </span><span class="s6">"match"</span><span class="s5">, the concatenated result value will be turned into a vector, matrix, or array that exactly matches the dimensions as </span><span class="s6">x</span><span class="s5">, with a one-to-one correspondence between </span><span class="s6">x</span><span class="s5"> and the elements of the return value just like a unary operator, as long as all of the lambda’s return values are singletons (with no </span><span class="s6">NULL</span><span class="s5"> values).<span class="Apple-converted-space">  </span>Both </span><span class="s6">"matrix"</span><span class="s5"> and </span><span class="s6">"match"</span><span class="s5"> will raise an error if their preconditions are not met, to avoid unexpected behavior, so care should be taken that the preconditions are always met when these options are used.</span></p>
<p class="p5"><span class="s5">As with </span><span class="s6">executeLambda()</span><span class="s5">, all defined variables are accessible within the lambda, and changes made to variables inside the lambda will persist beyond the end of the </span><span class="s6">sapply()</span><span class="s5"> call; the lambda is executing in the same scope as the rest of your code.</span></p>
<p class="p5"><span class="s5">The </span><span class="s6">sapply()</span><span class="s5"> function can seem daunting at first, but it is an essential tool in the Eidos toolbox.<span class="Apple-converted-space">  </span>It combines the iteration of a </span><span class="s6">for</span><span class="s5"> loop, the ability to select elements like operator </span><span class="s6">[]</span><span class="s5">, and the ability to assemble results of mixed type together into a single vector like </span><span class="s6">c()</span><span class="s5">, all with the power of arbitrary Eidos code execution like </span><span class="s6">executeLambda()</span><span class="s5">.<span class="Apple-converted-space">  </span>It is relatively fast, compared to other ways of achieving similar results such as a </span><span class="s6">for</span><span class="s5"> loop that accumulates results with </span><span class="s6">c()</span><span class="s5">.<span class="Apple-converted-space">  </span>Like </span><span class="s6">executeLambda()</span><span class="s5">, </span><span class="s6">sapply()</span><span class="s5"> is most efficient if it is called multiple times with a single </span><span class="s6">string</span><span class="s5"> script variable, rather than with a newly constructed </span><span class="s6">string</span><span class="s5"> for </span><span class="s6">lambdaSource</span><span class="s5"> each time.</span></p>
<p class="p5"><span class="s5">Prior to Eidos 1.6 (SLiM 2.6), </span><span class="s6">sapply()</span><span class="s5"> was instead named </span><span class="s6">apply()</span><span class="s5">; it was renamed to </span><span class="s6">sapply()</span><span class="s5"> in order to more closely match the naming of functions in R.<span class="Apple-converted-space">  </span>This renaming allowed a new </span><span class="s6">apply()</span><span class="s5"> function to be added to Eidos that operates on the margins of matrices and arrays, similar to the </span><span class="s6">apply()</span><span class="s5"> function of R (see </span><span class="s6">apply()</span><span class="s5">, above).</span></p>
<p class="p2">(void)setSeed(integer$ seed)</p>
<p class="p3"><b>Set the random number seed</b>.<span class="Apple-converted-space">  </span>Future random numbers will be based upon the seed value set, and the random number sequence generated from a particular seed value is guaranteed to be reproducible.<span class="Apple-converted-space">  </span>The last seed set can be recovered with the <span class="s2">getSeed()</span> function.</p>
<p class="p2">(void)source(string$<span class="s1"> </span>filePath)</p>
<p class="p3"><b>Executes the contents of an Eidos source file</b> found at the filesystem path <span class="s2">filePath</span><span class="s3">.</span><span class="Apple-converted-space">  </span>This is essentially shorthand for calling <span class="s2">readFile()</span>, joining the read lines with newlines to form a single string using <span class="s2">paste()</span>, and then passing that string to <span class="s2">executeLambda()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The source file must consist of complete Eidos statements.<span class="Apple-converted-space">  </span>Regardless of what the last executed source line evaluates to, <span class="s2">source()</span> has no return value.</p>
<p class="p2">(void)stop([Ns$<span class="s1"> </span>message<span class="s1"> </span>= NULL])</p>
<p class="p3"><b>Stops execution</b> of Eidos (and of the Context, such as the running SLiM simulation, if applicable), in the event of an error.<span class="Apple-converted-space">  </span>If the optional <span class="s2">message</span> parameter is not <span class="s2">NULL</span>, it will be printed to Eidos’s output stream prior to stopping.</p>
<p class="p4"><span class="s5">(logical$)suppressWarnings(logical$ suppress)</span></p>
<p class="p5"><span class="s5"><b>Turns suppression of warning messages on or off</b>.<span class="Apple-converted-space">  </span>The </span><span class="s6">suppress</span><span class="s5"> flag indicates whether suppression of warnings should be enabled (</span><span class="s6">T</span><span class="s5">) or disabled (</span><span class="s6">F</span><span class="s5">).<span class="Apple-converted-space">  </span>The previous warning-suppression value is returned by </span><span class="s6">suppressWarnings()</span><span class="s5">, making it easy to suppress warnings from a given call and then return to the previous suppression state afterwards.<span class="Apple-converted-space">  </span>It is recommended that warnings be suppressed only around short blocks of code (not all the time), so that unexpected but perhaps important warnings are not missed.<span class="Apple-converted-space">  </span>And of course warnings are generally emitted for good reasons; before deciding to disregard a given warning, make sure that you understand exactly why it is being issued, and are certain that it does not represent a serious problem.</span></p>
<p class="p2">(string)system(string$ command, [string args = ""], [string input = ""], [logical$ stderr = F], [logical$ wait = T])</p>
<p class="p3"><b>Runs a Un*x command in a </b><span class="s2"><b>/bin/sh</b></span><b> shell</b> with optional arguments and input, and returns the result as a vector of output lines.<span class="Apple-converted-space">  </span>The <span class="s2">args</span> parameter may contain a vector of arguments to <span class="s2">command</span>; they will be passed directly to the shell without any quoting, so applying the appropriate quoting as needed by <span class="s2">/bin/sh</span> is the caller’s responsibility.<span class="Apple-converted-space">  </span>The arguments are appended to <span class="s2">command</span>, separated by spaces, and the result is passed to the shell as a single command string, so arguments may simply be given as part of <span class="s2">command</span> instead, if preferred.<span class="Apple-converted-space">  </span>By default no input is supplied to <span class="s2">command</span>; if <span class="s2">input</span> is non-empty, however, it will be written to a temporary file (one line per <span class="s2">string</span> element) and the standard input of <span class="s2">command</span> will be redirected to that temporary file (using standard <span class="s2">/bin/sh</span> redirection with <span class="s2">&lt;</span>, appended to the command string passed to the shell).<span class="Apple-converted-space">  </span>By default, output sent to standard error will not be captured (and thus may end up in the output of the SLiM process, or may be lost); if <span class="s2">stderr</span> is <span class="s2">T</span>, however, the standard error stream will be redirected into standard out (using standard <span class="s2">/bin/sh</span> redirection with <span class="s2">2&gt;&amp;1</span>, appended to the command string passed to the shell).</p>
<p class="p3">Arbitrary command strings involving multiple commands, pipes, redirection, etc., may be used with <span class="s2">system()</span>, but may be incompatible with the way that <span class="s2">args</span><span class="s3">,</span> <span class="s2">input</span>, and <span class="s2">stderr</span> are handled by this function, so in this case supplying the whole command string in <span class="s2">command</span> may be the simplest course.<span class="Apple-converted-space">  </span>You may redirect standard error into standard output yourself in <span class="s2">command</span> with <span class="s2">2&gt;&amp;1</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Supplying input to a complex command line can often be facilitated by the use of parentheses to create a subshell; for example,</p>
<p class="p10">system("(wc -l | sed 's/ //g')", input=c('foo', 'bar', 'baz'));</p>
<p class="p3">will supply the input lines to <span class="s2">wc</span> courtesy of the subshell started for the <span class="s2">()</span> operator.<span class="Apple-converted-space">  </span>If this strategy doesn’t work for the command line you want to execute, you can always write a temporary file yourself using <span class="s2">writeFile()</span> or <span class="s2">writeTempFile()</span> and redirect that file to standard input in <span class="s2">command</span> with <span class="s2">&lt;</span><span class="s3">.</span></p>
<p class="p5"><span class="s5">If </span><span class="s6">wait</span><span class="s5"> is </span><span class="s6">T</span><span class="s5"> (the default), </span><span class="s6">system()</span><span class="s5"> will wait for the command to finish, and return the output generated as a </span><span class="s6">string</span><span class="s5"> vector, as described above.<span class="Apple-converted-space">  </span>If </span><span class="s6">wait</span><span class="s5"> is </span><span class="s6">F</span><span class="s5">, </span><span class="s6">system()</span><span class="s5"> will instead append </span><span class="s6">" &amp;"</span><span class="s5"> to the end of the command line to request that it be run in the background, and it will not collect and return the output from the command; instead it will return </span><span class="s6">string(0)</span><span class="s5"> immediately.<span class="Apple-converted-space">  </span>If the output from the command is needed, it could be redirected to a file, and that file could be checked periodically in Eidos for some indication that the command had completed; if output is not redirected to a file, it may appear in SLiM’s output stream.<span class="Apple-converted-space">  </span>If the final command line executed by </span><span class="s6">system()</span><span class="s5"> ends in </span><span class="s6">" &amp;"</span><span class="s5">, the behavior of </span><span class="s6">system()</span><span class="s5"> should be just as if </span><span class="s6">wait=T</span><span class="s5"> had been supplied, but it is recommended to use </span><span class="s6">wait=T</span><span class="s5"> instead to ensure that the command line is correctly assembled.</span></p>
<p class="p2">(string$)time(void)</p>
<p class="p3">Returns a <b>standard time string</b> for the current time in the local time of the executing machine.<span class="Apple-converted-space">  </span>The format is <span class="s2">%H:%M:%S</span> (hour in two digits, then minute in two digits, then seconds in two digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.<span class="Apple-converted-space">  </span>The 24-hour clock time is used (i.e., no AM/PM).</p>
<p class="p4"><span class="s5">(float$)usage([logical$ peak = F])</span></p>
<p class="p5"><span class="s5">Returns the <b>current (or peak) memory usage</b>.<span class="Apple-converted-space">  </span>This is the amount of memory used by the current process, in MB (megabytes); multiply by </span><span class="s6">1024*1024</span><span class="s5"> to get the usage in bytes.<span class="Apple-converted-space">  </span>If </span><span class="s6">peak</span><span class="s5"> is </span><span class="s6">F</span><span class="s5"> (the default), the current memory usage is returned; if </span><span class="s6">peak</span><span class="s5"> is </span><span class="s6">T</span><span class="s5">, the maximum memory usage over the history of the process is returned.<span class="Apple-converted-space">  </span>Memory usage is a surprisingly complex topic; the particular metric reported by </span><span class="s6">usage()</span><span class="s5"> is the resident set size, or RSS, which includes memory usage from shared libraries, but does not include memory that is swapped out or has never been used.<span class="Apple-converted-space">  </span>For most purposes, RSS is a useful metric of memory usage from a practical perspective.<span class="Apple-converted-space">  </span>On some platforms (AIX, BSD, Solaris) the memory usage reported may be zero, but it should be correct on both Mac OS X and Linux platforms.</span></p>
<p class="p5"><span class="s5">This function can be useful for documenting the memory usage of long runs as they are in progress; in SLiM, it could also be used to trigger tree-sequence simplification with a call to </span><span class="s6">treeSeqSimplify()</span><span class="s5">, to reduce memory usage when it becomes too large, but keep in mind that the simplification process itself may cause a substantial spike in memory usage.</span></p>
<p class="p5"><span class="s5">When running under SLiM, other tools for monitoring memory usage include the </span><span class="s6">slim</span><span class="s5"> command-line options </span><span class="s6">-m[em]</span><span class="s5"> and </span><span class="s6">-M[emhist]</span><span class="s5">, and the </span><span class="s6">outputUsage()</span><span class="s5"> method of </span><span class="s6">SLiMSim</span><span class="s5">; see the SLiM manual for more information.</span></p>
<p class="p4"><span class="s7">(float)version(</span><span class="s5">[logical$ print = T]</span><span class="s7">)</span></p>
<p class="p5"><span class="s5"><b>Get Eidos’s version.</b><span class="Apple-converted-space">  </span>There are two ways to use this function.<span class="Apple-converted-space">  </span>If </span><span class="s6">print</span><span class="s5"> is </span><span class="s6">T</span><span class="s5">, the default, then the version number is printed to the Eidos output stream in a formatted manner, like “</span><span class="s6">Eidos version 2.1</span><span class="s5">”.<span class="Apple-converted-space">  </span>If Eidos is attached to a Context that provides a version number, that is also printed, like “</span><span class="s6">SLiM version 3.1</span><span class="s5">”.<span class="Apple-converted-space">  </span>In this case, the Eidos version number, and the Context version number if available, are returned as an invisible </span><span class="s6">float</span><span class="s5"> vector.<span class="Apple-converted-space">  </span>This is most useful when using Eidos interactively.<span class="Apple-converted-space">  </span>If </span><span class="s6">print</span><span class="s5"> is </span><span class="s6">F</span><span class="s5">, on the other hand, nothing is printed, but the returned </span><span class="s6">float</span><span class="s5"> vector of version numbers is not invisible.<span class="Apple-converted-space">  </span>This is useful for scripts that need to test the Eidos or Context version they are running against.</span></p>
<p class="p5"><span class="s5">In both cases, in the </span><span class="s6">float</span><span class="s5"> version numbers returned, a version like 2.4.2 would be returned as </span><span class="s6">2.42</span><span class="s5">; this would not scale well to subversions greater than nine, so that will be avoided in our versioning.</span></p>
</body>
</html>
