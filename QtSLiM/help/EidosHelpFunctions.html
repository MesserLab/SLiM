<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2487.7">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo}
    p.p3 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima}
    p.p4 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p5 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p7 {margin: 3.0px 0.0px 3.0px 27.4px; font: 9.0px Menlo}
    p.p8 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #d50005}
    p.p9 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #969696}
    p.p10 {margin: 0.0px 0.0px 9.0px 54.0px; font: 9.0px Menlo; color: #000000}
    p.p11 {margin: 0.0px 0.0px 9.0px 54.0px; font: 10.0px Optima; color: #000000}
    p.p12 {margin: 3.0px 0.0px 3.0px 27.4px; font: 9.0px Menlo; color: #000000}
    p.p13 {margin: 0.0px 0.0px 3.0px 27.4px; text-indent: 18.0px; font: 10.0px Optima; color: #000000}
    p.p14 {margin: 9.0px 0.0px 9.0px 45.0px; font: 9.0px Menlo}
    li.li6 {margin: 3.0px 0.0px 3.0px 0.0px; font: 10.0px Optima}
    span.s1 {font: 9.0px 'Times New Roman'}
    span.s2 {font: 9.0px Menlo}
    span.s3 {font: 10.0px 'Times New Roman'}
    span.s4 {font: 10.0px 'Apple Symbols'}
    span.s5 {font-kerning: none}
    span.s6 {color: #000000}
    span.s7 {font: 9.0px Menlo; color: #000000}
    span.s8 {font: 10.0px 'Times New Roman'; color: #000000}
    span.s9 {font: 9.0px Menlo; font-kerning: none}
    span.s10 {font: 10.0px 'Times New Roman'; font-kerning: none}
    span.s11 {font: 6.7px 'Times New Roman'; font-kerning: none}
    span.s12 {font: 10.0px Helvetica}
    span.s13 {font: 6.7px Optima}
    span.s14 {font-kerning: none; color: #000000}
    span.s15 {font: 9.0px Menlo; font-kerning: none; color: #000000}
    span.s16 {font: 9.0px Symbol}
    span.s17 {font: 10.0px Symbol}
    span.s18 {font: 9.0px 'Times New Roman'; color: #000000}
    span.s19 {font: 10.0px Optima}
    span.s20 {text-decoration: underline ; color: #0000ff}
    span.s21 {font: 6.7px Optima; font-kerning: none}
    span.s22 {text-decoration: underline}
    span.Apple-tab-span {white-space:pre}
    ul.ul1 {list-style-type: disc}
  </style>
</head>
<body>
<p class="p1"><b>3.1.<span class="Apple-converted-space">  </span>Math functions</b></p>
<p class="p2">(numeric)abs(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>absolute value</b> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">integer</span>, the C++ function <span class="s2">llabs()</span> is used and an <span class="s2">integer</span> vector is returned; if <span class="s2">x</span> is <span class="s2">float</span>, the C++ function <span class="s2">fabs()</span> is used and a <span class="s2">float</span> vector is returned.</p>
<p class="p2">(float)acos(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>arc cosine</b> of <span class="s2">x</span> using the C++ function <span class="s2">acos()</span><span class="s3">.</span></p>
<p class="p2">(float)asin(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>arc sine</b> of <span class="s2">x</span> using the C++ function <span class="s2">asin()</span><span class="s3">.</span></p>
<p class="p2">(float)atan(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>arc tangent</b> of <span class="s2">x</span> using the C++ function <span class="s2">atan()</span><span class="s3">.</span></p>
<p class="p2">(float)atan2(numeric<span class="s1"> </span>x, numeric<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>arc tangent</b> of <span class="s2">y/x</span> using the C++ function <span class="s2">atan2()</span>, which uses the signs of both x and y to determine the correct quadrant for the result.</p>
<p class="p2">(float)ceil(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>ceiling</b> of <span class="s2">x</span>: the smallest integral value greater than or equal to <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p2">(float)cos(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>cosine</b> of <span class="s2">x</span> using the C++ function <span class="s2">cos()</span><span class="s3">.</span></p>
<p class="p2">(numeric)cumProduct(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>cumulative product</b> of <span class="s2">x</span>: a vector of equal length as <span class="s2">x</span>, in which the element at index <span class="s2">i</span> is equal to the product of the elements of <span class="s2">x</span> across the range <span class="s2">0:i</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The return type will match the type of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">integer</span>, but all of the values of the cumulative product vector cannot be represented in that type, an error condition will result.</p>
<p class="p2">(numeric)cumSum(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>cumulative sum</b> of <span class="s2">x</span>: a vector of equal length as <span class="s2">x</span>, in which the element at index <span class="s2">i</span> is equal to the sum of the elements of <span class="s2">x</span> across the range <span class="s2">0:i</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The return type will match the type of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">integer</span>, but all of the values of the cumulative sum vector cannot be represented in that type, an error condition will result.</p>
<p class="p2">(float)exp(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-<i>e</i> exponential</b> of <span class="s2">x, <i>e</i><sup>x</sup></span>,<span class="Apple-converted-space">  </span>using the C++ function <span class="s2">exp()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>This may be somewhat faster than <span class="s2">E^x</span> for large vectors.</p>
<p class="p2">(float)floor(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>floor</b> of <span class="s2">x</span>: the largest integral value less than or equal to <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p2">(integer)integerDiv(integer x, integer y)</p>
<p class="p3">Returns the result of <b>integer division</b> of <span class="s2">x</span> by <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The <span class="s2">/</span> operator in Eidos always produces a <span class="s2">float</span> result; if you want an <span class="s2">integer</span> result you may use this function instead.<span class="Apple-converted-space">  </span>If any value of <span class="s2">y</span> is <span class="s2">0</span>, an error will result.<span class="Apple-converted-space">  </span>The parameters <span class="s2">x</span> and <span class="s2">y</span> must either be of equal length, or one of the two must be a singleton.<span class="Apple-converted-space">  </span>The precise behavior of <span class="s2">integer</span> division, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of <span class="s2">integer</span> division is on the given platform.<span class="Apple-converted-space">  </span>Eidos does not guarantee any particular behavior, so use this function with caution.</p>
<p class="p2">(integer)integerMod(integer x<span class="s1">,</span> integer y)</p>
<p class="p3">Returns the result of <b>integer modulo</b> of <span class="s2">x</span> by <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The <span class="s2">%</span> operator in Eidos always produces a <span class="s2">float</span> result; if you want an <span class="s2">integer</span> result you may use this function instead.<span class="Apple-converted-space">  </span>If any value of <span class="s2">y</span> is <span class="s2">0</span>, an error will result.<span class="Apple-converted-space">  </span>The parameters <span class="s2">x</span> and <span class="s2">y</span> must either be of equal length, or one of the two must be a singleton.<span class="Apple-converted-space">  </span>The precise behavior of <span class="s2">integer</span> modulo, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of <span class="s2">integer</span> modulo is on the given platform.<span class="Apple-converted-space">  </span>Eidos does not guarantee any particular behavior, so use this function with caution.</p>
<p class="p2">(logical)isFinite(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>finiteness</b> of <span class="s2">x</span>: <span class="s2">T</span> if <span class="s2">x</span> is not <span class="s2">INF</span> or <span class="s2">NAN</span>, <span class="s2">F</span> if <span class="s2">x</span> is <span class="s2">INF</span> or <span class="s2">NAN</span><span class="s3">.</span><span class="Apple-converted-space">  </span><span class="s2">INF</span> and <span class="s2">NAN</span> are defined only for type <span class="s2">float</span>, so x is required to be a <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that <span class="s2">isFinite()</span> is not the opposite of <span class="s2">isInfinite()</span>, because <span class="s2">NAN</span> is considered to be neither finite nor infinite.</p>
<p class="p2">(logical)isInfinite(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>infiniteness</b> of <span class="s2">x</span>: <span class="s2">T</span> if <span class="s2">x</span> is <span class="s2">INF</span>, <span class="s2">F</span> otherwise.<span class="Apple-converted-space">  </span><span class="s2">INF</span> is defined only for type <span class="s2">float</span>, so x is required to be a <span class="s2">float</span>.<span class="Apple-converted-space">  </span>Note that <span class="s2">isInfinite()</span> is not the opposite of <span class="s2">isFinite()</span>, because <span class="s2">NAN</span> is considered to be neither finite nor infinite.</p>
<p class="p2">(logical)isNAN(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>undefinedness</b> of <span class="s2">x</span>: <span class="s2">T</span> if <span class="s2">x</span> is not <span class="s2">NAN</span>, <span class="s2">F</span> if <span class="s2">x</span> is <span class="s2">NAN</span><span class="s3">.</span><span class="Apple-converted-space">  </span><span class="s2">NAN</span> is defined only for type <span class="s2">float</span>, so x is required to be a <span class="s2">float</span><span class="s3">.</span></p>
<p class="p2">(float)log(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-<i>e</i> logarithm</b> of <span class="s2">x</span> using the C++ function <span class="s2">log()</span><span class="s3">.</span></p>
<p class="p2">(float)log10(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-10 logarithm</b> of <span class="s2">x</span> using the C++ function <span class="s2">log10()</span><span class="s3">.</span></p>
<p class="p2">(float)log2(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>base-2 logarithm</b> of <span class="s2">x</span> using the C++ function <span class="s2">log2()</span><span class="s3">.</span></p>
<p class="p2">(numeric$)product(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>product</b> of <span class="s2">x</span>: the result of multiplying all of the elements of <span class="s2">x</span> together.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">float</span>, the result will be <span class="s2">float</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">integer</span>, things are a bit more complex; the result will be <span class="s2">integer</span> if it can fit into the <span class="s2">integer</span> type without overflow issues (including during intermediate stages of the computation), otherwise it will be <span class="s2">float</span><span class="s3">.</span></p>
<p class="p2">(float)round(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>round</b> of <span class="s2">x</span>: the integral value nearest to <span class="s2">x</span>, rounding half-way cases away from <span class="s2">0</span> (different from the rounding policy of R, which rounds halfway cases toward the nearest even number).<span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p2">(*)setDifference(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic (asymmetric) difference</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∖</span> <span class="s2">y</span>: a vector containing all elements that are in <span class="s2">x</span> but are not in <span class="s2">y</span>.<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p2">(*)setIntersection(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic intersection</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∩</span> <span class="s2">y</span>: a vector containing all elements that are in both <span class="s2">x</span> and <span class="s2">y</span> (but not in <i>only</i> <span class="s2">x</span> or <span class="s2">y</span>).<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p2">(*)setSymmetricDifference(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic symmetric difference</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∆</span> <span class="s2">y</span>: a vector containing all elements that are in <span class="s2">x</span> or <span class="s2">y</span>, but not in both.<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p2">(*)setUnion(*<span class="s1"> </span>x, *<span class="s1"> </span>y)</p>
<p class="p3">Returns the <b>set-theoretic union</b> of <span class="s2">x</span> and <span class="s2">y</span>, denoted <span class="s2">x</span> <span class="s4">∪</span> <span class="s2">y</span>: a vector containing all elements that are in <span class="s2">x</span> and/or <span class="s2">y</span>.<span class="Apple-converted-space">  </span>Duplicate elements will be stripped out, in the same manner as the <span class="s2">unique()</span> function.<span class="Apple-converted-space">  </span>This function is therefore roughly equivalent to <span class="s2">unique(c(x, y))</span>, but this function will probably be faster.<span class="Apple-converted-space">  </span>The order of elements in the returned vector is arbitrary and should not be relied upon.<span class="Apple-converted-space">  </span>The returned vector will be of the same type as <span class="s2">x</span> and <span class="s2">y</span><span class="s3">,</span> and <span class="s2">x</span> and <span class="s2">y</span> must be of the same type.</p>
<p class="p4">(numeric)sign(numeric x)</p>
<p class="p5">Returns the <b>sign</b> of <span class="s2">x</span>, meaning that for each element of x, a value of either <span class="s2">-1</span>, <span class="s2">0</span>, or <span class="s2">1</span> will be returned as the corresponding element in the returned vector depending upon whether the original element was (respectively) negative, zero, or positive.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">integer</span>, an <span class="s2">integer</span> vector is returned; if <span class="s2">x</span> is <span class="s2">float</span>, a <span class="s2">float</span> vector is returned.</p>
<p class="p2">(float)sin(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>sine</b> of <span class="s2">x</span> using the C++ function <span class="s2">sin()</span><span class="s3">.</span></p>
<p class="p2">(float)sqrt(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>square root</b> of <span class="s2">x</span> using the C++ function <span class="s2">sqrt()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>This may be somewhat faster than <span class="s2">x^0.5</span> for large vectors.</p>
<p class="p2">(numeric$)sum(lif x)</p>
<p class="p3">Returns the <b>sum</b> of <span class="s2">x</span>: the result of adding all of the elements of <span class="s2">x</span> together.<span class="Apple-converted-space">  </span>The unusual parameter type signature <span class="s2">lif</span> indicates that <span class="s2">x</span> can be <span class="s2">logical</span>, <span class="s2">integer</span>, or <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">float</span>, the result will be <span class="s2">float</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">logical</span>, the result will be <span class="s2">integer</span> (the number of <span class="s2">T</span> values in <span class="s2">x</span>, since the <span class="s2">integer</span> values of <span class="s2">T</span> and <span class="s2">F</span> are <span class="s2">1</span> and <span class="s2">0</span> respectively).<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">integer</span>, things are a bit more complex; in this case, the result will be <span class="s2">integer</span> if it can fit into the <span class="s2">integer</span> type without overflow issues (including during intermediate stages of the computation), otherwise it will be <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that floating-point roundoff issues can cause this function to return inexact results when <span class="s2">x</span> is <span class="s2">float</span> type; this is rarely an issue, but see the <span class="s2">sumExact()</span> function for an alternative.</p>
<p class="p2">(float$)sumExact(float x)</p>
<p class="p3">Returns the <b>exact sum</b> of <span class="s2">x</span>: the exact result of adding all of the elements of <span class="s2">x</span> together.<span class="Apple-converted-space">  </span>Unlike the <span class="s2">sum()</span> function, <span class="s2">sumExact()</span> accepts only type <span class="s2">float</span>, since the <span class="s2">sum()</span> function is already exact for other types.<span class="Apple-converted-space">  </span>When summing floating-point values – particularly values that vary across many orders of magnitude – the precision limits of floating-point numbers can lead to roundoff errors that cause the <span class="s2">sum()</span> function to return an inexact result.<span class="Apple-converted-space">  </span>This function does additional work to ensure that the final result is exact within the possible limits of the <span class="s2">float</span> type; some roundoff may still inevitably occur, in other words, but a more exact result could not be represented with a value of type <span class="s2">float</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The disadvantage of using this function instead of <span class="s2">sum()</span> is that it is much slower – about 35 times slower, according to one test on macOS, but that will vary across operating systems and hardware.<span class="Apple-converted-space">  </span>This function is rarely truly needed, but apart from the performance consequences there is no disadvantage to using it.</p>
<p class="p2">(float)tan(numeric<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>tangent</b> of <span class="s2">x</span> using the C++ function <span class="s2">tan()</span><span class="s3">.</span></p>
<p class="p2">(float)trunc(float<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>truncation</b> of <span class="s2">x</span>: the integral value nearest to, but no larger in magnitude than, <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Note that the return value is <span class="s2">float</span> even though integral values are guaranteed, because values could be outside of the range representable by <span class="s2">integer</span><span class="s3">.</span></p>
<p class="p1"><b>3.2.<span class="Apple-converted-space">  </span>Statistics functions</b></p>
<p class="p4"><span class="s5">(float)cor(numeric x, </span>[Nif y = NULL]<span class="s5">)</span></p>
<p class="p5">Returns the <b>sample Pearson’s correlation coefficient</b> between vectors <span class="s2">x</span> and <span class="s2">y</span>, usually denoted <i>r</i>.<span class="Apple-converted-space">  </span>If <span class="s2">y</span> is <span class="s2">NULL</span>, it is considered to have the same value as <span class="s2">x</span>; for vector <span class="s2">x</span> this is not very useful (since the correlation of <span class="s2">x</span> with itself is <span class="s2">1.0</span> by definition), but it is more useful for calculating a correlation matrix using the columns of <span class="s2">x</span> (see below).<span class="Apple-converted-space">  </span>The sizes of <span class="s2">x</span> and <span class="s2">y</span> must be identical.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">y</span> have a size of <span class="s2">0</span> or <span class="s2">1</span>, <span class="s2">NAN</span> will be returned (a change in behavior from Eidos 4.0; it used to return <span class="s2">NULL</span>).<span class="Apple-converted-space">  </span>The return value will be a singleton <span class="s2">float</span>.</p>
<p class="p5">It is also legal to call <span class="s2">cor()</span> with matrix <span class="s2">x</span> and/or <span class="s2">y</span>.<span class="Apple-converted-space">  </span>In this case the return value will be a correlation matrix between x and y.<span class="Apple-converted-space">  </span>Each column of <span class="s2">x</span> will be represented by one row of the result (or if <span class="s2">x</span> is a vector, the result will simply have one row representing <span class="s2">x</span>), and each column of <span class="s2">y</span> will be represented by one column of the result (or if <span class="s2">y</span> is a vector, the result will simply have one column representing <span class="s2">y</span>).<span class="Apple-converted-space">  </span>Each element in the result matrix will therefore represent the correlation between a column of matrix <span class="s2">x</span> (or the entirety of vector <span class="s2">x</span>) and a column of matrix <span class="s2">y</span> (or the entirety of vector y).<span class="Apple-converted-space">  </span>Calling <span class="s2">cor(x, x)</span>, or equivalently <span class="s2">cor(x)</span>, thus produces a symmetric correlation matrix among the columns of <span class="s2">x</span>.</p>
<p class="p4"><span class="s5">(float)cov(numeric x, </span>[Nif y = NULL]<span class="s5">)</span></p>
<p class="p5">Returns the <b>corrected sample covariance</b> between vectors <span class="s2">x</span> and <span class="s2">y</span>.<span class="Apple-converted-space">  </span>If <span class="s2">y</span> is <span class="s2">NULL</span>, it is considered to have the same value as <span class="s2">x</span>; for vector <span class="s2">x</span> this is equivalent to calling <span class="s2">var(x)</span>, but it is more useful for calculating a variance-covariance matrix using the columns of <span class="s2">x</span> (see below).<span class="Apple-converted-space">  </span>The sizes of <span class="s2">x</span> and <span class="s2">y</span> must be identical.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">y</span> have a size of <span class="s2">0</span> or <span class="s2">1</span>, <span class="s2">NAN</span> will be returned (a change in behavior from Eidos 4.0; it used to return <span class="s2">NULL</span>).<span class="Apple-converted-space">  </span>The return value will be a singleton <span class="s2">float</span>.</p>
<p class="p5">It is also legal to call <span class="s2">cov()</span> with matrix <span class="s2">x</span> and/or <span class="s2">y</span>.<span class="Apple-converted-space">  </span>In this case the return value will be a covariance matrix between x and y.<span class="Apple-converted-space">  </span>Each column of <span class="s2">x</span> will be represented by one row of the result (or if <span class="s2">x</span> is a vector, the result will simply have one row representing <span class="s2">x</span>), and each column of <span class="s2">y</span> will be represented by one column of the result (or if <span class="s2">y</span> is a vector, the result will simply have one column representing <span class="s2">y</span>).<span class="Apple-converted-space">  </span>Each element in the result matrix will therefore represent the covariance between a column of matrix <span class="s2">x</span> (or the entirety of vector <span class="s2">x</span>) and a column of matrix <span class="s2">y</span> (or the entirety of vector y).<span class="Apple-converted-space">  </span>Calling <span class="s2">cov(x, x)</span>, or equivalently <span class="s2">cov(x)</span>, thus produces a symmetric variance-covariance matrix among the columns of <span class="s2">x</span>.</p>
<p class="p4">(float)filter(numeric x, float filter, [lif$ outside = F])</p>
<p class="p5">Returns the result of convolving <span class="s2">x</span> with <span class="s2">filter</span>.<span class="Apple-converted-space">  </span>The returned vector will be the same length as <span class="s2">x</span>.<span class="Apple-converted-space">  </span>The convolution is performed by centering <span class="s2">filter</span> on each position of <span class="s2">x</span> to produce a corresponding result element that is the sum over the products of each <span class="s2">filter</span> value with each <span class="s2">x</span> value within the filter’s range.<span class="Apple-converted-space">  </span>The length of <span class="s2">filter</span> is required to be odd, so that the filter has a central value (and can thus be centered over each value of <span class="s2">x</span>).</p>
<p class="p5">If the filter, centered over a given value of <span class="s2">x</span>, extends beyond the end of <span class="s2">x</span> then the calculation of the corresponding element of the result is governed by the <span class="s2">outside</span> parameter.<span class="Apple-converted-space">  </span>When <span class="s2">outside</span> is <span class="s2">F</span> (the default), the corresponding element in the result will be <span class="s2">NAN</span>; this matches the behavior of the R <span class="s2">filter()</span> function (except that R uses <span class="s2">NA</span>).<span class="Apple-converted-space">  </span>If <span class="s2">outside</span> is <span class="s2">T</span>, values outside <span class="s2">x</span> will be excluded from the calculation (the filter value covering that position will be considered to be <span class="s2">0</span>), and the other values in the filter will be adjusted so that the sum of the absolute values of the filter weights used is unchanged, to compensate for the excluded values by giving the positions inside <span class="s2">x</span> more weight. Finally, if <span class="s2">outside</span> is <span class="s2">integer</span> or <span class="s2">float</span>, that value will be used as the value of <span class="s2">x</span> for all positions outside <span class="s2">x</span>; one might pass an expected value or mean value in this way, to be used for all outside positions.</p>
<p class="p5">This function is useful for computing running means and similar transformations of an input vector.<span class="Apple-converted-space">  </span>For a simple running mean of width <span class="s2">w</span>, pass r<span class="s2">ep(1/w, w)</span> for <span class="s2">filter</span>.<span class="Apple-converted-space">  </span>That case is automatically detected and handled efficiently; otherwise, the runtime of this function is proportional to the length of <span class="s2">x</span> times the length of <span class="s2">filter</span>, and so will be slow for long filters.</p>
<p class="p2">(+$)max(+ x, ...)</p>
<p class="p3">Returns the <b>maximum</b> of <span class="s2">x</span> and the other arguments supplied: the single greatest value contained by all of them.<span class="Apple-converted-space">  </span>All of the arguments must be the same type as <span class="s2">x</span>, and the return type will match that of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If all of the arguments have a size of <span class="s2">0</span>, the return value will be <span class="s2">NULL</span>; note that this means that <span class="s2">max(x, max(y))</span> may produce an error, if <span class="s2">max(y)</span> is <span class="s2">NULL</span>, in cases where <span class="s2">max(x, y)</span> does not.</p>
<p class="p2">(float$)mean(lif<span class="s1"> </span>x)</p>
<p class="p5"><span class="s6">Returns the <b>arithmetic mean</b> of </span><span class="s7">x</span><span class="s6">: the sum of </span><span class="s7">x</span><span class="s6"> divided by the number of values in </span><span class="s7">x</span><span class="s8">.</span><span class="s6"><span class="Apple-converted-space">  </span>If </span><span class="s7">x</span><span class="s6"> has a size of </span><span class="s7">0</span><span class="s6">, the return value will be </span><span class="s7">NULL</span><span class="s8">.</span><span class="s5"><span class="Apple-converted-space">  </span>The unusual parameter type signature </span><span class="s9">lif</span><span class="s5"> indicates that </span><span class="s9">x</span><span class="s5"> can be </span><span class="s9">logical</span><span class="s5">, </span><span class="s9">integer</span><span class="s5">, or </span><span class="s9">float</span><span class="s5">; if </span><span class="s9">x</span><span class="s5"> is </span><span class="s9">logical</span><span class="s5">, it is coerced to </span><span class="s9">integer</span><span class="s5"> internally (with </span><span class="s9">F</span><span class="s5"> being </span><span class="s9">0</span><span class="s5"> and </span><span class="s9">T</span><span class="s5"> being </span><span class="s9">1</span><span class="s5">, as always), allowing </span><span class="s9">mean()</span><span class="s5"> to calculate the average truth value of a </span><span class="s9">logical</span><span class="s5"> vector.</span></p>
<p class="p2">(+$)min(+ x, ...)</p>
<p class="p3">Returns the <b>minimum</b> of <span class="s2">x</span> and the other arguments supplied: the single smallest value contained by all of them.<span class="Apple-converted-space">  </span>All of the arguments must be the same type as <span class="s2">x</span>, and the return type will match that of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If all of the arguments have a size of <span class="s2">0</span>, the return value will be <span class="s2">NULL</span>; note that this means that <span class="s2">min(x, min(y))</span> may produce an error, if <span class="s2">min(y)</span> is <span class="s2">NULL</span>, in cases where <span class="s2">min(x, y)</span> does not.</p>
<p class="p2">(+)pmax(+ x, + y)</p>
<p class="p3">Returns the <b>parallel maximum</b> of <span class="s2">x</span> and <span class="s2">y</span>: the element-wise maximum for each corresponding pair of elements in <span class="s2">x</span> and <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The type of <span class="s2">x</span> and <span class="s2">y</span> must match, and the returned value will have the same type.<span class="Apple-converted-space">  </span>In one usage pattern the size of <span class="s2">x</span> and <span class="s2">y</span> match, in which case the returned value will have the same size.<span class="Apple-converted-space">  </span>In the other usage pattern either <span class="s2">x</span> and <span class="s2">y</span> is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton’s element and each of the elements in the non-singleton.</p>
<p class="p2">(+)pmin(+ x, + y)</p>
<p class="p3">Returns the <b>parallel minimum</b> of <span class="s2">x</span> and <span class="s2">y</span>: the element-wise minimum for each corresponding pair of elements in <span class="s2">x</span> and <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The type of <span class="s2">x</span> and <span class="s2">y</span> must match, and the returned value will have the same type.<span class="Apple-converted-space">  </span>In one usage pattern the size of <span class="s2">x</span> and <span class="s2">y</span> match, in which case the returned value will have the same size.<span class="Apple-converted-space">  </span>In the other usage pattern either <span class="s2">x</span> and <span class="s2">y</span> is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton’s element and each of the elements in the non-singleton.</p>
<p class="p4">(float)quantile(numeric x, [Nf probs = NULL])</p>
<p class="p5">Returns <b>sample quantiles</b> of <span class="s2">x</span> for the given probabilities.<span class="Apple-converted-space">  </span>The smallest value in <span class="s2">x</span> corresponds to a probability of <span class="s2">0</span>, and the largest value in <span class="s2">x</span> to a probability of <span class="s2">1</span>.<span class="Apple-converted-space">  </span>The <span class="s2">probs</span> vector should be a vector of probabilities in <span class="s2">[0, 1]</span>, or <span class="s2">NULL</span>, which is equivalent to <span class="s2">c(0.0, 0.25, 0.5, 0.75, 1.0)</span>, requesting sample quartiles.</p>
<p class="p5">The quantile function linearly interpolates between the points of the empirical cumulative distribution function.<span class="Apple-converted-space">  </span>In other words, if <span class="s2">x</span> is a vector of length <i>n</i>+1, then the quantiles with <span class="s2">probs</span> equal to (0, 1/<i>n</i>, 2/<i>n</i>, ..., (<i>n</i>−1)/<i>n</i>, 1) are equal to the sorted values of <span class="s2">x</span>, and the quantile is a linear function of <span class="s2">probs</span> otherwise.<span class="Apple-converted-space">  </span>Note that there are many ways to compute quantiles; this algorithm corresponds to R’s default “type 7” algorithm.</p>
<p class="p2">(numeric)range(numeric<span class="s1"> </span>x, ...)</p>
<p class="p3">Returns the <b>range</b> of <span class="s2">x</span> and the other arguments supplied: a vector of length <span class="s2">2</span> composed of the minimum and maximum values contained by all of them, at indices <span class="s2">0</span> and <span class="s2">1</span> respectively.<span class="Apple-converted-space">  </span>All of the arguments must be the same type as <span class="s2">x</span>, and the return type will match that of <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If all of the arguments have a size of <span class="s2">0</span>, the return value will be <span class="s2">NULL</span>; note that this means that <span class="s2">range(x, range(y))</span> may produce an error, if <span class="s2">range(y)</span> is <span class="s2">NULL</span>, in cases where <span class="s2">range(x, y)</span> does not.</p>
<p class="p4">(numeric)rank(numeric x, [string$ tiesMethod = "average"])</p>
<p class="p5">Returns the <b>ranks</b> of the elements of <span class="s2">x</span>: a vector of length <span class="s2">L</span> (the length of <span class="s2">x</span>), composed of the relative ranks, from <span class="s2">1</span> to <span class="s2">L</span>, of each corresponding element of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>The <span class="s2">tiesMethod</span> parameter may be any of <span class="s2">"average"</span> (the default), <span class="s2">"first"</span>, <span class="s2">"last"</span>, <span class="s2">"max"</span>, or <span class="s2">"min"</span> (<span class="s2">"random"</span>, supported by R, is not supported by Eidos at this time but could be added if needed).<span class="Apple-converted-space">  </span>For <span class="s2">"average"</span>, the return value is of type <span class="s2">float</span>; for all others, it is of type <span class="s2">integer</span>.<span class="Apple-converted-space">  </span>(Note that the return type does <i>not</i> depend upon the type of <span class="s2">x</span>.)</p>
<p class="p5">The result for all of these <span class="s2">tiesMethod</span> values is identical (except for type) if the elements of <span class="s2">x</span> are unique; the difference between these methods is in how ties are resolved.<span class="Apple-converted-space">  </span>Suppose that <i>n</i> elements of <span class="s2">x</span> are tied (because they are equal), corresponding to ranks <i>k</i> through <i>k</i>+<i>n−</i>1.<span class="Apple-converted-space">  </span>For <span class="s2">tiesMethod</span> <span class="s2">"average"</span>, all <i>n</i> tied elements receive the same rank, (<i>k</i> + (<i>n−</i>1)/2), which is the average of the ranks.<span class="Apple-converted-space">  </span>For <span class="s2">"first"</span>, the first tied element receives rank <i>k</i>, upward to the last tied element receiving rank <i>k</i>+<i>n−</i>1.<span class="Apple-converted-space">  </span>For <span class="s2">"last"</span>, the last tied element receives rank <i>k</i>, downward to the first tied element receiving rank <i>k</i>+<i>n−</i>1.<span class="Apple-converted-space">  </span>For <span class="s2">"max"</span>, all <i>n</i> tied element receive the maximum rank, <i>k</i>+<i>n−</i>1.<span class="Apple-converted-space">  </span>For <span class="s2">"min"</span>, all <i>n</i> tied element receive the minimum rank, <i>k</i>.</p>
<p class="p2">(float$)sd(numeric<span class="s1"> </span>x)</p>
<p class="p5">Returns the <b>corrected sample standard deviation</b> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> has a size of <span class="s2">0</span> or <span class="s2">1</span>, <span class="s2">NAN</span> will be returned (a change in behavior from Eidos 4.0; it used to return <span class="s2">NULL</span>).<span class="Apple-converted-space">  </span>Matrix/array dimensions are ignored by <span class="s2">sd()</span>; it simply uses all of the elements of <span class="s2">x</span> for its calculation.</p>
<p class="p2">(float$)ttest(float<span class="s1"> </span>x, [Nf y = NULL], [Nf$ mu = NULL])</p>
<p class="p3">Returns the <i>p</i>-value resulting from running a <i>t</i>-test with the supplied data.<span class="Apple-converted-space">  </span>Two types of <i>t</i><span class="s3">-</span>tests can be performed.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">y</span> are supplied (i.e., <span class="s2">y</span> is non-<span class="s2">NULL</span>), a two-sample unpaired two-sided Welch’s <i>t</i>-test is conducted using the samples in <span class="s2">x</span> and <span class="s2">y</span>, each of which must contain at least two elements.<span class="Apple-converted-space">  </span>The null hypothesis for this test is that the two samples are drawn from populations with the same mean.<span class="Apple-converted-space">  </span>Other options, such as pooled-variance <i>t</i>-tests, paired <i>t</i>-tests, and one-sided <i>t</i>-tests, are not presently available.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">mu</span> are supplied (i.e., <span class="s2">mu</span> is non-<span class="s2">NULL</span>), a one-sample <i>t</i>-test is conducted in which the null hypothesis is that the sample is drawn from a population with mean <span class="s2">mu</span><span class="s3">.</span></p>
<p class="p3">Note that the results from this function are substantially different from those produced by R.<span class="Apple-converted-space">  </span>The Eidos <span class="s2">ttest() </span>function uses uncorrected sample statistics, which means they will be biased for small sample sizes, whereas R probably uses corrected, unbiased sample statistics.<span class="Apple-converted-space">  </span>This is an Eidos bug, and might be fixed if anyone complains.<span class="Apple-converted-space">  </span>If large sample sizes are used, however, the bias is likely to be small, and uncorrected statistics are simpler and faster to compute.</p>
<p class="p4"><span class="s5">(float$)var(numeric x)</span></p>
<p class="p5">Returns the <b>corrected sample variance</b> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> has a size of <span class="s2">0</span> or <span class="s2">1</span>, <span class="s2">NAN</span> will be returned (a change in behavior from Eidos 4.0; it used to return <span class="s2">NULL</span>).<span class="Apple-converted-space">  </span>This is the square of the standard deviation calculated by <span class="s2">sd()</span>.<span class="Apple-converted-space">  </span>It is illegal to call <span class="s2">var()</span> with a matrix or array argument; use <span class="s2">cov()</span> to calculate a variance-covariance matrix.</p>
<p class="p1"><b>3.3.<span class="Apple-converted-space">  </span>Distribution drawing and density functions</b></p>
<p class="p4"><span class="s5">(float)dmvnorm(float x, numeric mu, numeric sigma)</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for a <i>k</i>-dimensional multivariate normal distribution</b> with a length <i>k</i> mean vector </span><span class="s9">mu</span><span class="s5"> and a <i>k</i> × <i>k</i> variance-covariance matrix </span><span class="s9">sigma</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">mu</span><span class="s5"> and </span><span class="s9">sigma</span><span class="s5"> parameters are used for all densities.<span class="Apple-converted-space">  </span>The quantile values, </span><span class="s9">x</span><span class="s5">, should be supplied as a matrix with one row per vector of quantile values and <i>k</i> columns (one column per dimension); for convenience, a single quantile may be supplied as a vector rather than a matrix with just one row.<span class="Apple-converted-space">  </span>The number of dimensions <i>k</i> must be at least two; for <i>k</i>=1, use </span><span class="s9">dnorm()</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Cholesky decomposition of the variance-covariance matrix </span><span class="s9">sigma</span><span class="s5"> is involved as an internal step, and this requires that </span><span class="s9">sigma</span><span class="s5"> be positive-definite; if it is not, an error will result.<span class="Apple-converted-space">  </span>When more than one density is needed, it is much more efficient to call </span><span class="s9">dmvnorm()</span><span class="s5"> once to generate all of the densities, since the Cholesky decomposition of </span><span class="s9">sigma</span><span class="s5"> can then be done just once.</span></p>
<p class="p4"><span class="s5">(float)dbeta(float x, numeric alpha, numeric beta)</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for a beta distribution</b> at quantiles </span><span class="s9">x</span><span class="s5"> with parameters </span><span class="s9">alpha</span><span class="s5"> and </span><span class="s9">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">alpha</span><span class="s5"> and </span><span class="s9">beta</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of the same length as </span><span class="s9">x</span><span class="s5">, specifying a value for each density computation.<span class="Apple-converted-space">  </span>The probability density function is </span><span class="s10"><i>P</i>(<i>s</i> | <i>α</i>,<i>β</i>) = [Γ(<i>α</i>+<i>β</i>)/Γ(<i>α</i>)Γ(<i>β</i>)]<i>s</i></span><span class="s11"><i><sup>α</sup></i><sup>−1</sup></span><span class="s10">(1−<i>s</i>)</span><span class="s11"><i><sup>β</sup></i><sup>−1</sup></span><span class="s5">, where </span><span class="s10"><i>α</i></span><span class="s5"> is </span><span class="s9">alpha</span><span class="s5"> and </span><span class="s10"><i>β</i></span><span class="s5"> is </span><span class="s9">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>Both parameters must be greater than </span><span class="s9">0</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(float)dexp(float x, [numeric mu = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for an exponential distribution</b> at quantiles </span><span class="s9">x</span><span class="s5"> with mean </span><span class="s9">mu</span><span class="s5"> (i.e. rate </span><span class="s9">1/mu</span><span class="s5">).<span class="Apple-converted-space">  </span>The </span><span class="s9">mu</span><span class="s5"> parameter may either be a singleton, specifying a single value to be used for all of the draws, or they may be vectors of the same length as </span><span class="s9">x</span><span class="s5">, specifying a value for each density computation.</span></p>
<p class="p4"><span class="s5">(float)dgamma(float x, numeric mean, numeric shape)</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>probability densities for a gamma distribution</b> at quantiles </span><span class="s9">x</span><span class="s5"> with mean </span><span class="s9">mean</span><span class="s5"> and shape parameter </span><span class="s9">shape</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">mean</span><span class="s5"> and </span><span class="s9">shape</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of the same length as </span><span class="s9">x</span><span class="s5">, specifying a value for each density computation.<span class="Apple-converted-space">  </span>The probability density function is </span><span class="s10"><i>P</i>(<i>s</i> | <i>α</i>,<i>β</i>) = [Γ(<i>α</i>)<i>β</i></span><span class="s11"><i><sup>α</sup></i></span><span class="s10">]</span><span class="s11"><sup>−1</sup></span><span class="s10"><i>s</i></span><span class="s11"><i><sup>α</sup></i><sup>−1</sup></span><span class="s10">exp(−<i>s</i>/<i>β</i>)</span><span class="s5">, where </span><span class="s10"><i>α</i></span><span class="s5"> is the shape parameter </span><span class="s9">shape</span><span class="s5">, and the mean of the distribution given by </span><span class="s9">mean</span><span class="s5"> is equal to </span><span class="s10"><i>αβ</i></span><span class="s5">.</span></p>
<p class="p2">(float)dnorm(float x, [numeric mean = 0], [numeric sd = 1])</p>
<p class="p3">Returns a vector of <b>probability densities for a normal distribution</b> at quantiles <span class="s2">x</span> with mean <span class="s2">mean</span> and standard deviation <span class="s2">sd</span>.<span class="Apple-converted-space">  </span>The <span class="s2">mean</span> and <span class="s2">sd</span> parameters may either be singletons, specifying a single value to be used for all of the densities, or they may be vectors of the same length as <span class="s2">x</span>, specifying a value for each density computation.</p>
<p class="p4">(integer)findInterval(numeric x, numeric vec, [logical$ rightmostClosed = F], [logical$ allInside = F])</p>
<p class="p5">Returns a vector of <b>interval indices</b> for the values in <span class="s2">x</span> within a vector of non-decreasing breakpoints <span class="s2">vec</span>.<span class="Apple-converted-space">  </span>The returned <span class="s2">integer</span> vector contains, for each corresponding element of <span class="s2">x</span>, the index of the interval in <span class="s2">vec</span> within which that element of <span class="s2">x</span> is contained.</p>
<p class="p5">More precisely, if <span class="s2">i</span> is the returned <span class="s2">integer</span> vector from <span class="s2">findInterval(x, v)</span>, and <span class="s2">N</span> is <span class="s2">length(v)</span>, then for each index <span class="s2">j</span> in <span class="s2">x</span>, it will be true that <span class="s2">v[i[j]]</span> ≤ <span class="s2">x[j]</span> &lt; <span class="s2">v[i[j]+1]</span>, treating <span class="s2">v[-1]</span> as <span class="s2">-INF</span> and <span class="s2">v[N]</span> as <span class="s2">INF</span>, <i>assuming</i> that the two flags <span class="s2">rightmostClosed</span> and <span class="s2">allInside</span> have their default value of <span class="s2">F</span>.<span class="Apple-converted-space">  </span>The effects of the flags will be discussed below.<span class="Apple-converted-space">  </span>Note that <span class="s2">vec</span> must be non-decreasing; in other words, it must be sorted in ascending order, although it may have duplicate values.<span class="Apple-converted-space">  </span>The returned vector will thus be equal in length to <span class="s2">x</span>, and each of its elements will be in the interval [<span class="s2">-1</span>, <span class="s2">N-1</span>].</p>
<p class="p5">The <span class="s2">rightmostClosed</span> flag, if <span class="s2">T</span>, alters the above behavior to treat the rightmost interval, <span class="s2">vec[N-2]</span> .. <span class="s2">vec[N-1]</span>, as closed.<span class="Apple-converted-space">  </span>This means that if <span class="s2">x[j]==vec[N-1]</span> (i.e., equals <span class="s2">max(vec)</span>), the corresponding result <span class="s2">i[j]</span> will be <span class="s2">N-2</span> as for all other values in the last interval.</p>
<p class="p5">The <span class="s2">allInside</span> flag, if <span class="s2">T</span>, alters the above behavior to coerce returned indices into <span class="s2">0</span> .. <span class="s2">N-2</span>.<span class="Apple-converted-space">  </span>In other words, <span class="s2">-1</span> is mapped to <span class="s2">0</span>, and <span class="s2">N-1</span> is mapped to <span class="s2">N-2</span>.</p>
<p class="p4"><span class="s5">(float)pnorm(float q, [numeric mean = 0], [numeric sd = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>cumulative distribution function values for a normal distribution</b> at quantiles </span><span class="s9">q</span><span class="s5"> with mean </span><span class="s9">mean</span><span class="s5"> and standard deviation </span><span class="s9">sd</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">mean</span><span class="s5"> and </span><span class="s9">sd</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the quantiles, or they may be vectors of the same length as </span><span class="s9">q</span><span class="s5">, specifying a value for each quantile.</span></p>
<p class="p4"><span class="s5">(float)qnorm(float p, [numeric mean = 0], [numeric sd = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of <b>quantiles for a normal distribution</b> with lower tail probabilities less than </span><span class="s9">p</span><span class="s5">, with mean </span><span class="s9">mean</span><span class="s5"> and standard deviation </span><span class="s9">sd</span><span class="s5">. The </span><span class="s9">mean</span><span class="s5"> and </span><span class="s9">sd</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the quantiles, or they may be vectors of the same length as </span><span class="s9">p</span><span class="s5">, specifying a value for each quantile computation.</span></p>
<p class="p4"><span class="s5">(float)rbeta(integer$ n, numeric alpha, numeric beta)</span></p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s9">n</span><span class="s5"> <b>random draws from a beta distribution</b> with parameters </span><span class="s9">alpha</span><span class="s5"> and </span><span class="s9">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">alpha</span><span class="s5"> and </span><span class="s9">beta</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s9">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>Draws are made from a beta distribution with probability density </span><span class="s10"><i>P</i>(<i>s</i> | <i>α</i>,<i>β</i>) = [Γ(<i>α</i>+<i>β</i>)/Γ(<i>α</i>)Γ(<i>β</i>)]<i>s</i></span><span class="s11"><i><sup>α</sup></i><sup>−1</sup></span><span class="s10">(1−<i>s</i>)</span><span class="s11"><i><sup>β</sup></i><sup>−1</sup></span><span class="s5">, where </span><span class="s10"><i>α</i></span><span class="s5"> is </span><span class="s9">alpha</span><span class="s5"> and </span><span class="s10"><i>β</i></span><span class="s5"> is </span><span class="s9">beta</span><span class="s5">.<span class="Apple-converted-space">  </span>Both parameters must be greater than </span><span class="s9">0</span><span class="s5">.<span class="Apple-converted-space">  </span>The values drawn are in the interval [0, 1].</span></p>
<p class="p2">(integer)rbinom(integer$<span class="s1"> </span>n, integer size, float prob)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a binomial distribution</b> with a number of trials specified by <span class="s2">size</span> and a probability of success specified by <span class="s2">prob</span>.<span class="Apple-converted-space">  </span>The <span class="s2">size</span> and <span class="s2">prob</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p4"><span class="s5">(float)rcauchy(integer$ n, [numeric location = 0], [numeric scale = 1])</span></p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s9">n</span><span class="s5"> <b>random draws from a Cauchy distribution</b> with location </span><span class="s9">location</span><span class="s5"> and scale </span><span class="s9">scale</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">location</span><span class="s5"> and </span><span class="s9">scale</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s9">n</span><span class="s5">, specifying a value for each draw.</span></p>
<p class="p2">(integer)rdunif(integer$ n, [integer min = 0], [integer max<span class="s1"> </span>= 1])</p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s9">n</span><span class="s5"> <b>random draws from a discrete uniform distribution</b> from </span><span class="s9">min</span><span class="s5"> to </span><span class="s9">max</span><span class="s5">, inclusive.<span class="Apple-converted-space">  </span>The </span><span class="s9">min</span><span class="s5"> and </span><span class="s9">max</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s9">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>See </span><span class="s9">runif()</span><span class="s5"> for draws from a continuous uniform distribution.</span></p>
<p class="p2">(float)rexp(integer$<span class="s1"> </span>n, [numeric mu = 1])</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from an exponential distribution</b> with mean <span class="s2">mu</span> (i.e. rate <span class="s2">1/mu</span>).<span class="Apple-converted-space">  </span>The <span class="s2">mu</span> parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p4">(float)rf(integer$ n, numeric d1, numeric d2)</p>
<p class="p5">Returns a vector of <span class="s2">n</span> <b>random draws from an <i>F</i>-distribution</b> with degrees of freedom <span class="s2">d1</span> and <span class="s2">d2</span>.<span class="Apple-converted-space">  </span>The <span class="s2">d1</span> and <span class="s2">d2</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p2">(float)rgamma(integer$<span class="s1"> </span>n, numeric mean, numeric shape)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a gamma distribution</b> with mean <span class="s2">mean</span> and shape parameter <span class="s2">shape</span>.<span class="Apple-converted-space">  </span>The <span class="s2">mean</span> and <span class="s2">shape</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.<span class="Apple-converted-space">  </span>Draws are made from a gamma distribution with probability density <span class="s3"><i>P</i>(<i>s</i> | </span><span class="s12"><i>α</i></span><span class="s3">,</span><span class="s12"><i>β</i></span><span class="s3">) = [</span><span class="s12">Γ</span><span class="s3">(</span><span class="s12"><i>α</i></span><span class="s3">)</span><span class="s12"><i>βα</i></span><span class="s3">]<sup>−1</sup>exp(−<i>s</i>/</span><span class="s12"><i>β</i></span><span class="s3">)</span>, where <span class="s12"><i>α</i></span> is the shape parameter <span class="s2">shape</span>, and the mean of the distribution given by <span class="s2">mean</span> is equal to <span class="s12"><i>αβ</i></span><span class="s3">.</span><span class="Apple-converted-space">  </span>Values of <span class="s2">mean</span> less than zero are allowed, and are equivalent (in principle) to the negation of a draw from a gamma distribution with the same <span class="s2">shape</span> parameter and the negation of the <span class="s2">mean</span> parameter.</p>
<p class="p4"><span class="s5">(integer)rgeom(integer$ n, float p)</span></p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s9">n</span><span class="s5"> <b>random draws from a geometric distribution</b> with parameter </span><span class="s9">p</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">p</span><span class="s5"> parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length </span><span class="s9">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>Eidos follows R in using the geometric distribution with support on the set {0, 1, 2, …}, where the drawn value indicates the number of failures prior to success.<span class="Apple-converted-space">  </span>There is an alternative definition, based upon the number of trial required to get one success, so beware.</span></p>
<p class="p2">(float)rlnorm(integer$<span class="s1"> </span>n, [numeric meanlog = 0], [numeric sdlog = 1])</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a lognormal distribution</b> with mean <span class="s2">meanlog</span> and standard deviation <span class="s2">sdlog</span>, specified on the log scale.<span class="Apple-converted-space">  </span>The <span class="s2">meanlog</span> and <span class="s2">sdlog</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p4"><span class="s5">(float)rmvnorm(integer$ n, numeric mu, numeric sigma)</span></p>
<p class="p5"><span class="s5">Returns a matrix of </span><span class="s9">n</span><span class="s5"> <b>random draws from a <i>k</i>-dimensional multivariate normal distribution</b> with a length <i>k</i> mean vector </span><span class="s9">mu</span><span class="s5"> and a <i>k</i> × <i>k</i> variance-covariance matrix </span><span class="s9">sigma</span><span class="s5">.<span class="Apple-converted-space">  </span>The </span><span class="s9">mu</span><span class="s5"> and </span><span class="s9">sigma</span><span class="s5"> parameters are used for all </span><span class="s9">n</span><span class="s5"> draws.<span class="Apple-converted-space">  </span>The draws are returned as a matrix with </span><span class="s9">n</span><span class="s5"> rows (one row per draw) and <i>k</i> columns (one column per dimension).<span class="Apple-converted-space">  </span>The number of dimensions <i>k</i> must be at least two; for <i>k</i>=1, use </span><span class="s9">rnorm()</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Cholesky decomposition of the variance-covariance matrix </span><span class="s9">sigma</span><span class="s5"> is involved as an internal step, and this requires that </span><span class="s9">sigma</span><span class="s5"> be positive-definite; if it is not, an error will result.<span class="Apple-converted-space">  </span>When more than one draw is needed, it is much more efficient to call </span><span class="s9">rmvnorm()</span><span class="s5"> once to generate all of the draws, since the Cholesky decomposition of </span><span class="s9">sigma</span><span class="s5"> can then be done just once.</span></p>
<p class="p4">(integer)rnbinom(integer$ n, numeric size, float prob)</p>
<p class="p5">Returns a vector of <span class="s2">n</span> <b>random draws from a negative binomial distribution</b> representing the number of failures which occur in a sequence of Bernoulli trials before reaching a target number of successful trials specified by <span class="s2">size</span>, given a probability of success specified by <span class="s2">prob</span>.<span class="Apple-converted-space">  </span>The mean of this distribution for <span class="s2">size</span> <i>s</i> and <span class="s2">prob</span> <i>p</i> is <i>s</i>(1−<i>p</i>)/<i>p</i>, with variance <i>s</i>(1−<i>p</i>)/<i>p</i><span class="s13"><sup>2</sup></span>.<span class="Apple-converted-space">  </span>The <span class="s2">size</span> and <span class="s2">prob</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p2">(float)rnorm(integer$<span class="s1"> </span>n, [numeric mean = 0], [numeric sd = 1])</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a normal distribution</b> with mean <span class="s2">mean</span> and standard deviation <span class="s2">sd</span>.<span class="Apple-converted-space">  </span>The <span class="s2">mean</span> and <span class="s2">sd</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p2">(integer)rpois(integer$<span class="s1"> </span>n, numeric lambda)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a Poisson distribution</b> with parameter <span class="s2">lambda</span> (not to be confused with the language concept of a “lambda”; <span class="s2">lambda</span> here is just the name of a parameter, because the symbol typically used for the parameter of a Poisson distribution is the Greek letter <span class="s12">λ</span>).<span class="Apple-converted-space">  </span>The <span class="s2">lambda</span> parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length <span class="s2">n</span>, specifying a value for each draw.</p>
<p class="p2">(float)runif(integer$ n, [numeric min = 0], [numeric max<span class="s1"> </span>= 1])</p>
<p class="p5"><span class="s5">Returns a vector of </span><span class="s9">n</span><span class="s5"> <b>random draws from a continuous uniform distribution</b> from </span><span class="s9">min</span><span class="s5"> to </span><span class="s9">max</span><span class="s5">, inclusive.<span class="Apple-converted-space">  </span>The </span><span class="s9">min</span><span class="s5"> and </span><span class="s9">max</span><span class="s5"> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length </span><span class="s9">n</span><span class="s5">, specifying a value for each draw.<span class="Apple-converted-space">  </span>See </span><span class="s9">rdunif()</span><span class="s5"> for draws from a discrete uniform distribution.</span></p>
<p class="p2">(float)rweibull(integer$<span class="s1"> </span>n, numeric lambda, numeric k)</p>
<p class="p3">Returns a vector of <span class="s2">n</span> <b>random draws from a Weibull distribution</b> with scale parameter <span class="s2">lambda</span> and shape parameter <span class="s2">k</span>, both greater than zero.<span class="Apple-converted-space">  </span>The <span class="s2">lambda</span> and <span class="s2">k</span> parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length <span class="s2">n</span>, specifying a value for each draw.<span class="Apple-converted-space">  </span>Draws are made from a Weibull distribution with probability distribution <span class="s3"><i>P</i>(<i>s</i> | </span><span class="s12"><i>λ</i></span><span class="s3">,<i>k</i>) = (<i>k</i> / </span><span class="s12"><i>λ</i></span><span class="s3"><i><sup>k</sup></i>) <i>s<sup>k</sup></i><sup>−1</sup> exp(-(<i>s</i>/</span><span class="s12"><i>λ</i></span><span class="s3">)<i><sup>k</sup></i>).</span></p>
<p class="p4">(integer)rztpois(integer$ n, numeric lambda)</p>
<p class="p5">Returns a vector of <span class="s2">n</span> <b>random draws from a zero-truncated Poisson distribution</b> with parameter <span class="s2">lambda</span> (not to be confused with the language concept of a “lambda”; <span class="s2">lambda</span> here is just the name of a parameter, because the symbol typically used for the parameter of a Poisson distribution is the Greek letter <span class="s3"><i>λ</i></span>).<span class="Apple-converted-space">  </span>The zero-truncated Poisson distribution is the conditional probability distribution of a Poisson-distributed random variable, given that the value of the random variable is not zero.<span class="Apple-converted-space">  </span>The values returned by <span class="s2">rztpois()</span> will therefore never be zero.</p>
<p class="p5">The <span class="s2">lambda</span> parameter, <span class="s3"><i>λ</i></span>, may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length <span class="s2">n</span>, specifying a value for each draw.<span class="Apple-converted-space">  </span>It is important to note that for <span class="s2">rpois()</span> the expected mean of the distribution is <span class="s3"><i>λ</i></span>, but for <span class="s2">rztpois()</span> the expected mean of the distribution is <span class="s3"><i>λ</i></span> / (1 − exp(−<span class="s3"><i>λ</i></span>)), precisely because the zero-truncated Poisson distribution is conditional upon being non-zero.</p>
<p class="p1"><b>3.4.<span class="Apple-converted-space">  </span>Vector construction functions</b></p>
<p class="p2">(*)c(...)</p>
<p class="p3">Returns the <b>concatenation</b> of all of its parameters into a single vector<span class="s14">, stripped of all matrix/array dimensions (see </span><span class="s15">rbind()</span><span class="s14"> and </span><span class="s15">cbind()</span><span class="s14"> for concatenation that does not strip this information)</span>.<span class="Apple-converted-space">  </span>The parameters will be promoted to the highest type represented among them, and that type will be the return type.<span class="Apple-converted-space">  </span><span class="s2">NULL</span> values are ignored; they have no effect on the result.</p>
<p class="p2">(float)float(integer$<span class="s1"> </span>length)</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>float</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">0.0</span> values.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p2">(integer)integer(integer$<span class="s1"> </span>length, [integer$ fill1 = 0], [integer$ fill2 = 1], [Ni fill2Indices = NULL])</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>integer</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">0</span> values by default.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p3">If a value is supplied for <span class="s2">fill1</span>, the new vector will be filled with that value instead of the default of <span class="s2">0</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Additionally, if a non-<span class="s2">NULL</span> vector is supplied for <span class="s2">fill2Indices</span>, the indices specified by <span class="s2">fill2Indices</span> will be filled with the value provided by <span class="s2">fill2</span><span class="s3">.</span><span class="Apple-converted-space">  </span>For example, given the default values of <span class="s2">0</span> and <span class="s2">1</span> for <span class="s2">fill1</span> and <span class="s2">fill2</span>, the returned vector will contain <span class="s2">1</span> at all positions specified by <span class="s2">fill2Indices</span>, and will contain <span class="s2">0</span> at all other positions.</p>
<p class="p2">(logical)logical(integer$<span class="s1"> </span>length)</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>logical</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">F</span> values.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p2">(object&lt;Object&gt;)object(void)</p>
<p class="p3">Returns a <b>new empty </b><span class="s2"><b>object</b></span><b> vector</b>.<span class="Apple-converted-space">  </span>Unlike <span class="s2">float()</span>, <span class="s2">integer()</span>, <span class="s2">logical()</span>, and <span class="s2">string()</span>, a length cannot be specified and the new vector contains no elements.<span class="Apple-converted-space">  </span>This is because there is no default value for the object type.<span class="Apple-converted-space">  </span>Adding to such a vector is typically done with <span class="s2">c()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Note that the return value is of type <span class="s2">object&lt;Object&gt;</span>; this method creates an <span class="s2">object</span> vector that does not know what element type it contains.<span class="Apple-converted-space">  </span>Such <span class="s2">object</span> vectors may be mixed freely with other <span class="s2">object</span> vectors in <span class="s2">c()</span> and similar contexts; the result of such mixing will take its <span class="s2">object</span>-element type from the <span class="s2">object</span> vector with a defined <span class="s2">object</span>-element type (if any).</p>
<p class="p2">(*)rep(*<span class="s1"> </span>x, integer$<span class="s1"> </span>count)</p>
<p class="p3">Returns the <b>repetition</b> of <span class="s2">x</span>: the entirety of <span class="s2">x</span> is repeated <span class="s2">count</span> times.<span class="Apple-converted-space">  </span>The return type matches the type of <span class="s2">x</span><span class="s3">.</span></p>
<p class="p2">(*)repEach(*<span class="s1"> </span>x, integer<span class="s1"> </span>count)</p>
<p class="p3">Returns the <b>repetition of elements</b> of <span class="s2">x</span>: each element of <span class="s2">x</span> is repeated.<span class="Apple-converted-space">  </span>If <span class="s2">count</span> is a singleton, it specifies the number of times that each element of <span class="s2">x</span> will be repeated.<span class="Apple-converted-space">  </span>Otherwise, the length of <span class="s2">count</span> must be equal to the length of <span class="s2">x</span>; in this case, each element of <span class="s2">x</span> is repeated a number of times specified by the corresponding value of <span class="s2">count</span><span class="s3">.</span></p>
<p class="p2">(*)sample(* x, integer$ size, [logical$<span class="s1"> </span>replace = F], [Nif weights = NULL])</p>
<p class="p3">Returns a vector of <span class="s2">size</span> containing a <b>sample from the elements of </b><span class="s2"><b>x</b></span>.<span class="Apple-converted-space">  </span>If <span class="s2">replace</span> is <span class="s2">T</span>, sampling is conducted with replacement (the same element may be drawn more than once); if it is <span class="s2">F</span> (the default), then sampling is done without replacement.<span class="Apple-converted-space">  </span>A vector of weights may be supplied in the optional parameter <span class="s2">weights</span>; if not <span class="s2">NULL</span>, it must be equal in size to <span class="s2">x</span>, all weights must be non-negative, and the sum of the weights must be greater than <span class="s2">0</span>.<span class="Apple-converted-space">  </span>If <span class="s2">weights</span> is <span class="s2">NULL</span> (the default), then equal weights are used for all elements of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>An error occurs if <span class="s2">sample()</span> runs out of viable elements from which to draw; most notably, if sampling is done without replacement then <span class="s2">size</span> must be at most equal to the size of <span class="s2">x</span>, but if weights of zero are supplied then the restriction on <span class="s2">size</span> will be even more stringent.<span class="Apple-converted-space">  </span>The draws are obtained from the standard Eidos random number generator, which might be shared with the Context.</p>
<p class="p2">(numeric)seq(numeric$<span class="s1"> </span>from, numeric$<span class="s1"> </span>to, [Nif$<span class="s1"> </span>by<span class="s1"> </span>= NULL], [Ni$<span class="s1"> </span>length = NULL])</p>
<p class="p3">Returns a <b>sequence</b>, starting at <span class="s2">from</span> and proceeding in the direction of <span class="s2">to</span> until the next value in the sequence would fall beyond <span class="s2">to</span>.<span class="Apple-converted-space">  </span>If the optional parameters <span class="s2">by</span> and <span class="s2">length</span> are both <span class="s2">NULL</span> (the default), the sequence steps by values of <span class="s2">1</span> or <span class="s2">-1</span> (as needed to proceed in the direction of <span class="s2">to</span>).<span class="Apple-converted-space">  </span>A different step value may be supplied with <span class="s2">by</span>, but must have the necessary sign.<span class="Apple-converted-space">  </span>Alternatively, a sequence length may be supplied in <span class="s2">length</span>, in which case the step magnitude will be chosen to produce a sequence of the requested length (with the necessary sign, as before).<span class="Apple-converted-space">  </span>If <span class="s2">from</span> and <span class="s2">to</span> are both <span class="s2">integer</span> then the return type will be <span class="s2">integer</span> when possible (but this may not be possible, depending upon values supplied for <span class="s2">by</span> or <span class="s2">length</span>), otherwise it will be <span class="s2">float</span><span class="s3">.</span></p>
<p class="p4"><span class="s5">(integer)seqAlong(* x)</span></p>
<p class="p5"><span class="s5">Returns an <b>index sequence along </b></span><span class="s9"><b>x</b></span><span class="s5">, from </span><span class="s9">0</span><span class="s5"> to </span><span class="s9">size(x) - 1</span><span class="s5">, with a step of </span><span class="s9">1</span><span class="s5">.<span class="Apple-converted-space">  </span>This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.<span class="Apple-converted-space">  </span>Any matrix/array dimension information is ignored; the index sequence is suitable for indexing into </span><span class="s9">x</span><span class="s5"> as a vector.</span></p>
<p class="p4"><span class="s5">(integer)seqLen(integer$ length)</span></p>
<p class="p5"><span class="s5">Returns an <b>index sequence of </b></span><span class="s9"><b>length</b></span><span class="s5">, from </span><span class="s9">0</span><span class="s5"> to </span><span class="s9">length - 1</span><span class="s5">, with a step of </span><span class="s9">1</span><span class="s5">; if </span><span class="s9">length</span><span class="s5"> is </span><span class="s9">0</span><span class="s5"> the sequence will be zero-length.<span class="Apple-converted-space">  </span>This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.<span class="Apple-converted-space">  </span>Note that when </span><span class="s9">length</span><span class="s5"> is </span><span class="s9">0</span><span class="s5">, using the sequence operator with </span><span class="s9">0:(length-1)</span><span class="s5"> will produce </span><span class="s9">0 -1</span><span class="s5">, and calling </span><span class="s9">seq(a, b, length=length)</span><span class="s5"> will raise an error, but </span><span class="s9">seqLen(length)</span><span class="s5"> will return </span><span class="s9">integer(0)</span><span class="s5">, making </span><span class="s9">seqLen()</span><span class="s5"> particularly useful for generating a sequence of a given length that might be zero.</span></p>
<p class="p2">(string)string(integer$<span class="s1"> </span>length)</p>
<p class="p3">Returns a <b>new </b><span class="s2"><b>string</b></span><b> vector</b> of the length specified by <span class="s2">length</span>, filled with <span class="s2">""</span> values.<span class="Apple-converted-space">  </span>This can be useful for pre-allocating a vector which you then fill with values by subscripting.</p>
<p class="p1"><b>3.5.<span class="Apple-converted-space">  </span>Value inspection &amp; manipulation functions</b></p>
<p class="p2">(logical$)all(logical<span class="s1"> </span>x, ...)</p>
<p class="p3">Returns <span class="s2">T</span> if <b>all values are </b><span class="s2"><b>T</b></span> in <span class="s2">x</span> and in any other arguments supplied; if any value is <span class="s2">F</span>, returns <span class="s2">F</span><span class="s3">.</span><span class="Apple-converted-space">  </span>All arguments must be of <span class="s2">logical</span> type.<span class="Apple-converted-space">  </span>If all arguments are zero-length, <span class="s2">T</span> is returned.</p>
<p class="p2">(logical$)any(logical<span class="s1"> </span>x, ...)</p>
<p class="p3">Returns <span class="s2">T</span> if <b>any value is </b><span class="s2"><b>T</b></span> in <span class="s2">x</span> or in any other arguments supplied; if all values are <span class="s2">F</span>, returns <span class="s2">F</span><span class="s3">.</span><span class="Apple-converted-space">  </span>All arguments must be of <span class="s2">logical</span> type.<span class="Apple-converted-space">  </span>If all arguments are zero-length, <span class="s2">F</span> is returned.</p>
<p class="p2">(void)cat(*<span class="s1"> </span>x, [string$<span class="s1"> </span>sep<span class="s1"> </span>= " "]<span class="s6">, [logical$ error = F]</span>)</p>
<p class="p3"><b>Concatenates output</b> to Eidos’s output stream, joined together by <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>The value <span class="s2">x</span> that is output may be of any type.<span class="Apple-converted-space">  </span>A newline is not appended to the output, unlike the behavior of <span class="s2">print()</span>; if a trailing newline is desired, you can use <span class="s2">"\n"</span> (or use the <span class="s2">catn()</span> function).<span class="Apple-converted-space">  </span>Also unlike <span class="s2">print()</span>, <span class="s2">cat()</span> tends to emit very literal output; <span class="s2">print(logical(0))</span> will emit “<span class="s2">logical(0)</span>”, for example – showing a semantic interpretation of the value – whereas <span class="s2">cat(logical(0))</span> will emit nothing at all, since there are no elements in the value (it is zero-length).<span class="Apple-converted-space">  </span>Similarly, <span class="s2">print(NULL)</span> will emit “<span class="s2">NULL</span>”, but <span class="s2">cat(NULL)</span> will emit nothing.</p>
<p class="p5">By default (when <span class="s2">error</span> is <span class="s2">F</span>), the output is sent to the standard Eidos output stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stdout</span>; when running in SLiMgui, this sends it to the simulation window’s output textview.<span class="Apple-converted-space">  </span>If <span class="s2">error</span> is <span class="s2">T</span>, the output is instead sent to the Eidos error stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stderr</span>; when running in SLiMgui, the output is routed to the simulation’s debugging output window.</p>
<p class="p2">(void)catn([*<span class="s1"> </span>x<span class="s1"> </span>= ""], [string$<span class="s1"> </span>sep<span class="s1"> </span>= " "]<span class="s6">, [logical$ error = F]</span>)</p>
<p class="p3"><b>Concatenates output (with a trailing newline)</b> to Eidos’s output stream, joined together by <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>The behavior of <span class="s2">catn()</span> is identical to that of <span class="s2">cat()</span>, except that a final newline character is appended to the output for convenience.<span class="Apple-converted-space">  </span>For <span class="s2">catn()</span> a default value of <span class="s2">""</span> is supplied for <span class="s2">x</span>, to allow a simple <span class="s2">catn()</span> call with no parameters to emit a newline.</p>
<p class="p5">By default (when <span class="s2">error</span> is <span class="s2">F</span>), the output is sent to the standard Eidos output stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stdout</span>; when running in SLiMgui, this sends it to the simulation window’s output textview.<span class="Apple-converted-space">  </span>If <span class="s2">error</span> is <span class="s2">T</span>, the output is instead sent to the Eidos error stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stderr</span>; when running in SLiMgui, the output is routed to the simulation’s debugging output window.</p>
<p class="p2">(string)format(string$<span class="s1"> </span>format, numeric x)</p>
<p class="p3">Returns a vector of <b>formatted strings</b> generated from <span class="s2">x</span>, based upon the formatting string <span class="s2">format</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The <span class="s2">format</span> parameter may be any <span class="s2">string</span> value, but must contain exactly one escape sequence beginning with the <span class="s2">%</span> character.<span class="Apple-converted-space">  </span>This escape sequence specifies how to format a single value from the vector <span class="s2">x</span>.<span class="Apple-converted-space">  </span>The returned vector contains one <span class="s2">string</span> value for each element of <span class="s2">x</span>; each <span class="s2">string</span> value is identical to the string supplied in <span class="s2">format</span>, except with a formatted version of the corresponding value from <span class="s2">x</span> substituted in place of the escape sequence.</p>
<p class="p3">The syntax for <span class="s2">format</span> is a subset of the standard C/C++ <span class="s2">printf()</span>-style format strings (e.g., http://en.cppreference.com/w/c/io/fprintf).<span class="Apple-converted-space">  </span>The escape sequence used to format each value of x is composed of several elements:</p>
<ul class="ul1">
  <li class="li6">–<span class="Apple-converted-space">  </span>A <span class="s2">%</span> character at the beginning, initiating the escape sequence (if an actual <span class="s2">%</span> character is desired, rather than an escape sequence, <span class="s2">%%</span> may be used)</li>
  <li class="li6">–<span class="Apple-converted-space">  </span>Optional flags that modify the style of formatting:</li>
</ul>
<ul class="ul1">
  <li class="li6"><span class="s16">•<span class="Apple-tab-span">	</span></span><span class="s2">-</span> :<span class="Apple-tab-span">	</span>The value is left-justified with the field (as opposed to the default of right-justification).</li>
  <li class="li6"><span class="s16">•<span class="Apple-tab-span">	</span></span><span class="s2">+</span> :<span class="Apple-tab-span">	</span>The sign of the value is always prepended, even if the value is positive (as opposed to the default of appending the sign only if the value is negative).</li>
  <li class="li6"><span class="s17">•<span class="Apple-tab-span">	</span></span><i>space</i> :<span class="Apple-tab-span">	</span>The value is prepended by a space when a sign is not prepended.<span class="Apple-converted-space">  </span>This is ignored if the <span class="s2">+</span> flag is present, since values are then always prepended by a sign.</li>
  <li class="li6"><span class="s16">•<span class="Apple-tab-span">	</span></span><span class="s2">#</span> :<span class="Apple-tab-span">	</span>An alternative format is used.<span class="Apple-converted-space">  </span>For <span class="s2">%o</span>, at least one leading zero is always produced.<span class="Apple-converted-space">  </span>For <span class="s2">%x</span> and <span class="s2">%X</span>, <span class="s2">0x</span> or <span class="s2">0X</span> (respectively) is prepended if the value is nonzero.<span class="Apple-converted-space">  </span>For <span class="s2">%f</span>, <span class="s2">%F</span>, <span class="s2">%e</span>, <span class="s2">%E</span>, <span class="s2">%g</span>, and <span class="s2">%G</span>, a decimal point is forced even if no zeros follow.</li>
  <li class="li6"><span class="s16">•<span class="Apple-tab-span">	</span></span><span class="s2">0</span> :<span class="Apple-tab-span">	</span>Leading zeros are used to pad the field instead of spaces.<span class="Apple-converted-space">  </span>This flag is ignored if the left-justification flag, <span class="s2">-</span>, is present.<span class="Apple-converted-space">  </span>It is also ignored for <span class="s2">integer</span> values, if a precision is specified.</li>
</ul>
<ul class="ul1">
  <li class="li6">–<span class="Apple-converted-space">  </span>An optional minimum field width, specified as an integer value.<span class="Apple-converted-space">  </span>Fields will be padded out to this minimum width.<span class="Apple-converted-space">  </span>Padding will be done with space characters by default (or with zeros, if the <span class="s2">0</span> flag is used), on the left by default (or on the right, if the <span class="s2">-</span> flag is used).</li>
  <li class="li6">–<span class="Apple-converted-space">  </span>An optional precision, given as an integer value preceded by a <span class="s2">.</span> character.<span class="Apple-converted-space">  </span>If no integer value follows the <span class="s2">.</span> character, a precision of zero will be used.<span class="Apple-converted-space">  </span>For integer values of <span class="s2">x</span> (formatted with <span class="s2">%d</span>, <span class="s2">%i</span>, <span class="s2">%o</span>, <span class="s2">%x</span>, or <span class="s2">%X</span>) the precision specifies the minimum number of digits that will appear (with extra zeros on the left if necessary), with a default precision of <span class="s2">1</span><span class="s3">.</span><span class="Apple-converted-space">  </span>For float values of <span class="s2">x</span> formatted with <span class="s2">%f</span>, <span class="s2">%F</span>, <span class="s2">%e</span>, <span class="s2">%E</span>, <span class="s2">%g</span>, or <span class="s2">%G</span>, the precision specifies the minimum number of digits that will appear to the right of the decimal point (with extra zeros on the right if necessary), with a default precision of <span class="s2">6</span><span class="s3">.</span></li>
  <li class="li6">–<span class="Apple-converted-space">  </span>A format specifier.<span class="Apple-converted-space">  </span>For <span class="s2">integer</span> values, this may be <span class="s2">%d</span> or <span class="s2">%i</span> (producing base-10 output; there is no difference between the two), <span class="s2">%o</span> (producing base-8 or octal output), <span class="s2">%x</span> (producing base-16 hexadecimal output using lowercase letters), or <span class="s2">%X</span> (producing base-16 hexadecimal output using uppercase letters).<span class="Apple-converted-space">  </span>For <span class="s2">float</span> values, this may be <span class="s2">%f</span> or <span class="s2">%F</span> to produce decimal notation (of the form <span class="s2">[−]ddd.ddd</span>; there is no difference between the two), <span class="s2">%e</span> or <span class="s2">%E</span> to produce scientific notation (of the form <span class="s2">[−]d.ddde±dd</span> or <span class="s2">[−]d.dddE±dd</span>, respectively), or <span class="s2">%g</span> or <span class="s2">%G</span> to produce either decimal notation or scientific notation (using the formatting of <span class="s2">%f</span> / <span class="s2">%e</span> or <span class="s2">%F</span> / <span class="s2">%E</span>, respectively) on a per-value basis, depending upon the range of the value.</li>
</ul>
<p class="p3">Note that relative to the standard C/C++ <span class="s2">printf()</span>-style behavior, there are a few differences: (1) only a single escape sequence may be present in the format string, (2) the use of <span class="s2">*</span> to defer field width and precision values to a passed parameter is not supported, (3) only <span class="s2">integer</span> and <span class="s2">float</span> values of <span class="s2">x</span> are supported, (4) only the <span class="s2">%d</span>, <span class="s2">%i</span>, <span class="s2">%o</span>, <span class="s2">%x</span>, <span class="s2">%X</span>, <span class="s2">%f</span>, <span class="s2">%F</span>, <span class="s2">%e</span>, <span class="s2">%E</span>, <span class="s2">%g</span>, and <span class="s2">%G</span> format specifiers are supported, and (5) no length modifiers may be supplied, since Eidos does not support different sizes of the <span class="s2">integer</span> and <span class="s2">float</span> types.<span class="Apple-converted-space">  </span>Note also that the Eidos conventions of emitting <span class="s2">INF</span> and <span class="s2">NAN</span> for infinities and Not-A-Number values respectively is not honored by this function; the strings generated for such values are platform-dependent, following the implementation definition of the C++ compiler used to build Eidos, since <span class="s2">format()</span> calls through to <span class="s2">snprintf()</span> to assemble the final string values.</p>
<p class="p3">For example, <span class="s2">format("A number: %+7.2f", c(-4.1, 15.375, 8))</span> will produce a vector with three elements: <span class="s2">"A number: <span class="Apple-converted-space">  </span>-4.10" "A number:<span class="Apple-converted-space">  </span>+15.38" "A number: <span class="Apple-converted-space">  </span>+8.00"</span><span class="s3">.</span><span class="Apple-converted-space">  </span>The precision of <span class="s2">.2</span> results in two digits after the decimal point, the minimum field width of <span class="s2">7</span> results in padding of the values on the left (with spaces) to a minimum of seven characters, the flag <span class="s2">+</span> causes a sign to be shown on positive values as well as negative values, and the format specifier <span class="s2">f</span> leads to the <span class="s2">float</span> values of <span class="s2">x</span> being formatted in base-10 decimal.<span class="Apple-converted-space">  </span>One <span class="s2">string</span> value is produced in the result vector for each value in the parameter <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>These values could then be merged into a single string with <span class="s2">paste()</span>, for example, or printed with <span class="s2">print()</span> or <span class="s2">cat()</span><span class="s3">.</span></p>
<p class="p2">(logical$)identical(* x, * y)</p>
<p class="p3">Returns a <span class="s2">logical</span> value indicating <b>whether two values are identical</b>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> and <span class="s2">y</span> have exactly the same type and size, and all of their corresponding elements are exactly the same, <span class="s14">and (for matrices and arrays) their dimensions are identical, </span>this will return <span class="s2">T</span>, otherwise it will return <span class="s2">F</span>.<span class="Apple-converted-space">  </span>The test here is for <i>exact</i> equality; an <span class="s2">integer</span> value of <span class="s2">1</span> is not considered identical to a <span class="s2">float</span> value of <span class="s2">1.0</span>, for example.<span class="Apple-converted-space">  </span>Elements in <span class="s2">object</span> values must be literally the same element, not simply identical in all of their properties.<span class="Apple-converted-space">  </span>Type promotion is never done.<span class="Apple-converted-space">  </span>For testing whether two values are the same, this is generally preferable to the use of operator <span class="s2">==</span> or operator <span class="s2">!=</span>.<span class="Apple-converted-space">  </span>Note that <span class="s2">identical(NULL,NULL)</span> is <span class="s2">T</span><span class="s3">.</span></p>
<p class="p2">(*)ifelse(logical test, * trueValues, * falseValues)</p>
<p class="p3">Returns the result of a <b>vector conditional</b> operation: a vector composed of values from <span class="s2">trueValues</span>, for indices where <span class="s2">test</span> is <span class="s2">T</span>, and values from <span class="s2">falseValues</span>, for indices where <span class="s2">test</span> is <span class="s2">F</span>.<span class="Apple-converted-space">  </span>The lengths of <span class="s2">trueValues</span> and <span class="s2">falseValues</span> must either be equal to <span class="s2">1</span> or to the length of <span class="s2">test</span>; however, <span class="s2">trueValues</span> and <span class="s2">falseValues</span> don’t need to be the same length as each other.<span class="Apple-converted-space">  </span>Furthermore, the type of <span class="s2">trueValues</span> and <span class="s2">falseValues</span> must be the same (including, if they are <span class="s2">object</span> type, their element type).<span class="Apple-converted-space">  </span>The return will be of the same length as <span class="s2">test</span>, and of the same type as <span class="s2">trueValues</span> and <span class="s2">falseValues</span>.<span class="Apple-converted-space">  </span>Each element of the return vector will be taken from the corresponding element of <span class="s2">trueValues</span> if the corresponding element of <span class="s2">test</span> is <span class="s2">T</span>, or from the corresponding element of <span class="s2">falseValues</span> if the corresponding element of <span class="s2">test</span> is <span class="s2">F</span>; if the vector from which the value is to be taken (i.e., <span class="s2">trueValues</span> or <span class="s2">falseValues</span>) has a length of <span class="s2">1</span>, that single value is used repeatedly, recycling the vector.<span class="s14"><span class="Apple-converted-space">  </span>If </span><span class="s15">test</span><span class="s14">, </span><span class="s15">trueValues</span><span class="s14">, and/or </span><span class="s15">falseValues</span><span class="s14"> are matrices or arrays, that will be ignored by </span><span class="s15">ifelse()</span><span class="s14"> <i>except</i> that the result will be of the same dimensionality as </span><span class="s15">test</span><span class="s14">.</span></p>
<p class="p3">This is quite similar to a function in R of the same name; note, however, that Eidos evaluates all arguments to functions calls immediately, so <span class="s2">trueValues</span> and <span class="s2">falseValues</span> will be evaluated fully regardless of the values in <span class="s2">test</span>, unlike in R.<span class="Apple-converted-space">  </span>Value expressions without side effects are therefore recommended.</p>
<p class="p4"><span class="s5">(integer$)length(* x)</span></p>
<p class="p5"><span class="s5">Returns the <b>size</b> (e.g., length) of </span><span class="s9">x</span><span class="s5">: the number of elements contained in </span><span class="s9">x</span><span class="s5">.<span class="Apple-converted-space">  </span>Note that </span><span class="s9">length()</span><span class="s5"> is a synonym for </span><span class="s9">size()</span><span class="s5">.</span></p>
<p class="p2">(integer)match(* x, * table)</p>
<p class="p3">Returns a vector of the <b>positions of (first) matches</b> of <span class="s2">x</span> in <span class="s2">table</span>.<span class="Apple-converted-space">  </span>Type promotion is not performed; x and <span class="s2">table</span> must be of the same type.<span class="Apple-converted-space">  </span>For each element of <span class="s2">x</span>, the corresponding element in the result will give the position of the first match for that element of <span class="s2">x</span> in <span class="s2">table</span>; if the element has no match in <span class="s2">table</span>, the element in the result vector will be <span class="s2">-1</span>.<span class="Apple-converted-space">  </span>The result is therefore a vector of the same length as <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If a <span class="s2">logical</span> result is desired, with <span class="s2">T</span> indicating that a match was found for the corresponding element of <span class="s2">x</span>, use <span class="s2">(match(x, table) &gt;= 0)</span><span class="s3">.</span></p>
<p class="p2">(integer)order(+ x, [logical$<span class="s1"> </span>ascending<span class="s1"> </span>= T])</p>
<p class="p3">Returns a <b>vector of sorting indices</b> for <span class="s2">x</span>: a new <span class="s2">integer</span> vector of the same length as <span class="s2">x</span>, containing the indices into <span class="s2">x</span> that would sort <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, <span class="s2">x[order(x)]==sort(x)</span>.<span class="Apple-converted-space">  </span>This can be useful for more complex sorting problems, such as sorting several vectors in parallel by a sort order determined by one of the vectors.<span class="Apple-converted-space">  </span>If the optional <span class="s2">logical</span> parameter <span class="s2">ascending</span> is <span class="s2">T</span> (the default), then the sorted order will be ascending; if it is <span class="s2">F</span>, the sorted order will be descending.<span class="Apple-converted-space">  </span>The ordering is determined according to the same logic as the <span class="s2">&lt;</span> and <span class="s2">&gt;</span> operators in Eidos.<span class="Apple-converted-space">  </span>To easily sort vectors in a single step, use <span class="s2">sort()</span> or <span class="s2">sortBy()</span>, for non-<span class="s2">object</span> and <span class="s2">object</span> vectors respectively.</p>
<p class="p4">(string$)paste(..., [string$ sep = " "])</p>
<p class="p5">Returns a <b>joined string</b> composed from the <span class="s2">string</span> representations of the elements of the parameters passed in, taken in order, joined together by <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>Although this function is based upon the R <span class="s2">paste()</span> function of the same name, note that it is much simpler and less powerful; in particular, the result is always a singleton <span class="s2">string</span>, rather than returning a non-singleton <span class="s2">string</span> vector when one of the parameters is a non-singleton.<span class="Apple-converted-space">  </span>The string representation used by <span class="s2">paste()</span> is the same as that emitted by <span class="s2">cat()</span>.</p>
<p class="p4">(string$)paste0(...)</p>
<p class="p5">Returns a <b>joined string</b> composed from the <span class="s2">string</span> representations of the elements of the parameters passed in, taken in order, joined together with no separator.<span class="Apple-converted-space">  </span>This function is identical to <span class="s2">paste()</span>, except that no separator is used.<span class="Apple-converted-space">  </span>Note that this differs from the semantics of <span class="s2">paste0()</span> in R.</p>
<p class="p4"><span class="s6">(void)print(*</span><span class="s18"> </span><span class="s6">x</span>, [logical$ error = F]<span class="s6">)</span></p>
<p class="p3"><b>Prints output</b> to Eidos’s output stream.<span class="Apple-converted-space">  </span>The value <span class="s2">x</span> that is output may be of any type.<span class="Apple-converted-space">  </span>A newline is appended to the output.<span class="Apple-converted-space">  </span>See <span class="s2">cat()</span> for a discussion of the differences between <span class="s2">print()</span> and <span class="s2">cat()</span><span class="s3">.</span></p>
<p class="p5">By default (when <span class="s2">error</span> is <span class="s2">F</span>), the output is sent to the standard Eidos output stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stdout</span>; when running in SLiMgui, this sends it to the simulation window’s output textview.<span class="Apple-converted-space">  </span>If <span class="s2">error</span> is <span class="s2">T</span>, the output is instead sent to the Eidos error stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stderr</span>; when running in SLiMgui, the output is routed to the simulation’s debugging output window.</p>
<p class="p2">(*)rev(*<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>reverse</b> of <span class="s2">x</span>: a new vector with the same elements as <span class="s2">x</span>, but in the opposite order.</p>
<p class="p2">(integer$)size(*<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>size</b> of <span class="s2">x</span>: the number of elements contained in <span class="s2">x</span><span class="s3">.</span><span class="s14"><span class="Apple-converted-space">  </span>Note that </span><span class="s15">length()</span><span class="s14"> is a synonym for </span><span class="s15">size()</span><span class="s14">.</span></p>
<p class="p2">(+)sort(+ x, [logical$<span class="s1"> </span>ascending<span class="s1"> </span>= T])</p>
<p class="p3">Returns a <b>sorted copy</b> of <span class="s2">x</span>: a new vector with the same elements as <span class="s2">x</span>, but in sorted order.<span class="Apple-converted-space">  </span>If the optional <span class="s2">logical</span> parameter <span class="s2">ascending</span> is <span class="s2">T</span> (the default), then the sorted order will be ascending; if it is <span class="s2">F</span>, the sorted order will be descending.<span class="Apple-converted-space">  </span>The ordering is determined according to the same logic as the <span class="s2">&lt;</span> and <span class="s2">&gt;</span> operators in Eidos.<span class="Apple-converted-space">  </span>To sort an <span class="s2">object</span> vector, use <span class="s2">sortBy()</span><span class="s3">.</span><span class="Apple-converted-space">  </span>To obtain indices for sorting, use <span class="s2">order()</span><span class="s3">.</span></p>
<p class="p2">(object)sortBy(object x, string$<span class="s1"> </span>property, [logical$<span class="s1"> </span>ascending<span class="s1"> </span>= T])</p>
<p class="p3">Returns a <b>sorted copy</b> of <span class="s2">x</span>: a new vector with the same elements as <span class="s2">x</span>, but in sorted order.<span class="Apple-converted-space">  </span>If the optional <span class="s2">logical</span> parameter <span class="s2">ascending</span> is <span class="s2">T</span> (the default), then the sorted order will be ascending; if it is <span class="s2">F</span>, the sorted order will be descending.<span class="Apple-converted-space">  </span>The ordering is determined according to the same logic as the <span class="s2">&lt;</span> and <span class="s2">&gt;</span> operators in Eidos.<span class="Apple-converted-space">  </span>The <span class="s2">property</span> argument gives the name of the property within the elements of <span class="s2">x</span> according to which sorting should be done.<span class="Apple-converted-space">  </span>This must be a simple property name; it cannot be a property path.<span class="Apple-converted-space">  </span>For example, to sort a <span class="s2">Mutation</span> vector by the selection coefficients of the mutations, you would simply pass <span class="s2">"selectionCoeff"</span>, including the quotes, for <span class="s2">property</span><span class="s3">.</span><span class="Apple-converted-space">  </span>To sort a non-<span class="s2">object</span> vector, use <span class="s2">sort()</span>.<span class="Apple-converted-space">  </span>To obtain indices for sorting, use <span class="s2">order()</span><span class="s3">.</span></p>
<p class="p4"><span class="s6">(void)str(*</span><span class="s18"> </span><span class="s6">x</span>, [logical$ error = F]<span class="s6">)</span></p>
<p class="p3"><b>Prints the structure</b> of <span class="s2">x</span>: a summary of its type and the values it contains.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is an <span class="s2">object</span><span class="s3">,</span> note that <span class="s2">str()</span> produces different results from the <span class="s2">str()</span> method of <span class="s2">x</span>; the <span class="s2">str()</span> function prints the external structure of <span class="s2">x</span> (the fact that it is an object, and the number and type of its elements), whereas the <span class="s2">str()</span> method prints the internal structure of <span class="s2">x</span> (the external structure of all the properties contained by <span class="s2">x</span>).</p>
<p class="p5">By default (when <span class="s2">error</span> is <span class="s2">F</span>), the output is sent to the standard Eidos output stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stdout</span>; when running in SLiMgui, this sends it to the simulation window’s output textview.<span class="Apple-converted-space">  </span>If <span class="s2">error</span> is <span class="s2">T</span>, the output is instead sent to the Eidos error stream.<span class="Apple-converted-space">  </span>When running at the command line, this sends it to <span class="s2">stderr</span>; when running in SLiMgui, the output is routed to the simulation’s debugging output window.</p>
<p class="p4">(integer)tabulate(integer bin, [Ni$ maxbin = NULL])</p>
<p class="p5">Returns <b>occurrence counts</b> for each non-negative integer in <span class="s2">bin</span>.<span class="Apple-converted-space">  </span>Occurrence counts are tabulated into bins for each value <span class="s2">0:maxbin</span> in <span class="s2">bin</span>; values outside that range are ignored.<span class="Apple-converted-space">  </span>The default value of <span class="s2">maxbin</span>, <span class="s2">NULL</span>, is equivalent to passing <span class="s2">maxbin=max(0, bin)</span>; in other words, by default the result vector will be exactly large enough to accommodate counts for every integer in <span class="s2">bin</span>.<span class="Apple-converted-space">  </span>In any case, the result vector will contain <span class="s2">maxbin+1</span> elements (some or all of which might be zero, if the occurrence count of that integer in <span class="s2">bin</span> is zero).</p>
<p class="p5">Note that the semantics of this function differ slightly from the <span class="s2">tabulate()</span> function in R, because R is <span class="s2">1</span>-based and Eidos is <span class="s2">0</span>-based.</p>
<p class="p2">(*)unique(* x, [logical$ preserveOrder = T])</p>
<p class="p3">Returns the <b>unique values</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, for each value <span class="s2">k</span> in <span class="s2">x</span> that occurs at least once, the vector returned will contain <span class="s2">k</span> exactly once.<span class="Apple-converted-space">  </span>If <span class="s2">preserveOrder</span> is <span class="s2">T</span> (the default), the order of values in <span class="s2">x</span> is preserved, taking the first instance of each value; this is relatively slow, with O(<i>n</i>^2) performance.<span class="Apple-converted-space">  </span>If <span class="s2">preserveOrder</span> if <span class="s2">F</span> instead, the order of values in <span class="s2">x</span> is not preserved, and no particular ordering should be relied upon; this is relatively fast, with O(<i>n</i> log <i>n</i>) performance.<span class="Apple-converted-space">  </span>This performance difference will only matter for large vectors, however; for most applications the default behavior can be retained whether the order of the result matters or not.</p>
<p class="p2">(integer)which(logical<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>indices of </b><span class="s2"><b>T</b></span><b> values</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, if an index <span class="s2">k</span> in <span class="s2">x</span> is <span class="s2">T</span>, then the vector returned will contain <span class="s2">k</span>; if index <span class="s2">k</span> in <span class="s2">x</span> is <span class="s2">F</span>, the vector returned will omit <span class="s2">k</span>.<span class="Apple-converted-space">  </span>One way to look at this is that it converts from a <span class="s2">logical</span> subsetting vector to an <span class="s2">integer</span> (index-based) subsetting vector, without changing which subset positions would be selected.</p>
<p class="p2">(integer$)whichMax(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>index of the (first) maximum value</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, if <span class="s2">k</span> is equal to the maximum value in <span class="s2">x</span>, then the vector returned will contain the index of the first occurrence of <span class="s2">k</span> in <span class="s2">x</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If the maximum value is unique, the result is the same as (but more efficient than) the expression <span class="s2">which(x==max(x))</span>, which returns the indices of <i>all</i> of the occurrences of the maximum value in <span class="s2">x</span><span class="s3">.</span></p>
<p class="p2">(integer$)whichMin(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>index of the (first) minimum value</b> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>In other words, if <span class="s2">k</span> is equal to the minimum value in <span class="s2">x</span>, then the vector returned will contain the index of the first occurrence of <span class="s2">k</span> in <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If the minimum value is unique, the result is the same as (but more efficient than) the expression <span class="s2">which(x==min(x))</span>, which returns the indices of <i>all</i> of the occurrences of the minimum value in <span class="s2">x</span><span class="s3">.</span></p>
<p class="p1"><b>3.6.<span class="Apple-converted-space">  </span>Value type testing and coercion functions</b></p>
<p class="p2">(float)asFloat(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>conversion to </b><span class="s2"><b>float</b></span> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is <span class="s2">string</span> and cannot be converted to <span class="s2">float</span>, Eidos will throw an error.</p>
<p class="p2">(integer)asInteger(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>conversion to </b><span class="s2"><b>integer</b></span> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">string</span> or <span class="s2">float</span> and cannot be converted to <span class="s2">integer</span>, Eidos will throw an error.</p>
<p class="p2">(logical)asLogical(+<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>conversion to </b><span class="s2"><b>logical</b></span> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Recall that in Eidos the empty <span class="s2">string</span> <span class="s2">""</span> is considered <span class="s2">F</span>, and all other <span class="s2">string</span> values are considered <span class="s2">T</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Converting <span class="s2">INF</span> or <span class="s2">-INF</span> to <span class="s2">logical</span> yields <span class="s2">T</span> (since those values are not equal to zero); converting <span class="s2">NAN</span> to <span class="s2">logical</span> throws an error.</p>
<p class="p2">(string)asString(+<span class="s1"> </span>x)</p>
<p class="p5"><span class="s6">Returns the <b>conversion to </b></span><span class="s7"><b>string</b></span><span class="s6"> of </span><span class="s7">x</span><span class="s8">.</span><span class="s5"><span class="Apple-converted-space">  </span>Note that </span><span class="s9">asString(NULL)</span><span class="s5"> returns </span><span class="s9">"NULL"</span><span class="s5"> even though </span><span class="s9">NULL</span><span class="s5"> is zero-length.</span></p>
<p class="p2">(string$)elementType(*<span class="s1"> </span>x)</p>
<p class="p3">Returns the <b>element type</b> of <span class="s2">x</span>, as a <span class="s2">string</span>.<span class="Apple-converted-space">  </span>For the non-<span class="s2">object</span> types, the element type is the same as the type: <span class="s2">"NULL"</span>, <span class="s2">"logical"</span>, <span class="s2">"integer"</span>, <span class="s2">"float"</span>, or <span class="s2">"string"</span>.<span class="Apple-converted-space">  </span>For <span class="s2">object</span> type, however, <span class="s2">elementType()</span> returns the name of the type of element contained by the object, such as <span class="s2">"Species"</span> or <span class="s2">"Mutation"</span> in the Context of SLiM.<span class="Apple-converted-space">  </span>Contrast this with <span class="s2">type()</span><span class="s3">.</span></p>
<p class="p2">(logical$)isFloat(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>float</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isInteger(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>integer</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isLogical(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>logical</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isNULL(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>NULL</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isObject(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>object</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(logical$)isString(*<span class="s1"> </span>x)</p>
<p class="p3">Returns <span class="s2">T</span> if <span class="s2">x</span> <b>is </b><span class="s2"><b>string</b></span><b> type</b>, <span class="s2">F</span> otherwise.</p>
<p class="p2">(string$)type(*<span class="s1"> </span>x)</p>
<p class="p7"><span class="s19">Returns the <b>type</b> of </span>x<span class="s19">, as a </span>string<span class="s19">: </span>"NULL"<span class="s19">, </span>"logical"<span class="s19">, </span>"integer"<span class="s19">, </span>"float"<span class="s19">, </span>"string"<span class="s19">, or </span>"object"<span class="s19">.<span class="Apple-converted-space">  </span>Contrast this with </span>elementType()<span class="s3">.</span></p>
<p class="p1"><b>3.7.<span class="Apple-converted-space">  </span>String manipulation functions</b></p>
<p class="p4">(lis)grep(string$ pattern, string x, [logical$ ignoreCase = F], [string$ grammar = "ECMAScript"], [string$ value = "indices"], [logical$ fixed = F], [logical$ invert = F])</p>
<p class="p5">Searches for <b>regular expression matches</b> in the string-elements of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Regular expressions (regexes) express patterns that strings can either match or not match; they are very widely used in programming languages and terminal shells.<span class="Apple-converted-space">  </span>The topic of regexes is very complex, and a great deal of information about them can be found online, including examples and tutorials; this manual will not attempt to document the topic in detail.</p>
<p class="p5">The <span class="s2">grep()</span> function uses a regex supplied in <span class="s2">pattern</span>, looking for matches for the regex in each element of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">ignoreCase</span> is <span class="s2">F</span> (the default), the pattern matching will be case sensitive (i.e., uppercase versus lowercase will matter); if it is T, the pattern matching will be case-insensitive.</p>
<p class="p5">The <span class="s2">grammar</span> parameter determines the regex grammar used to find matches.<span class="Apple-converted-space">  </span>Several options are available.<span class="Apple-converted-space">  </span>The default, <span class="s2">"ECMAScript"</span>, is a straightforward regex grammar, the specification for which can be found at <a href="https://www.cplusplus.com/reference/regex/ECMAScript/"><span class="s20">https://www.cplusplus.com/reference/regex/ECMAScript/</span></a> among many other links.<span class="Apple-converted-space">  </span>The <span class="s2">"basic"</span> grammar uses POSIX basic regular expressions, often called BRE; this is documented at <a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions"><span class="s20">https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions</span></a>.<span class="Apple-converted-space">  </span>The <span class="s2">"extended"</span> grammar uses POSIX extended regular expressions, often called ERE; this is documented at <a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions"><span class="s20">https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions</span></a>.<span class="Apple-converted-space">  </span>The <span class="s2">"awk"</span> grammar is based upon the <span class="s2">"extended"</span> grammar, with more escapes for non-printing characters.<span class="Apple-converted-space">  </span>The <span class="s2">"grep"</span> and <span class="s2">"egrep"</span> grammars are based upon the <span class="s2">"basic"</span> and <span class="s2">"extended"</span> grammars, respectively, but also allow newline characters (<span class="s2">"\n"</span>) to separate alternations.<span class="Apple-converted-space">  </span>If you are not sure which grammar you want to use, <span class="s2">"ECMAScript"</span> is recommended.<span class="Apple-converted-space">  </span>All of these grammars are implemented internally in Eidos using the C++ <span class="s2">&lt;regex&gt;</span> library, so if you need clarification on the details of a grammar, you can search for related C++ materials online.</p>
<p class="p5">Information about the matches found is returned in one of four ways.<span class="Apple-converted-space">  </span>If <span class="s2">value</span> is <span class="s2">"indices"</span> (the default), an <span class="s2">integer</span> vector is returned containing the index in <span class="s2">x</span> for each match.<span class="Apple-converted-space">  </span>If <span class="s2">value</span> is <span class="s2">"elements"</span>, a <span class="s2">string</span> vector is returned containing the actual string-elements of <span class="s2">x</span> for each match.<span class="Apple-converted-space">  </span>If <span class="s2">value</span> is <span class="s2">"matches"</span>, a <span class="s2">string</span> vector is returned containing only the substring that matched, within each string-element in <span class="s2">x</span> that matched (if more than one substring in a given element matched, the <i>first</i> match is returned).<span class="Apple-converted-space">  </span>Finally, if <span class="s2">value</span> is <span class="s2">"logical"</span> a <span class="s2">logical</span> vector is returned, of the same length as <span class="s2">x</span>, containing <span class="s2">T</span> where the corresponding element of <span class="s2">x</span> matched, or <span class="s2">F</span> where it did not match.<span class="Apple-converted-space">  </span>This function therefore encapsulates the functionality of both the <span class="s2">grep()</span> and <span class="s2">grepl()</span> functions of R; use <span class="s2">value="logical"</span> for functionality like that of R’s <span class="s2">grepl()</span>.</p>
<p class="p5">If <span class="s2">fixed</span> is <span class="s2">F</span> (the default), matching is determined using <span class="s2">pattern</span> following the specified regex grammar as described above.<span class="Apple-converted-space">  </span>If <span class="s2">fixed</span> is <span class="s2">T</span>, matching is instead determined using <span class="s2">pattern</span> as a <span class="s2">string</span> value to be matched “as is”, rather than as a regular expression; the <span class="s2">grammar</span> specified does not matter in this case, but <span class="s2">ignoreCase</span> still applies.<span class="Apple-converted-space">  </span>This could be thought of as another <span class="s2">grammar</span> value, really, meaning “no grammar”, but it is supplied as a separate flag following R.</p>
<p class="p5">Finally, if <span class="s2">invert</span> if <span class="s2">F</span> (the default) matching proceeds as normal for the chosen regex grammar, whereas if <span class="s2">invert</span> if <span class="s2">T</span> matching is inverted: indices, elements, or <span class="s2">logical</span> values are returned for the elements of <span class="s2">x</span> that did <i>not</i> match.<span class="Apple-converted-space">  </span>If <span class="s2">invert</span> is <span class="s2">T</span>, the <span class="s2">value</span> parameter may not be <span class="s2">"matches"</span>.</p>
<p class="p5">Note that there is not presently any way to extract subpattern matches, nor is there any way to perform replacements of matches.</p>
<p class="p4">(integer)nchar(string x)</p>
<p class="p5">Returns a vector of the <b>number of characters</b> in the string-elements of <span class="s2">x</span>.</p>
<p class="p4">(logical)strcontains(string x, string$ s, [integer$ pos = 0])</p>
<p class="p5">Returns the <b>occurrence of a string</b> specified by <span class="s2">s</span> in each of the elements of <span class="s2">x</span>, starting at position <span class="s2">pos</span>.<span class="Apple-converted-space">  </span>Position <span class="s2">0</span>, the default, is the beginning of <span class="s2">x</span>; a position of <span class="s2">0</span> means the entire string is searched.<span class="Apple-converted-space">  </span>A starting search position that is at or beyond the end of a given element of <span class="s2">x</span> is not an error; it just implies that a match will not be found in that element.<span class="Apple-converted-space">  </span>The existences of matches are returned as a <span class="s2">logical</span> vector; if a match was found in a given element, the corresponding value in the returned vector is <span class="s2">T</span>, otherwise it is <span class="s2">F</span>.<span class="Apple-converted-space">  </span>This function is a simplified version of <span class="s2">strfind()</span>, which returns the positions of matches.<span class="Apple-converted-space">  </span>The <span class="s2">strprefix()</span> and <span class="s2">strsuffix()</span> functions are also related.</p>
<p class="p4">(integer)strfind(string x, string$ s, [integer$ pos = 0])</p>
<p class="p5">Returns the <b>first occurrence of a string</b> specified by <span class="s2">s</span> in each of the elements of <span class="s2">x</span>, starting at position <span class="s2">pos</span>.<span class="Apple-converted-space">  </span>Position <span class="s2">0</span>, the default, is the beginning of <span class="s2">x</span>; a position of <span class="s2">0</span> means the entire string is searched.<span class="Apple-converted-space">  </span>A starting search position that is at or beyond the end of a given element of <span class="s2">x</span> is not an error; it just implies that a match will not be found in that element.<span class="Apple-converted-space">  </span>The positions of matches are returned as an <span class="s2">integer</span> vector; if no match was found in a given element, the corresponding value in the returned vector is <span class="s2">-1</span>.<span class="Apple-converted-space">  </span>The <span class="s2">strcontains()</span> function may be used when a logical value (found / not found) is desired.</p>
<p class="p4">(logical)strprefix(string x, string$ s)</p>
<p class="p5">Returns the <b>occurrence of a prefix string</b> specified by <span class="s2">s</span> at the beginning of each of the elements of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>The existences of prefixes are returned as a <span class="s2">logical</span> vector; if a given element begins with the prefix, the corresponding value in the returned vector is <span class="s2">T</span>, otherwise it is <span class="s2">F</span>.</p>
<p class="p4">(string)strsplit(string$ x, [string$ sep = " "])</p>
<p class="p5">Returns <b>substrings</b> of <span class="s2">x</span> that were separated by the separator string <span class="s2">sep</span>.<span class="Apple-converted-space">  </span>Every substring defined by an occurrence of the separator is included, and thus zero-length substrings may be returned.<span class="Apple-converted-space">  </span>For example, <span class="s2">strsplit(".foo..bar.", ".")</span> returns a string vector containing <span class="s2">""</span>, <span class="s2">"foo"</span>, <span class="s2">""</span>, <span class="s2">"bar"</span>, <span class="s2">""</span>.<span class="Apple-converted-space">  </span>In that example, the empty string between <span class="s2">"foo"</span> and <span class="s2">"bar"</span> in the returned vector is present because there were two periods between <span class="s2">foo</span> and <span class="s2">bar</span> in the input string – the empty string is the substring between those two separators.<span class="Apple-converted-space">  </span>If <span class="s2">sep</span> is <span class="s2">""</span>, a vector of single characters will be returned, resulting from splitting <span class="s2">x</span> at every position.<span class="Apple-converted-space">  </span>Note that <span class="s2">paste()</span> performs the inverse operation of <span class="s2">strsplit()</span>.</p>
<p class="p4">(logical)strsuffix(string x, string$ s)</p>
<p class="p5">Returns the <b>occurrence of a suffix string</b> specified by <span class="s2">s</span> at the end of each of the elements of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>The existences of suffixes are returned as a <span class="s2">logical</span> vector; if a given element ends with the suffix, the corresponding value in the returned vector is <span class="s2">T</span>, otherwise it is <span class="s2">F</span>.</p>
<p class="p4">(string)substr(string x, integer first, [Ni last = NULL])</p>
<p class="p5">Returns <b>substrings</b> extracted from the elements of <span class="s2">x,</span> spanning character position <span class="s2">first</span> to character position <span class="s2">last</span> (inclusive).<span class="Apple-converted-space">  </span>Character positions are numbered from <span class="s2">0</span> to <span class="s2">nchar(x)-1</span>.<span class="Apple-converted-space">  </span>Positions that fall outside of that range are legal; a substring range that encompasses no characters will produce an empty string.<span class="Apple-converted-space">  </span>If <span class="s2">first</span> is greater than <span class="s2">last</span>, an empty string will also result.<span class="Apple-converted-space">  </span>If <span class="s2">last</span> is NULL (the default), then the substring will extend to the end of the string.<span class="Apple-converted-space">  </span>The parameters <span class="s2">first</span> and <span class="s2">last</span> may either be singletons, specifying a single value to be used for all of the substrings, or they may be vectors of the same length as <span class="s2">x</span>, specifying a value for each substring.</p>
<p class="p1"><b>3.8.<span class="Apple-converted-space">  </span>Matrix and array functions</b></p>
<p class="p2">(*)apply(* x, integer margin, string$ lambdaSource)</p>
<p class="p8"><span class="s5"><i>Prior to Eidos 1.6 / SLiM 2.6, </i></span><span class="s9"><i>sapply()</i></span><span class="s5"><i> was named </i></span><span class="s9"><i>apply()</i></span><span class="s5"><i>, and this function did not yet exist</i></span></p>
<p class="p5"><span class="s5"><b>Applies a block of Eidos code to margins of x</b>.<span class="Apple-converted-space">  </span>This function is essentially an extension of </span><span class="s9">sapply()</span><span class="s5"> for use with matrices and arrays; it is recommended that you fully understand </span><span class="s9">sapply()</span><span class="s5"> before tackling this function.<span class="Apple-converted-space">  </span>As with </span><span class="s9">sapply()</span><span class="s5">, the lambda specified by </span><span class="s9">lambdaSource</span><span class="s5"> will be executed for subsets of </span><span class="s9">x</span><span class="s5">, and the results will be concatenated together with type-promotion in the style of </span><span class="s9">c()</span><span class="s5"> to produce a result.<span class="Apple-converted-space">  </span>Unlike </span><span class="s9">sapply()</span><span class="s5">, however, the subsets of </span><span class="s9">x</span><span class="s5"> used might be rows, columns, or higher-dimensional slices of </span><span class="s9">x</span><span class="s5">, rather than just single elements, depending upon the value of </span><span class="s9">margin</span><span class="s5">.<span class="Apple-converted-space">  </span>For </span><span class="s9">apply()</span><span class="s5">, </span><span class="s9">x</span><span class="s5"> must be a matrix or array.<span class="Apple-converted-space">  </span>The </span><span class="s9">apply()</span><span class="s5"> function in Eidos is patterned directly after the </span><span class="s9">apply()</span><span class="s5"> function in R, and should behave identically, except that dimension indices in Eidos are zero-based whereas in R they are one-based.</span></p>
<p class="p5"><span class="s5">The </span><span class="s9">margin</span><span class="s5"> parameter gives the indices of dimensions of </span><span class="s9">x</span><span class="s5"> that will be iterated over when assembling values to supply to lambdaSource.<span class="Apple-converted-space">  </span>If </span><span class="s9">x</span><span class="s5"> is a matrix it has two dimensions: rows, of dimension index </span><span class="s9">0</span><span class="s5">, and columns, of dimension index </span><span class="s9">1</span><span class="s5">.<span class="Apple-converted-space">  </span>These are the indices of the dimension sizes returned by </span><span class="s9">dim()</span><span class="s5">; </span><span class="s9">dim(x)[0]</span><span class="s5"> gives the number of rows of </span><span class="s9">x</span><span class="s5">, and </span><span class="s9">dim(x)[1]</span><span class="s5"> gives the number of columns.<span class="Apple-converted-space">  </span>These dimension indices are also apparent when subsetting </span><span class="s9">x</span><span class="s5">; a subset index in position </span><span class="s9">0</span><span class="s5">, such as </span><span class="s9">x[m,]</span><span class="s5">, gives row </span><span class="s9">m</span><span class="s5"> of </span><span class="s9">x</span><span class="s5">, whereas a subset index in position </span><span class="s9">1</span><span class="s5">, such as </span><span class="s9">x[,n]</span><span class="s5">, gives column </span><span class="s9">n</span><span class="s5"> of </span><span class="s9">x</span><span class="s5">.<span class="Apple-converted-space">  </span>In the same manner, supplying </span><span class="s9">0</span><span class="s5"> for </span><span class="s9">margin</span><span class="s5"> specifies that subsets of </span><span class="s9">x</span><span class="s5"> from </span><span class="s9">x[0,]</span><span class="s5"> to </span><span class="s9">x[m,]</span><span class="s5"> should be “passed” to </span><span class="s9">lambdaSource</span><span class="s5">, through the </span><span class="s9">applyValue</span><span class="s5"> “parameter”; dimension </span><span class="s9">0</span><span class="s5"> is iterated over, whereas dimension </span><span class="s9">1</span><span class="s5"> is taken in aggregate since it is not included in </span><span class="s9">margin</span><span class="s5">.<span class="Apple-converted-space">  </span>The final effect of this is that whole rows of </span><span class="s9">x</span><span class="s5"> are passed to </span><span class="s9">lambdaSource</span><span class="s5"> through </span><span class="s9">applyValue</span><span class="s5">.<span class="Apple-converted-space">  </span>Similarly, </span><span class="s9">margin=1</span><span class="s5"> would specify that subsets of </span><span class="s9">x</span><span class="s5"> from </span><span class="s9">x[,0]</span><span class="s5"> to </span><span class="s9">x[,n]</span><span class="s5"> should be passed to </span><span class="s9">lambdaSource</span><span class="s5">, resulting in whole columns being passed.<span class="Apple-converted-space">  </span>Specifying </span><span class="s9">margin=c(0,1)</span><span class="s5"> would indicate that dimensions </span><span class="s9">0</span><span class="s5"> and </span><span class="s9">1</span><span class="s5"> should both be iterated over (dimension </span><span class="s9">0</span><span class="s5"> more rapidly), so for a matrix each each individual value of </span><span class="s9">x</span><span class="s5"> would be passed to l</span><span class="s9">ambdaSource</span><span class="s5">.<span class="Apple-converted-space">  </span>Specifying </span><span class="s9">margin=c(1,0)</span><span class="s5"> would similarly iterate over both dimensions, but dimension </span><span class="s9">1</span><span class="s5"> more rapidly; the traversal order would therefore be different, and the dimensionality of the result would also differ (see below).<span class="Apple-converted-space">  </span>For higher-dimensional arrays dimension indices beyond </span><span class="s9">1</span><span class="s5"> exist, and so </span><span class="s9">margin=c(0,1)</span><span class="s5"> or </span><span class="s9">margin=c(1,0)</span><span class="s5"> would provide slices of </span><span class="s9">x</span><span class="s5"> to </span><span class="s9">lambdaSource</span><span class="s5">, each slice having a specific row and column index.<span class="Apple-converted-space">  </span>Slices are generated by subsetting in the same way as operator </span><span class="s9">[]</span><span class="s5">, but additionally, redundant dimensions are dropped as by </span><span class="s9">drop()</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">The return value from </span><span class="s9">apply()</span><span class="s5"> is built up from the type-promoted concatenated results, as if by the </span><span class="s9">c()</span><span class="s5"> function, from the iterated execution of </span><span class="s9">lambdaSource</span><span class="s5">; the only question is what dimensional structure is imposed upon that vector of values.<span class="Apple-converted-space">  </span>If the results from </span><span class="s9">lambdaSource</span><span class="s5"> are not of a consistent length, or are of length zero, then the concatenated results are returned as a plain vector.<span class="Apple-converted-space">  </span>If all results are of length </span><span class="s9">n &gt; 1</span><span class="s5">, the return value is an array of dimensions </span><span class="s9">c(n, dim(x)[margin]);</span><span class="s5"> in other words, each </span><span class="s9">n</span><span class="s5">-vector provides the lowest dimension of the result, and the sizes of the marginal dimensions are imposed upon the data above that.<span class="Apple-converted-space">  </span>If all results are of length </span><span class="s9">n == 1</span><span class="s5">, then if a single margin was specified the result is a vector (of length equal to the size of that marginal dimension), or if more than one margin was specified the result is an array of dimension </span><span class="s9">dim(x)[margin]</span><span class="s5">; in other words, the sizes of the marginal dimensions are imposed upon the data.<span class="Apple-converted-space">  </span>Since </span><span class="s9">apply()</span><span class="s5"> iterates over the marginal dimensions in the same manner, these structures follows the structure of the data.</span></p>
<p class="p5"><span class="s5">The above explanation may not be entirely clear, so let’s look at an example.<span class="Apple-converted-space">  </span>If </span><span class="s9">x</span><span class="s5"> is a matrix with two rows and three columns, such as defined by </span><span class="s9">x = matrix(1:6, nrow=2);</span><span class="s5">, then executing </span><span class="s9">apply(x, 0, "sum(applyValue);");</span><span class="s5"> would cause each row of </span><span class="s9">x</span><span class="s5"> to be supplied to the lambda through </span><span class="s9">applyValue</span><span class="s5">, and the values in each row would thus be summed to produce </span><span class="s9">9 12</span><span class="s5"> as a result.<span class="Apple-converted-space">  </span>The call </span><span class="s9">apply(x, 1, "sum(applyValue);");</span><span class="s5"> would instead sum columns of </span><span class="s9">x</span><span class="s5">, producing </span><span class="s9">3 7 11</span><span class="s5"> as a result.<span class="Apple-converted-space">  </span>Now consider using </span><span class="s9">range()</span><span class="s5"> rather than </span><span class="s9">sum()</span><span class="s5"> in the lambda, thus producing two values for each row or column.<span class="Apple-converted-space">  </span>The call </span><span class="s9">apply(x, 0, "range(applyValue);");</span><span class="s5"> produces a result of </span><span class="s9">matrix(c(1,5,2,6), nrow=2)</span><span class="s5">, with the range of the first row of </span><span class="s9">x</span><span class="s5">, 1–5, in the first column of the result, and the range of the second row of </span><span class="s9">x</span><span class="s5">, 2–6, in the second column.<span class="Apple-converted-space">  </span>Although visualization becomes more difficult, these same patterns extend to higher dimensions and arbitrary margins of </span><span class="s9">x</span><span class="s5">.</span></p>
<p class="p5">For efficiently obtaining the sums of the rows or columns of a matrix, see <span class="s2">rowSums()</span> and <span class="s2">colSums()</span>.</p>
<p class="p2">(*)array(* data, integer dim)</p>
<p class="p5"><span class="s5"><b>Creates a new array</b> from the data specified by </span><span class="s9">data</span><span class="s5">, with the dimension sizes specified by </span><span class="s9">dim</span><span class="s5">.<span class="Apple-converted-space">  </span>The first dimension size in </span><span class="s9">dim</span><span class="s5"> is the number of rows, and the second is the number of columns; further entries specify the sizes of higher-order dimensions.<span class="Apple-converted-space">  </span>As many dimensions may be specified as desired, but with a minimum of two dimensions.<span class="Apple-converted-space">  </span>An array with two dimensions is a matrix (by definition); note that </span><span class="s9">matrix()</span><span class="s5"> may provide a more convenient way to make a new matrix.<span class="Apple-converted-space">  </span>Each dimension must be of size </span><span class="s9">1</span><span class="s5"> or greater; </span><span class="s9">0</span><span class="s5">-size dimensions are not allowed.</span></p>
<p class="p5"><span class="s5">The elements of </span><span class="s9">data</span><span class="s5"> are used to populate the new array; the size of </span><span class="s9">data</span><span class="s5"> must therefore be equal to the size of the new array, which is the product of all the values in </span><span class="s9">dim</span><span class="s5">.<span class="Apple-converted-space">  </span>The new array will be filled in dimension order: one element in each row until a column is filled, then on to the next column in the same manner until all columns are filled, and then onward into the higher-order dimensions in the same manner.</span></p>
<p class="p4">(*)asVector(* x)</p>
<p class="p5"><b>Creates a new vector</b> from the elements of <span class="s2">x</span>, stripping off any dimensional information associated with <span class="s2">x</span> being a vector or array.<span class="Apple-converted-space">  </span>The values of the resulting vector are read out from <span class="s2">x</span> in dimension order: one element from each row until a column is completed, then on to the next column in the same manner until all columns are completed, and then onward into the higher-order dimensions in the same manner.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is already a vector, it is returned unmodified.<span class="Apple-converted-space">  </span>See <span class="s2">drop()</span> for a similar method that drops only matrix/array dimensions that are redundant.</p>
<p class="p2">(*)cbind(...)</p>
<p class="p5"><span class="s5"><b>Combines vectors or matrices by column</b> to produce a single matrix.<span class="Apple-converted-space">  </span>The parameters must be vectors (which are interpreted by </span><span class="s9">cbind()</span><span class="s5"> as if they were one-column matrices) or matrices.<span class="Apple-converted-space">  </span>They must be of the same type, of the same class if they are of type </span><span class="s9">object</span><span class="s5">, and have the same number of rows.<span class="Apple-converted-space">  </span>If these conditions are met, the result is a single matrix with the parameters joined together, left to right.<span class="Apple-converted-space">  </span>Parameters may instead be </span><span class="s9">NULL</span><span class="s5">, in which case they are ignored; or if all parameters are </span><span class="s9">NULL</span><span class="s5">, the result is </span><span class="s9">NULL</span><span class="s5">.<span class="Apple-converted-space">  </span>A sequence of vectors, matrices, and </span><span class="s9">NULL</span><span class="s5">s may thus be concatenated with the </span><span class="s9">NULL</span><span class="s5"> values removed, analogous to </span><span class="s9">c()</span><span class="s5">.<span class="Apple-converted-space">  </span>Calling </span><span class="s9">cbind(x)</span><span class="s5"> is an easy way to create a one-column matrix from a vector.</span></p>
<p class="p5"><span class="s5">To combine vectors or matrices by row instead, see </span><span class="s9">rbind()</span><span class="s5">.</span></p>
<p class="p4">(numeric)colSums(lif x)</p>
<p class="p5"><b>Returns the sums of the columns</b> of <span class="s2">x</span>, which must be a matrix.<span class="Apple-converted-space">  </span>The result is a vector of elements, each providing the sum of the corresponding column of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">logical</span> or <span class="s2">integer</span> the result will be of type <span class="s2">integer</span>; unlike the <span class="s2">sum()</span> function, <span class="s2">colSums()</span> does not promote the return type to <span class="s2">float</span> if <span class="s2">integer</span> overflow occurs, but instead throws an error.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">float</span> the result will be of type <span class="s2">float</span>.<span class="Apple-converted-space">  </span>Except for the change in the treatment of <span class="s2">integer</span> overflow noted above, this is equivalent to using <span class="s2">apply()</span> with <span class="s2">sum()</span> to sum the columns of <span class="s2">x</span>, but is much faster.</p>
<p class="p4">(numeric$)det(numeric x)</p>
<p class="p5"><b>Returns the determinant</b> of <span class="s2">x</span>, which must be a square matrix (otherwise an error is raised).<span class="Apple-converted-space">  </span>The determinant is a scalar-valued function of the entries of the matrix, and characterizes some properties of the matrix.<span class="Apple-converted-space">  </span>In particular, the determinant is nonzero if and only if the matrix is invertible.<span class="Apple-converted-space">  </span>If the determinant is zero, the matrix does not have an inverse and is referred to as “singular”.<span class="Apple-converted-space">  </span>In Eidos the determinant is calculated from the <i>LU</i> decomposition of the matrix.<span class="Apple-converted-space">  </span>The return type will match the type of <span class="s2">x</span>.</p>
<p class="p4">(*)diag([* x = 1], [Ni$ nrow = NULL], [Ni$ ncol = NULL])</p>
<p class="p5"><b>Returns the diagonal</b> of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>This function has four distinct usage patterns (matching R).<span class="Apple-converted-space">  </span>First, if <span class="s2">x</span> is a matrix of any type, it returns the diagonal elements of <span class="s2">x</span> as a vector; in this case, <span class="s2">nrow</span> and <span class="s2">ncol</span> must be <span class="s2">NULL</span>.<span class="Apple-converted-space">  </span>Second, if <span class="s2">x</span> is <span class="s2">1</span> (the default) and <span class="s2">nrow</span> is non-<span class="s2">NULL</span>, it returns an identity matrix with the requested number of rows (and, if <span class="s2">ncol</span> is also non-<span class="s2">NULL</span>, the requested number of columns, otherwise the matrix will be square).<span class="Apple-converted-space">  </span>Third, if <span class="s2">x</span> is a singleton <span class="s2">integer</span> value and <span class="s2">nrow</span> and <span class="s2">ncol</span> are <span class="s2">NULL</span>, it returns a square identity matrix of size <span class="s2">x</span>.<span class="Apple-converted-space">  </span>Fourth, if x is a <span class="s2">logical</span>, <span class="s2">integer</span>, or <span class="s2">float</span> vector of length at least <span class="s2">2</span>, it returns a matrix that uses the values of <span class="s2">x</span> as its diagonal (without recycling or truncation, unlike R) and has <span class="s2">F</span>, <span class="s2">0</span>, or <span class="s2">0.0</span> off-diagonal entries as appropriate.</p>
<p class="p5">Note that using <span class="s2">diag(x)</span>, without <span class="s2">nrow</span> or <span class="s2">ncol</span>, can have unexpected effects if <span class="s2">x</span> is a vector that could be of length one.<span class="Apple-converted-space">  </span>Use <span class="s2">diag(x, nrow=length(x))</span> for consistent behavior.</p>
<p class="p2">(integer)dim(* x)</p>
<p class="p5"><span class="s5"><b>Returns the dimensions</b> of matrix or array </span><span class="s9">x</span><span class="s5">.<span class="Apple-converted-space">  </span>The first dimension value is the number of rows, the second is the number of columns, and further values indicate the sizes of higher-order dimensions, identically to how dimensions are supplied to </span><span class="s9">array()</span><span class="s5">.<span class="Apple-converted-space">  </span></span><span class="s9">NULL</span><span class="s5"> is returned if </span><span class="s9">x</span><span class="s5"> is not a matrix or array.</span></p>
<p class="p2">(*)drop(* x)</p>
<p class="p5"><span class="s5"><b>Returns the result of dropping redundant dimensions</b> from matrix or array </span><span class="s9">x</span><span class="s5">.<span class="Apple-converted-space">  </span>Redundant dimensions are those with a size of exactly 1.<span class="Apple-converted-space">  </span>Non-redundant dimensions are retained.<span class="Apple-converted-space">  </span>If only one non-redundant dimension is present, the result is a vector; if more than one non-redundant dimension is present, the result will be a matrix or array.<span class="Apple-converted-space">  </span>If </span><span class="s9">x</span><span class="s5"> is not a matrix or array, it is returned unmodified.</span><span class="Apple-converted-space">  </span>See <span class="s2">asVector()</span> for a way to drop all dimensions of a matrix or array, whether redundant or not.</p>
<p class="p4">(float)inverse(numeric x)</p>
<p class="p5"><b>Returns the (multiplicative) inverse</b> of <span class="s2">x</span>, which must be a square non-singular matrix (otherwise an error is raised).<span class="Apple-converted-space">  </span>If matrix <b>B</b> is the inverse of <i>n</i>-by-<i>n</i> matrix <b>A</b>, then <b>AB</b> = <b>BA</b> = <b>I</b><span class="s13"><i><sub>n</sub></i></span>, where <b>I</b><span class="s13"><i><sub>n</sub></i></span> denotes the <i>n</i>-by-<i>n</i> identity matrix and the multiplication used is ordinary matrix multiplication as performed by <span class="s2">matrixMult()</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> might be singular (and thus non-invertible), and you wish to avoid the possibility of an error, you can call <span class="s2">det()</span> first to find the determinant of the matrix; if the determinant is zero, the matrix is singular and does not have an inverse, and so <span class="s2">inverse()</span> should not be called.<span class="Apple-converted-space">  </span>In Eidos the inverse is calculated from the <i>LU</i> decomposition of the matrix.</p>
<p class="p4">(logical)lowerTri(* x, [logical$ diag = F])</p>
<p class="p5"><b>Returns the lower triangle</b> of <span class="s2">x</span>, which must be a matrix.<span class="Apple-converted-space">  </span>The return value will be a <span class="s2">logical</span> matrix of the same dimensions as <span class="s2">x</span>, with elements <span class="s2">T</span> in the lower triangle, <span class="s2">F</span> elsewhere.<span class="Apple-converted-space">  </span>If <span class="s2">diag</span> is <span class="s2">F</span> (the default), the diagonal is not included in the lower triangle; if <span class="s2">diag</span> is <span class="s2">T</span>, the diagonal is included in the lower triangle (i.e., its elements will be <span class="s2">T</span>).</p>
<p class="p2">(*)matrix(* data, [Ni$ nrow = NULL], [Ni$ ncol = NULL], [logical$ byrow = F])</p>
<p class="p5"><span class="s5"><b>Creates a new matrix</b> from the data specified by </span><span class="s9">data</span><span class="s5">.<span class="Apple-converted-space">  </span>By default this creates a one-column matrix.<span class="Apple-converted-space">  </span>If non-</span><span class="s9">NULL</span><span class="s5"> values are supplied for </span><span class="s9">nrow</span><span class="s5"> and/or </span><span class="s9">ncol</span><span class="s5">, a matrix will be made with the requested number of rows and/or columns if possible; if the length of </span><span class="s9">data</span><span class="s5"> is not compatible with the requested dimensions, an error will result.<span class="Apple-converted-space">  </span>By default, values from data will populate the matrix by columns, filling each column sequentially before moving on to the next column; if </span><span class="s9">byrow</span><span class="s5"> is </span><span class="s9">T</span><span class="s5"> the matrix will be populated by rows instead.</span></p>
<p class="p2">(numeric)matrixMult(numeric x, numeric y)</p>
<p class="p5"><span class="s5"><b>Returns the result of matrix multiplication</b> of </span><span class="s9">x</span><span class="s5"> with </span><span class="s9">y</span><span class="s5">.<span class="Apple-converted-space">  </span>In Eidos (as in R), with two matrices </span><span class="s9">A</span><span class="s5"> and </span><span class="s9">B</span><span class="s5"> the simple product </span><span class="s9">A * B</span><span class="s5"> multiplies the corresponding elements of the matrices; in other words, if </span><span class="s9">X</span><span class="s5"> is the result of </span><span class="s9">A * B</span><span class="s5">, then </span><span class="s9">X</span><span class="s21"><i><sub>ij</sub></i></span><span class="s5"> = </span><span class="s9">A</span><span class="s21"><i><sub>ij</sub></i></span><span class="s5"> * </span><span class="s9">B</span><span class="s21"><i><sub>ij</sub></i></span><span class="s5">.<span class="Apple-converted-space">  </span>This is parallel to the definition of other operators; A + B adds the corresponding elements of the matrices (</span><span class="s9">X</span><span class="s21"><i><sub>ij</sub></i></span><span class="s5"> = </span><span class="s9">A</span><span class="s21"><i><sub>ij</sub></i></span><span class="s5"> + </span><span class="s9">B</span><span class="s21"><i><sub>ij</sub></i></span><span class="s5">), etc.<span class="Apple-converted-space">  </span>In R, true matrix multiplication is achieved with a special operator, </span><span class="s9">%*%</span><span class="s5">; in Eidos, the </span><span class="s9">matrixMult()</span><span class="s5"> function is used instead.</span></p>
<p class="p5"><span class="s5">Both </span><span class="s9">x</span><span class="s5"> and </span><span class="s9">y</span><span class="s5"> must be matrices, and must be conformable according to the standard definition of matrix multiplication (i.e., if </span><span class="s9">x</span><span class="s5"> is an <i>n</i> × <i>m</i> matrix then </span><span class="s9">y</span><span class="s5"> must be a <i>m</i> × <i>p</i> matrix, and the result will be a <i>n</i> × <i>p</i> matrix).<span class="Apple-converted-space">  </span>Vectors will not be promoted to matrices by this function, even if such promotion would lead to a conformable matrix.</span></p>
<p class="p4">(numeric)matrixPow(numeric x, integer$ power)</p>
<p class="p5"><b>Returns the result of raising matrix </b><span class="s2"><b>x</b></span><b> to an </b><span class="s2"><b>integer</b></span><b> </b><span class="s2"><b>power</b></span><b>.</b><span class="Apple-converted-space">  </span>The parameter x must be a square matrix (or an error will be raised).<span class="Apple-converted-space">  </span>This operation is performed by repeated matrix multiplication with <span class="s2">matrixMult()</span>, and uses <span class="s2">inverse()</span> to compute the inverse of the matrix if <span class="s2">power</span> is negative.</p>
<p class="p2">(integer$)nrow(* x)</p>
<p class="p5"><span class="s5"><b>Returns the number of rows</b> in matrix or array </span><span class="s9">x</span><span class="s5">.<span class="Apple-converted-space">  </span>For vector </span><span class="s9">x</span><span class="s5">, </span><span class="s9">nrow()</span><span class="s5"> returns </span><span class="s9">NULL</span><span class="s5">; </span><span class="s9">size()</span><span class="s5"> should be used.<span class="Apple-converted-space">  </span>An equivalent of R’s </span><span class="s9">NROW()</span><span class="s5"> function, which treats vectors as </span><span class="s9">1</span><span class="s5">-column matrices, is not provided but would be trivial to implement as a user-defined function.</span></p>
<p class="p2">(integer$)ncol(* x)</p>
<p class="p5"><span class="s5"><b>Returns the number of columns</b> in matrix or array </span><span class="s9">x</span><span class="s5">.<span class="Apple-converted-space">  </span>For vector </span><span class="s9">x</span><span class="s5">, </span><span class="s9">ncol()</span><span class="s5"> returns </span><span class="s9">NULL</span><span class="s5">; </span><span class="s9">size()</span><span class="s5"> should be used.<span class="Apple-converted-space">  </span>An equivalent of R’s </span><span class="s9">NCOL()</span><span class="s5"> function, which treats vectors as </span><span class="s9">1</span><span class="s5">-column matrices, is not provided but would be trivial to implement as a user-defined function.</span></p>
<p class="p4">(numeric)outerProduct(numeric x, numeric y)</p>
<p class="p5"><b>Returns the outer product</b> of vectors <span class="s2">x</span> and <span class="s2">y</span>.<span class="Apple-converted-space">  </span>The outer product, <span class="s2">x</span> <span class="s4">⊗</span> <span class="s2">y</span>, is the result of matrix multiplication of <span class="s2">x</span> with the transpose of <span class="s2">y</span>, or <span class="s2">xy</span><span class="s13"><sup>T</sup></span>.<span class="Apple-converted-space">  </span>It will be a matrix with a number of rows equal to the length of <span class="s2">x</span>, and a number of columns equal to the length of <span class="s2">y</span>.<span class="Apple-converted-space">  </span>It is required that <span class="s2">x</span> and <span class="s2">y</span> be vectors, not matrices or arrays, that they have non-zero lengths, and that they be the same type – both <span class="s2">integer</span> or both <span class="s2">float</span>.<span class="Apple-converted-space">  </span>The return value will be of the same type as <span class="s2">x</span> and <span class="s2">y</span>.</p>
<p class="p2">(*)rbind(...)</p>
<p class="p5"><span class="s5"><b>Combines vectors or matrices by row</b> to produce a single matrix.<span class="Apple-converted-space">  </span>The parameters must be vectors (which are interpreted by </span><span class="s9">rbind()</span><span class="s5"> as if they were one-row matrices) or matrices.<span class="Apple-converted-space">  </span>They must be of the same type, of the same class if they are of type </span><span class="s9">object</span><span class="s5">, and have the same number of columns.<span class="Apple-converted-space">  </span>If these conditions are met, the result is a single matrix with the parameters joined together, top to bottom.<span class="Apple-converted-space">  </span>Parameters may instead be </span><span class="s9">NULL</span><span class="s5">, in which case they are ignored; or if all parameters are </span><span class="s9">NULL</span><span class="s5">, the result is </span><span class="s9">NULL</span><span class="s5">.<span class="Apple-converted-space">  </span>A sequence of vectors, matrices, and </span><span class="s9">NULL</span><span class="s5">s may thus be concatenated with the </span><span class="s9">NULL</span><span class="s5"> values removed, analogous to </span><span class="s9">c()</span><span class="s5">.<span class="Apple-converted-space">  </span>Calling </span><span class="s9">rbind(x)</span><span class="s5"> is an easy way to create a one-row matrix from a vector.</span></p>
<p class="p5"><span class="s5">To combine vectors or matrices by column instead, see </span><span class="s9">cbind()</span><span class="s5">.</span></p>
<p class="p4">(numeric)rowSums(lif x)</p>
<p class="p5"><b>Returns the sums of the rows</b> of <span class="s2">x</span>, which must be a matrix.<span class="Apple-converted-space">  </span>The result is a vector of elements, each providing the sum of the corresponding row of <span class="s2">x</span>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">logical</span> or <span class="s2">integer</span> the result will be of type <span class="s2">integer</span>; unlike the <span class="s2">sum()</span> function, <span class="s2">rowSums()</span> does not promote the return type to <span class="s2">float</span> if <span class="s2">integer</span> overflow occurs, but instead throws an error.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is of type <span class="s2">float</span> the result will be of type <span class="s2">float</span>.<span class="Apple-converted-space">  </span>Except for the change in the treatment of <span class="s2">integer</span> overflow noted above, this is equivalent to using <span class="s2">apply()</span> with <span class="s2">sum()</span> to sum the rows of <span class="s2">x</span>, but is much faster.</p>
<p class="p2">(*)t(* x)</p>
<p class="p5"><span class="s5"><b>Returns the transpose</b> of </span><span class="s9">x</span><span class="s5">, which must be a matrix.<span class="Apple-converted-space">  </span>This is the matrix reflected across its diagonal; or alternatively, the matrix with its columns written out instead as rows in the same order.</span></p>
<p class="p4">(numeric$)tr(numeric x)</p>
<p class="p5"><b>Returns the trace</b> of <span class="s2">x</span>, which must be a square matrix (otherwise an error is raised).<span class="Apple-converted-space">  </span>The trace is the sum of the diagonal elements of the matrix.<span class="Apple-converted-space">  </span>The return type will match the type of <span class="s2">x</span>.</p>
<p class="p4">(logical)upperTri(* x, [logical$ diag = F])</p>
<p class="p5"><b>Returns the upper triangle</b> of <span class="s2">x</span>, which must be a matrix.<span class="Apple-converted-space">  </span>The return value will be a <span class="s2">logical</span> matrix of the same dimensions as <span class="s2">x</span>, with elements <span class="s2">T</span> in the upper triangle, <span class="s2">F</span> elsewhere.<span class="Apple-converted-space">  </span>If <span class="s2">diag</span> is <span class="s2">F</span> (the default), the diagonal is not included in the upper triangle; if <span class="s2">diag</span> is <span class="s2">T</span>, the diagonal is included in the upper triangle (i.e., its elements will be <span class="s2">T</span>).</p>
<p class="p1"><b>3.9.<span class="Apple-converted-space">  </span>Filesystem access functions</b></p>
<p class="p2">(logical$)createDirectory(string$ path)</p>
<p class="p3"><b>Creates a new filesystem directory</b> at the path specified by <span class="s2">path</span> and returns a <span class="s2">logical</span> value indicating if the creation succeeded (<span class="s2">T</span>) or failed (<span class="s2">F</span>).<span class="Apple-converted-space">  </span>If the path already exists, <span class="s2">createDirectory()</span> will do nothing to the filesystem, will emit a warning, and will return <span class="s2">T</span> to indicate success if the existing path is a directory, or <span class="s2">F</span> to indicate failure if the existing path is not a directory.</p>
<p class="p2">(logical$)deleteFile(string$ filePath)</p>
<p class="p3"><b>Deletes the file</b> specified by <span class="s2">filePath</span> and returns a <span class="s2">logical</span> value indicating if the deletion succeeded (<span class="s2">T</span>) or failed (<span class="s2">F</span>).</p>
<p class="p5">This function might also be able to delete a directory at <span class="s2">filePath</span>, but only if it is empty (apart from the <span class="s2">.</span> and <span class="s2">..</span> directory entries that exist on Un*x filesystems).<span class="Apple-converted-space">  </span>If other files (including invisible files) exist in the directory, <span class="s2">deleteFile()</span> will probably fail as a safety measure, in which case the contained files must be deleted individually first.<span class="Apple-converted-space">  </span>This is vague because the actual policy regarding deletion of directories will depend upon the operating system, since Eidos achieves the deletion by calling an operating-system function.</p>
<p class="p4"><span class="s5">(logical$)fileExists(string$ filePath)</span></p>
<p class="p5"><span class="s5"><b>Checks the existence of the file</b> specified by </span><span class="s9">filePath</span><span class="s5"> and returns a </span><span class="s9">logical</span><span class="s5"> value indicating if it exists (</span><span class="s9">T</span><span class="s5">) or does not exist (</span><span class="s9">F</span><span class="s5">).<span class="Apple-converted-space">  </span>This also works for directories.</span></p>
<p class="p2">(string)filesAtPath(string$ path, [logical$ fullPaths = F])</p>
<p class="p3">Returns a <span class="s2">string</span> vector containing the <b>names of all files in a directory</b> specified by <span class="s2">path</span><span class="s3">.</span><span class="Apple-converted-space">  </span>If the optional parameter <span class="s2">fullPaths</span> is <span class="s2">T</span>, full filesystem paths are returned for each file; if <span class="s2">fullPaths</span> is <span class="s2">F</span> (the default), then only the filenames relative to the specified directory are returned.<span class="Apple-converted-space">  </span>This list includes directories (i.e. subfolders), including the <span class="s2">"."</span> and <span class="s2">".."</span> directories on Un*x systems.<span class="Apple-converted-space">  </span>The list also includes invisible files, such as those that begin with a <span class="s2">"."</span> on Un*x systems.<span class="Apple-converted-space">  </span>This function does not descend recursively into subdirectories.<span class="Apple-converted-space">  </span>If an error occurs during the read, <span class="s2">NULL</span> will be returned.</p>
<p class="p4">(logical$)flushFile(string$ filePath)</p>
<p class="p5"><b>Flushes buffered content to a file</b> specified by <span class="s2">filePath</span>.<span class="Apple-converted-space">  </span>Normally, written data is buffered by <span class="s2">writeFile()</span> if the <span class="s2">compress</span> option of that function is <span class="s2">T</span>, holding the data in memory rather than writing it to disk immediately.<span class="Apple-converted-space">  </span>This buffering improves both performance and file size; however, sometimes it is desirable to flush the buffered data to disk with <span class="s2">flush()</span> so that the filesystem is up to date.<span class="Apple-converted-space">  </span>Note that flushing after every write is not recommended, since it will lose all of the benefits of buffering.<span class="Apple-converted-space">  </span>Calling <span class="s2">flushFile()</span> for a path that has not been written to, or is not being buffered, will do nothing.<span class="Apple-converted-space">  </span>If the flush is successful, <span class="s2">T</span> will be returned; if not, <span class="s2">F</span> will be returned (but at present, an error will result instead).</p>
<p class="p4"><span class="s5">(string$)getwd(void)</span></p>
<p class="p5"><span class="s5"><b>Gets the current filesystem working directory</b>.<span class="Apple-converted-space">  </span>The filesystem working directory is the directory which will be used as a base path for relative filesystem paths.<span class="Apple-converted-space">  </span>For example, if the working directory is </span><span class="s9">"~/Desktop"</span><span class="s5"> (the </span><span class="s9">Desktop</span><span class="s5"> subdirectory within the current user’s home directory, as represented by </span><span class="s9">~</span><span class="s5">), then the filename </span><span class="s9">"foo.txt"</span><span class="s5"> would correspond to the filesystem path </span><span class="s9">"~/Desktop/foo.txt"</span><span class="s5">, and the relative path </span><span class="s9">"bar/baz/"</span><span class="s5"> would correspond to the filesystem path </span><span class="s9">“~/Desktop/bar/baz/“</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Note that the path returned may not be identical to the path previously set with </span><span class="s9">setwd()</span><span class="s5">, if for example symbolic links are involved; but it ought to refer to the same actual directory in the filesystem.</span></p>
<p class="p5"><span class="s5">The initial working directory is – as is generally the case on Un*x – simply the directory given to the running Eidos process by its parent process (the operating system, a shell, a job scheduler, a debugger, or whatever the case may be).<span class="Apple-converted-space">  </span>If you launch Eidos (or SLiM) from the command line in a Un*x shell, it is typically the current directory in that shell.<span class="Apple-converted-space">  </span>Before relative filesystem paths are used, you may therefore wish check what the initial working directory is on your platform, with </span><span class="s9">getwd()</span><span class="s5">, if you are not sure.<span class="Apple-converted-space">  </span>Alternatively, you can simply use </span><span class="s9">setwd()</span><span class="s5"> to set the working directory to a known path.</span></p>
<p class="p4">(object&lt;DataFrame&gt;$)readCSV(string$ filePath, [ls colNames = T], [Ns$ colTypes = NULL], [string$ sep = ","], [string$ quote = '"'], [string$ dec = "."], [string$ comment = ""])</p>
<p class="p5"><b>Reads data from a CSV or other delimited file</b> specified by <span class="s2">filePath</span> and returns a <span class="s2">DataFrame</span> object containing the data in a tabular form.<span class="Apple-converted-space">  </span>CSV (comma-separated value) files use a somewhat standard file format in which a table of data is provided, with values within a row separated by commas, while rows in the table are separated by newlines.<span class="Apple-converted-space">  </span>Software from R to Excel (and Eidos; see the <span class="s2">serialize()</span> method of <span class="s2">Dictionary</span>) can export data in CSV format.<span class="Apple-converted-space">  </span>This function can actually also read files that use a delimiter other than commas; TSV (tab-separated value) files are a popular alternative.<span class="Apple-converted-space">  </span>Since there is substantial variation in the exact file format for CSV files, this documentation will try to specify the precise format expected by this function.<span class="Apple-converted-space">  </span>Note that CSV files represent values differently that Eidos usually does, and some of the format options allowed by <span class="s2">readCSV()</span>, such as decimal commas, are not otherwise available in Eidos.</p>
<p class="p5">If <span class="s2">colNames</span> is <span class="s2">T</span> (the default), the first row of data is taken to be a header, containing the string names of the columns in the data table; those names will be used by the resulting <span class="s2">DataFrame</span>.<span class="Apple-converted-space">  </span>If <span class="s2">colNames</span> is <span class="s2">F</span>, a header row is not expected and column names are auto-generated as <span class="s2">X1</span>, <span class="s2">X2</span>, etc.<span class="Apple-converted-space">  </span>If <span class="s2">colNames</span> is a <span class="s2">string</span> vector, a header row is not expected and <span class="s2">colNames</span> will be used as the column names; if additional columns exist beyond the length of <span class="s2">colNames</span> their names will be auto-generated.<span class="Apple-converted-space">  </span>Duplicate column names will generate a warning and be made unique.</p>
<p class="p5">If <span class="s2">colTypes</span> is <span class="s2">NULL</span> (the default), the value type for each column will be guessed from the values it contains, as described below.<span class="Apple-converted-space">  </span>If <span class="s2">colTypes</span> is a singleton <span class="s2">string</span>, it should contain single-letter codes indicating the desired type for each column, from left to right.<span class="Apple-converted-space">  </span>The letters <span class="s2">lifs</span> have the same meaning as in Eidos signatures (<span class="s2">logical</span>, <span class="s2">integer</span>, <span class="s2">float</span>, and <span class="s2">string</span>); in addition, <span class="s2">?</span> may be used to indicate that the type for that column should be guessed as by default, and <span class="s2">_</span> or <span class="s2">-</span> may be used to indicate that that column should be skipped – omitted from the returned <span class="s2">DataFrame</span>.<span class="Apple-converted-space">  </span>Other characters in <span class="s2">colTypes</span> will result in an error.<span class="Apple-converted-space">  </span>If additional columns exist beyond the end of the <span class="s2">colTypes</span> string their types will be guessed as by default.</p>
<p class="p5">The separator between values is supplied by <span class="s2">sep</span>; it is a comma by default, but a tab can be used instead by supplying tab (<span class="s2">"\t"</span> in Eidos), or another character may also be used.<span class="Apple-converted-space">  </span>If <span class="s2">sep</span> is the empty string <span class="s2">""</span>, the separator between values is “whitespace”, meaning one or more spaces or tabs.<span class="Apple-converted-space">  </span>When the separator is whitespace, whitespace at the beginning or the end of a line will be ignored.</p>
<p class="p5">Similarly, the character used to quote string values is a double quote (<span class="s2">'"'</span> in Eidos), by default, but another character may be supplied in <span class="s2">quote</span>.<span class="Apple-converted-space">  </span>When the string delimiter is encountered, <i>all</i> following characters are considered to be part of the string until another string delimiter is encountered, terminating the string; this includes spaces, comment characters, newlines, and everything else.<span class="Apple-converted-space">  </span>Within a string value, the string delimiter itself is used twice in a row to indicate that the delimiter itself is present within the string; for example, if the string value (shown without the usual surrounding quotes to try to avoid confusion) is <span class="s2">she said "hello"</span>, and the string delimiter is the double quote as it is by default, then in the CSV file the value would be given as <span class="s2">"she said ""hello"""</span>.<span class="Apple-converted-space">  </span>The usual Eidos style of escaping characters using a backslash is <i>not</i> part of the CSV standard followed here.<span class="Apple-converted-space">  </span>(When a string value is provided <i>without</i> using the string delimiter, all following characters are considered part of the string except a newline, the value separator <span class="s2">sep</span>, the quote separator <span class="s2">quote</span>, and the comment separator <span class="s2">comment</span>; if none of those characters are present in the string value, the quote delimiter may be omitted.)</p>
<p class="p5">The character used to indicate a decimal delimiter in numbers may be supplied with <span class="s2">dec</span>; by default this is <span class="s2">"."</span> (and so <span class="s2">10.0</span> would be ten, written with a decimal point), but <span class="s2">","</span> is common in European data files (and so <span class="s2">10,0</span> would be ten, written with a decimal comma).<span class="Apple-converted-space">  </span>Note that <span class="s2">dec</span> and <span class="s2">sep</span> may not be the same, so that it is unambiguous whether <span class="s2">10,0</span> is two numbers (<span class="s2">10</span> and <span class="s2">0</span>) or one number (<span class="s2">10.0</span>).<span class="Apple-converted-space">  </span>For this reason, European CSV files that use a decimal comma typically use a semicolon as the value separator, which may be supplied with <span class="s2">sep=";"</span> to <span class="s2">readCSV()</span>.</p>
<p class="p5">Finally, the remainder of a line following a comment character will be ignored when the file is read; by default <span class="s2">comment</span> is the empty string, <span class="s2">""</span>, indicating that comments do not exist at all, but <span class="s2">"#"</span> is a popular comment prefix.</p>
<p class="p5">To translate the CSV data into a <span class="s2">DataFrame</span>, it is necessary for Eidos to guess what value type each column is unless a column type is specified by <span class="s2">colTypes</span>.<span class="Apple-converted-space">  </span>Quotes surrounding a value are irrelevant to this guess; for example, <span class="s2">1997</span> and <span class="s2">"1997"</span> are both candidates to be <span class="s2">integer</span> values (because some programs generate CSV output in which <i>every</i> value is quoted regardless of type).<span class="Apple-converted-space">  </span>If <i>every</i> value in a column is either <span class="s2">true</span>, <span class="s2">false</span>, <span class="s2">TRUE</span>, <span class="s2">FALSE</span>, <span class="s2">T</span>, or <span class="s2">F</span>, the column will be taken to be <span class="s2">logical</span>.<span class="Apple-converted-space">  </span>Otherwise, if <i>every</i> value in a column is an integer (here defined as an optional <span class="s2">+</span> or <span class="s2">-</span>, followed by nothing but decimal digits <span class="s2">0123456789</span>), the column will be taken to be <span class="s2">integer</span>.<span class="Apple-converted-space">  </span>Otherwise, if <i>every</i> value in a column is a floating-point number (here defined as an optional <span class="s2">+</span> or <span class="s2">-</span>, followed by decimal digits <span class="s2">0123456789</span>, optionally a decimal separator and then optionally more decimal digits, and ending with an optional exponent like <span class="s2">e7</span>, <span class="s2">E+05</span>, or <span class="s2">e-2</span>), the column will be taken to be <span class="s2">float</span>; the special values <span class="s2">NAN</span>, <span class="s2">INF</span>, <span class="s2">INFINITY</span>, <span class="s2">-INF</span>, and <span class="s2">-INFINITY</span> (not case-sensitive) are also candidates to be <span class="s2">float</span> (if the rest of the column is also convertible to <span class="s2">float</span>), representing the corresponding <span class="s2">float</span> constants.<span class="Apple-converted-space">  </span>Otherwise, the column will be taken to be <span class="s2">string</span>.<span class="Apple-converted-space">  </span><span class="s2">NULL</span> and <span class="s2">NA</span> are not recognized by <span class="s2">readCSV()</span> in CSV files and will be read as strings.<span class="Apple-converted-space">  </span>Every line in a CSV file must contain the same number of values (forming a rectangular data table); missing values are not allowed by <span class="s2">readCSV()</span> since there is no way to represent them in <span class="s2">DataFrame</span> (since Eidos has no equivalent of R’s <span class="s2">NA</span> value).<span class="Apple-converted-space">  </span>Spaces are considered part of a data field and are not trimmed, following the RFC 4180 standard.<span class="Apple-converted-space">  </span>These choices are an attempt to provide optimal behavior for most clients, but given the lack of any universal standard for CSV files, and the lack of any type information in the CSV format, they will not always work as desired; in such cases, it should be reasonably straightforward to preprocess input files using standard Unix text-processing tools like <span class="s2">sed</span> and <span class="s2">awk</span>.</p>
<p class="p2">(string)readFile(string$ filePath)</p>
<p class="p3"><b>Reads in the contents of a file</b> specified by <span class="s2">filePath</span> and returns a <span class="s2">string</span> vector containing the lines (separated by <span class="s2">\n</span> and <span class="s2">\r</span> characters) of the file.<span class="Apple-converted-space">  </span>Reading files other than text files is not presently supported.<span class="Apple-converted-space">  </span>If an error occurs during the read, <span class="s2">NULL</span> will be returned.</p>
<p class="p4"><span class="s5">(string$)setwd(string$ path)</span></p>
<p class="p5"><span class="s5"><b>Sets the current filesystem working directory</b>.<span class="Apple-converted-space">  </span>The filesystem working directory is the directory which will be used as a base path for relative filesystem paths (see </span><span class="s9">getwd()</span><span class="s5"> for further discussion).<span class="Apple-converted-space">  </span>An error will result if the working directory cannot be set to the given path.</span></p>
<p class="p5"><span class="s5">The current working directory prior to the change will be returned as an invisible </span><span class="s9">string</span><span class="s5"> value; the value returned is identical to the value that would have been returned by </span><span class="s9">getwd()</span><span class="s5">, apart from its invisibility.</span></p>
<p class="p5"><span class="s5">See </span><span class="s9">getwd()</span><span class="s5"> for discussion regarding the initial working directory, before it is set with </span><span class="s9">setwd()</span><span class="s5">.</span></p>
<p class="p4">(string$)tempdir(void)</p>
<p class="p5"><b>Returns a path to a directory appropriate for saving temporary files</b>.<span class="Apple-converted-space">  </span>The path returned by <span class="s2">tempdir()</span> is platform-specific, and is not guaranteed to be the same from one run of SLiM to the next.<span class="Apple-converted-space">  </span>It is guaranteed to end in a slash, so further path components should be appended without a leading slash.<span class="Apple-converted-space">  </span>At present, on macOS and Linux systems, the path will be <span class="s2">"/tmp/"</span>; this may change in future Eidos versions without warning.</p>
<p class="p2">(logical$)writeFile(string$ filePath, string contents, [logical$ append = F], [logical$ compress = F])</p>
<p class="p3"><b>Writes or appends to a file</b> specified by <span class="s2">filePath</span> with contents specified by <span class="s2">contents</span>, a <span class="s2">string</span> vector of lines.<span class="Apple-converted-space">  </span>If <span class="s2">append</span> is <span class="s2">T</span>, the write will be appended to the existing file (if any) at <span class="s2">filePath</span>; if it is <span class="s2">F</span> (the default), then the write will replace an existing file at that path.<span class="s6"><span class="Apple-converted-space">  </span>If the write is successful, </span><span class="s7">T</span><span class="s6"> will be returned; if not, </span><span class="s7">F</span><span class="s6"> will be returned (but at present, an error will result instead).</span></p>
<p class="p5">If <span class="s2">compress</span> is <span class="s2">T</span>, the contents will be compressed with <span class="s2">zlib</span> as they are written, and the standard <span class="s2">.gz</span> extension for <span class="s2">gzip</span>-compressed files will be appended to the filename in <span class="s2">filePath</span> if it is not already present.<span class="Apple-converted-space">  </span>If the <span class="s2">compress</span> option is used in conjunction with <span class="s2">append==T</span>, Eidos will buffer data to append and flush it to the file in a delayed fashion (for performance reasons), and so appended data may not be visible in the file until later – potentially not until the process ends (i.e., the end of the SLiM simulation, for example).<span class="Apple-converted-space">  </span>If that delay if undesirable, buffered data can be explicitly flushed to the filesystem with <span class="s2">flushFile()</span>.<span class="Apple-converted-space">  </span>The <span class="s2">compress</span> option was added in Eidos 2.4 (SLiM 3.4).<span class="Apple-converted-space">  </span>Note that <span class="s2">readFile()</span> does not currently support reading in compressed data.</p>
<p class="p3">Note that newline characters will be added at the ends of the lines in <span class="s2">contents</span>.<span class="Apple-converted-space">  </span>If you do not wish to have newlines added, you should use <span class="s2">paste()</span> to assemble the elements of <span class="s2">contents</span> together into a singleton <span class="s2">string</span><span class="s3">.</span></p>
<p class="p2">(string$)writeTempFile(string$ prefix, string$ suffix, string contents, [logical$ compress = F])</p>
<p class="p3"><b>Writes to a unique temporary file</b> with contents specified by <span class="s2">contents</span>, a <span class="s2">string</span> vector of lines.<span class="Apple-converted-space">  </span>The filename used will begin with <span class="s2">prefix</span> and end with <span class="s2">suffix</span>, and will contain six random characters in between; for example, if <span class="s2">prefix</span> is <span class="s2">"plot1_"</span> and <span class="s2">suffix</span> is <span class="s2">".pdf"</span>, the generated filename might look like <span class="s2">"plot1_r5Mq0t.pdf"</span>.<span class="Apple-converted-space">  </span>It is legal for <span class="s2">prefix</span>, <span class="s2">suffix</span>, or both to be the empty string, <span class="s2">""</span>, but supplying a file extension is usually advisable at minimum.<span class="Apple-converted-space">  </span>The file will be created inside the <span class="s2">/tmp/</span> directory of the system, which is provided by Un*x systems as a standard location for temporary files; the <span class="s2">/tmp/</span> directory should not be specified as part of prefix (nor should any other directory information).<span class="Apple-converted-space">  </span>The filename generated is guaranteed not to already exist in <span class="s2">/tmp/</span>.<span class="Apple-converted-space">  </span>The file is created with Un*x permissions <span class="s2">0600</span>, allowing reading and writing only by the user for security.<span class="Apple-converted-space">  </span>If the write is successful, the full path to the temporary file will be returned; if not, <span class="s2">""</span> will be returned.</p>
<p class="p5"><span class="s5">If </span><span class="s9">compress</span><span class="s5"> is </span><span class="s9">T</span><span class="s5">, the contents will be compressed with </span><span class="s9">zlib</span><span class="s5"> as they are written, and the standard </span><span class="s9">.gz</span><span class="s5"> extension for </span><span class="s9">gzip</span><span class="s5">-compressed files will be appended to the filename suffix in </span><span class="s9">suffix</span><span class="s5"> if it is not already present.<span class="Apple-converted-space">  </span>The </span><span class="s9">compress</span><span class="s5"> option was added in Eidos 2.4 (SLiM 3.4).<span class="Apple-converted-space">  </span>Note that </span><span class="s9">readFile()</span><span class="s5"> does not currently support reading in compressed data.</span></p>
<p class="p3">Note that newline characters will be added at the ends of the lines in <span class="s2">contents</span>.<span class="Apple-converted-space">  </span>If you do not wish to have newlines added, you should use <span class="s2">paste()</span> to assemble the elements of <span class="s2">contents</span> together into a singleton <span class="s2">string</span><span class="s3">.</span></p>
<p class="p1"><b>3.10.<span class="Apple-converted-space">  </span>Color manipulation functions</b></p>
<p class="p4"><span class="s5">(string)cmColors(integer$ n)</span></p>
<p class="p5"><b>This method has been deprecated, and may be removed in a future release of Eidos.</b><span class="Apple-converted-space">  </span>In SLiM 3.5 and later, use <span class="s2">colors(n, "cm")</span> instead.</p>
<p class="p9">Generate colors in a “cyan-magenta” color palette.</p>
<p class="p4">(string)colors(numeric x, string$ name)</p>
<p class="p5"><b>Generate colors in a standard color palette</b>.<span class="Apple-converted-space">  </span>If <span class="s2">x</span> is a singleton <span class="s2">integer</span>, the returned vector will contain <span class="s2">x</span> color strings representing <span class="s2">x</span> colors equidistant along the named palette, spanning its full extent.<span class="Apple-converted-space">  </span>Alternatively, if <span class="s2">x</span> is a <span class="s2">float</span> vector of values in [<span class="s2">0</span>,<span class="s2">1</span>], the returned vector will contain one color string for each value in <span class="s2">x</span>, representing the color at the corresponding fraction along the named palette (values outside [<span class="s2">0</span>,<span class="s2">1</span>] will be clamped to that range).<span class="Apple-converted-space">  </span>(Note that the function signature states the type of <span class="s2">x</span> as <span class="s2">numeric</span>, but in this function the <span class="s2">integer</span> and <span class="s2">float</span> cases have completely different semantic meanings.)</p>
<p class="p5">The color palette specified by <span class="s2">name</span> may be any of the following color palettes based upon color palettes in R: <span class="s2">"cm"</span>, <span class="s2">"heat"</span>, and <span class="s2">"terrain"</span>.</p>
<p class="p5">It may also be one of the following color palettes based on color palettes in MATLAB (and the Turbo palette from Anton Mikhailov of the Google AI group, based upon the Jet palette provided by MATLAB): <span class="s2">"parula"</span>, <span class="s2">"hot"</span>, <span class="s2">"jet"</span>, <span class="s2">"turbo"</span>, and <span class="s2">"gray"</span>.</p>
<p class="p5">Finally, it may be one of the following color palettes based upon color palettes in Matplotlib, also available in the <span class="s2">viridis</span> R package: <span class="s2">"magma"</span>, <span class="s2">"inferno"</span>, <span class="s2">"plasma"</span>, <span class="s2">"viridis"</span>, and <span class="s2">"cividis"</span>.<span class="Apple-converted-space">  </span>These color palettes are designed to be perceptually uniform, changing continuously and linearly.<span class="Apple-converted-space">  </span>They are also designed to perform well even for users with red-green colorblindness; the <span class="s2">"cividis"</span> palette, in particular, is designed to look nearly identical to those with and without red-green colorblindness, to be perceptually uniform in both hue and brightness, and to increase linearly in brightness.</p>
<p class="p5">This function replaces the deprecated <span class="s2">cmColors()</span>, <span class="s2">heatColors()</span>, and <span class="s2">terrainColors()</span> functions, and adds several several additional color palettes to Eidos.<span class="Apple-converted-space">  </span>See <span class="s2">rainbow()</span> for another color palette function.</p>
<p class="p2">(float)color2rgb(string color)</p>
<p class="p5"><span class="s5"><b>Converts a color string to RGB</b>.<span class="Apple-converted-space">  </span>The color string specified in </span><span class="s9">color</span><span class="s5"> may be either a named color or a color in hexadecimal format such as </span><span class="s9">"#007FC0"</span><span class="s5">.<span class="Apple-converted-space">  </span>The equivalent RGB color is returned as a </span><span class="s9">float</span><span class="s5"> vector of length three (red, green, blue).<span class="Apple-converted-space">  </span>Returned RGB values will be in the interval [0, 1].</span></p>
<p class="p5"><span class="s5">This function can also be called with a non-singleton vector of color strings in </span><span class="s9">color</span><span class="s5">.<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s9">float</span><span class="s5"> value will be a matrix of RGB values, with three columns (red, green, blue) and one row per element of </span><span class="s9">color</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(string)heatColors(integer$ n)</span></p>
<p class="p5"><b>This method has been deprecated, and may be removed in a future release of Eidos.</b><span class="Apple-converted-space">  </span>In SLiM 3.5 and later, use <span class="s2">colors(n, "heat")</span> instead.</p>
<p class="p9">Generate colors in a “heat map” color palette.</p>
<p class="p2">(float)hsv2rgb(float hsv)</p>
<p class="p3"><b>Converts an HSV color to RGB</b><span class="s3">.</span><span class="Apple-converted-space">  </span>The HSV color is specified in <span class="s2">hsv</span> as a <span class="s2">float</span> vector of length three (hue, saturation, value), and the equivalent RGB color is returned as a <span class="s2">float</span> vector of length three (red, green, blue).<span class="Apple-converted-space">  </span>HSV values will be clamped to the interval [0, 1], and returned RGB values will also be in the interval [0, 1].</p>
<p class="p5"><span class="s5">This function can also be called with a matrix of HSV values, with three columns (hue, saturation, value).<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s9">float</span><span class="s5"> value will be a matrix of RGB values, with three columns (red, green, blue) and one row per row of </span><span class="s9">hsv</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(string)rainbow(integer$ n, [float$ s = 1.0], [float$ v = 1.0], [float$ start = 0.0], [Nf$ end = NULL], [logical$ ccw = T])</span></p>
<p class="p5"><span class="s5"><b>Generate colors in a “rainbow” color palette</b>.<span class="Apple-converted-space">  </span>The number of colors desired is passed in </span><span class="s9">n</span><span class="s5">, and the returned vector will contain </span><span class="s9">n</span><span class="s5"> color strings.<span class="Apple-converted-space">  </span>Parameters </span><span class="s9">s</span><span class="s5"> and </span><span class="s9">v</span><span class="s5"> control the saturation and value of the rainbow colors generated.<span class="Apple-converted-space">  </span>The color sequence begins with the hue </span><span class="s9">start</span><span class="s5">, and ramps to the hue </span><span class="s9">end</span><span class="s5">, in a counter-clockwise direction around the standard HSV color wheel if </span><span class="s9">ccw</span><span class="s5"> is </span><span class="s9">T</span><span class="s5"> (the default, following R), otherwise in a clockwise direction.<span class="Apple-converted-space">  </span>If </span><span class="s9">end</span><span class="s5"> is </span><span class="s9">NULL</span><span class="s5"> (the default), a value of </span><span class="s9">(n-1)/n</span><span class="s5"> is used, producing a complete rainbow around the color wheel when </span><span class="s9">start</span><span class="s5"> is also the default value of </span><span class="s9">0.0</span><span class="s5">.<span class="Apple-converted-space">  </span>See </span><span class="s9">colors()</span><span class="s5"> for other color palettes.</span></p>
<p class="p2">(string)rgb2color(float rgb)</p>
<p class="p3"><b>Converts an RGB color to a color string</b><span class="s3">.</span><span class="Apple-converted-space">  </span>The RGB color is specified in <span class="s2">rgb</span> as a <span class="s2">float</span> vector of length three (red, green, blue).<span class="Apple-converted-space">  </span>The equivalent color string is returned as singleton <span class="s2">string</span> specifying the color in the format <span class="s2">"#RRGGBB"</span>, such as <span class="s2">"#007FC0"</span><span class="s3">.</span><span class="Apple-converted-space">  </span>RGB values will be clamped to the interval [0, 1].</p>
<p class="p5"><span class="s5">This function can also be called with a matrix of RGB values, with three columns (red, green, blue).<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s9">string</span><span class="s5"> value will be a vector of color strings, with one element per row of </span><span class="s9">rgb</span><span class="s5">.</span></p>
<p class="p2">(float)rgb2hsv(float rgb)</p>
<p class="p3"><b>Converts an RGB color to HSV</b><span class="s3">.</span><span class="Apple-converted-space">  </span>The RGB color is specified in <span class="s2">rgb</span> as a <span class="s2">float</span> vector of length three (red, green, blue), and the equivalent HSV color is returned as a <span class="s2">float</span> vector of length three (hue, saturation, value).<span class="Apple-converted-space">  </span>RGB values will be clamped to the interval [0, 1], and returned HSV values will also be in the interval [0, 1].</p>
<p class="p5"><span class="s5">This function can also be called with a matrix of RGB values, with three columns (red, green, blue).<span class="Apple-converted-space">  </span>In this case, the returned </span><span class="s9">float</span><span class="s5"> value will be a matrix of HSV values, with three columns (hue, saturation, value) and one row per row of </span><span class="s9">rgb</span><span class="s5">.</span></p>
<p class="p4"><span class="s5">(string)terrainColors(integer$ n)</span></p>
<p class="p5"><b>This method has been deprecated, and may be removed in a future release of Eidos.</b><span class="Apple-converted-space">  </span>In SLiM 3.5 and later, use <span class="s2">colors(n, "terrain")</span> instead.</p>
<p class="p9">Generate colors in a “terrain” color palette.</p>
<p class="p1"><b>3.11.<span class="Apple-converted-space">  </span>Miscellaneous functions</b></p>
<p class="p4">(void)assert(logical assertions, [Ns$ message = NULL])</p>
<p class="p5"><b>Assert that a condition or conditions are true</b>.<span class="Apple-converted-space">  </span>If any element of <span class="s2">assertions</span> is <span class="s2">F</span>, execution will be stopped.<span class="Apple-converted-space">  </span>A message, “assertion failed”, will be printed before stopping; if <span class="s2">message</span> is not <span class="s2">NULL</span>; its value will then be printed.</p>
<p class="p2">(void)beep([Ns$ soundName = NULL])</p>
<p class="p3"><b>Plays a sound or beeps.</b><span class="Apple-converted-space">  </span>On macOS in a GUI environment (i.e., in EidosScribe or SLiMgui), the optional parameter <span class="s2">soundName</span> can be the name of a sound file to play; in other cases (if <span class="s2">soundName</span> is <span class="s2">NULL</span>, or at the command line, or on platforms other than OS X) <span class="s2">soundName</span> is ignored and a standard system beep is played.</p>
<p class="p3">When <span class="s2">soundName</span> is not <span class="s2">NULL</span><span class="s3">,</span> a sound file in a supported format (such as <span class="s2">.aiff</span> or <span class="s2">.mp3</span>) is searched for sequentially in four standard locations, in this order: <span class="s2">~/Library/Sounds</span>, <span class="s2">/Library/Sounds</span>, <span class="s2">/Network/Library/Sounds</span>, and finally <span class="s2">/System/Library/Sounds</span>.<span class="Apple-converted-space">  </span>Standard OS X sounds located in <span class="s15">/System/Library/Sounds</span> include <span class="s2">"Basso"</span><span class="s3">,</span> <span class="s2">"Blow"</span><span class="s3">,</span> <span class="s2">"Bottle"</span><span class="s3">,</span> <span class="s2">"Frog"</span><span class="s3">,</span> <span class="s2">"Funk"</span><span class="s3">,</span> <span class="s2">"Glass"</span><span class="s3">,</span> <span class="s2">"Hero"</span><span class="s3">,</span> <span class="s2">"Morse"</span><span class="s3">,</span> <span class="s2">"Ping"</span><span class="s3">,</span> <span class="s2">"Pop"</span><span class="s3">,</span> <span class="s2">"Purr"</span><span class="s3">,</span> <span class="s2">"Sosumi"</span><span class="s3">,</span> <span class="s2">"Submarine"</span>, and <span class="s2">"Tink"</span>.<span class="Apple-converted-space">  </span>Do not include the file extension, such as <span class="s2">.aiff</span> or <span class="s2">.mp3</span>, in <span class="s2">soundName</span><span class="s3">.</span></p>
<p class="p3"><b>CAUTION:</b> When not running in EidosScribe or SLiMgui, it is often the case that the only simple means available to play a beep is to send a <span class="s2">BEL</span> character (ASCII 7) to the standard output.<span class="Apple-converted-space">  </span>Unfortunately, when this is the case, it means that (1) no beep will be audible if output is being redirected into a file, and (2) a control character, <span class="s2">^G</span>, will occur in the output at the point when the beep was requested.<span class="Apple-converted-space">  </span>It is therefore recommended that <span class="s2">beep()</span> be used only when doing interactive work in a terminal shell (or in a GUI), not when producing output files.<span class="Apple-converted-space">  </span>However, this issue is platform-specific; on some platforms <span class="s2">beep()</span> may result in a beep, and no emitted <span class="s2">^G</span>, even when output is redirected.<span class="Apple-converted-space">  </span>When a <span class="s2">^G</span> must be emitted to the standard output to generate the beep, a warning message will also be emitted to make any associated problems easier to diagnose.</p>
<p class="p2">(void)citation(void)</p>
<p class="p3"><b>Prints citation information for Eidos</b> to Eidos’s output stream.</p>
<p class="p4"><span class="s5">(float$)clock([string$ type = "cpu"])</span></p>
<p class="p5"><span class="s5">Returns the value of a <b>system clock</b>.<span class="Apple-converted-space">  </span>If </span><span class="s9">type</span><span class="s5"> is </span><span class="s9">"cpu"</span><span class="s5">, this returns the current value of the CPU usage clock.<span class="Apple-converted-space">  </span>This is the amount of CPU time used by the current process, in seconds; it is unrelated to the current time of day (for that, see the </span><span class="s9">time()</span><span class="s5"> function).<span class="Apple-converted-space">  </span>This is useful mainly for determining how much processor time a given section of code takes; </span><span class="s9">clock()</span><span class="s5"> can be called before and after a block of code, and the end clock minus the start clock gives the elapsed CPU time consumed in the execution of the block of code.<span class="Apple-converted-space">  </span>See also the </span><span class="s9">timed</span><span class="s5"> parameter of </span><span class="s9">executeLambda()</span><span class="s5">, which automates this procedure.<span class="Apple-converted-space">  </span>Note that if multiple cores are utilized by the process, the CPU usage clock will be the sum of the CPU usage across all cores, and may therefore run faster than the wall clock.</span></p>
<p class="p5"><span class="s5">If </span><span class="s9">type</span><span class="s5"> is </span><span class="s9">"mono"</span><span class="s5">, this returns the value of the system’s monotonic clock.<span class="Apple-converted-space">  </span>This represents user-perceived (“wall clock”) elapsed time from some arbitrary timebase (which will not change during the execution of the program), but it will not jump if the time zone or the wall clock time are changed for the system.<span class="Apple-converted-space">  </span>This clock is useful for measuring user-perceived elapsed time, as described above, and may provide a more useful metric for performance than CPU time if multiple cores are being utilized.</span></p>
<p class="p2">(string$)date(void)</p>
<p class="p3">Returns a <b>standard date string</b> for the current date in the local time of the executing machine.<span class="Apple-converted-space">  </span>The format is <span class="s2">%d-%m-%Y</span> (day in two digits, then month in two digits, then year in four digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.</p>
<p class="p4">(string$)debugIndent(void)</p>
<p class="p5">Returns the <b>indentation string</b> currently being used to start lines in the debugging output stream.<span class="Apple-converted-space">  </span>In a pure Eidos context this will currently be the empty string, <span class="s2">""</span>.<span class="Apple-converted-space">  </span>In specific Contexts, such as SLiM, the debugging output stream may be structured with nested indentation, in which case this string will typically be a series of spaces or tabs.<span class="Apple-converted-space">  </span>To make your debugging output (such as from <span class="s2">cat()</span>, <span class="s2">catn()</span>, or <span class="s2">print()</span> with the <span class="s2">error=T</span> optional argument set) line up with other output at the current level of execution nesting, you can start your new lines of output with this string if you wish.</p>
<p class="p4">(void)defineConstant(string$ symbol, * value)</p>
<p class="p5"><b>Defines a new constant</b> with the name <span class="s2">symbol</span> and the value specified by <span class="s2">value</span>.<span class="Apple-converted-space">  </span>The name cannot previously be defined in any way (i.e., as either a variable or a constant).<span class="Apple-converted-space">  </span>The defined constant acts identically to intrinsic Eidos constants such as <span class="s2">T</span>, <span class="s2">NAN</span>, and <span class="s2">PI</span>, and will remain defined for as long as the Eidos context lives even if it is defined inside a block being executed by <span class="s2">executeLambda()</span>, <span class="s2">apply()</span>, <span class="s2">sapply()</span>, or a Context-defined script block.</p>
<p class="p5">Syntactically, <span class="s2">value</span> may be any value at all; semantically, however, if <span class="s2">value</span> is of <span class="s2">object</span> type then <span class="s2">value</span>’s class must be under an internal memory-management scheme called “retain-release”.<span class="Apple-converted-space">  </span>Objects that are not under retain-release can cease to exist whenever the Context is finished using them, and thus a defined constant referencing such an object could become invalid, which must be prevented.<span class="Apple-converted-space">  </span>Objects that are under retain-release will not cease to exist if they are referenced by a global constant; the reference to them from the global constant “retains” them and keeps them in existence.<span class="Apple-converted-space">  </span>All object classes built into Eidos are under retain-release; see the SLiM manual (section “SLiM scoping rules”) for discussion of which SLiM object classes are under retain-release.</p>
<p class="p4">(void)defineGlobal(string$ symbol, * value)</p>
<p class="p5"><b>Defines a new global variable</b> with the name <span class="s2">symbol</span> and the value specified by <span class="s2">value</span>.<span class="Apple-converted-space">  </span>The name cannot previously be defined as a constant.<span class="Apple-converted-space">  </span>The result is similar to a standard variable assignment with operator <span class="s2">=</span>, except that the variable is always defined in the global scope (even if the <span class="s2">defineGlobal()</span> call is made inside a user-defined function or other locally-scoped block, such as a SLiM event or callback).<span class="Apple-converted-space">  </span>This means that the variable will remain defined even after the current scope is exited.<span class="Apple-converted-space">  </span>Note that global variables can be hidden by local variables with the same name; unlike defined constants, such scoped masking is allowed.</p>
<p class="p5">Syntactically, <span class="s2">value</span> may be any value at all; semantically, however, if <span class="s2">value</span> is of <span class="s2">object</span> type then <span class="s2">value</span>’s class must be under an internal memory-management scheme called “retain-release”.<span class="Apple-converted-space">  </span>Objects that are not under retain-release can cease to exist whenever the Context is finished using them, and thus a global variable referencing such an object could become invalid, which must be prevented.<span class="Apple-converted-space">  </span>Objects that are under retain-release will not cease to exist if they are referenced by a global variable; the reference to them from the global variable “retains” them and keeps them in existence.<span class="Apple-converted-space">  </span>All object classes built into Eidos are under retain-release; see the SLiM manual (section “SLiM scoping rules”) for discussion of which SLiM object classes are under retain-release.</p>
<p class="p2">(<span class="s14">vNlifso</span>)doCall(string$ functionName, ...)</p>
<p class="p3">Returns the results from a <b>call to a specified function</b>.<span class="Apple-converted-space">  </span>The function named by the parameter <span class="s2">functionName</span> is called, and the remaining parameters to <span class="s2">doCall()</span> are forwarded on to that function verbatim.<span class="Apple-converted-space">  </span>This can be useful for calling one of a set of similar functions, such as <span class="s2">sin()</span>, <span class="s2">cos()</span>, etc., to perform a math function determined at runtime, or one of the <span class="s2">as...()</span> family of functions to convert to a type determined at runtime.<span class="Apple-converted-space">  </span>Note that named arguments and default arguments, beyond the <span class="s2">functionName</span> argument, are not supported by <span class="s2">doCall()</span>; all arguments to the target function must be specified explicitly, without names.</p>
<p class="p2">(<span class="s14">vNlifso</span>)executeLambda(string$ lambdaSource, [ls$ timed = F])</p>
<p class="p5"><span class="s5"><b>Executes a block of Eidos code</b> defined by </span><span class="s9">lambdaSource</span><span class="s5">.<span class="Apple-converted-space">  </span>Eidos allows you to execute <i>lambdas</i>: blocks of Eidos code which can be called directly within the same scope as the caller.<span class="Apple-converted-space">  </span>Eidos lambdas do not take arguments; for this reason, they are not first-class functions.<span class="Apple-converted-space">  </span>(Since they share the scope of the caller, however, you may effectively pass values in and out of a lambda using variables.)<span class="Apple-converted-space">  </span>The </span><span class="s9">string</span><span class="s5"> argument </span><span class="s9">lambdaSource</span><span class="s5"> may contain one or many Eidos statements as a single </span><span class="s9">string</span><span class="s5"> value.<span class="Apple-converted-space">  </span>Lambdas are represented, to the caller, only as the source code </span><span class="s9">string</span><span class="s5"> </span><span class="s9">lambdaSource</span><span class="s5">; the executable code is not made available programmatically.<span class="Apple-converted-space">  </span>If an error occurs during the tokenization, parsing, or execution of the lambda, that error is raised as usual; executing code inside a lambda does not provide any additional protection against exceptions raised.<span class="Apple-converted-space">  </span>The return value produced by the code in the lambda is returned by </span><span class="s9">executeLambda()</span><span class="s5">.<span class="Apple-converted-space">  </span>If the optional parameter </span><span class="s9">timed</span><span class="s5"> is </span><span class="s9">T</span><span class="s5">, the total (CPU clock) execution time for the lambda will be printed after the lambda has completed (see </span><span class="s9">clock()</span><span class="s5">); if it is </span><span class="s9">F</span><span class="s5"> (the default), no timing information will be printed.<span class="Apple-converted-space">  </span>The </span><span class="s9">timed</span><span class="s5"> parameter may also be </span><span class="s9">"cpu"</span><span class="s5"> or </span><span class="s9">"mono"</span><span class="s5"> to specifically request timing with the CPU clock (which will count the usage across all cores, and may thus run faster than wall clock time if multiple cores are being utilized) or the monotonic clock (which will correspond, more or less, to elapsed wall clock time regardless of multithreading); see the documentation for </span><span class="s9">clock()</span><span class="s5"> for further discussion of these timing options.</span></p>
<p class="p3">The current implementation of <span class="s2">executeLambda()</span> caches a tokenized and parsed version of <span class="s2">lambdaSource</span>, so calling <span class="s2">executeLambda()</span> repeatedly on a single source <span class="s2">string</span> is much more efficient than calling <span class="s2">executeLambda()</span> with a newly constructed <span class="s2">string</span> each time.<span class="Apple-converted-space">  </span>If you can use a <span class="s2">string</span> literal for <span class="s2">lambdaSource</span>, or reuse a constructed source <span class="s2">string</span> stored in a variable, that will improve performance considerably.</p>
<p class="p2">(logical)exists(string symbol)</p>
<p class="p5"><span class="s5">Returns a </span><span class="s9">logical</span><span class="s5"> vector indicating <b>whether symbols exist</b>.<span class="Apple-converted-space">  </span>If a symbol has been defined as an intrinsic Eidos constant like </span><span class="s9">T</span><span class="s5">, </span><span class="s9">INF</span><span class="s5">, and </span><span class="s9">PI</span><span class="s5">, or as a Context-defined constant like </span><span class="s9">sim</span><span class="s5"> in SLiM, or as a user-defined constant using </span><span class="s9">defineConstant()</span><span class="s5">, or as a variable by assignment, this function returns </span><span class="s9">T</span><span class="s5">.<span class="Apple-converted-space">  </span>Otherwise, the symbol has not been defined, and </span><span class="s9">exists()</span><span class="s5"> returns </span><span class="s9">F</span><span class="s5">.<span class="Apple-converted-space">  </span>This is commonly used to check whether a user-defined constant already exists, with the intention of defining the constant if it has not already been defined.<span class="Apple-converted-space">  </span>A vector of symbols may be passed, producing a vector of corresponding results.</span></p>
<p class="p2">(void)functionSignature([Ns$<span class="s1"> </span>functionName<span class="s1"> </span>= NULL])</p>
<p class="p3"><b>Prints function signatures</b> for all functions (if <span class="s2">functionName</span> is <span class="s2">NULL</span>, the default), or for the function named by <span class="s2">functionName</span>, to Eidos’s output stream.</p>
<p class="p4">(void)functionSource(string$ functionName)</p>
<p class="p5"><b>Prints the Eidos source code</b> for the function specified by <span class="s2">functionName</span>, or prints a diagnostic message if the function is implemented in C++ rather than Eidos.</p>
<p class="p2">(integer$)getSeed(void)</p>
<p class="p3">Returns the <b>random number seed</b>.<span class="Apple-converted-space">  </span>This is the last seed value set using <span class="s2">setSeed()</span>; if <span class="s2">setSeed()</span> has not been called, it will be a seed value chosen based on the process-id and the current time when Eidos was initialized, unless the Context has set a different seed value.</p>
<p class="p2">(void)license(void)</p>
<p class="p3"><b>Prints Eidos’s license terms</b> to Eidos’s output stream.</p>
<p class="p4"><span class="s6">(void)ls(</span>[logical$ showSymbolTables = F]<span class="s6">)</span></p>
<p class="p3"><b>Prints all currently defined variables</b> to Eidos’s output stream.</p>
<p class="p5">Beginning in Eidos 2.5 (SLiM 3.5), the <span class="s2">showSymbolTables</span> optional argument can be set to <span class="s2">T</span> to request full information on the current symbol table chain.<span class="Apple-converted-space">  </span>This will show which symbol table a given symbol is defined in, as well as revealing whether there are other symbols with the same name that have been masked by a local definition.<span class="Apple-converted-space">  </span>This is mostly useful for debugging.</p>
<p class="p4">(integer$)parallelGetNumThreads(void)</p>
<p class="p5"><b>Gets the number of threads</b> that is requested be used in subsequent parallel (i.e., multithreaded) regions, as set with <span class="s2">parallelSetNumThreads()</span>.<span class="Apple-converted-space">  </span>If Eidos is not configured to run multithreaded, this function will return <span class="s2">1</span>.<span class="Apple-converted-space">  </span>See also <span class="s2">parallelGetMaxThreads()</span>, which returns the maximum number of threads that can be used.<span class="Apple-converted-space">  </span>Note that if this function returns the maximum number of threads, as returned by <span class="s2">parallelGetMaxThreads()</span>, then there are <i>two possible semantic meanings</i> of that return value, which cannot be distinguished using this function; see <span class="s2">parallelSetNumThreads()</span> for discussion.</p>
<p class="p4">(integer$)parallelGetMaxThreads(void)</p>
<p class="p5"><b>Gets the maximum number of threads</b> that can be used in parallel (i.e., multithreaded) regions.<span class="Apple-converted-space">  </span>This is configured externally; it may be OpenMP’s default number of threads for the hardware platform being used, or may be set by an environment variable or command-line option.<span class="Apple-converted-space">  </span>If Eidos is not configured to run multithreaded, this function will return <span class="s2">1</span>.</p>
<p class="p4">(object&lt;Dictionary&gt;$)parallelGetTaskThreadCounts(void)</p>
<p class="p5"><b>Gets the number of threads</b> that is requested to be used for specific tasks in Eidos and SLiM.<span class="Apple-converted-space">  </span>Returns a new <span class="s2">Dictionary</span> containing values for all of the tasks for which a number of threads can be specified; see <span class="s2">parallelSetTaskThreadCounts()</span> for a list of all such tasks.<span class="Apple-converted-space">  </span>Note that the specified number of threads will not necessarily be used in practice; in particular, a thread count set by <span class="s2">parallelSetNumThreads()</span> will override these per-task counts.<span class="Apple-converted-space">  </span>Also, if the task size is below a certain task-specific threshold the task will not be executed in parallel regardless of these settings.</p>
<p class="p4">(void)parallelSetNumThreads([Ni$ numThreads = NULL])</p>
<p class="p5"><b>Sets the number of threads</b> that is requested to be used in subsequent parallel (i.e., multithreaded) regions.<span class="Apple-converted-space">  </span>If Eidos is not configured to run multithreaded, this function will have no effect.<span class="Apple-converted-space">  </span>The requested number of threads will be clamped to the interval [<span class="s2">1</span>, <span class="s2">maxThreads</span>], where <span class="s2">maxThreads</span> is the maximum number of threads configured externally (either by OpenMP’s default, or by an environment variable or command-line option).<span class="Apple-converted-space">  </span>That maximum number of threads (the value of <span class="s2">maxThreads</span>) can be obtained from <span class="s2">parallelGetMaxThreads()</span>.</p>
<p class="p5">There is an important wrinkle in the semantics of this method that must be explained.<span class="Apple-converted-space">  </span>Passing <span class="s2">NULL</span> (the default) resets Eidos to the default number of threads for which it is configured to run.<span class="Apple-converted-space">  </span>In this configuration, <span class="s2">parallelGetNumThreads()</span> will return <span class="s2">maxThreads</span>, but the number of threads used for any given parallel operation might not, in fact, be equal to <span class="s2">maxThreads</span>; Eidos might use fewer threads if it determines that that would improve performance.<span class="Apple-converted-space">  </span>Passing the value of <span class="s2">maxThreads</span> explicitly, on the other hand, sets Eidos to always use <span class="s2">maxThreads</span> threads, even if it may result in lower performance; but in this configuration, too, <span class="s2">parallelGetNumThreads()</span> will return <span class="s2">maxThreads</span>.<span class="Apple-converted-space">  </span>For example, suppose <span class="s2">maxThreads</span> is <span class="s2">16</span>.<span class="Apple-converted-space">  </span>Passing <span class="s2">NULL</span> requests that Eidos use <i>up to</i> <span class="s2">16</span> threads, as it sees fit; in contrast, explicitly passing <span class="s2">16</span> requests that Eidos use <i>exactly</i> 16 threads.<span class="Apple-converted-space">  </span>In both cases, however, <span class="s2">parallelGetNumThreads()</span> will return <span class="s2">16</span>.</p>
<p class="p5">If you wish to temporarily change the number of threads used, the standard pattern is to call <span class="s2">parallelSetNumThreads()</span> with the number of threads you want to use, do the operation you wish to control, and then call <span class="s2">parallelSetNumThreads(NULL)</span> to return to the default behavior of Eidos.</p>
<p class="p5">Note that the number of threads requested here overrides any per-task request set with <span class="s2">parallelSetTaskThreadCounts()</span>.<span class="Apple-converted-space">  </span>Also, if the task size is below a certain task-specific threshold the task will not be executed in parallel regardless of these settings.</p>
<p class="p4">(void)parallelSetTaskThreadCounts(No&lt;Dictionary&gt;$ dict)</p>
<p class="p5"><b>Sets the number of threads</b> that is requested to be used for specific tasks in Eidos and SLiM.<span class="Apple-converted-space">  </span>The dictionary <span class="s2">dict</span> should contain <span class="s2">string</span> keys that identify tasks, and <span class="s2">integer</span> values that provide the number of threads to be used when performing those tasks.<span class="Apple-converted-space">  </span>For example, a key of <span class="s2">"LOG10_FLOAT"</span> identifies the task of performing the <span class="s2">log10()</span> function on a <span class="s2">float</span> vector, and a value of <span class="s2">8</span> for that key would tell Eidos to use eight threads when performing that task.<span class="Apple-converted-space">  </span>The number of threads actually used will never be greater than the maximum thread count as returned by <span class="s2">parallelGetMaxThreads()</span>.<span class="Apple-converted-space">  </span>Furthermore, a thread count set with <span class="s2">parallelSetNumThreads()</span> overrides the per-task setting, so if you wish to set specific per-task thread counts you should not set an overall thread count with <span class="s2">parallelSetNumThreads()</span>.<span class="Apple-converted-space">  </span>If <span class="s2">dict</span> is <span class="s2">NULL</span>, all task thread counts will be reset to their default values.</p>
<p class="p5">The currently requested thread counts for all tasks can be obtained with <span class="s2">parallelGetTaskThreadCounts()</span>.<span class="Apple-converted-space">  </span>Note that the counts returned by that function may not match the counts requested with <span class="s2">parallelSetTaskThreadCounts()</span>; in particular, they may be clipped to the maximum number of threads as returned by <span class="s2">parallelGetMaxThreads()</span>.</p>
<p class="p5">The task keys recognized, and the tasks they govern, are:</p>
<p class="p10">"ABS_FLOAT"<span class="Apple-tab-span">	</span>abs(float x)<br>
"CEIL"<span class="Apple-tab-span">	</span>ceil()<br>
"EXP_FLOAT"<span class="Apple-tab-span">	</span>exp(float x)<br>
"FLOOR"<span class="Apple-tab-span">	</span>floor()<br>
"LOG_FLOAT"<span class="Apple-tab-span">	</span>log(float x)<br>
"LOG10_FLOAT"<span class="Apple-tab-span">	</span>log10(float x)<br>
"LOG2_FLOAT"<span class="Apple-tab-span">	</span>log2(float x)<br>
"ROUND"<span class="Apple-tab-span">	</span>round()<br>
"SQRT_FLOAT"<span class="Apple-tab-span">	</span>sqrt(float x)<br>
"SUM_INTEGER"<span class="Apple-tab-span">	</span>sum(integer x)<br>
"SUM_FLOAT"<span class="Apple-tab-span">	</span>sum(float x)<br>
"SUM_LOGICAL"<span class="Apple-tab-span">	</span>sum(logical x)<br>
"TRUNC"<span class="Apple-tab-span">	</span>trunc()</p>
<p class="p10">"MAX_INT"<span class="Apple-tab-span">	</span>max(integer x)<br>
"MAX_FLOAT"<span class="Apple-tab-span">	</span>max(float x)<br>
"MIN_INT"<span class="Apple-tab-span">	</span>min(integer x)<br>
"MIN_FLOAT"<span class="Apple-tab-span">	</span>min(float x)<br>
"PMAX_INT_1"<span class="Apple-tab-span">	</span>pmax(i$ x, i y) / pmax(i x, i$ y)<br>
"PMAX_INT_2"<span class="Apple-tab-span">	</span>pmax(integer x, integer y)<br>
"PMAX_FLOAT_1"<span class="Apple-tab-span">	</span>pmax(f$ x, f y) / pmax(f x, f$ y)<br>
"PMAX_FLOAT_2"<span class="Apple-tab-span">	</span>pmax(float x, float y)<br>
"PMIN_INT_1"<span class="Apple-tab-span">	</span>pmin(i$ x, i y) / pmax(i x, i$ y)<br>
"PMIN_INT_2"<span class="Apple-tab-span">	</span>pmin(integer x, integer y)<br>
"PMIN_FLOAT_1"<span class="Apple-tab-span">	</span>pmin(f$ x, f y) / pmin(f x, f$ y)<br>
"PMIN_FLOAT_2"<span class="Apple-tab-span">	</span>pmin(float x, float y)</p>
<p class="p10">"MATCH_INT"<span class="Apple-tab-span">	</span>match(integer x, integer table)<br>
"MATCH_FLOAT"<span class="Apple-tab-span">	</span>match(float x, float table)<br>
"MATCH_STRING"<span class="Apple-tab-span">	</span>match(string x, string table)<br>
"MATCH_OBJECT"<span class="Apple-tab-span">	</span>match(object x, object table)<br>
"SAMPLE_INDEX"<span class="Apple-tab-span">	</span>sample()<span class="s19"> index buffer generation (internal)</span><br>
"SAMPLE_R_INT"<span class="Apple-tab-span">	</span>sample(integer x, weights=NULL)<br>
"SAMPLE_R_FLOAT"<span class="Apple-tab-span">	</span>sample(float x, weights=NULL)<br>
"SAMPLE_R_OBJECT"<span class="Apple-tab-span">	</span>sample(object x, weights=NULL)<br>
"SAMPLE_WR_INT"<span class="Apple-tab-span">	</span>sample(integer x, if weights)<br>
"SAMPLE_WR_FLOAT"<span class="Apple-tab-span">	</span>sample(float x, if weights)<br>
"SAMPLE_WR_OBJECT"<span class="Apple-tab-span">	</span>sample(object x, if weights)<br>
"TABULATE_MAXBIN"<span class="Apple-tab-span">	</span>tabulate()<span class="s19"> determination of </span>maxbin<span class="s19"> (if not supplied)</span><br>
"TABULATE"<span class="Apple-tab-span">	</span>tabulate()<span class="s19"> main loop</span></p>
<p class="p10">"DNORM_1"<span class="Apple-tab-span">	</span>dnorm(numeric$ mean, numeric$ sd)<br>
"DNORM_2"<span class="Apple-tab-span">	</span>dnorm()<span class="s19"> other cases</span><br>
"RBINOM_1"<span class="Apple-tab-span">	</span>rbinom(i$ size = 1, f$ prob = 0.5)<br>
"RBINOM_2"<span class="Apple-tab-span">	</span>rbinom(i$ size, f$ prob)<span class="s19"> other cases</span><br>
"RBINOM_3"<span class="Apple-tab-span">	</span>rbinom()<span class="s19"> other cases</span><br>
"RDUNIF_1"<span class="Apple-tab-span">	</span>rdunif(i$ min = 0, i$ max = 1)<span class="s19"> and similar</span><br>
"RDUNIF_2"<span class="Apple-tab-span">	</span>rdunif(i$ min, i$ max)<span class="s19"> other cases</span><br>
"RDUNIF_3"<span class="Apple-tab-span">	</span>rdunif()<span class="s19"> other cases</span><br>
"REXP_1"<span class="Apple-tab-span">	</span>rexp(numeric$ mu)<br>
"REXP_2"<span class="Apple-tab-span">	</span>rexp()<span class="s19"> other cases</span><br>
"RNORM_1"<span class="Apple-tab-span">	</span>rnorm(numeric$ mean, numeric$ sd)<br>
"RNORM_2"<span class="Apple-tab-span">	</span>rnorm(numeric$ sigma)<br>
"RNORM_3"<span class="Apple-tab-span">	</span>rnorm()<span class="s19"> other cases</span><br>
"RPOIS_1"<span class="Apple-tab-span">	</span>rpois(numeric$ lambda)<br>
"RPOIS_2"<span class="Apple-tab-span">	</span>rpois()<span class="s19"> other cases</span><br>
"RUNIF_1"<span class="Apple-tab-span">	</span>runif(numeric$ min = 0, numeric$ max = 1)<br>
"RUNIF_2"<span class="Apple-tab-span">	</span>runif(numeric$ min, numeric$ max)<span class="s19"> other cases</span><br>
"RUNIF_3"<span class="Apple-tab-span">	</span>runif()<span class="s19"> other cases</span></p>
<p class="p10">"SORT_INT"<span class="Apple-tab-span">	</span>sort(integer x)<br>
"SORT_FLOAT"<span class="Apple-tab-span">	</span>sort(float x)<br>
"SORT_STRING"<span class="Apple-tab-span">	</span>sort(string x)</p>
<p class="p10">"CLIPPEDINTEGRAL_1S"<span class="Apple-tab-span">	</span>clippedIntegral()<span class="s19"> for </span>"x"<span class="s19">, </span>"y"<span class="s19">, </span>"z"<br>
"CLIPPEDINTEGRAL_2S"<span class="Apple-tab-span">	</span>clippedIntegral()<span class="s19"> for </span>"xy"<span class="s19">, </span>"xz"<span class="s19">, </span>"yz"<br>
"DRAWBYSTRENGTH"<span class="Apple-tab-span">	</span>drawByStrength(returnDict=T)<br>
"INTNEIGHCOUNT"<span class="Apple-tab-span">	</span>interactingNeighborSount()<br>
"LOCALPOPDENSITY"<span class="Apple-tab-span">	</span>localPopulationDensity()<br>
"NEARESTINTNEIGH"<span class="Apple-tab-span">	</span>nearestInteractingNeighbors(returnDict=T)<br>
"NEARESTNEIGH"<span class="Apple-tab-span">	</span>nearestNeighbors(returnDict=T)<br>
"NEIGHCOUNT"<span class="Apple-tab-span">	</span>neighborCount()<br>
"TOTNEIGHSTRENGTH"<span class="Apple-tab-span">	</span>totalOfNeighborsStrengths()</p>
<p class="p10">"POINT_IN_BOUNDS_1D"<span class="Apple-tab-span">	</span>pointInBounds()<span class="s19">, 1D case</span><br>
"POINT_IN_BOUNDS_2D"<span class="Apple-tab-span">	</span>pointInBounds()<span class="s19">, 2D case</span><br>
"POINT_IN_BOUNDS_3D"<span class="Apple-tab-span">	</span>pointInBounds()<span class="s19">, 3D case</span><br>
"POINT_PERIODIC_1D"<span class="Apple-tab-span">	</span>pointPeriodic()<span class="s19">, 1D case</span><br>
"POINT_PERIODIC_2D"<span class="Apple-tab-span">	</span>pointPeriodic()<span class="s19">, 2D case</span><br>
"POINT_PERIODIC_3D"<span class="Apple-tab-span">	</span>pointPeriodic()<span class="s19">, 3D case</span><br>
"POINT_REFLECTED_1D"<span class="Apple-tab-span">	</span>pointReflected()<span class="s19">, 1D case</span><br>
"POINT_REFLECTED_2D"<span class="Apple-tab-span">	</span>pointReflected()<span class="s19">, 2D case</span><br>
"POINT_REFLECTED_3D"<span class="Apple-tab-span">	</span>pointReflected()<span class="s19">, 3D case</span><br>
"POINT_STOPPED_1D"<span class="Apple-tab-span">	</span>pointStopped()<span class="s19">, 1D case</span><br>
"POINT_STOPPED_2D"<span class="Apple-tab-span">	</span>pointStopped()<span class="s19">, 2D case</span><br>
"POINT_STOPPED_3D"<span class="Apple-tab-span">	</span>pointStopped()<span class="s19">, 3D case</span><br>
"POINT_UNIFORM_1D"<span class="Apple-tab-span">	</span>pointUniform()<span class="s19">, 1D case</span><br>
"POINT_UNIFORM_2D"<span class="Apple-tab-span">	</span>pointUniform()<span class="s19">, 2D case</span><br>
"POINT_UNIFORM_3D"<span class="Apple-tab-span">	</span>pointUniform()<span class="s19">, 3D case</span><br>
"SET_SPATIAL_POS_1_1D"<span class="Apple-tab-span">	</span>setSpatialPosition()<span class="s19"> with one point, 1D case</span><br>
"SET_SPATIAL_POS_1_2D"<span class="Apple-tab-span">	</span>setSpatialPosition()<span class="s19"> with one point, 2D case</span><br>
"SET_SPATIAL_POS_1_3D"<span class="Apple-tab-span">	</span>setSpatialPosition()<span class="s19"> with one point, 3D case</span><br>
"SET_SPATIAL_POS_2_1D"<span class="Apple-tab-span">	</span>setSpatialPosition()<span class="s19"> with <i>N</i> points, 1D case</span><br>
"SET_SPATIAL_POS_2_2D"<span class="Apple-tab-span">	</span>setSpatialPosition()<span class="s19"> with <i>N</i> points, 2D case</span><br>
"SET_SPATIAL_POS_2_3D"<span class="Apple-tab-span">	</span>setSpatialPosition()<span class="s19"> with <i>N</i> points, 3D case</span><br>
"SPATIAL_MAP_VALUE"<span class="Apple-tab-span">	</span>spatialMapValue()</p>
<p class="p10">"CONTAINS_MARKER_MUT"<span class="Apple-tab-span">	</span>containsMarkerMutation(returnMutation = F)<br>
"I_COUNT_OF_MUTS_OF_TYPE"<span class="Apple-tab-span">	</span>countOfMutationsOfType() (Individual)<br>
"H_COUNT_OF_MUTS_OF_TYPE"<span class="Apple-tab-span">	</span>countOfMutationsOfType() (Haplosome)<br>
"INDS_W_PEDIGREE_IDS"<span class="Apple-tab-span">	</span>individualsWithPedigreeIDs()<br>
"RELATEDNESS"<span class="Apple-tab-span">	</span>relatedness()<br>
"SAMPLE_INDIVIDUALS_1"<span class="Apple-tab-span">	</span>sampleIndividuals()<span class="s19"> simple case with replace=T</span><br>
"SAMPLE_INDIVIDUALS_2"<span class="Apple-tab-span">	</span>sampleIndividuals()<span class="s19"> base case with replace=T</span><br>
"SET_FITNESS_SCALE_1"<span class="Apple-tab-span">	</span>Individual.fitness = <span class="s19">one value</span><br>
"SET_FITNESS_SCALE_2"<span class="Apple-tab-span">	</span>Individual.fitness = <span class="s19"><i>N</i> values</span><br>
"SUM_OF_MUTS_OF_TYPE"<span class="Apple-tab-span">	</span>sumOfMutationsOfType()</p>
<p class="p11"><span class="s2">"AGE_INCR"<span class="Apple-tab-span">	</span></span>incrementing <span class="s2">Individual age</span> values<span class="s2"><br>
"DEFERRED_REPRO"<span class="Apple-tab-span">	</span></span>deferred nonWF reproduction<span class="s2"><br>
"WF_REPRO"<span class="Apple-tab-span">	</span></span>WF reproduction (no callbacks)<span class="s2"><br>
"FITNESS_ASEX_1"<span class="Apple-tab-span">	</span></span>fitness eval, asex, individual <span class="s2">fitnessScaling<br>
"FITNESS_ASEX_2"<span class="Apple-tab-span">	</span></span>fitness eval, asex, no <span class="s2">fitnessScaling</span> or mutations<span class="s2"><br>
"FITNESS_ASEX_3"<span class="Apple-tab-span">	</span></span>fitness eval, asex, <span class="s2">fitnessScaling</span> and mutations<span class="s2"><br>
"FITNESS_SEX_1"<span class="Apple-tab-span">	</span></span>fitness eval, sexual, individual <span class="s2">fitnessScaling<br>
"FITNESS_SEX_2"<span class="Apple-tab-span">	</span></span>fitness eval, sexual, no <span class="s2">fitnessScaling</span> or mutations<span class="s2"><br>
"FITNESS_SEX_3"<span class="Apple-tab-span">	</span></span>fitness eval, sexual, <span class="s2">fitnessScaling</span> and mutations<span class="s2"><br>
"MIGRANT_CLEAR"<span class="Apple-tab-span">	</span></span>clearing the <span class="s2">migrant</span> property at tick end<span class="s2"><br>
"SIMPLIFY_SORT_PRE"<span class="Apple-tab-span">	</span></span>preparation for simplification sorting (internal)<span class="s2"><br>
"SIMPLIFY_SORT"<span class="Apple-tab-span">	</span></span>simplification sorting<span class="s2"><br>
"SIMPLIFY_SORT_POST"<span class="Apple-tab-span">	</span></span>cleanup after simplification sorting (internal)<span class="s2"><br>
"PARENTS_CLEAR"<span class="Apple-tab-span">	</span></span>clearing parental haplosomes at tick end in WF models<span class="s2"><br>
"UNIQUE_MUTRUNS"<span class="Apple-tab-span">	</span></span>uniquing mutation runs (internal bookkeeping)<span class="s2"><br>
"SURVIVAL"<span class="Apple-tab-span">	</span></span>survival evaluation (no callbacks)</p>
<p class="p5">Typically, a dictionary of task keys and thread counts is read from a file and set up with this function at initialization time, but it is also possible to change new task thread counts dynamically.<span class="Apple-converted-space">  </span>If Eidos is not configured to run multithreaded, this function has no effect.</p>
<p class="p4">(void)rm([Ns variableNames = NULL])</p>
<p class="p5"><b>Removes variables</b> from the Eidos namespace; in other words, it causes the variables to become undefined.<span class="Apple-converted-space">  </span>Variables are specified by their <span class="s2">string</span> name in the <span class="s2">variableNames</span> parameter.<span class="Apple-converted-space">  </span>If the optional <span class="s2">variableNames</span> parameter is <span class="s2">NULL</span> (the default), <i>all</i> variables will be removed (be careful!).</p>
<p class="p5">In SLiM 3, there was an optional parameter <span class="s2">removeConstants</span> that, if <span class="s2">T</span>, allowed you to remove defined constants (and then potentially redefine them to have a different value).<span class="Apple-converted-space">  </span>The <span class="s2">removeConstants</span> parameter was removed in SLiM 4, since the <span class="s2">defineGlobal()</span> function now provides the ability to define (and redefine) global variables that are not constant.</p>
<p class="p2">(*)sapply(* x, string$ lambdaSource, [string$ simplify = "vector"])</p>
<p class="p8"><span class="s5"><i>Named </i></span><span class="s9"><i>apply()</i></span><span class="s5"><i> prior to Eidos 1.6 / SLiM 2.6</i></span></p>
<p class="p5"><span class="s5"><b>Applies a block of Eidos code to the elements of x</b>.<span class="Apple-converted-space">  </span>This function is sort of a hybrid between </span><span class="s9">c()</span><span class="s5"> and </span><span class="s9">executeLambda()</span><span class="s5">; it might be useful to consult the documentation for both of those functions to better understand what </span><span class="s9">sapply()</span><span class="s5"> does.<span class="Apple-converted-space">  </span>For each element in </span><span class="s9">x</span><span class="s5">, the lambda defined by </span><span class="s9">lambdaSource</span><span class="s5"> will be called.<span class="Apple-converted-space">  </span>For the duration of that callout, a variable named </span><span class="s9">applyValue</span><span class="s5"> will be defined to have as its value the element of </span><span class="s9">x</span><span class="s5"> currently being processed.<span class="Apple-converted-space">  </span>The expectation is that the lambda will use </span><span class="s9">applyValue</span><span class="s5"> in some way, and will return either </span><span class="s9">NULL</span><span class="s5"> or a new value (which need not be a singleton, and need not be of the same type as </span><span class="s9">x</span><span class="s5">).<span class="Apple-converted-space">  </span>The return value of </span><span class="s9">sapply()</span><span class="s5"> is generated by concatenating together all of the individual vectors returned by the lambda, in exactly the same manner as the </span><span class="s9">c()</span><span class="s5"> function (including the possibility of type promotion).</span></p>
<p class="p5"><span class="s5">Since this function can be hard to understand at first, here is an example:</span></p>
<p class="p12"><span class="s5">sapply(1:10, "if (applyValue % 2) applyValue ^ 2; else NULL;");</span></p>
<p class="p5">This produces the output <span class="s2">1 9 25 49 81</span>.<span class="Apple-converted-space">  </span>The <span class="s2">sapply()</span> operation begins with the vector <span class="s2">1:10</span>.<span class="Apple-converted-space">  </span>For each element of that vector, the lambda is called and <span class="s2">applyValue</span> is defined with the element value.<span class="Apple-converted-space">  </span>In this respect, <span class="s2">sapply()</span> is actually very much like a <span class="s2">for</span> loop.<span class="Apple-converted-space">  </span>If <span class="s2">applyValue</span> is even (as evaluated by the modulo operator, <span class="s2">%</span>), the condition of the <span class="s2">if</span> statement is <span class="s2">F</span> and so <span class="s2">NULL</span> is returned by the lambda; this must be done explicitly, since a <span class="s2">void</span> return is not allowed by <span class="s2">sapply()</span>.<span class="Apple-converted-space">  </span>If <span class="s2">applyValue</span> is odd, on the other hand, the lambda returns its square (as calculated by the exponential operator, <span class="s2">^</span>).<span class="Apple-converted-space">  </span>Just as with the <span class="s2">c()</span> function, <span class="s2">NULL</span> values are dropped during concatenation, so the final result contains only the squares of the odd values.</p>
<p class="p5"><span class="s5">This example illustrates that the lambda can “drop” values by returning </span><span class="s9">NULL</span><span class="s5">, so </span><span class="s9">sapply()</span><span class="s5"> can be used to select particular elements of a vector that satisfy some condition, much like the subscript operator, </span><span class="s9">[]</span><span class="s5">.<span class="Apple-converted-space">  </span>The example also illustrates that input and result types do not have to match; the vector passed in is </span><span class="s9">integer</span><span class="s5">, whereas the result vector is </span><span class="s9">float</span><span class="s5">.</span></p>
<p class="p5"><span class="s5">Beginning in Eidos 1.6, a new optional parameter named </span><span class="s9">simplify</span><span class="s5"> allows the result of </span><span class="s9">sapply()</span><span class="s5"> to be a matrix or array in certain cases, better organizing the elements of the result.<span class="Apple-converted-space">  </span>If the </span><span class="s9">simplify</span><span class="s5"> parameter is </span><span class="s9">"vector"</span><span class="s5">, the concatenated result value is returned as a plain vector in all cases; this is the default behavior, for backward compatibility.<span class="Apple-converted-space">  </span>Two other possible values for </span><span class="s9">simplify</span><span class="s5"> are presently supported.<span class="Apple-converted-space">  </span>If </span><span class="s9">simplify</span><span class="s5"> is </span><span class="s9">"matrix"</span><span class="s5">, the concatenated result value will be turned into a matrix with one column for each non-</span><span class="s9">NULL</span><span class="s5"> value returned by the lambda, as if the values were joined together with </span><span class="s9">cbind()</span><span class="s5">, as long as all of the lambda’s return values are either (a) </span><span class="s9">NULL</span><span class="s5"> or (b) the same length as the other non-</span><span class="s9">NULL</span><span class="s5"> values returned.<span class="Apple-converted-space">  </span>If </span><span class="s9">simplify</span><span class="s5"> is </span><span class="s9">"match"</span><span class="s5">, the concatenated result value will be turned into a vector, matrix, or array that exactly matches the dimensions as </span><span class="s9">x</span><span class="s5">, with a one-to-one correspondence between </span><span class="s9">x</span><span class="s5"> and the elements of the return value just like a unary operator, as long as all of the lambda’s return values are singletons (with no </span><span class="s9">NULL</span><span class="s5"> values).<span class="Apple-converted-space">  </span>Both </span><span class="s9">"matrix"</span><span class="s5"> and </span><span class="s9">"match"</span><span class="s5"> will raise an error if their preconditions are not met, to avoid unexpected behavior, so care should be taken that the preconditions are always met when these options are used.</span></p>
<p class="p5"><span class="s5">As with </span><span class="s9">executeLambda()</span><span class="s5">, all defined variables are accessible within the lambda, and changes made to variables inside the lambda will persist beyond the end of the </span><span class="s9">sapply()</span><span class="s5"> call; the lambda is executing in the same scope as the rest of your code.</span></p>
<p class="p5"><span class="s5">The </span><span class="s9">sapply()</span><span class="s5"> function can seem daunting at first, but it is an essential tool in the Eidos toolbox.<span class="Apple-converted-space">  </span>It combines the iteration of a </span><span class="s9">for</span><span class="s5"> loop, the ability to select elements like operator </span><span class="s9">[]</span><span class="s5">, and the ability to assemble results of mixed type together into a single vector like </span><span class="s9">c()</span><span class="s5">, all with the power of arbitrary Eidos code execution like </span><span class="s9">executeLambda()</span><span class="s5">.<span class="Apple-converted-space">  </span>It is relatively fast, compared to other ways of achieving similar results such as a </span><span class="s9">for</span><span class="s5"> loop that accumulates results with </span><span class="s9">c()</span><span class="s5">.<span class="Apple-converted-space">  </span>Like </span><span class="s9">executeLambda()</span><span class="s5">, </span><span class="s9">sapply()</span><span class="s5"> is most efficient if it is called multiple times with a single </span><span class="s9">string</span><span class="s5"> script variable, rather than with a newly constructed </span><span class="s9">string</span><span class="s5"> for </span><span class="s9">lambdaSource</span><span class="s5"> each time.</span></p>
<p class="p5"><span class="s5">Prior to Eidos 1.6 (SLiM 2.6), </span><span class="s9">sapply()</span><span class="s5"> was instead named </span><span class="s9">apply()</span><span class="s5">; it was renamed to </span><span class="s9">sapply()</span><span class="s5"> in order to more closely match the naming of functions in R.<span class="Apple-converted-space">  </span>This renaming allowed a new </span><span class="s9">apply()</span><span class="s5"> function to be added to Eidos that operates on the margins of matrices and arrays, similar to the </span><span class="s9">apply()</span><span class="s5"> function of R (see </span><span class="s9">apply()</span><span class="s5">, above).</span></p>
<p class="p2">(void)setSeed(integer$ seed)</p>
<p class="p3"><b>Set the random number seed</b>.<span class="Apple-converted-space">  </span>Future random numbers will be based upon the seed value set, and the random number sequence generated from a particular seed value is guaranteed to be reproducible.<span class="Apple-converted-space">  </span>The last seed set can be recovered with the <span class="s2">getSeed()</span> function.</p>
<p class="p2">(void)source(string$<span class="s1"> </span>filePath<span class="s6">, [logical$ chdir = F]</span>)</p>
<p class="p5"><b>Executes the contents of an Eidos source file</b> found at the filesystem path <span class="s2">filePath</span>.<span class="Apple-converted-space">  </span>This is essentially shorthand for calling <span class="s2">readFile()</span>, joining the read lines with newlines to form a single string using <span class="s2">paste()</span>, and then passing that string to <span class="s2">executeLambda()</span>.<span class="Apple-converted-space">  </span>The source file must consist of complete Eidos statements.<span class="Apple-converted-space">  </span>Regardless of what the last executed source line evaluates to, <span class="s2">source()</span> has no return value.<span class="Apple-converted-space">  </span>If no file exists at <span class="s2">filePath</span>, an error will be raised.</p>
<p class="p5">The <span class="s2">chdir</span> parameter controls the current working directory in effect while the source file is executed.<span class="Apple-converted-space">  </span>If <span class="s2">chdir</span> is <span class="s2">F</span> (the default), the current working directory will remain unchanged.<span class="Apple-converted-space">  </span>If <span class="s2">chdir</span> is <span class="s2">T</span>, the current working directory will be temporarily changed to the filesystem path at which the source file is located, and restored after execution of the source file is complete.</p>
<p class="p2">(void)stop([Ns$<span class="s1"> </span>message<span class="s1"> </span>= NULL])</p>
<p class="p3"><b>Stops execution</b> of Eidos (and of the Context, such as the running SLiM simulation, if applicable), in the event of an error.<span class="Apple-converted-space">  </span>If the optional <span class="s2">message</span> parameter is not <span class="s2">NULL</span>, it will be printed to Eidos’s output stream prior to stopping.</p>
<p class="p4"><span class="s5">(logical$)suppressWarnings(logical$ suppress)</span></p>
<p class="p5"><span class="s5"><b>Turns suppression of warning messages on or off</b>.<span class="Apple-converted-space">  </span>The </span><span class="s9">suppress</span><span class="s5"> flag indicates whether suppression of warnings should be enabled (</span><span class="s9">T</span><span class="s5">) or disabled (</span><span class="s9">F</span><span class="s5">).<span class="Apple-converted-space">  </span>The previous warning-suppression value is returned by </span><span class="s9">suppressWarnings()</span><span class="s5">, making it easy to suppress warnings from a given call and then return to the previous suppression state afterwards.<span class="Apple-converted-space">  </span>It is recommended that warnings be suppressed only around short blocks of code (not all the time), so that unexpected but perhaps important warnings are not missed.<span class="Apple-converted-space">  </span>And of course warnings are generally emitted for good reasons; before deciding to disregard a given warning, make sure that you understand exactly why it is being issued, and are certain that it does not represent a serious problem.</span></p>
<p class="p4">(*)sysinfo(string$ key)</p>
<p class="p5"><b>Returns information about the system</b>.<span class="Apple-converted-space">  </span>The information returned by <span class="s2">tempdir()</span> depends upon the value of <span class="s2">key</span>, which selects one of the pieces of information listed:</p>
<p class="p13"><span class="s22"><b>key</b></span><span class="Apple-tab-span">	</span><span class="s22"><b>value</b></span></p>
<p class="p13"><span class="s2">os</span><span class="Apple-tab-span">	</span>the name of the OS; <span class="s2">"macOS"</span> or <span class="s2">"Windows"</span>, or <span class="s2">"Unix"</span> for all others</p>
<p class="p13"><span class="s2">sysname</span><span class="Apple-tab-span">	</span>the name of the kernel</p>
<p class="p13"><span class="s2">release</span><span class="Apple-tab-span">	</span>the operating system (kernel) release</p>
<p class="p13"><span class="s2">version</span><span class="Apple-tab-span">	</span>the operating system (kernel) version</p>
<p class="p13"><span class="s2">nodename</span><span class="Apple-tab-span">	</span>the name by which the machine is known on the network</p>
<p class="p13"><span class="s2">machine</span><span class="Apple-tab-span">	</span>the hardware type; often the CPU type (e.g., <span class="s2">"x86_64"</span>)</p>
<p class="p5">The value <span class="s2">"unknown"</span> will be returned for a key if the correct value cannot be ascertained.<span class="Apple-converted-space">  </span>Note that the values of keys that refer to the kernel may not be what you expect; for example, on one particular macOS 10.15.7 system, <span class="s2">sysname</span> returns <span class="s2">"Darwin"</span>, <span class="s2">release</span> returns <span class="s2">"19.6.0"</span>, and <span class="s2">version</span> returns <span class="s2">"Darwin Kernel Version 19.6.0: Thu Sep 16 20:58:47 PDT 2021; root:xnu-6153.141.40.1~1/RELEASE_X86_64"</span>.</p>
<p class="p5">Further keys can be added if there is information that would be useful, particularly if a cross-platform way to obtain the information can be found.</p>
<p class="p2">(string)system(string$ command, [string args = ""], [string input = ""], [logical$ stderr = F], [logical$ wait = T])</p>
<p class="p3"><b>Runs a Un*x command in a </b><span class="s2"><b>/bin/sh</b></span><b> shell</b> with optional arguments and input, and returns the result as a vector of output lines.<span class="Apple-converted-space">  </span>The <span class="s2">args</span> parameter may contain a vector of arguments to <span class="s2">command</span>; they will be passed directly to the shell without any quoting, so applying the appropriate quoting as needed by <span class="s2">/bin/sh</span> is the caller’s responsibility.<span class="Apple-converted-space">  </span>The arguments are appended to <span class="s2">command</span>, separated by spaces, and the result is passed to the shell as a single command string, so arguments may simply be given as part of <span class="s2">command</span> instead, if preferred.<span class="Apple-converted-space">  </span>By default no input is supplied to <span class="s2">command</span>; if <span class="s2">input</span> is non-empty, however, it will be written to a temporary file (one line per <span class="s2">string</span> element) and the standard input of <span class="s2">command</span> will be redirected to that temporary file (using standard <span class="s2">/bin/sh</span> redirection with <span class="s2">&lt;</span>, appended to the command string passed to the shell).<span class="Apple-converted-space">  </span>By default, output sent to standard error will not be captured (and thus may end up in the output of the SLiM process, or may be lost); if <span class="s2">stderr</span> is <span class="s2">T</span>, however, the standard error stream will be redirected into standard out (using standard <span class="s2">/bin/sh</span> redirection with <span class="s2">2&gt;&amp;1</span>, appended to the command string passed to the shell).</p>
<p class="p3">Arbitrary command strings involving multiple commands, pipes, redirection, etc., may be used with <span class="s2">system()</span>, but may be incompatible with the way that <span class="s2">args</span><span class="s3">,</span> <span class="s2">input</span>, and <span class="s2">stderr</span> are handled by this function, so in this case supplying the whole command string in <span class="s2">command</span> may be the simplest course.<span class="Apple-converted-space">  </span>You may redirect standard error into standard output yourself in <span class="s2">command</span> with <span class="s2">2&gt;&amp;1</span><span class="s3">.</span><span class="Apple-converted-space">  </span>Supplying input to a complex command line can often be facilitated by the use of parentheses to create a subshell; for example,</p>
<p class="p14">system("(wc -l | sed 's/ //g')", input=c('foo', 'bar', 'baz'));</p>
<p class="p3">will supply the input lines to <span class="s2">wc</span> courtesy of the subshell started for the <span class="s2">()</span> operator.<span class="Apple-converted-space">  </span>If this strategy doesn’t work for the command line you want to execute, you can always write a temporary file yourself using <span class="s2">writeFile()</span> or <span class="s2">writeTempFile()</span> and redirect that file to standard input in <span class="s2">command</span> with <span class="s2">&lt;</span><span class="s3">.</span></p>
<p class="p5"><span class="s5">If </span><span class="s9">wait</span><span class="s5"> is </span><span class="s9">T</span><span class="s5"> (the default), </span><span class="s9">system()</span><span class="s5"> will wait for the command to finish, and return the output generated as a </span><span class="s9">string</span><span class="s5"> vector, as described above.<span class="Apple-converted-space">  </span>If </span><span class="s9">wait</span><span class="s5"> is </span><span class="s9">F</span><span class="s5">, </span><span class="s9">system()</span><span class="s5"> will instead append </span><span class="s9">" &amp;"</span><span class="s5"> to the end of the command line to request that it be run in the background, and it will not collect and return the output from the command; instead it will return </span><span class="s9">string(0)</span><span class="s5"> immediately.<span class="Apple-converted-space">  </span>If the output from the command is needed, it could be redirected to a file, and that file could be checked periodically in Eidos for some indication that the command had completed; if output is not redirected to a file, it may appear in SLiM’s output stream.<span class="Apple-converted-space">  </span>If the final command line executed by </span><span class="s9">system()</span><span class="s5"> ends in </span><span class="s9">" &amp;"</span><span class="s5">, the behavior of </span><span class="s9">system()</span><span class="s5"> should be just as if </span><span class="s9">wait=T</span><span class="s5"> had been supplied, but it is recommended to use </span><span class="s9">wait=T</span><span class="s5"> instead to ensure that the command line is correctly assembled.</span></p>
<p class="p5">There is an example at <a href="https://github.com/MesserLab/SLiM-Extras/blob/master/functions/rgnorm.slim"><span class="s20">https://github.com/MesserLab/SLiM-Extras/blob/master/functions/rgnorm.slim</span></a> that demonstrates the use of <span class="s2">system()</span>, calling out to Python, to obtain draws from a generalized normal distribution (which is not supported intrinsically by Eidos).<span class="Apple-converted-space">  </span>That example even includes internal buffering of a large number of draws, making it a reasonably efficient solution.</p>
<p class="p2">(string$)time(void)</p>
<p class="p3">Returns a <b>standard time string</b> for the current time in the local time of the executing machine.<span class="Apple-converted-space">  </span>The format is <span class="s2">%H:%M:%S</span> (hour in two digits, then minute in two digits, then seconds in two digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.<span class="Apple-converted-space">  </span>The 24-hour clock time is used (i.e., no AM/PM).</p>
<p class="p4"><span class="s5">(float$)usage(</span>[ls$ type = "rss"]<span class="s5">)</span></p>
<p class="p5">Returns the <b>memory usage</b>.<span class="Apple-converted-space">  </span>This is the amount of memory used by the current process, in MB (megabytes); multiply by <span class="s2">1024*1024</span> to get the usage in bytes.</p>
<p class="p5">Memory usage is a surprisingly complex topic.<span class="Apple-converted-space">  </span>One metric reported by <span class="s2">usage()</span> is the resident set size, or RSS, which includes memory usage from shared libraries, but does not include memory that is swapped out or has never been used.<span class="Apple-converted-space">  </span>For most purposes, RSS is a useful metric of memory usage from a practical perspective.<span class="Apple-converted-space">  </span>On some platforms (AIX, BSD, Solaris) the memory usage reported may be zero, but it should be correct on both macOS and Linux platforms.<span class="Apple-converted-space">  </span>On macOS, memory pages that have not been used for a while may get compressed by the kernel to reduce the RSS of the process; the RSS metric reported by <span class="s2">usage()</span> will reflect the compressed size of such pages, not their original size, so surprising decreases in memory usage may be observed when the kernel decides to compress some memory pages.<span class="Apple-converted-space">  </span>The RSS is requested with a <span class="s2">type</span> of <span class="s2">"rss"</span>, which is the default; for historical reasons, it can also be requested with a <span class="s2">type</span> of <span class="s2">F</span>.</p>
<p class="p5">Another metric reported by <span class="s2">usage()</span> is the peak RSS.<span class="Apple-converted-space">  </span>This is just the highest RSS value that has ever been recorded by the kernel.<span class="Apple-converted-space">  </span>It should generally mirror the behavior of RSS, except that it ratchets upward monotonically.<span class="Apple-converted-space">  </span>The peak RSS is requested with a <span class="s2">type</span> of <span class="s2">"rss_peak"</span>; for historical reasons, it can also be requested with a <span class="s2">type</span> of <span class="s2">T</span>.</p>
<p class="p5">The third metric currently reported by <span class="s2">usage()</span> is the virtual memory usage.<span class="Apple-converted-space">  </span>This is essentially the amount of memory used by pages that have been assigned to the process, whether those pages are resident, compressed, or swapped.<span class="Apple-converted-space">  </span>It is typically much larger than the RSS, because it includes various types of memory that are not counted in the RSS; indeed, for some system configurations the virtual memory usage can be reported as being the entire memory space of the computer.<span class="Apple-converted-space">  </span>Whether it is a useful metric will be platform-dependent; <i>caveat emptor</i>.</p>
<p class="p5">This function can be useful for documenting the memory usage of long runs as they are in progress.<span class="Apple-converted-space">  </span>In SLiM, the RSS could also be used to trigger tree-sequence simplification with a call to <span class="s2">treeSeqSimplify()</span>, to reduce memory usage when it becomes too large, but keep in mind that the simplification process itself may cause a substantial spike in memory usage, and that page compression and swaps may reduce the RSS even though the memory actually used by tree-sequence recording continues to increase.</p>
<p class="p5">When running under SLiM, other tools for monitoring memory usage include the <span class="s2">slim</span> command-line options <span class="s2">-m[em]</span> and <span class="s2">-M[emhist]</span>, and the <span class="s2">usage()</span> and <span class="s2">outputUsage()</span> methods of <span class="s2">Community</span>; see the SLiM manual for more information.</p>
<p class="p4"><span class="s6">(float)version(</span><span class="s5">[logical$ print = T]</span><span class="s6">)</span></p>
<p class="p5"><span class="s5"><b>Get Eidos’s version.</b><span class="Apple-converted-space">  </span>There are two ways to use this function.<span class="Apple-converted-space">  </span>If </span><span class="s9">print</span><span class="s5"> is </span><span class="s9">T</span><span class="s5">, the default, then the version number is printed to the Eidos output stream in a formatted manner, like “</span><span class="s9">Eidos version 2.1</span><span class="s5">”.<span class="Apple-converted-space">  </span>If Eidos is attached to a Context that provides a version number, that is also printed, like “</span><span class="s9">SLiM version 3.1</span><span class="s5">”.<span class="Apple-converted-space">  </span>In this case, the Eidos version number, and the Context version number if available, are returned as an invisible </span><span class="s9">float</span><span class="s5"> vector.<span class="Apple-converted-space">  </span>This is most useful when using Eidos interactively.<span class="Apple-converted-space">  </span>If </span><span class="s9">print</span><span class="s5"> is </span><span class="s9">F</span><span class="s5">, on the other hand, nothing is printed, but the returned </span><span class="s9">float</span><span class="s5"> vector of version numbers is not invisible.<span class="Apple-converted-space">  </span>This is useful for scripts that need to test the Eidos or Context version they are running against.</span></p>
<p class="p5"><span class="s5">In both cases, in the </span><span class="s9">float</span><span class="s5"> version numbers returned, a version like 2.4.2 would be returned as </span><span class="s9">2.42</span><span class="s5">; this would not scale well to subversions greater than nine, so that will be avoided in our versioning.</span></p>
</body>
</html>
