<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2299.5">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo}
    p.p3 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p4 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p5 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Menlo; color: #000000}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Menlo}
    p.p8 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #969696}
    p.p9 {margin: 0.0px 0.0px 3.0px 54.0px; font: 10.0px Optima; color: #000000}
    p.p10 {margin: 3.0px 0.0px 3.0px 27.4px; font: 11.0px Optima; color: #000000}
    span.s1 {font-kerning: none}
    span.s2 {font: 9.0px Menlo; font-kerning: none}
    span.s3 {font: 9.0px Menlo}
    span.s4 {font-kerning: none; color: #000000}
    span.s5 {font: 10.0px Optima; font-kerning: none}
    span.s6 {font: 10.0px 'Times New Roman'}
    span.s7 {color: #000000}
    span.s8 {font: 9.0px Menlo; color: #000000}
    span.s9 {font: 7.0px 'Apple Color Emoji'}
    span.s10 {font: 6.7px Optima; font-kerning: none}
    span.s11 {font: 6.7px Optima}
    span.s12 {font: 7.3px Optima}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><b>3.1.<span class="Apple-converted-space">  </span>Initialization functions</b></p>
<p class="p2">(integer$)initializeAncestralNucleotides(is sequence)</p>
<p class="p3"><span class="s1">This function, which may be called only in nucleotide-based models, supplies an ancestral nucleotide sequence for the model.<span class="Apple-converted-space">  </span>The </span><span class="s2">sequence</span><span class="s1"> parameter may be an </span><span class="s2">integer</span><span class="s1"> vector providing nucleotide values (A=0, C=1, G=2, T=3), or a </span><span class="s2">string</span><span class="s1"> vector providing single-character nucleotides (</span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"C"</span><span class="s1">, </span><span class="s2">"G"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">), or a singleton </span><span class="s2">string</span><span class="s1"> providing the sequence as one string (</span><span class="s2">"ACGT..."</span><span class="s1">), or a singleton </span><span class="s2">string</span><span class="s1"> providing the filesystem path of a FASTA file which will be read in to provide the sequence (if the file contains than one sequence, the first sequence will be used).<span class="Apple-converted-space">  </span>Only A/C/G/T nucleotide values may be provided; other symbols, such as those for amino acids, gaps, or nucleotides of uncertain identity, are not allowed.<span class="Apple-converted-space">  </span>The two semantic meanings of </span><span class="s2">sequence</span><span class="s1"> that involve a singleton </span><span class="s2">string</span><span class="s1"> value are distinguished heuristically; a singleton </span><span class="s2">string</span><span class="s1"> that contains only the letters ACGT will be assumed to be a nucleotide sequence rather than a filename.<span class="Apple-converted-space">  </span>The length of the ancestral sequence is returned.</span></p>
<p class="p3"><span class="s1">A utility function, </span><span class="s2">randomNucleotides()</span><span class="s1">, is provided by SLiM to assist in generating simple random nucleotide sequences.</span></p>
<p class="p4"><span class="s1">(void)initializeGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0], [logical$ redrawLengthsOnFailure = F])</span></p>
<p class="p3"><span class="s1">Calling this function switches the recombination model from a “simple crossover” model to a “double-stranded break (DSB)” model, and configures the details of the gene conversion tracts that will therefore be modeled.<span class="Apple-converted-space">  </span>The fraction of DSBs that will be modeled as non-crossover events is given by </span><span class="s2">nonCrossoverFraction</span><span class="s1">.<span class="Apple-converted-space">  </span>The mean length of gene conversion tracts (whether associated with crossover or non-crossover events) is given by </span><span class="s2">meanLength</span><span class="s1">; the actual extent of a gene conversion tract will be the sum of two independent draws from a geometric distribution with mean </span><span class="s2">meanLength/2</span><span class="s1">.<span class="Apple-converted-space">  </span>The fraction of gene conversion tracts that are modeled as “simple” is given by </span><span class="s2">simpleConversionFraction</span><span class="s1">; the remainder will be modeled as “complex”, involving repair of heteroduplex mismatches.<span class="Apple-converted-space">  </span>Finally, the </span><span class="s2">GC</span><span class="s1"> bias during heteroduplex mismatch repair is given by </span><span class="s2">bias</span><span class="s1">, with the default of </span><span class="s2">0.0</span><span class="s1"> indicating no bias, </span><span class="s2">1.0</span><span class="s1"> indicating an absolute preference for </span><span class="s2">G</span><span class="s1">/</span><span class="s2">C</span><span class="s1"> mutations over </span><span class="s2">A</span><span class="s1">/</span><span class="s2">T</span><span class="s1"> mutations, and </span><span class="s2">-1.0</span><span class="s1"> indicating an absolute preference for </span><span class="s2">A</span><span class="s1">/</span><span class="s2">T</span><span class="s1"> mutations over </span><span class="s2">G</span><span class="s1">/</span><span class="s2">C</span><span class="s1"> mutations.<span class="Apple-converted-space">  </span>A non-zero bias may only be set in nucleotide-based models.<span class="Apple-converted-space">  </span>This function, and the way that gene conversion is modeled, fundamentally changed in SLiM 3.3.</span></p>
<p class="p3">Beginning in SLiM 4.1, the <span class="s3">redrawLengthsOnFailure</span> parameter can be used to modify the internal mechanics of layout of gene conversion tracts.<span class="Apple-converted-space">  </span>If it is <span class="s3">F</span> (the default, and the only behavior supported before SLiM 4.1), then if an attempt to lay out gene conversion tracts fails (because the tracts overlap each other, or overlap the start or end of the chromosome), SLiM will try again by drawing new positions for the tracts – essentially shuffling the tracts around to try to find positions for them that don’t overlap.<span class="Apple-converted-space">  </span>If <span class="s3">redrawLengthsOnFailure</span> is <span class="s3">T</span>, then if an attempt to lay out gene conversion tracts fails, SLiM will try again by drawing new lengths for the tracts, as well as new positions.<span class="Apple-converted-space">  </span>This makes it more likely that layout will succeed, but risks biasing the realized mean tract length downward from the requested mean length (since layout of long tracts is more likely fail due to overlap).<span class="Apple-converted-space">  </span>In either case, if SLiM attempts to lay out gene conversion tracts 100 times without success, an error will result.<span class="Apple-converted-space">  </span>That error indicates that the specified constraints for gene conversion are difficult to satisfy – tracts may commonly be so long that it is difficult or impossible to find an acceptable layout for them within the specified chromosome length.<span class="Apple-converted-space">  </span>Setting <span class="s3">redrawLengthsOnFailure</span> to <span class="s3">T</span> may mitigate this problem, at the price of biasing the mean tract length downward as discussed.</p>
<p class="p2">(object&lt;GenomicElement&gt;)initializeGenomicElement(io&lt;GenomicElementType&gt; genomicElementType, integer start, integer end)</p>
<p class="p3"><span class="s1">Add a genomic element to the chromosome at initialization time.<span class="Apple-converted-space">  </span>The </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1"> parameters give the first and last base positions to be spanned by the new genomic element.<span class="Apple-converted-space">  </span>The new element will be based upon the genomic element type identified by </span><span class="s2">genomicElementType</span><span class="s1">, which can be either an </span><span class="s2">integer</span><span class="s1">, representing the ID of the desired element type, or an </span><span class="s2">object</span><span class="s1"> of type </span><span class="s2">GenomicElementType</span><span class="s1"> specified directly.</span></p>
<p class="p3"><span class="s1">Beginning in SLiM 3.3, this function is vectorized: the </span><span class="s2">genomicElementType</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, and </span><span class="s2">end</span><span class="s1"> parameters do not have to be singletons.<span class="Apple-converted-space">  </span>In particular, </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1"> may be of any length, but must be equal in length; each </span><span class="s2">start</span><span class="s1">/</span><span class="s2">end</span><span class="s1"> element pair will generate one new genomic element spanning the given base positions.<span class="Apple-converted-space">  </span>In this case, </span><span class="s2">genomicElementType</span><span class="s1"> may still be a singleton, providing the genomic element type to be used for all of the new genomic elements, or it may be equal in length to </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1">, providing an independent genomic element type for each new element.<span class="Apple-converted-space">  </span>When adding a large number of genomic elements, it will be much faster to add them in order of ascending position with a vectorized call.</span></p>
<p class="p3"><span class="s1">The return value provides the genomic element(s) created by the call, in the order in which they were specified in the parameters to </span><span class="s2">initializeGenomicElement()</span><span class="s1">.</span></p>
<p class="p2">(object&lt;GenomicElementType&gt;$)initializeGenomicElementType(is$ id, io&lt;MutationType&gt; mutationTypes, numeric proportions<span class="s4">, [Nf mutationMatrix = NULL]</span>)</p>
<p class="p5">Add a genomic element type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> must not already be used for any genomic element type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s3">mutationTypes</span> vector identifies the mutation types used by the genomic element, and the <span class="s3">proportions</span> vector should be of equal length, specifying the relative proportion of mutations that will be drawn from the corresponding mutation type (proportions do not need to add up to one; they are interpreted relatively).<span class="Apple-converted-space">  </span>The <span class="s3">id</span> parameter may be either an <span class="s3">integer</span> giving the ID of the new genomic element type, or a <span class="s3">string</span> giving the name of the new genomic element type (such as <span class="s3">"g5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>The <span class="s3">mutationTypes</span> parameter may be either an <span class="s3">integer</span> vector representing the IDs of the desired mutation types, or an <span class="s3">object</span> vector of <span class="s3">MutationType</span> elements specified directly.<span class="Apple-converted-space">  </span>The global symbol for the new genomic element type is immediately available; the return value also provides the new object.</p>
<p class="p3"><span class="s1">The </span><span class="s2">mutationMatrix</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> by default, and in non-nucleotide-based models it must be </span><span class="s2">NULL</span><span class="s1">.<span class="Apple-converted-space">  </span>In nucleotide-based models, on the other hand, it must be non-</span><span class="s2">NULL</span><span class="s1">, and therefore must be supplied.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">mutationMatrix</span><span class="s1"> should take one of two standard forms.<span class="Apple-converted-space">  </span>For sequence-based mutation rates that depend upon only the single nucleotide at a mutation site, </span><span class="s2">mutationMatrix</span><span class="s1"> should be a 4×4 </span><span class="s2">float</span><span class="s1"> matrix, specifying mutation rates for an existing nucleotide state (rows from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">3</span><span class="s1"> representing A/C/G/T) to each of the four possible derived nucleotide states (columns, with the same meaning).<span class="Apple-converted-space">  </span>The mutation rates in this matrix are absolute rates, per nucleotide per gamete; they will be used by SLiM directly unless they are multiplied by a factor from the hotspot map (see </span><span class="s2">initializeHotspotMap()</span><span class="s1">).<span class="Apple-converted-space">  </span>Rates in </span><span class="s2">mutationMatrix</span><span class="s1"> that involve the mutation of a nucleotide to itself (</span><span class="s2">A</span><span class="s1"> to </span><span class="s2">A</span><span class="s1">, </span><span class="s2">C</span><span class="s1"> to </span><span class="s2">C</span><span class="s1">, etc.) are not used by SLiM and must be </span><span class="s2">0.0</span><span class="s1"> by convention.</span></p>
<p class="p3"><span class="s1">It is important to note that the order of the rows and columns used in SLiM, A/C/G/T, is not a universal convention; other sources will present substitution-rate/transition-rate matrices using different conventions, and so care must be taken when importing such matrices into SLiM.</span></p>
<p class="p3"><span class="s1">For sequence-based mutation rates that depend upon the trinucleotide sequence centered upon a mutation site (the adjacent bases to the left and right, in other words, as well as the mutating nucleotide itself), </span><span class="s2">mutationMatrix</span><span class="s1"> should be a 64×4 </span><span class="s2">float</span><span class="s1"> matrix, specifying mutation rates for the central nucleotide of an existing trinucleotide sequence (rows from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">63</span><span class="s1">, representing codons as described in the documentation for the </span><span class="s2">ancestralNucleotides()</span><span class="s1"> method of </span><span class="s2">Chromosome</span><span class="s1">) to each of the four possible derived nucleotide states (columns from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">3</span><span class="s1"> for A/C/G/T as before).<span class="Apple-converted-space">  </span>Note that in every case it is the central nucleotide of the trinucleotide sequence that is mutating, but rates can be specified independently based upon the nucleotides in the first and third positions as well, with this type of mutation matrix.</span></p>
<p class="p3"><span class="s1">Several helper functions are defined to construct common types of mutation matrices, such as </span><span class="s2">mmJukesCantor()</span><span class="s1"> to create a mutation matrix for a Jukes–Cantor model.</span></p>
<p class="p4"><span class="s1">(void)initializeHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = "*"])</span></p>
<p class="p3"><span class="s1">In nucleotide-based models, set the mutation rate <i>multiplier</i> along the chromosome.<span class="Apple-converted-space">  </span>Nucleotide-based models define sequence-based mutation rates that are set up with the </span><span class="s2">mutationMatrix</span><span class="s1"> parameter to </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>If no hotspot map is specified by calling </span><span class="s2">initializeHotspotMap()</span><span class="s1">, a hotspot map with a multiplier of </span><span class="s2">1.0</span><span class="s1"> across the whole chromosome is assumed (and so the sequence-based rates are the absolute mutation rates used by SLiM).<span class="Apple-converted-space">  </span>A hotspot map modifies the sequence-based rates by scaling them up in some regions, with multipliers greater than </span><span class="s2">1.0</span><span class="s1"> (representing mutational hot spots), and/or scaling them down in some regions, with multipliers less than </span><span class="s2">1.0</span><span class="s1"> (representing mutational cold spots).</span></p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">multipliers</span><span class="s1"> must be a singleton value that specifies a single multiplier to be used along the entire chromosome (typically </span><span class="s2">1.0</span><span class="s1">, but not required to be).<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">multipliers</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">multipliers</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p6"><span class="s5"><span class="Apple-tab-span">	</span></span><span class="s1">initializeHotspotMap(c(1.0, 1.2), c(5000, 9999));</span></p>
<p class="p3"><span class="s1">then the result is that the mutation rate multiplier for bases </span><span class="s2">0</span><span class="s1">...</span><span class="s2">5000</span><span class="s1"> (inclusive) will be </span><span class="s2">1.0</span><span class="s1"> (and so the specified sequence-based mutation rates will be used verbatim), and the multiplier for bases </span><span class="s2">5001</span><span class="s1">...</span><span class="s2">9999</span><span class="s1"> (inclusive) will be </span><span class="s2">1.2</span><span class="s1"> (and so the sequence-based mutation rates will be multiplied by 1.2 within the region).</span></p>
<p class="p3"><span class="s1">Note that mutations are generated by SLiM only within genomic elements, regardless of the hotspot map.<span class="Apple-converted-space">  </span>In effect, the hotspot map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a multiplier of zero.<span class="Apple-converted-space">  </span>There is no harm in supplying a hotspot map that specifies multipliers for areas outside of the genomic elements defined; the excess information is simply not used.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied hotspot map is used only for that sex (i.e., when generating a gamete from a parent of that sex).<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeHotspotMap()</span><span class="s1">, one for each sex, even if a multiplier of </span><span class="s2">1.0</span><span class="s1"> is desired for the other sex; no default hotspot map is supplied.</span></p>
<p class="p2">(object&lt;InteractionType&gt;$)initializeInteractionType(is$ id, string$ spatiality, [logical$ reciprocal = F], [numeric$ maxDistance = INF], [string$ sexSegregation = "**"])</p>
<p class="p3">Add an interaction type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> must not already be used for any interaction type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> parameter may be either an <span class="s3">integer</span> giving the ID of the new interaction type, or a <span class="s3">string</span> giving the name of the new interaction type (such as <span class="s3">"i5"</span> to specify an ID of 5).</p>
<p class="p3">The <span class="s3">spatiality</span> may be <span class="s3">""</span>, for non-spatial interactions (i.e., interactions that do not depend upon the distance between individuals); <span class="s3">"x"</span>, <span class="s3">"y"</span>, or <span class="s3">"z"</span> for one-dimensional interactions; <span class="s3">"xy"</span>, <span class="s3">"xz"</span>, or <span class="s3">"yz"</span> for two-dimensional interactions; or <span class="s3">"xyz"</span> for three-dimensional interactions.<span class="Apple-converted-space">  </span>The dimensions referenced by spatiality must be defined as spatial dimensions with <span class="s3">initializeSLiMOptions()</span>; if the simulation has dimensionality <span class="s3">"xy"</span>, for example, then interactions in the simulation may have spatiality <span class="s3">""</span>, <span class="s3">"x"</span>, <span class="s3">"y"</span>, or <span class="s3">"xy"</span>, but may not reference spatial dimension <i>z</i> and thus may not have spatiality <span class="s3">"xz"</span>, <span class="s3">"yz"</span>, or <span class="s3">"xyz"</span>.<span class="Apple-converted-space">  </span>If no spatial dimensions have been configured, only non-spatial interactions may be defined.</p>
<p class="p3">The <span class="s3">reciprocal</span> flag may be <span class="s3">T</span>, in which case the interaction is guaranteed by the user to be <i>reciprocal</i>: whatever the interaction strength is for exerter B upon receiver A, it will be equal (in magnitude and sign) for exerter A upon receiver B.<span class="Apple-converted-space">  </span>In principle, this allows the <span class="s3">InteractionType</span> to reduce the amount of computation necessary by up to a factor of two (although it may or may not be used).<span class="Apple-converted-space">  </span>If <span class="s3">reciprocal</span> is <span class="s3">F</span>, the interaction is not guaranteed to be reciprocal and each interaction will be computed independently.<span class="Apple-converted-space">  </span>The built-in interaction formulas are all reciprocal, but if you implement an <span class="s3">interaction()</span> callback, you must consider whether the callback you have implemented preserves reciprocality or not.<span class="Apple-converted-space">  </span>For this reason, the default is <span class="s3">reciprocal=F</span>, so that bugs are not inadvertently introduced by an invalid assumption of reciprocality.<span class="Apple-converted-space">  </span>See below for a note regarding reciprocality in sexual simulations when using the <span class="s3">sexSegregation</span> flag.</p>
<p class="p3">The <span class="s3">maxDistance</span> parameter supplies the maximum distance over which interactions of this type will be evaluated; at greater distances, the interaction strength is considered to be zero (for efficiency).<span class="Apple-converted-space">  </span>The default value of <span class="s3">maxDistance</span>, <span class="s3">INF</span> (positive infinity), indicates that there is no maximum interaction distance; note that this can make some interaction queries much less efficient, and is therefore not recommended.<span class="Apple-converted-space">  </span>In SLiM 3.1 and later, a warning will be issued if a spatial interaction type is defined with no maximum distance to encourage a maximum distance to be defined.</p>
<p class="p3">The <span class="s3">sexSegregation</span> parameter governs the applicability of the interaction to each sex, in sexual simulations.<span class="Apple-converted-space">  </span>It does not affect distance calculations in any way; it only modifies the way in which interaction strengths are calculated.<span class="Apple-converted-space">  </span>The default, <span class="s3">"**"</span>, implies that the interaction is felt by both sexes (the first character of the <span class="s3">string</span> value) and is exerted by both sexes (the second character of the <span class="s3">string</span> value).<span class="Apple-converted-space">  </span>Either or both characters may be <span class="s3">M</span> or <span class="s3">F</span> instead; for example, <span class="s3">"MM"</span> would indicate a male-male interaction, such as male-male competition, whereas <span class="s3">"FM"</span> would indicate an interaction influencing only female receivers that is influenced only by male exerters, such as male mating displays that influence female attraction.<span class="Apple-converted-space">  </span>This parameter may be set only to <span class="s3">"**"</span> unless sex has been enabled with <span class="s3">initializeSex()</span>.<span class="Apple-converted-space">  </span>Note that a value of <span class="s3">sexSegregation</span> other than <span class="s3">"**"</span> may imply some degree of non-reciprocality, but it is not necessary to specify <span class="s3">reciprocal</span> to be <span class="s3">F</span> for this reason; SLiM will take the sex-segregation of the interaction into account for you.<span class="Apple-converted-space">  </span>The value of <span class="s3">reciprocal</span> may therefore be interpreted as meaning: in those cases, if any, in which A interacts with B and B interacts with A, is the interaction strength guaranteed to be the same in both directions?<span class="Apple-converted-space">  </span>The <span class="s3">sexSegregation</span> parameter is shorthand for setting sex constraints on the interaction type using the <span class="s3">setConstraints()</span> method; see that method for a more extensive set of constraints that may be used.</p>
<p class="p3">By default, the interaction strength is <span class="s3">1.0</span> for all interactions within <span class="s3">maxDistance</span>.<span class="Apple-converted-space">  </span>Often it is desirable to change the interaction function using <span class="s3">setInteractionFunction()</span>; modifying interaction strengths can also be achieved with <span class="s3">interaction()</span> callbacks if necessary.<span class="Apple-converted-space">  </span>In any case, interactions beyond <span class="s3">maxDistance</span> always have a strength of <span class="s3">0.0</span>, and the interaction strength of an individual with itself is always <span class="s3">0.0</span>, regardless of the interaction function or callbacks.</p>
<p class="p3">The global symbol for the new interaction type is immediately available; the return value also provides the new object.<span class="Apple-converted-space">  </span>Note that in multispecies models, <span class="s3">initializeInteractionType()</span> must be called from a non-species-specific <span class="s3">interaction()</span> callback (declared as <span class="s3">species all initialize()</span>), since interactions are managed at the community level.</p>
<p class="p2">(void)initializeMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p3"><span class="s1">Set the mutation rate per base position per gamete.<span class="Apple-converted-space">  </span>To be precise, this mutation rate is the expected mean number of mutations that will occur per base position per gamete; note that this is different from how the recombination rate is defined (see </span><span class="s2">initializeRecombinationRate()</span><span class="s1">).<span class="Apple-converted-space">  </span>The number of mutations that actually occurs at a given base position when generating an offspring genome is, in effect, drawn from a Poisson distribution with that expected mean (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).<span class="Apple-converted-space">  </span>It is possible for this Poisson draw to indicate that two or more new mutations have arisen at the same base position, particularly when the mutation rate is very high; in this case, the new mutations will be added to the site one at a time, and as always the mutation stacking policy will be followed.</span></p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">rates</span><span class="s1"> must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p7"><span class="s6"><span class="Apple-tab-span">	</span></span>initializeMutationRate(c(1e-7, 2.5e-8), c(5000, 9999));</p>
<p class="p3"><span class="s1">then the result is that the mutation rate for bases </span><span class="s2">0</span><span class="s1">...</span><span class="s2">5000</span><span class="s1"> (inclusive) will be </span><span class="s2">1e-7</span><span class="s1">, and the rate for bases </span><span class="s2">5001</span><span class="s1">...</span><span class="s2">9999</span><span class="s1"> (inclusive) will be </span><span class="s2">2.5e-8</span><span class="s1">.</span></p>
<p class="p3"><span class="s1">Note that mutations are generated by SLiM only within genomic elements, regardless of the mutation rate map.<span class="Apple-converted-space">  </span>In effect, the mutation rate map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a mutation rate of zero.<span class="Apple-converted-space">  </span>There is no harm in supplying a mutation rate map that specifies rates for areas outside of the genomic elements defined; that rate information is simply not used.<span class="Apple-converted-space">  </span>The </span><span class="s2">overallMutationRate</span><span class="s1"> family of properties on </span><span class="s2">Chromosome</span><span class="s1"> provide the overall mutation rate after genomic element coverage has been taken into account, so it will reflect the rate at which new mutations will actually be generated in the simulation as configured.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied mutation rate map is used only for that sex (i.e., when generating a gamete from a parent of that sex).<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeMutationRate()</span><span class="s1">, one for each sex, even if a rate of zero is desired for the other sex; no default mutation rate map is supplied.</span></p>
<p class="p3"><span class="s1">In nucleotide-based models, </span><span class="s2">initializeMutationRate()</span><span class="s1"> may not be called.<span class="Apple-converted-space">  </span>Instead, the desired sequence-based mutation rate(s) should be expressed in the </span><span class="s2">mutationMatrix</span><span class="s1"> parameter to </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>If variation in the mutation rate along the chromosome is desired, </span><span class="s2">initializeHotspotMap()</span><span class="s1"> should be used.</span></p>
<p class="p2">(object&lt;MutationType&gt;$)initializeMutationType(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)</p>
<p class="p3">Add a mutation type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> must not already be used for any mutation type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> parameter may be either an <span class="s3">integer</span> giving the ID of the new mutation type, or a <span class="s3">string</span> giving the name of the new mutation type (such as <span class="s3">"m5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>The dominanceCoeff parameter supplies the dominance coefficient for the mutation type; <span class="s3">0.0</span> produces no dominance, <span class="s3">1.0</span> complete dominance, and values greater than <span class="s3">1.0</span>, overdominance.<span class="Apple-converted-space">  </span>The <span class="s3">distributionType</span> may be <span class="s3">"f"</span>, in which case the ellipsis <span class="s3">...</span> should supply a <span class="s3">numeric$</span> fixed selection coefficient; <span class="s3">"e"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient for an exponential distribution; <span class="s3">"g"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient and a <span class="s3">numeric$</span> alpha shape parameter for a gamma distribution; <span class="s3">"n"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient and a <span class="s3">numeric$</span> sigma (standard deviation) parameter for a normal distribution; <span class="s3">"p"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient and a <span class="s3">numeric$</span> scale parameter for a Laplace distribution; <span class="s3">"w"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> <span class="s6">λ</span> scale parameter and a <span class="s3">numeric$</span> k shape parameter for a Weibull distribution; or <span class="s3">"s"</span>, in which case the ellipsis should supply a <span class="s3">string$</span> Eidos script parameter.<span class="Apple-converted-space">  </span>The global symbol for the new mutation type is immediately available; the return value also provides the new object.</p>
<p class="p3"><span class="s1">Note that by default in WF models, all mutations of a given mutation type will be converted into </span><span class="s2">Substitution</span><span class="s1"> objects when they reach fixation, for efficiency reasons.<span class="Apple-converted-space">  </span>If you need to disable this conversion, to keep mutations of a given type active in the simulation even after they have fixed, you can do so by setting the </span><span class="s2">convertToSubstitution</span><span class="s1"> property of </span><span class="s2">MutationType</span><span class="s1"> to </span><span class="s2">F</span><span class="s1">.<span class="Apple-converted-space">  </span>In contrast, by default in nonWF models mutations will not be converted into </span><span class="s2">Substitution</span><span class="s1"> objects when they reach fixation; </span><span class="s2">convertToSubstitution</span><span class="s1"> is </span><span class="s2">F</span><span class="s1"> by default in nonWF models.<span class="Apple-converted-space">  </span>To enable conversion in nonWF models for neutral mutation types with no indirect fitness effects, you should therefore set </span><span class="s2">convertToSubstitution</span><span class="s1"> to </span><span class="s2">T</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(object&lt;MutationType&gt;$)initializeMutationTypeNuc(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)</span></p>
<p class="p3"><span class="s1">Add a nucleotide-based mutation type at initialization time.<span class="Apple-converted-space">  </span>This function is identical to </span><span class="s2">initializeMutationType()</span><span class="s1"> except that the new mutation type will be nucleotide-based – in other words, mutations belonging to the new mutation type will have an associated nucleotide.<span class="Apple-converted-space">  </span>This function may be called only in nucleotide-based models (as enabled by the </span><span class="s2">nucleotideBased</span><span class="s1"> parameter to </span><span class="s2">initializeSLiMOptions()</span><span class="s1">).</span></p>
<p class="p3"><span class="s1">Nucleotide-based mutations always use a </span><span class="s2">mutationStackGroup</span><span class="s1"> of </span><span class="s2">-1</span><span class="s1"> and a </span><span class="s2">mutationStackPolicy</span><span class="s1"> of </span><span class="s2">"l"</span><span class="s1">.<span class="Apple-converted-space">  </span>This ensures that a new nucleotide mutation always replaces any previously existing nucleotide mutation at a given position, regardless of the mutation types of the nucleotide mutations.<span class="Apple-converted-space">  </span>These values are set automatically by </span><span class="s2">initializeMutationTypeNuc()</span><span class="s1">, and may not be changed.</span></p>
<p class="p3"><span class="s1">See the documentation for </span><span class="s2">initializeMutationType()</span><span class="s1"> for all other discussion.</span></p>
<p class="p2">(void)initializeRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p3"><span class="s1">Set the recombination rate per base position per gamete.<span class="Apple-converted-space">  </span>To be precise, this recombination rate is the probability that a breakpoint will occur between one base and the next base; note that this is different from how the mutation rate is defined (see </span><span class="s2">initializeMutationRate()</span><span class="s1">).<span class="Apple-converted-space">  </span>All rates must be in the interval [</span><span class="s2">0.0</span><span class="s1">, </span><span class="s2">0.5</span><span class="s1">].<span class="Apple-converted-space">  </span>A rate of </span><span class="s2">0.5</span><span class="s1"> implies complete independence between the adjacent bases, which might be used to implement independent assortment of loci located on different chromosomes (see the example below).<span class="Apple-converted-space">  </span>Whether a breakpoint occurs between two bases is then, in effect, determined by a binomial draw with a single trial and the given rate as probability (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).<span class="Apple-converted-space">  </span>The recombinational process in SLiM will never generate more then one crossover between one base and the next (in one generation/genome), and a supplied rate of </span><span class="s2">0.5</span><span class="s1"> will therefore result in an actual probability of </span><span class="s2">0.5</span><span class="s1"> for a crossover at the relevant position.<span class="Apple-converted-space">  </span>(Note that this was not true in SLiM 2.x and earlier, however; their implementation of recombination resulted in a crossover probability of about 39.3% for a rate of </span><span class="s2">0.5</span><span class="s1">, due to the use of an inaccurate approximation method.<span class="Apple-converted-space">  </span>Recombination rates lower than about </span><span class="s2">0.01</span><span class="s1"> would have been essentially exact, since the approximation error became large only as the rate approached </span><span class="s2">0.5</span><span class="s1">.)</span></p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">rates</span><span class="s1"> must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).<span class="Apple-converted-space">  </span>Note that a recombination rate of 1 centimorgan/Mbp corresponds to a recombination rate of </span><span class="s2">1e-8</span><span class="s1"> in the units used by SLiM.</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p7"><span class="s6"><span class="Apple-tab-span">	</span></span>initializeRecombinationRate(c(0, 0.5, 0), c(5000, 5001, 9999));</p>
<p class="p3"><span class="s1">then the result is that the recombination rates between bases </span><span class="s2">0</span><span class="s1"> / </span><span class="s2">1</span><span class="s1">, </span><span class="s2">1</span><span class="s1"> / </span><span class="s2">2</span><span class="s1">, ..., </span><span class="s2">4999</span><span class="s1"> / </span><span class="s2">5000</span><span class="s1"> will be </span><span class="s2">0</span><span class="s1">, the rate between bases </span><span class="s2">5000</span><span class="s1"> / </span><span class="s2">5001</span><span class="s1"> will be </span><span class="s2">0.5</span><span class="s1">, and the rate between bases </span><span class="s2">5001</span><span class="s1"> / </span><span class="s2">5002</span><span class="s1"> onward (up to </span><span class="s2">9998</span><span class="s1"> / </span><span class="s2">9999</span><span class="s1">) will again be </span><span class="s2">0</span><span class="s1">.<span class="Apple-converted-space">  </span>Setting the recombination rate between one specific pair of bases to </span><span class="s2">0.5</span><span class="s1"> forces recombination to occur with a probability of </span><span class="s2">0.5</span><span class="s1"> between those bases, which effectively breaks the simulated locus into separate chromosomes at that point; this example effectively has one simulated chromosome from base position </span><span class="s2">0</span><span class="s1"> to </span><span class="s2">5000</span><span class="s1">, and another from </span><span class="s2">5001</span><span class="s1"> to </span><span class="s2">9999</span><span class="s1">.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied recombination map is used only for that sex.<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeRecombinationRate()</span><span class="s1">, one for each sex, even if a rate of zero is desired for the other sex; no default recombination map is supplied.</span></p>
<p class="p4">(void)initializeSex(string$ chromosomeType)</p>
<p class="p3">Enable and configure sex in the simulation.<span class="Apple-converted-space">  </span>The argument <span class="s3">chromosomeType</span> gives the type of chromosome to be simulated; this should be <span class="s3">"A"</span>, <span class="s3">"X"</span>, or <span class="s3">"Y"</span>.<span class="Apple-converted-space">  </span>Calling this function has the side effect of enabling sex in the simulation; individuals will be male and female (rather than hermaphroditic) regardless of the <span class="s3">chromosomeType</span> chosen for simulation.<span class="Apple-converted-space">  </span>There is no way to disable sex once it has been enabled; if you don’t want to have sex, don’t call this function.</p>
<p class="p8"><span class="s7"><b>The </b></span><span class="s8"><b>xDominanceCoeff</b></span><span class="s7"><b> parameter has been deprecated and removed.</b><span class="Apple-converted-space">  </span>In SLiM 3.7 and later, use the </span><span class="s8">haploidDominanceCoeff</span><span class="s7"> property of </span><span class="s8">MutationType</span><span class="s7"> instead.<span class="Apple-converted-space">  </span></span>If the <span class="s3">chromosomeType</span> is <span class="s3">"X"</span>, the optional <span class="s3">xDominanceCoeff</span> parameter can supply the dominance coefficient used when a mutation is present in an XY male, and is thus “heterozygous” (but in a different sense than the heterozygosity of an XX female with one copy of the mutation).</p>
<p class="p2">(void)initializeSLiMModelType(string$ modelType)</p>
<p class="p3"><span class="s1">Configure the type of SLiM model used for the simulation.<span class="Apple-converted-space">  </span>At present, one of two model types may be selected.<span class="Apple-converted-space">  </span>If </span><span class="s2">modelType</span><span class="s1"> is </span><span class="s2">"WF"</span><span class="s1">, SLiM will use a Wright-Fisher (WF) model; this is the model type that has always been supported by SLiM, and is the model type used if </span><span class="s2">initializeSLiMModelType()</span><span class="s1"> is not called.<span class="Apple-converted-space">  </span>If </span><span class="s2">modelType</span><span class="s1"> is </span><span class="s2">"nonWF"</span><span class="s1">, SLiM will use a non-Wright-Fisher (nonWF) model instead; this is a new model type supported by SLiM 3.0 and above.</span></p>
<p class="p3"><span class="s1">If </span><span class="s2">initializeSLiMModelType()</span><span class="s1"> is called at all then it must be called before any other initialization function, so that SLiM knows from the outset which features are enabled and which are not.</span></p>
<p class="p2">(void)initializeSLiMOptions([logical$ keepPedigrees = F], [string$ dimensionality = ""], [string$ periodicity = ""], [integer$ mutationRuns = 0], [logical$ preventIncidentalSelfing = F]<span class="s4">, [logical$ nucleotideBased = F], [logical$ randomizeCallbacks = T]</span>)</p>
<p class="p3"><span class="s1">Configure options for the simulation.<span class="Apple-converted-space">  </span>If </span><span class="s2">initializeSLiMOptions()</span><span class="s1"> is called at all then it must be called before any other initialization function (except </span><span class="s2">initializeSLiMModelType()</span><span class="s1">), so that SLiM knows from the outset which optional features are enabled and which are not.</span></p>
<p class="p3">If <span class="s3">keepPedigrees</span> is <span class="s3">T</span>, SLiM will keep pedigree information for every individual in the simulation, tracking the identity of its parents and grandparents.<span class="Apple-converted-space">  </span>This allows individuals to assess their degree of pedigree-based relatedness to other individuals (see <span class="s3">Individual</span>’s <span class="s3">relatedness()</span> and <span class="s3">sharedParentCount()</span> methods), as well as allowing a model to find “trios” (two parents and an offspring they generated) using the pedigree properties of <span class="s3">Individual</span>.<span class="Apple-converted-space">  </span>As a side effect of <span class="s3">keepPedigrees</span> being <span class="s3">T</span>, the <span class="s3">pedigreeID</span>, <span class="s3">pedigreeParentIDs</span>, and <span class="s3">pedigreeGrandparentIDs</span> properties of <span class="s3">Individual</span> will have defined values, as will the <span class="s3">genomePedigreeID</span> property of <span class="s3">Genome</span>.<span class="Apple-converted-space">  </span>Note that pedigree-based relatedness doesn’t necessarily correspond to genetic relatedness, due to effects such as assortment and recombination.<span class="Apple-converted-space">  </span>Beginning in SLiM 3.5, <span class="s3">keepPedigrees=T</span> also enables tracking of individual reproductive output, available through the <span class="s3">reproductiveOutput</span> property of <span class="s3">Individual</span> and the <span class="s3">lifetimeReproductiveOutput</span> property of <span class="s3">Subpopulation</span>.</p>
<p class="p5">If <span class="s3">dimensionality</span> is not <span class="s3">""</span>, SLiM will enable its optional “continuous space” facility.<span class="Apple-converted-space">  </span>Three values for <span class="s3">dimensionality</span> are presently supported: <span class="s3">"x"</span>, <span class="s3">"xy"</span>, and <span class="s3">"xyz"</span>, specifying that continuous space should be enabled for one, two, or three dimensions, respectively, using (<i>x</i>), (<i>x</i>, <i>y</i>), and (<i>x</i>, <i>y</i>, <i>z</i>) coordinates respectively.<span class="Apple-converted-space">  </span>This has a number of side effects.<span class="Apple-converted-space">  </span>First of all, it means that the specified properties of <span class="s3">Individual</span> (<span class="s3">x</span>, <span class="s3">y</span>, and/or <span class="s3">z</span>) will be interpreted by SLiM as spatial positions; in particular, SLiMgui will use those properties to display subpopulations spatially.<span class="Apple-converted-space">  </span>Second, it allows spatial interactions to be defined, evaluated, and queried using <span class="s3">initializeInteractionType()</span> and <span class="s3">interaction()</span> callbacks.<span class="Apple-converted-space">  </span>And third, it enables the use of any other properties and methods related to continuous space, such as setting the spatial boundaries of subpopulations, which would otherwise raise an error.</p>
<p class="p3"><span class="s1">If </span><span class="s2">periodicity</span><span class="s1"> is not </span><span class="s2">""</span><span class="s1">, SLiM will designate the specified spatial dimensions as being periodic – wrapping around at the edges of the spatial boundaries of that dimension.<span class="Apple-converted-space">  </span>This option may only be used if the </span><span class="s2">dimensionality</span><span class="s1"> parameter to </span><span class="s2">initializeSLiMOptions()</span><span class="s1"> has been used to enable spatiality in the model, and only spatial dimensions that were specified in the dimensionality of the model may be declared to be periodic (but if desired, it is permissible to make just a subset of those dimensions periodic; it is not an all-or-none proposition).<span class="Apple-converted-space">  </span>For example, if the specified dimensionality is </span><span class="s2">"xy"</span><span class="s1">, the model’s periodicity may be </span><span class="s2">"x"</span><span class="s1">, </span><span class="s2">"y"</span><span class="s1">, or </span><span class="s2">"xy"</span><span class="s1"> (or </span><span class="s2">""</span><span class="s1">, the default, to specify that there are no periodic dimensions).<span class="Apple-converted-space">  </span>A one-dimensional periodic model would model a space like the perimeter of a circle.<span class="Apple-converted-space">  </span>A two-dimensional model periodic in one of those dimensions would model a space like a cylinder without its end caps; if periodic in both dimensions, the modeled space is a torus.<span class="Apple-converted-space">  </span>The shapes of three-dimensional periodic models are harder to visualize, but are essentially higher-dimensional analogues of these concepts.<span class="Apple-converted-space">  </span>Periodic boundary conditions are commonly used to model spatial scenarios without “edge effects”, since there are no edges in the periodic spatial dimensions.<span class="Apple-converted-space">  </span>The </span><span class="s2">pointPeriodic()</span><span class="s1"> method of </span><span class="s2">Subpopulation</span><span class="s1"> is typically used in conjunction with this option, to actually implement the periodic boundary condition for the specified dimensions.</span></p>
<p class="p5">If <span class="s3">mutationRuns</span> is not <span class="s3">0</span>, SLiM will use the value given as the number of mutation runs inside <span class="s3">Genome</span> objects; if it is <span class="s3">0</span> (the default), SLiM will calculate a number of mutation runs that it estimates will work well.<span class="Apple-converted-space">  </span>Internally, SLiM divides genomes into a sequence of consecutive mutation runs, allowing more efficient internal computations.<span class="Apple-converted-space">  </span>The optimal mutation run length is short enough that each mutation run is relatively unlikely to be modified by mutation/recombination events when inherited, but long enough that each mutation run is likely to contain a relatively large number of mutations; these priorities are in tension, so an intermediate balance between them is generally desirable.<span class="Apple-converted-space">  </span>The optimal number of mutation runs will depend upon the machine and even the compiler used to build SLiM, so SLiM’s default value may not be optimal; for maximal performance it can thus be beneficial to experiment with different values and find the optimal value for the simulation.<span class="Apple-converted-space">  </span>Specifying the number of mutation runs is an advanced technique, but in certain cases it can improve performance significantly; in particular, if a simulation involves a very long chromosome but only a small portion of that chromosome is actually used by the simulation, it may be beneficial to specify that a single mutation run be used with <span class="s3">mutationRuns=1</span><span class="s6">.</span></p>
<p class="p5">If <span class="s3">preventIncidentalSelfing</span> is <span class="s3">T</span>, incidental selfing in hermaphroditic models will be prevented by SLiM.<span class="Apple-converted-space">  </span>By default (i.e., if <span class="s3">preventIncidentalSelfing</span> is <span class="s3">F</span>), SLiM chooses the first and second parents in a biparental mating event independently.<span class="Apple-converted-space">  </span>It is therefore possible for the same individual to be chosen as both the first and second parent, resulting in selfing events even when the selfing rate is zero.<span class="Apple-converted-space">  </span>In many models this is unimportant, since it happens fairly infrequently and does not have large consequences.<span class="Apple-converted-space">  </span>This behavior is SLiM’s default because it is the simplest option, and produces results that most closely align with simple analytical population genetics models.<span class="Apple-converted-space">  </span>However, in some models this selfing can be undesirable and problematic.<span class="Apple-converted-space">  </span>In particular, models that involve very high variance in fitness or very small effective population sizes may see elevated rates of selfing that substantially influence model results.<span class="Apple-converted-space">  </span>If <span class="s3">preventIncidentalSelfing</span> is set to <span class="s3">T</span>, all such incidental selfing will be prevented (by choosing a new second parent if the first parent was chosen again).<span class="Apple-converted-space">  </span>Non-incidental selfing, as requested by the selfing rate, will still be permitted.<span class="Apple-converted-space">  </span>Note that if incidental selfing is prevented, SLiM will hang if it is unable to find a different second parent; there must always be at least two individuals in the population with non-zero fitness, and <span class="s3">mateChoice()</span> and <span class="s3">modifyChild()</span> callbacks must not absolutely prevent those two individuals from producing viable offspring.<span class="Apple-converted-space">  </span>Enforcement of the prohibition on incidental selfing will occur after <span class="s3">mateChoice()</span> callbacks have been called (and thus the default mating weights provided to <span class="s3">mateChoice()</span> callbacks will <i>not</i> exclude the first parent!), but will occur before <span class="s3">modifyChild()</span> callbacks are called (so those callbacks may assume that the first and second parents are distinct).</p>
<p class="p3"><span class="s1">If </span><span class="s2">nucleotideBased</span><span class="s1"> is </span><span class="s2">T</span><span class="s1">, the model will be nucleotide-based.<span class="Apple-converted-space">  </span>In this case, auto-generated mutations (i.e., mutation types used by genomic element types) must be nucleotide-based, and an ancestral nucleotide sequence must be supplied with </span><span class="s2">initializeAncestralNucleotides()</span><span class="s1">.<span class="Apple-converted-space">  </span>Non-nucleotide-based mutations may still be used, but may not be referenced by genomic element types.<span class="Apple-converted-space">  </span>A mutation rate (or rate map) may not be supplied with </span><span class="s2">initializeMutationRate()</span><span class="s1">; instead, a hotspot map may (optionally) be supplied with </span><span class="s2">initializeHotspotMap()</span><span class="s1">.<span class="Apple-converted-space">  </span>This choice has many consequences across SLiM.<span class="Apple-converted-space"> </span></span></p>
<p class="p3">If <span class="s3">randomizeCallbacks</span> is <span class="s3">T</span> (the default), the order in which individuals are processed in callbacks will be randomized to make it easier to avoid order-dependency bugs.<span class="Apple-converted-space">  </span>This flag exists because the order of individuals in each subpopulation is non-random; most notably, females always come before males in the individuals vector, but non-random ordering may also occur with respect to things like migrant versus non-migrant status, origin by selfing versus cloning versus biparental mating, and other factors.<span class="Apple-converted-space">  </span>When this option is <span class="s3">F</span>, individuals in a subpopulation are processed in the order of the individuals vector in each tick cycle stage, which may lead to order-dependency issues if there is an enabled callback whose behavior is not fully independent between calls.<span class="Apple-converted-space">  </span>Setting this option to <span class="s3">T</span> will cause individuals within each subpopulation to be processed in a randomized order in each tick cycle stage; specifically, this randomizes the order of calls to <span class="s3">mutationEffect()</span> callbacks in both WF and nonWF models, and calls to <span class="s3">reproduction()</span> and <span class="s3">survival()</span> callbacks in nonWF models.<span class="Apple-converted-space">  </span>Each subpopulation is still processed separately, in sequential order, so order-dependency issues between subpopulations are still possible if callbacks have effects that are not fully independent.<span class="Apple-converted-space">  </span>This feature was added in SLiM 4, breaking backward compatibility; to recover the behavior of previous versions of SLiM, pass <span class="s3">F</span> for this option (but then be very careful about order-dependency issues in your script).<span class="Apple-converted-space">  </span>The default of <span class="s3">T</span> is the safe option, but a small speed penalty is incurred by the randomization of the processing order – for most models the difference will be less than 1%, but in the worst case it may approach 10%.<span class="Apple-converted-space">  </span>Models that do not have any order-dependency issue may therefore run somewhat faster if this is set to <span class="s3">F</span>.<span class="Apple-converted-space">  </span>Note that anywhere that your script uses the <span class="s3">individuals</span> property of <span class="s3">Subpopulation</span>, the order of individuals returned will be non-random (regardless of the setting of this option); you should use <span class="s3">sample()</span> to shuffle the order of the individuals vector if necessary to avoid order-dependency issues in your script.</p>
<p class="p5">This function will likely be extended with further options in the future, added on to the end of the argument list.<span class="Apple-converted-space">  </span>Using named arguments with this call is recommended for readability.<span class="Apple-converted-space">  </span>Note that turning on optional features may increase the runtime and memory footprint of SLiM.</p>
<p class="p4">(void)initializeSpecies([integer$ tickModulo = 1], [integer$ tickPhase = 1], [string$ avatar = ""], [string$ color = ""])</p>
<p class="p3">Configure options for the species being initialized.<span class="Apple-converted-space">  </span>This initialization function may only be called in multispecies models (i.e., models with explicit species declarations); in single-species models, the default values are assumed and cannot be changed.</p>
<p class="p3">The <span class="s3">tickModulo</span> and <span class="s3">tickPhase</span> parameters determine the activation schedule for the species.<span class="Apple-converted-space">  </span>The <span class="s3">active</span> property of the species will be set to <span class="s3">T</span> (thus activating the species) every <span class="s3">tickModulo</span> ticks, beginning in tick <span class="s3">tickPhase</span>.<span class="Apple-converted-space">  </span>(However, when the species is activated in a given tick, the <span class="s3">skipTick()</span> method may still be called in a <span class="s3">first()</span> event to deactivate it.)<span class="Apple-converted-space">  </span>See the <span class="s3">active</span> property of <span class="s3">Species</span> for more details.</p>
<p class="p3">The <span class="s3">avatar</span> parameter, if not <span class="s3">""</span>, sets a <span class="s3">string</span> value used to represent the species graphically, particularly in SLiMgui but perhaps in other contexts also.<span class="Apple-converted-space">  </span>The <span class="s3">avatar</span> should generally be a single character – usually an emoji corresponding to the species, such as <span class="s3">"</span><span class="s9">🦊</span><span class="s3">"</span> for foxes or <span class="s3">"</span><span class="s9">🐭</span><span class="s3">"</span> for mice.<span class="Apple-converted-space">  </span>If <span class="s3">avatar</span> is the empty string, <span class="s3">""</span>, SLiMgui will choose a default avatar.</p>
<p class="p3">The <span class="s3">color</span> parameter, if not <span class="s3">""</span>, sets a <span class="s3">string</span> color value used to represent the species in SLiMgui.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s3">"#RRGGBB"</span> (see the Eidos manual for details).<span class="Apple-converted-space">  </span>If <span class="s3">color</span> is the empty string, <span class="s3">""</span>, SLiMgui will choose a default color.</p>
<p class="p4"><span class="s1">(void)initializeTreeSeq([logical$ recordMutations = T], [Nif$ simplificationRatio = NULL], [Ni$ simplificationInterval = NULL], [logical$ checkCoalescence = F], [logical$ runCrosschecks = F], [logical$ </span>retainCoalescentOnly<span class="s1"> = T]</span>, [Ns$ timeUnit = NULL]<span class="s1">)</span></p>
<p class="p3">Configure options for tree sequence recording.<span class="Apple-converted-space">  </span>Calling this function turns on tree sequence recording, as a side effect, for later reconstruction of the simulation’s evolutionary dynamics; if you do not want tree sequence recording to be enabled, do not call this function. Note that tree-sequence recording internally uses SLiM’s “pedigree tracking” feature to uniquely identify individuals and genomes; however, if you want to use pedigree tracking in your script you must still enable it yourself with <span class="s3">initializeSLiMOptions(keepPedigrees=T)</span>.</p>
<p class="p3">The <span class="s3">recordMutations</span> flag controls whether information about individual mutations is recorded or not.<span class="Apple-converted-space">  </span>Such recording takes time and memory, and so can be turned off if only the tree sequence itself is needed, but it is turned on by default since mutation recording is generally useful.</p>
<p class="p3">The <span class="s3">simplificationRatio</span> and <span class="s3">simplificationInterval</span> parameters control how often automatic simplification of the recorded tree sequence occurs.<span class="Apple-converted-space">  </span>This is a speed–memory tradeoff: more frequent simplification (lower <span class="s3">simplificationRatio</span> or smaller <span class="s3">simplificationInterval</span>) means the stored tree sequences will use less memory, but at a cost of somewhat longer run times.<span class="Apple-converted-space">  </span>Conversely, a larger <span class="s3">simplificationRatio</span> or <span class="s3">simplificationInterval</span> means that SLiM will wait longer between simplifications.<span class="Apple-converted-space">  </span>There are three ways these parameters can be used.<span class="Apple-converted-space">  </span>With the first option, with a non-<span class="s3">NULL</span> <span class="s3">simplificationRatio</span> and a <span class="s3">NULL</span> value for <span class="s3">simplificationInterval</span>, SLiM will try to find an optimal tick interval for simplification such that the ratio of the memory used by the tree sequence tables, (before:after) simplification, is close to the requested ratio. The default of <span class="s3">10</span> (used if both <span class="s3">simplificationRatio</span> and <span class="s3">simplificationInterval</span> are <span class="s3">NULL</span>) thus requests that SLiM try to find a tick interval such that the maximum size of the stored tree sequences is ten times the size after simplification. <span class="s3">INF</span> may be supplied to indicate that automatic simplification should never occur; <span class="s3">0</span> may be supplied to indicate that automatic simplification should be performed at the end of every tick.<span class="Apple-converted-space">  </span>Alternatively – the second option – <span class="s3">simplificationRatio</span> may be <span class="s3">NULL</span> and <span class="s3">simplificationInterval</span> may be set to the interval, in ticks, between simplifications.<span class="Apple-converted-space">  </span>This may provide more reliable performance, but the interval must be chosen carefully to avoid exceeding the available memory.<span class="Apple-converted-space">  </span>The <span class="s3">simplificationInterval</span> value may be a very large number to specify that simplification should never occur (not <span class="s3">INF</span>, though, since it is an <span class="s3">integer</span> value), or <span class="s3">1</span> to simplify every tick.<span class="Apple-converted-space">  </span>Finally – the third option – both parameters may be non-<span class="s3">NULL</span>, in which case <span class="s3">simplificationRatio</span> is used as described above, while <span class="s3">simplificationInterval</span> provides the <i>initial</i> interval first used by SLiM (and then subsequently increased or decreased to try to match the requested simplification ratio).<span class="Apple-converted-space">  </span>The default initial interval, used when <span class="s3">simplificationInterval</span> is <span class="s3">NULL</span>, is usually <span class="s3">20</span>; this is chosen to be relatively frequent, and thus unlikely to lead to a memory overflow, but it can result in rather slow spool-up for models where the equilibrium simplification interval, as determined by the simplification ratio, is much longer.<span class="Apple-converted-space">  </span>It can therefore be helpful to set a larger initial interval so that the early part of the model run is not excessively bogged down in simplification.</p>
<p class="p3">The <span class="s3">checkCoalescence</span> parameter controls whether a check for full coalescence is conducted after each simplification.<span class="Apple-converted-space">  </span>If a model will call <span class="s3">treeSeqCoalesced()</span> to check for coalescence during its execution, <span class="s3">checkCoalescence</span> should be set to <span class="s3">T</span>.<span class="Apple-converted-space">  </span>Since the coalescence checks entail a performance penalty, the default of <span class="s3">F</span> is preferable otherwise.<span class="Apple-converted-space">  </span>See the documentation for <span class="s3">treeSeqCoalesced()</span> for further discussion.</p>
<p class="p3">The <span class="s3">runCrosschecks</span> parameter controls whether cross-checks between SLiM’s internal data structures and the tree-sequence recording data structures will be conducted.<span class="Apple-converted-space">  </span>These two sets of data structures record much the same thing (mutations in genomes), but using completely different representations, so such cross-checks can be useful to confirm that the two data structures do indeed represent the same conceptual state.<span class="Apple-converted-space">  </span>This slows down the model considerably, however, and would normally be turned on only for debugging purposes, so it is turned off by default.</p>
<p class="p3">The <span class="s3">retainCoalescentOnly</span> parameter controls how, exactly, simplification of the tree-sequence data is performed in SLiM (both for auto-simplification and for calls to <span class="s3">treeSeqSimplify()</span>).<span class="Apple-converted-space">  </span>More specifically, this parameter controls the behavior of simplification for individuals and genomes that have been “retained” by calling <span class="s3">treeSeqRememberIndividuals()</span> with the parameter <span class="s3">permanent=F</span>.<span class="Apple-converted-space">  </span>The default of <span class="s3">retainCoalescentOnly=T</span> helps to keep the number of retained individuals relatively small, which is helpful if your simulation regularly flags many individuals for retaining.<span class="Apple-converted-space">  </span>In this case, changing <span class="s3">retainCoalescentOnly</span> to <span class="s3">F</span> may dramatically increase memory usage and runtime, in a similar way to permanently remembering all the individuals.<span class="Apple-converted-space">  </span>See the documentation of <span class="s3">treeSeqRememberIndividuals()</span> for further discussion.</p>
<p class="p3">The <span class="s3">timeUnit</span> parameter controls the time unit stated in the tree sequence when it is saved (which can be accessed through <span class="s3">tskit</span> APIs); it has no effect on the running simulation whatsoever.<span class="Apple-converted-space">  </span>The default value, <span class="s3">NULL</span>, means that a time unit of <span class="s3">"ticks"</span> will be used for all model types.<span class="Apple-converted-space">  </span>(In SLiM 3.7 / 3.7.1, <span class="s3">NULL</span> implied a time unit of <span class="s3">"generations"</span> for WF models, but <span class="s3">"ticks"</span> for nonWF models; given the new multispecies timescale parameters in SLiM 4, a default of <span class="s3">"ticks"</span> makes sense in all cases since now even in WF models one tick might not equal one biological generation.)<span class="Apple-converted-space">  </span>It may be helpful to set <span class="s3">timeUnit</span> to <span class="s3">"generations"</span> explicitly when modeling non-overlapping generations in which one tick equals one generation, to tell <span class="s3">tskit</span> that the time unit does in fact represent biological generations; doing so may avoid warnings from <span class="s3">tskit</span> or <span class="s3">msprime</span> regarding the time unit, in cases such as recapitation where the simulation timescale is important.</p>
<p class="p1"><b>3.2.<span class="Apple-converted-space">  </span>Nucleotide utilities</b></p>
<p class="p4"><span class="s1">(is)codonsToAminoAcids(integer codons, [li$ long = F], [logical$ paste = T])</span></p>
<p class="p3">Returns the amino acid sequence corresponding to the codon sequence in <span class="s3">codons</span>.<span class="Apple-converted-space">  </span>Codons should be represented with values in [<span class="s3">0</span>, <span class="s3">63</span>] where AAA is <span class="s3">0</span>, AAC is <span class="s3">1</span>, AAG is <span class="s3">2</span>, and TTT is <span class="s3">63</span>; see <span class="s3">ancestralNucleotides()</span> for discussion of this encoding.<span class="Apple-converted-space">  </span>If <span class="s3">long</span> is <span class="s3">F</span> (the default), the standard single-letter codes for amino acids will be used (where Serine is <span class="s3">"S"</span>, etc.); if <span class="s3">long</span> is <span class="s3">T</span>, the standard three-letter codes will be used instead (where Serine is <span class="s3">"Ser"</span>, etc.).<span class="Apple-converted-space">  </span>Beginning in SLiM 3.5, if <span class="s3">long</span> is <span class="s3">0</span>, <span class="s3">integer</span> codes will be used as follows (and <span class="s3">paste</span> will be ignored):</p>
<p class="p9">stop (TAA, TAG, TGA)<span class="Apple-tab-span">	</span><span class="s3">0</span><br>
Alanine<span class="Apple-tab-span">	</span><span class="s3">1</span><br>
Arginine<span class="Apple-tab-span">	</span><span class="s3">2</span><br>
Asparagine<span class="Apple-tab-span">	</span><span class="s3">3</span><br>
Aspartic acid (Aspartate)<span class="Apple-tab-span">	</span><span class="s3">4</span><br>
Cysteine<span class="Apple-tab-span">	</span><span class="s3">5</span><br>
Glutamine<span class="Apple-tab-span">	</span><span class="s3">6</span><br>
Glutamic acid (Glutamate)<span class="Apple-tab-span">	</span><span class="s3">7</span><br>
Glycine<span class="Apple-tab-span">	</span><span class="s3">8</span><br>
Histidine<span class="Apple-tab-span">	</span><span class="s3">9</span><br>
Isoleucine<span class="Apple-tab-span">	</span><span class="s3">10</span><br>
Leucine<span class="Apple-tab-span">	</span><span class="s3">11</span><br>
Lysine<span class="Apple-tab-span">	</span><span class="s3">12</span><br>
Methionine<span class="Apple-tab-span">	</span><span class="s3">13</span><br>
Phenylalanine<span class="Apple-tab-span">	</span><span class="s3">14</span><br>
Proline<span class="Apple-tab-span">	</span><span class="s3">15</span><br>
Serine<span class="Apple-tab-span">	</span><span class="s3">16</span><br>
Threonine<span class="Apple-tab-span">	</span><span class="s3">17</span><br>
Tryptophan<span class="Apple-tab-span">	</span><span class="s3">18</span><br>
Tyrosine<span class="Apple-tab-span">	</span><span class="s3">19</span><br>
Valine<span class="Apple-tab-span">	</span><span class="s3">20</span></p>
<p class="p3">There does not seem to be a widely used standard for integer coding of amino acids, so SLiM just numbers them alphabetically, making stop codons <span class="s3">0</span>.<span class="Apple-converted-space">  </span>If you want a different coding, you can make your own 64-element vector and use it to convert codons to whatever integer codes you need.<span class="Apple-converted-space">  </span>Other <span class="s3">integer</span> values of <span class="s3">long</span> are reserved for future use (to support other codings), and will currently produce an error.</p>
<p class="p3">When <span class="s3">long</span> is <span class="s3">T</span> or <span class="s3">F</span> and <span class="s3">paste</span> is <span class="s3">T</span> (the default), the amino acid sequence returned will be a singleton <span class="s3">string</span>, such as <span class="s3">"LYATI"</span> (when <span class="s3">long</span> is <span class="s3">F</span>) or <span class="s3">"Leu-Tyr-Ala-Thr-Ile"</span> (when <span class="s3">long</span> is <span class="s3">T</span>).<span class="Apple-converted-space">  </span>When <span class="s3">long</span> is <span class="s3">T</span> or <span class="s3">F</span> and <span class="s3">paste</span> is <span class="s3">F</span>, the amino acid sequence will instead be returned as a <span class="s3">string</span> vector, with one element per amino acid, such as <span class="s3">"L" "Y" "A" "T" "I"</span> (when <span class="s3">long</span> is <span class="s3">F</span>) or <span class="s3">"Leu" "Tyr" "Ala" "Thr" "Ile"</span> (when <span class="s3">long</span> is <span class="s3">T</span>).<span class="Apple-converted-space">  </span>Using the <span class="s3">paste=T</span> option is considerably faster than using <span class="s3">paste()</span> in script.</p>
<p class="p3"><span class="s1">This function interprets the supplied codon sequence as the <i>sense</i> strand (i.e., the strand that is <i>not</i> transcribed, and which mirrors the mRNA’s sequence).<span class="Apple-converted-space">  </span>This uses the standard DNA codon table directly.<span class="Apple-converted-space">  </span>For example, if the nucleotide sequence is CAA TTC, that will correspond to a codon vector of </span><span class="s2">16 61</span><span class="s1">, and will result in the amino acid sequence Gln-Phe (</span><span class="s2">"QF"</span><span class="s1">).</span></p>
<p class="p4"><span class="s1">(is)codonsToNucleotides(integer codons, [string$ format = "string"])</span></p>
<p class="p3"><span class="s1">Returns the nucleotide sequence corresponding to the codon sequence supplied in </span><span class="s2">codons</span><span class="s1">.<span class="Apple-converted-space">  </span>Codons should be represented with values in [</span><span class="s2">0</span><span class="s1">, </span><span class="s2">63</span><span class="s1">] where AAA is </span><span class="s2">0</span><span class="s1">, AAC is </span><span class="s2">1</span><span class="s1">, AAG is </span><span class="s2">2</span><span class="s1">, and TTT is </span><span class="s2">63</span><span class="s1">; see </span><span class="s2">ancestralNucleotides()</span><span class="s1"> for discussion of this encoding.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">format</span><span class="s1"> parameter controls the format of the returned sequence.<span class="Apple-converted-space">  </span>It may be </span><span class="s2">"string"</span><span class="s1"> to obtain the sequence as a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATACG"</span><span class="s1">), </span><span class="s2">"char"</span><span class="s1"> to obtain it as a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"C"</span><span class="s1">, </span><span class="s2">"G"</span><span class="s1">), or </span><span class="s2">"integer"</span><span class="s1"> to obtain it as an </span><span class="s2">integer</span><span class="s1"> vector (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">1</span><span class="s1">, </span><span class="s2">2</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)mm16To256(float mutationMatrix16)</span></p>
<p class="p3"><span class="s1">Returns a 64×4 mutation matrix that is functionally identical to the supplied 4×4 mutation matrix in </span><span class="s2">mutationMatrix16</span><span class="s1">.<span class="Apple-converted-space">  </span>The mutation rate for each of the 64 trinucleotides will depend only upon the central nucleotide of the trinucleotide, and will be taken from the corresponding entry for the same nucleotide in </span><span class="s2">mutationMatrix16</span><span class="s1">.<span class="Apple-converted-space">  </span>This function can be used to easily construct a simple trinucleotide-based mutation matrix which can then be modified so that specific trinucleotides sustain a mutation rate that does not depend only upon their central nucleotide.</span></p>
<p class="p3"><span class="s1">See the documentation for </span><span class="s2">initializeGenomicElementType()</span><span class="s1"> for further discussion of how these 64×4 mutation matrices are interpreted and used.</span></p>
<p class="p4"><span class="s1">(float)mmJukesCantor(float$ alpha)</span></p>
<p class="p3"><span class="s1">Returns a mutation matrix representing a Jukes–Cantor (1969) model with mutation rate </span><span class="s2">alpha</span><span class="s1"> to each possible alternative nucleotide at a site.<span class="Apple-converted-space">  </span>This 2×2 matrix is suitable for use with </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>Note that the actual mutation rate produced by this matrix is </span><span class="s2">3*alpha</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)mmKimura(float$ alpha, float$ beta)</span></p>
<p class="p3"><span class="s1">Returns a mutation matrix representing a Kimura (1980) model with transition rate </span><span class="s2">alpha</span><span class="s1"> and transversion rate </span><span class="s2">beta</span><span class="s1">.<span class="Apple-converted-space">  </span>This 2×2 matrix is suitable for use with </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>Note that the actual mutation rate produced by this model is </span><span class="s2">alpha+2*beta</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(integer)nucleotideCounts(is sequence)</span></p>
<p class="p3"><span class="s1">A convenience function that returns an </span><span class="s2">integer</span><span class="s1"> vector of length four, providing the number of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.<span class="Apple-converted-space">  </span>The parameter sequence may be a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector (e.g., 3, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)nucleotideFrequencies(is sequence)</span></p>
<p class="p3"><span class="s1">A convenience function that returns a </span><span class="s2">float</span><span class="s1"> vector of length four, providing the frequencies of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.<span class="Apple-converted-space">  </span>The parameter sequence may be a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector (e.g., 3, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(integer)nucleotidesToCodons(is sequence)</span></p>
<p class="p3"><span class="s1">Returns the codon sequence corresponding to the nucleotide sequence in </span><span class="s2">sequence</span><span class="s1">.<span class="Apple-converted-space">  </span>The codon sequence is an </span><span class="s2">integer</span><span class="s1"> vector with values from </span><span class="s2">0</span><span class="s1"> to </span><span class="s2">63</span><span class="s1">, based upon successive nucleotide triplets in the nucleotide sequence.<span class="Apple-converted-space">  </span>The codon value for a given nucleotide triplet XYZ is 16X + 4Y + Z, where X, Y, and Z have the usual values A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>For example, the triplet AAA has a codon value of </span><span class="s2">0</span><span class="s1">, AAC is </span><span class="s2">1</span><span class="s1">, AAG is </span><span class="s2">2</span><span class="s1">, AAT is </span><span class="s2">3</span><span class="s1">, ACA is </span><span class="s2">4</span><span class="s1">, and on upward to TTT which is </span><span class="s2">63</span><span class="s1">.<span class="Apple-converted-space">  </span>If the nucleotide sequence AACACATTT is passed in, the codon vector </span><span class="s2">1 4 63</span><span class="s1"> will therefore be returned.<span class="Apple-converted-space">  </span>These codon values can be useful in themselves; they can also be passed to </span><span class="s2">codonsToAminoAcids()</span><span class="s1"> to translate them into the corresponding amino acid sequence if desired.</span></p>
<p class="p3"><span class="s1">The nucleotide sequence in </span><span class="s2">sequence</span><span class="s1"> may be supplied in any of three formats: a </span><span class="s2">string</span><span class="s1"> vector with single-letter nucleotides (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), a singleton </span><span class="s2">string</span><span class="s1"> of nucleotide letters (e.g., </span><span class="s2">"TATA"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector of nucleotide values (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">) using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>If the choice of format is not driven by other considerations, such as ease of manipulation, then the singleton </span><span class="s2">string</span><span class="s1"> format will certainly be the most memory-efficient for long sequences, and will probably also be the fastest.<span class="Apple-converted-space">  </span>The nucleotide sequence provided must be a multiple of three in length, so that it translates to an integral number of codons.</span></p>
<p class="p2">(is)randomNucleotides(integer$ length, [Nif basis = NULL], [string$ format = "string"])</p>
<p class="p3"><span class="s1">Generates a new random nucleotide sequence with </span><span class="s2">length</span><span class="s1"> bases.<span class="Apple-converted-space">  </span>The four nucleotides ACGT are equally probable if </span><span class="s2">basis</span><span class="s1"> is </span><span class="s2">NULL</span><span class="s1"> (the default); otherwise, </span><span class="s2">basis</span><span class="s1"> may be a 4-element </span><span class="s2">integer</span><span class="s1"> or </span><span class="s2">float</span><span class="s1"> vector providing relative fractions for A, C, G, and T respectively (these need not sum to </span><span class="s2">1.0</span><span class="s1">, as they will be normalized).<span class="Apple-converted-space">  </span>More complex generative models such as Markov processes are not supported intrinsically in SLiM at this time, but arbitrary generated sequences may always be loaded from files on disk.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">format</span><span class="s1"> parameter controls the format of the returned sequence.<span class="Apple-converted-space">  </span>It may be </span><span class="s2">"string"</span><span class="s1"> to obtain the generated sequence as a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), </span><span class="s2">"char"</span><span class="s1"> to obtain it as a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or </span><span class="s2">"integer"</span><span class="s1"> to obtain it as an </span><span class="s2">integer</span><span class="s1"> vector (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3, 0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>For passing directly to </span><span class="s2">initializeAncestralNucleotides()</span><span class="s1">, format </span><span class="s2">"string"</span><span class="s1"> (a singleton string) will certainly be the most memory-efficient, and probably also the fastest.<span class="Apple-converted-space">  </span>Memory efficiency can be a significant consideration; the nucleotide sequence for a chromosome of length 10</span><span class="s10"><sup>9</sup></span><span class="s1"> will occupy approximately 1 GB of memory when stored as a singleton string (with one byte per nucleotide), and much more if stored in the other formats.<span class="Apple-converted-space">  </span>However, the other formats can be easier to work with in Eidos, and so may be preferable for relatively short chromosomes if you are manipulating the generated sequence.</span></p>
<p class="p1"><b>3.3.<span class="Apple-converted-space">  </span>Population genetics utilities</b></p>
<p class="p4">(float$)calcFST(object&lt;Genome&gt; genomes1, object&lt;Genome&gt; genomes2, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates the <i>F</i><span class="s11"><sub>ST</sub></span> between two <span class="s3">Genome</span> vectors – typically, but not necessarily, the genomes that constitute two different subpopulations (which we will assume for the purposes of this discussion).<span class="Apple-converted-space">  </span>In general, higher <i>F</i><span class="s11"><sub>ST</sub></span> indicates greater genetic divergence between subpopulations.</p>
<p class="p3">The calculation is done using only the mutations in <span class="s3">muts</span>; if <span class="s3">muts</span> is <span class="s3">NULL</span>, all mutations are used.<span class="Apple-converted-space">  </span>The <span class="s3">muts</span> parameter can therefore be used to calculate the <i>F</i><span class="s11"><sub>ST</sub></span> only for a particular mutation type (by passing only mutations of that type).</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the genome-wide <i>F</i><span class="s11"><sub>ST</sub></span>, which is often used to assess the overall level of genetic divergence between sister species or allopatric subpopulations.</p>
<p class="p3">The code for <span class="s3">calcFST()</span> is, roughly, an Eidos implementation of Wright’s definition of <i>F</i><span class="s11"><sub>ST</sub></span> (but see below for further discussion and clarification):</p>
<p class="p3"><i>F</i><span class="s11"><sub>ST</sub></span><span class="s1"> = 1 - <i>H</i></span><span class="s11"><sub>S</sub></span><span class="s1"> / <i>H</i></span><span class="s11"><sub>T</sub></span></p>
<p class="p3">where <i>H</i><span class="s11"><i><sub>S</sub></i></span> is the average heterozygosity in the two subpopulations, and <i>H</i><span class="s11"><i><sub>T </sub></i></span>is the total heterozygosity when both subpopulations are combined.<span class="Apple-converted-space">  </span>In this implementation, the two genome vectors are weighted equally, not weighted by their size.<span class="Apple-converted-space">  </span>In SLiM 3, the implementation followed Wright’s definition closely, and returned the <i>average of ratios</i>: <span class="s3">mean(1.0 - H_s/H_t)</span>, in the Eidos code.<span class="Apple-converted-space">  </span>In SLiM 4, it returns the <i>ratio of averages</i> instead: <span class="s3">1.0 - mean(H_s)/mean(H_t)</span>.<span class="Apple-converted-space">  </span>In other words, the <i>F</i><span class="s11"><sub>ST</sub></span> value reported by SLiM 4 is an average across the specified mutations in the two sets of genomes, where <span class="s3">H_s</span> and <span class="s3">H_t</span> are first averaged across all specified mutations prior to taking the ratio of the two.<span class="Apple-converted-space">  </span>This ratio of averages is less biased than the average of ratios, and and is generally considered to be best practice (see, e.g., Bhatia et al., 2013).<span class="Apple-converted-space">  </span>This means that the behavior of <span class="s3">calcFST()</span> differs between SLiM 3 and SLiM 4.</p>
<p class="p3">The implementation of <span class="s3">calcFST()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation in <span class="s3">muts</span> as independent in the heterozygosity calculations; in other words, if mutations are stacked, the heterozygosity calculated is <i>by mutation</i>, not <i>by site</i>.<span class="Apple-converted-space">  </span>Similarly, if multiple <span class="s3">Mutation</span> objects exist in different genomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each <span class="s3">Mutation</span> object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.<span class="Apple-converted-space">  </span>One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of these choices will be negligible; however, in some models these distinctions may be important.</p>
<p class="p4">(float$)calcHeterozygosity(object&lt;Genome&gt; genomes, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates the heterozygosity for a vector of genomes, based upon the frequencies of mutations in the genomes.<span class="Apple-converted-space">  </span>The result is the <i>expected</i> heterozygosity, for the individuals to which the genomes belong, assuming that they are under Hardy-Weinberg equilibrium; this can be compared to the <i>observed</i> heterozygosity of an individual, as calculated by <span class="s3">calcPairHeterozygosity()</span>.<span class="Apple-converted-space">  </span>Often <span class="s3">genomes</span> will be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.<span class="Apple-converted-space">  </span>By default, with <span class="s3">muts=NULL</span>, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for <span class="s3">muts</span>.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the genome-wide heterozygosity.</p>
<p class="p3">The implementation of <span class="s3">calcHeterozygosity()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations.<span class="Apple-converted-space">  </span>One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>See <span class="s3">calcPairHeterozygosity()</span> for further discussion.</p>
<p class="p4">(float$)calcInbreedingLoad(object&lt;Genome&gt; genomes, [No&lt;MutationType&gt;$ mutType = NULL])</p>
<p class="p3">Calculates inbreeding load (the haploid number of lethal equivalents, or <i>B</i>) for a vector of genomes passed in <span class="s3">genomes</span>.<span class="Apple-converted-space">  </span>The calculation can be limited to a focal mutation type passed in <span class="s3">mutType</span>; if <span class="s3">mutType</span> is <span class="s3">NULL</span> (the default), all of the mutations for the focal species will be considered.<span class="Apple-converted-space">  </span>In any case, only deleterious mutations (those with a negative selection coefficient) will be included in the final calculation.</p>
<p class="p3">The inbreeding load is a measure of the quantity of recessive deleterious variation that is heterozygous in a population and can contribute to fitness declines under inbreeding.<span class="Apple-converted-space">  </span>This function implements the following equation from Morton et al. (1956), which assumes no epistasis and random mating:</p>
<p class="p10"><i>B</i> = sum(<i>qs</i>) − sum(<i>q</i><span class="s12"><sup>2</sup></span><i>s</i>) − 2sum(<i>q</i>(1−<i>q</i>)<i>sh</i>)</p>
<p class="p3">where <i>q</i> is the frequency of a given deleterious allele, <i>s</i> is the absolute value of the selection coefficient, and <i>h</i> is its dominance coefficient.<span class="Apple-converted-space">  </span>Note that the implementation sets a maximum |<i>s</i>| of <span class="s3">1.0</span> (i.e., a lethal allele); |<i>s</i>| can sometimes be greater than <span class="s3">1.0</span> when <i>s</i> is drawn from a distribution, but in practice an allele with <i>s</i> &lt; <span class="s3">-1.0</span> has the same lethal effect as when <i>s</i> = <span class="s3">-1.0</span>.<span class="Apple-converted-space">  </span>Also note that this implementation will not work when the model changes the dominance coefficients of mutations using <span class="s3">mutationEffect()</span> callbacks, since it relies on the <span class="s3">dominanceCoeff</span> property of <span class="s3">MutationType</span>. Finally, note that, to estimate the diploid number of lethal equivalents (2<i>B</i>), the result from this function can simply be multiplied by two.</p>
<p class="p3">This function was contributed by Chris Kyriazis; thanks, Chris!</p>
<p class="p4">(float$)calcPairHeterozygosity(object&lt;Genome&gt;$ genome1, object&lt;Genome&gt;$ genome2, [Ni$ start = NULL], [Ni$ end = NULL], [logical$ infiniteSites = T])</p>
<p class="p3">Calculates the heterozygosity for a pair of genomes; these will typically be the two genomes of a diploid individual (<span class="s3">individual.genome1</span> and <span class="s3">individual.genome2</span>), but any two genomes may be supplied.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the genome-wide heterozygosity.</p>
<p class="p3">The implementation of <span class="s3">calcPairHeterozygosity()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations by default (i.e., with <span class="s3">infiniteSites=T</span>).<span class="Apple-converted-space">  </span>If mutations are stacked, the heterozygosity calculated therefore depends upon the number of <i>unshared mutations</i>, not the number of <i>differing sites</i>.<span class="Apple-converted-space">  </span>Similarly, if multiple <span class="s3">Mutation</span> objects exist in different genomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each <span class="s3">Mutation</span> object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.<span class="Apple-converted-space">  </span>One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>The behavior of <span class="s3">calcPairHeterozygosity()</span> can be switched to calculate based upon the number of differing sites, rather than the number of unshared mutations, by passing <span class="s3">infiniteSites=F</span>.</p>
<p class="p4">(float$)calcWattersonsTheta(object&lt;Genome&gt; genomes, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates Watterson’s theta (a metric of genetic diversity comparable to heterozygosity) for a vector of genomes, based upon the mutations in the genomes.<span class="Apple-converted-space">  </span>Often <span class="s3">genomes</span> will be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.<span class="Apple-converted-space">  </span>By default, with <span class="s3">muts=NULL</span>, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for <span class="s3">muts</span>.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the genome-wide Watterson’s theta.</p>
<p class="p3">The implementation of <span class="s3">calcWattersonsTheta()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations.<span class="Apple-converted-space">  </span>One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with <span class="s3">calcHeterozygosity()</span>.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>See <span class="s3">calcPairHeterozygosity()</span> for further discussion.</p>
<p class="p4">(float$)calcVA(object&lt;Individual&gt; individuals, io&lt;MutationType&gt;$ mutType)</p>
<p class="p3">Calculates <i>V</i><span class="s11"><sub>A</sub></span>, the additive genetic variance, among a vector <span class="s3">individuals</span>, in a particular mutation type <span class="s3">mutType</span> that represents quantitative trait loci (QTLs) influencing a quantitative phenotypic trait.<span class="Apple-converted-space">  </span>The <span class="s3">mutType</span> parameter may be either an <span class="s3">integer</span> representing the ID of the desired mutation type, or a <span class="s3">MutationType</span> object specified directly.</p>
<p class="p3">This function assumes that mutations of type <span class="s3">mutType</span> encode their effect size upon the quantitative trait in their <span class="s3">selectionCoeff</span> property, as is fairly standard in SLiM.<span class="Apple-converted-space">  </span>The implementation of <span class="s3">calcVA()</span>, which is viewable with <span class="s3">functionSource()</span>, is quite simple; if effect sizes are stored elsewhere (such as with <span class="s3">setValue()</span>), a new user-defined function following the pattern of <span class="s3">calcVA()</span> can easily be written.</p>
<p class="p1"><b>3.4.<span class="Apple-converted-space">  </span>Other utilities</b></p>
<p class="p4">(float)summarizeIndividuals(object&lt;Individual&gt; individuals, integer dim, numeric spatialBounds, string$ operation, [Nlif$ empty = 0.0], [logical$ perUnitArea = F], [Ns$ spatiality = NULL])</p>
<p class="p3">Returns a vector, matrix, or array that summarizes spatial patterns of information related to the individuals in <span class="s3">individuals</span>.<span class="Apple-converted-space">  </span>In essence, those individuals are assigned into <i>bins</i> according to their spatial position, and then a summary value for each bin is calculated based upon the individuals each bin contains.<span class="Apple-converted-space">  </span>The individuals might be binned in one dimension (resulting in a vector of summary values), in two dimensions (resulting in a matrix), or in three dimensions (resulting in an array).<span class="Apple-converted-space">  </span>Typically the spatiality of the result (the dimensions into which the individuals are binned) will match the dimensionality of the model, as indicated by the default value of <span class="s3">NULL</span> for the optional <span class="s3">spatiality</span> parameter; for example, a two-dimensional (<span class="s3">"xy"</span>) model would by default produce a two-dimensional matrix as a summary.<span class="Apple-converted-space">  </span>However, a spatiality that is more restrictive than the model dimensionality may be passed; for example, in a two-dimensional (<span class="s3">"xy"</span>) model a <span class="s3">spatiality</span> of <span class="s3">"y"</span> could be passed to summarize individuals into a vector, rather than a matrix, assigning them to bins based only upon their <i>y</i> position (i.e., the value of their <span class="s3">y</span> property).<span class="Apple-converted-space">  </span>Whatever spatiality is chosen, the parameter <span class="s3">dim</span> provides the dimensions of the desired result, in the same form that the <span class="s3">dim()</span> function does: first the number of rows, then the number of columns, and then the number of planes, as needed (see the Eidos manual for discussion of matrices, arrays, and <span class="s3">dim()</span>).<span class="Apple-converted-space">  </span>The length of <span class="s3">dims</span> must match the requested spatiality; for spatiality <span class="s3">"xy"</span>, for example, <span class="s3">dims</span> might be <span class="s3">c(50,100)</span> to request that the returned matrix have <span class="s3">50</span> rows and <span class="s3">100</span> columns.<span class="Apple-converted-space">  </span>The result vector/matrix/array is in the correct orientation to be directly usable as a spatial map, by passing it to the <span class="s3">defineSpatialMap()</span> method of <span class="s3">Subpopulation</span>.<span class="Apple-converted-space">  </span>For further discussion of dimensionality and spatiality, see <span class="s3">initializeInteractionType()</span> and <span class="s3">InteractionType</span>.</p>
<p class="p3">The <span class="s3">spatialBounds</span> parameter defines the spatial boundaries within which the individuals are binned.<span class="Apple-converted-space">  </span>Typically this is the spatial bounds of a particular subpopulation, within which the individuals reside; for individuals in <span class="s3">p1</span>, for example, you would likely pass <span class="s3">p1.spatialBounds</span> for this.<span class="Apple-converted-space">  </span>However, this is not required; individuals may come from any or all subpopulations in the model, and <span class="s3">spatialBounds</span> may be any bounds of non-zero area (if an individual falls outside of the given spatial bounds, it is excluded, as if it were not in <span class="s3">individuals</span> at all).<span class="Apple-converted-space">  </span>If you have multiple subpopulations that conceptually reside within the same overall coordinate space, for example, that can be accommodated here.<span class="Apple-converted-space">  </span>The bounds are supplied in the dimensionality of the model, in the same form as for <span class="s3">Subpopulation</span>; for an <span class="s3">"xy"</span> model, for example, they are supplied as a four-element vector of the form <span class="s3">c(x0, y0, x1, y1)</span> even if the summary is being produced with spatiality <span class="s3">"y"</span>.<span class="Apple-converted-space">  </span>To produce the result, a grid with dimensions defined by <span class="s3">dims</span> is conceptually stretched out across the given spatial bounds, such that the <i>centers</i> of the edge and corner grid squares are aligned with the limits of the spatial bounds.<span class="Apple-converted-space">  </span>This matches the way that <span class="s3">defineSpatialMap()</span> defines its maps.</p>
<p class="p3">The particular summary produced depends upon the parameters <span class="s3">operation</span> and <span class="s3">empty</span>.<span class="Apple-converted-space">  </span>Consider a single grid square represented by a single element in the result.<span class="Apple-converted-space">  </span>That grid square contains zero or more of the individuals in <span class="s3">individuals</span>.<span class="Apple-converted-space">  </span>If it contains zero individuals <i>and</i> <span class="s3">empty</span> is not <span class="s3">NULL</span>, the <span class="s3">empty</span> value is used for the result, regardless of <span class="s3">operation</span>, providing specific, separate control over the treatment of empty grid squares.<span class="Apple-converted-space">  </span>If <span class="s3">empty</span> is <span class="s3">NULL</span>, this separate control over the treatment of empty grid squares is declined; empty grid squares will be handled through the standard mechanism described next.<span class="Apple-converted-space">  </span>In all other cases for the given grid square – when it contains more than zero individuals, or when <span class="s3">empty</span> is <span class="s3">NULL</span> – <span class="s3">operation</span> is executed as an Eidos <i>lambda</i>, a small snippet of code, supplied as a singleton <span class="s3">string</span>, that is executed in a manner similar to a function call.<span class="Apple-converted-space">  </span>Within the execution of the <span class="s3">operation</span> lambda, a constant named <span class="s3">individuals</span> is defined to be the focal individuals being evaluated – all of the individuals within that grid square.<span class="Apple-converted-space">  </span>This lambda should evaluate to a singleton <span class="s3">logical</span>, <span class="s3">integer</span>, or <span class="s3">float</span> value, comprising the result value for the grid square; these types will all be coerced to <span class="s3">float</span> (<span class="s3">T</span> being <span class="s3">1</span> and <span class="s3">F</span> being <span class="s3">0</span>).</p>
<p class="p3">Two examples may illustrate the use of <span class="s3">empty</span> and <span class="s3">operation</span>.<span class="Apple-converted-space">  </span>To produce a summary indicating presence/absence, simply use the default of <span class="s3">0.0</span> for <span class="s3">empty</span>, and <span class="s3">"1.0;</span> <span class="s3">"</span> (or <span class="s3">"1;"</span>, or <span class="s3">"T;"</span>) for <span class="s3">operation</span>.<span class="Apple-converted-space">  </span>This will produce <span class="s3">0.0</span> for empty grid squares, and <span class="s3">1.0</span> for those that contain at least one individual.<span class="Apple-converted-space">  </span>Note that the use of <span class="s3">empty</span> is essential here, because <span class="s3">operation</span> doesn’t even check whether individuals are present or not.<span class="Apple-converted-space">  </span>To produce a summary with a count of the number of individuals in each grid square, again use the default of <span class="s3">0.0</span> for <span class="s3">empty</span>, but now use an <span class="s3">operation</span> of <span class="s3">"individuals.size();"</span>, counting the number of individuals in each grid square.<span class="Apple-converted-space">  </span>In this case, <span class="s3">empty</span> could be <span class="s3">NULL</span> instead and <span class="s3">operation</span> would still produce the correct result; but using <span class="s3">empty</span> makes <span class="s3">summarizeIndividuals()</span> more efficient since it allows the execution of <span class="s3">operation</span> to be skipped for those squares.</p>
<p class="p3">Lambdas are not limited in their complexity; they can use <span class="s3">if</span>, <span class="s3">for</span>, etc., and can call methods and functions.<span class="Apple-converted-space">  </span>A typical <span class="s3">operation</span> to compute the mean phenotype in a quantitative genetic model that stores phenotype values in <span class="s3">tagF</span>, for example, would be <span class="s3">"mean(individuals.tagF);"</span>, and this is still quite simple compared to what is possible.<span class="Apple-converted-space">  </span>However, keep in mind that the lambda will be evaluated for every grid cell (or at least those that are non-empty), so efficiency can be a concern, and you may wish to pre-calculate values shared by all of the lambda calls, making them available to your lambda code using <span class="s3">defineGlobal()</span> or <span class="s3">defineConstant()</span>.</p>
<p class="p3">There is one last twist, if <span class="s3">perUnitArea</span> is <span class="s3">T</span>: values are divided by the area (or length, in 1D, or volume, in 3D) that their corresponding grid cell comprises, so that each value is in units of “per unit area” (or “per unit length”, or “per unit volume”).<span class="Apple-converted-space">  </span>The total area of the grid is defined by the spatial bounds, and the area of a given grid cell is defined by the portion of the spatial bounds that is within that cell.<span class="Apple-converted-space">  </span>This is not the same for all grid cells; grid cells that fall partially outside <span class="s3">spatialBounds</span> (because, remember, the <i>centers</i> of the edge/corner grid cells are aligned with the limits of <span class="s3">spatialBounds</span>) will have a smaller area inside the bounds.<span class="Apple-converted-space">  </span>For an <span class="s3">"xy"</span> spatiality summary, for example, corner cells have only a quarter of their area inside <span class="s3">spatialBounds</span>, while edge elements have half of their area inside <span class="s3">spatialBounds</span>; for purposes of <span class="s3">perUnitArea</span>, then, their respective areas are ¼ and ½ the area of an interior grid cell.<span class="Apple-converted-space">  </span>By default, <span class="s3">perUnitArea</span> is <span class="s3">F</span>, and no scaling is performed.<span class="Apple-converted-space">  </span>Whether you want <span class="s3">perUnitArea</span> to be <span class="s3">F</span> or <span class="s3">T</span> depends upon whether the summary you are producing is, conceptually, “per unit area”, such as density (individuals per unit area) or local competition strength (total interaction strength per unit area), or is not, such as “mean individual age”, or “maximum <span class="s3">tag</span> value”.<span class="Apple-converted-space">  </span>For the previous example of counting individuals with an operation of <span class="s3">"individuals.size();"</span>, a value of <span class="s3">F</span> for <span class="s3">perUnitArea</span> (the default) will produce a simple <i>count</i> of individuals in each grid square, whereas with <span class="s3">T</span> it would produce the <i>density</i> of individuals in each grid square.</p>
<p class="p4">(object&lt;Dictionary&gt;$)treeSeqMetadata(string$ filePath, [logical$ userData = T])</p>
<p class="p3">Returns a <span class="s3">Dictionary</span> containing top-level metadata from the <span class="s3">.trees</span> (tree-sequence) file at <span class="s3">filePath</span>.<span class="Apple-converted-space">  </span>If <span class="s3">userData</span> is <span class="s3">T</span> (the default), the top-level metadata under the <span class="s3">SLiM/user_metadata</span> key is returned; this is the same metadata that can optionally be supplied to <span class="s3">treeSeqOutput()</span> in its <span class="s3">metadata</span> parameter, so it makes it easy to recover metadata that you attached to the tree sequence when it was saved.<span class="Apple-converted-space">  </span>If <span class="s3">userData</span> is <span class="s3">F</span>, the entire top-level metadata <span class="s3">Dictionary</span> object is returned; this can be useful for examining the values of other keys under the <span class="s3">SLiM</span> key, or values inside the top-level dictionary itself that might have been placed there by <span class="s3">msprime</span> or other software.</p>
<p class="p3">This function can be used to read in parameter values or other saved state (<span class="s3">tag</span> property values, for example), in order to resuscitate the complete state of a simulation that was written to a <span class="s3">.trees</span> file.<span class="Apple-converted-space">  </span>It could be used for more esoteric purposes too, such as to search through <span class="s3">.trees</span> files in a directory (with the help of the Eidos function <span class="s3">filesAtPath()</span>) to find those files that satisfy some metadata criterion.</p>
</body>
</html>
