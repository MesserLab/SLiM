<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2487.7">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo}
    p.p3 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p4 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p5 {margin: 0.0px 0.0px 3.0px 45.4px; font: 10.0px Optima; color: #000000}
    p.p6 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Menlo; color: #000000}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Menlo}
    p.p9 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #969696}
    p.p10 {margin: 0.0px 0.0px 3.0px 54.0px; font: 10.0px Optima; color: #000000}
    p.p11 {margin: 3.0px 0.0px 3.0px 27.4px; font: 11.0px Optima; color: #000000}
    span.s1 {font-kerning: none}
    span.s2 {font: 9.0px Menlo; font-kerning: none}
    span.s3 {font: 9.0px Menlo}
    span.s4 {font: 6.7px Optima}
    span.s5 {font-kerning: none; color: #000000}
    span.s6 {font: 10.0px Optima; font-kerning: none}
    span.s7 {font: 10.0px 'Times New Roman'}
    span.s8 {color: #000000}
    span.s9 {font: 9.0px Menlo; color: #000000}
    span.s10 {font: 7.0px 'Apple Color Emoji'}
    span.s11 {font: 6.7px Optima; font-kerning: none}
    span.s12 {font: 7.3px Optima}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><b>3.1.<span class="Apple-converted-space">  </span>Initialization functions</b></p>
<p class="p2">(integer$)initializeAncestralNucleotides(is sequence)</p>
<p class="p3"><span class="s1">This function, which may be called only in nucleotide-based models, supplies an ancestral nucleotide sequence for the model.<span class="Apple-converted-space">  </span>The </span><span class="s2">sequence</span><span class="s1"> parameter may be an </span><span class="s2">integer</span><span class="s1"> vector providing nucleotide values (A=0, C=1, G=2, T=3), or a </span><span class="s2">string</span><span class="s1"> vector providing single-character nucleotides (</span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"C"</span><span class="s1">, </span><span class="s2">"G"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">), or a singleton </span><span class="s2">string</span><span class="s1"> providing the sequence as one string (</span><span class="s2">"ACGT..."</span><span class="s1">), or a singleton </span><span class="s2">string</span><span class="s1"> providing the filesystem path of a FASTA file which will be read in to provide the sequence (if the file contains than one sequence, the first sequence will be used).<span class="Apple-converted-space">  </span>Only A/C/G/T nucleotide values may be provided; other symbols, such as those for amino acids, gaps, or nucleotides of uncertain identity, are not allowed.<span class="Apple-converted-space">  </span>The two semantic meanings of </span><span class="s2">sequence</span><span class="s1"> that involve a singleton </span><span class="s2">string</span><span class="s1"> value are distinguished heuristically; a singleton </span><span class="s2">string</span><span class="s1"> that contains only the letters ACGT will be assumed to be a nucleotide sequence rather than a filename.<span class="Apple-converted-space">  </span>The length of the ancestral sequence is returned.</span></p>
<p class="p3"><span class="s1">A utility function, </span><span class="s2">randomNucleotides()</span><span class="s1">, is provided by SLiM to assist in generating simple random nucleotide sequences.</span></p>
<p class="p4">(object&lt;Chromosome&gt;$)initializeChromosome(integer$ id, [Ni$ length = NULL], [string$ type = "A"], [Ns$ symbol = NULL], [Ns$ name = NULL], [integer$ mutationRuns = 0])</p>
<p class="p3">Calling this function, added in SLiM 5, initiates the configuration of a chromosome in the species being initialized.<span class="Apple-converted-space">  </span>The new <span class="s3">Chromosome</span> object is returned, but it is still under construction and will error if used; see below for details.<span class="Apple-converted-space">  </span>That chromosome is then the “focal chromosome” for subsequent genetic initialization functions – specifically, for <span class="s3">initializeAncestralNucleotides()</span>, <span class="s3">initializeGeneConversion()</span>, <span class="s3">initializeGenomicElement()</span>, <span class="s3">initializeHotspotMap()</span>, <span class="s3">initializeMutationRate()</span>, and <span class="s3">initializeRecombinationRate()</span>.<span class="Apple-converted-space">  </span>If you wish to call <span class="s3">initializeChromosome()</span> at all (which is not required), you must call it <i>before</i> calling any of those genetic initialization functions, so that the focal chromosome is created <i>before</i> being configured further; otherwise, SLiM will assume that you want a default single-chromosome model, and when <span class="s3">initializeChromosome()</span> is called later (contradicting that assumption), an error will result.</p>
<p class="p3">Furthermore, there are some other initialization functions must be called before <span class="s3">initializeChromosome()</span> if they are called at all – specifically, <span class="s3">initializeSex()</span>, <span class="s3">initializeTreeSeq()</span>, <span class="s3">initializeSpecies()</span>, and <span class="s3">initializeSLiMOptions()</span>.<span class="Apple-converted-space">  </span>This is so that <span class="s3">initializeChromosome()</span> knows the context within which the new chromosome is to be created; if these methods have not been called when <span class="s3">initializeChromosome()</span> is called, the default context is assumed (non-sexual, no tree-sequence recording, single-species, non-nucleotide-based), and an error will result downstream if one of those functions is later called (indicating that those assumptions might be incorrect).</p>
<p class="p3">The parameters to <span class="s3">initializeChromosome()</span> configure the chromosome created.<span class="Apple-converted-space">  </span>They will be discussed out of order here, because that order of presentation will, I hope, be clearer.</p>
<p class="p3">There are three parameters that in some way identify the chromosome.<span class="Apple-converted-space">  </span>First, the required <span class="s3">id</span> parameter provides an <span class="s3">integer</span> identifier for the chromosome, which can be used to look up the chromosome later in the simulation; it can be any non-negative <span class="s3">integer</span> value, but must be unique within the species (two chromosomes in the same species cannot have the same <span class="s3">id</span>).<span class="Apple-converted-space">  </span>Often it is an empirical chromosome number, for convenience and clarity; if modeling human chromosome 7, for example, you might provide <span class="s3">7</span>.<span class="Apple-converted-space">  </span>Second, the <span class="s3">symbol</span> parameter provides a <span class="s3">string</span> identifier for the chromosome, which can also be used to look up the chromosome later in the simulation.<span class="Apple-converted-space">  </span>If <span class="s3">NULL</span> (the default) is passed for <span class="s3">symbol</span>, the chromosome’s default <span class="s3">symbol</span> value will be the <span class="s3">string</span> version of its <span class="s3">id</span> (<span class="s3">"7"</span> for an <span class="s3">id</span> of <span class="s3">7</span>, for example).<span class="Apple-converted-space">  </span>The chromosome’s <span class="s3">symbol</span> value will be used to identify the chromosome in output – in VCF output, for example, and in SLiMgui.<span class="Apple-converted-space">  </span>It must be non-empty (not <span class="s3">""</span>), no more than five characters long, and unique within the species.<span class="Apple-converted-space">  </span>Third, the <span class="s3">name</span> parameter can be any <span class="s3">string</span> value; if <span class="s3">NULL</span> (the default) is passed, the <span class="s3">name</span> value will be <span class="s3">""</span>.<span class="Apple-converted-space">  </span>The <span class="s3">name</span> is not used by SLiM, and can be used in any way you wish.</p>
<p class="p3">The <span class="s3">length</span> parameter sets the length, in base positions, of the chromosome, and must either be <span class="s3">NULL</span>, or an <span class="s3">integer</span> greater than or equal to <span class="s3">1</span>.<span class="Apple-converted-space">  </span>If <span class="s3">length</span> is <span class="s3">NULL</span>, the length of the chromosome will be calculated after all <span class="s3">initialize()</span> callbacks have been called, as the maximum position referenced by the chromosome’s genomic elements, recombination map, mutation rate map, and (in nucleotide-based models) hotspot map; in other words, the chromosome will be sized to encompass all of the things it contains (which is also the behavior of the implicitly defined chromosome if <span class="s3">initializeChromosome()</span> is not called).<span class="Apple-converted-space">  </span>Otherwise – if <span class="s3">length</span> is specified with an <span class="s3">integer</span> value – the chromosome’s length will be fixed at that value, and the last valid base position in the chromosome will be <span class="s3">length-1</span>.<span class="Apple-converted-space">  </span>Attempting to add a genomic element or a mutation after the last position will raise an error.<span class="Apple-converted-space">  </span>Similarly, the last position of the chromosome must match the last position specified for recombination, mutation, and hotspot maps for that chromosome, but not all positions on a chromosome have to actually be used in the model (i.e., not all positions must be covered by a genomic element).</p>
<p class="p3">The <span class="s3">type</span> parameter specifies the type of chromosome to be created.<span class="Apple-converted-space">  </span>There are numerous options, and they are somewhat complex.<span class="Apple-converted-space">  </span>They are discussed in more detail in the documentation for class <span class="s3">Chromosome</span>, particularly their specific patterns of inheritance; but they are briefly summarized here for quick reference.<span class="Apple-converted-space">  </span>Note that “–“ below indicates a null haplosome.<span class="Apple-converted-space">  </span>First of all, in hermaphroditic models <span class="s3">type</span> will generally be one of:</p>
<p class="p5"><span class="s3">"A"</span> (autosome), the default, specifying a diploid autosomal chromosome.</p>
<p class="p5"><span class="s3">"H"</span> (haploid), specifying a haploid autosomal chromosome that recombines in biparental crosses.</p>
<p class="p5"><span class="s3">"HF"</span> (haploid female-inherited), specifying a haploid autosomal chromosome that is inherited by both sexes from the first (female) parent in biparental crosses (also allowed in hermaphroditic models for inheritance that is always from the first parent).</p>
<p class="p5"><span class="s3">"HM"</span> (haploid male-inherited), specifying a haploid autosomal chromosome that is inherited by both sexes from the second (male) parent in biparental crosses (also allowed in hermaphroditic models for inheritance that is always from the second parent).</p>
<p class="p3">Some sex-chromosome types are supported only in sexual models:</p>
<p class="p5"><span class="s3">"X"</span> (X), specifying an X chromosome that is diploid (XX) in females, haploid (X–) in males.</p>
<p class="p5"><span class="s3">"Y"</span> (Y), specifying a Y chromosome that is haploid (Y) in males, absent (–) in females.</p>
<p class="p5"><span class="s3">"Z"</span> (Z), specifying a Z chromosome that is diploid (ZZ) in males, haploid (–Z) in females.</p>
<p class="p5"><span class="s3">"W"</span> (W), specifying a W chromosome that is haploid (W) in females, absent (–) in males.</p>
<p class="p3">And there are some haploid chromosome types that are also supported only in sexual models:</p>
<p class="p5"><span class="s3">"FL"</span> (female line), specifying a haploid autosomal chromosome that is inherited only by females, from the female parent, and is represented by a null haplosome in males.</p>
<p class="p5"><span class="s3">"ML"</span> (male line), specifying a haploid autosomal chromosome that is inherited only by males, from the male parent, and is represented by a null haplosome in females.</p>
<p class="p3">Finally, two additional values of <span class="s3">type</span>, <span class="s3">"H-"</span> and <span class="s3">"-Y"</span>, are supported for backward compatibility (not intended for use in new models).<span class="Apple-converted-space">  </span>They are discussed in the <span class="s3">Chromosome</span> documentation.</p>
<p class="p3">The <span class="s3">mutationRuns</span> parameter specifies how many mutation runs the chromosome should use.<span class="Apple-converted-space">  </span>Internally, SLiM divides haplosomes into a sequence of consecutive mutation runs, allowing more efficient internal computations.<span class="Apple-converted-space">  </span>The optimal mutation run length is short enough that each mutation run is relatively unlikely to be modified by mutation/recombination events when inherited, but long enough that each mutation run is likely to contain a relatively large number of mutations; these priorities are in tension, so an intermediate balance between them is generally optimal.<span class="Apple-converted-space">  </span>The optimal number of mutation runs will depend on the model’s details, and may also depend upon the machine and even the compiler used to build SLiM.<span class="Apple-converted-space">  </span>If the <span class="s3">mutationRuns</span> parameter is not <span class="s3">0</span>, SLiM will use the value given as the number of mutation runs inside <span class="s3">Haplosome</span> objects for the chromosome.<span class="Apple-converted-space">  </span>If <span class="s3">mutationRuns</span> is <span class="s3">0</span> (the default), then the behavior depends upon a parameter to the <span class="s3">initializeSLiMOptions()</span> function, <span class="s3">doMutationRunExperiments</span>.<span class="Apple-converted-space">  </span>If that flag is <span class="s3">F</span>, the behavior here is as if <span class="s3">mutationRuns=1</span> had been passed: one mutation run will be used, and mutation run experiments will not be conducted.<span class="Apple-converted-space">  </span>If that flag is <span class="s3">T</span> (the default), then for <span class="s3">mutationRuns=0</span> SLiM will conduct experiments at runtime, using different mutation run counts, to try to determine the number of mutation runs that produces the best performance.<span class="Apple-converted-space">  </span>The value that SLiM’s experiments determine may not be optimal, however, and in any case there is some overhead associated with conducting these experiments; for maximal performance it can thus be beneficial to determine the true optimal value for the simulation yourself, and set it explicitly using this parameter. Specifying the number of mutation runs is an advanced technique, but in some cases it can improve performance significantly.</p>
<p class="p3">The order in which <span class="s3">initializeChromosome()</span> calls are made is generally unimportant, since the chromosomes assort independently of each other anyway, but SLiM will preserve the order in which they were defined for you (for the <span class="s3">chromosomes</span> property of Species, for display in SLiMgui, for writing out to VCF, and so forth).<span class="Apple-converted-space">  </span>All of the above types of chromosomes can be defined any number of times; you can have any number of autosomal chromosomes, for example.<span class="Apple-converted-space">  </span>In a sexual model you could even have multiple defined sex chromosomes – not in the sense of a female being XX, but in the sense of a female being X<span class="s4"><sub>1</sub></span>X<span class="s4"><sub>1</sub></span>X<span class="s4"><sub>2</sub></span>X<span class="s4"><sub>2</sub></span>, where X<span class="s4"><sub>1</sub></span> and X<span class="s4"><sub>2</sub></span> are two different kinds of X chromosome.<span class="Apple-converted-space">  </span>Similarly, you could define both an X and a Z for a species, if you wish; each would segregate correctly according to the sex of the offspring.<span class="Apple-converted-space">  </span>In sexual models in SLiM the sex of an offspring is determined randomly or given by the user in script; it is not a function of the sex chromosomes present in the individual, although the sex chromosomes present in the individual will correlate with sex.<span class="Apple-converted-space">  </span>In other words, SLiM does not know and does not care what sex-determination system the species is using; the chromosomes follow the sex, rather than the sex following the chromosomes.<span class="Apple-converted-space">  </span>This should allow any sex-determination system to be modeled, even if it is unusual, non-genetic, etc.</p>
<p class="p3">As stated above, the new <span class="s3">Chromosome</span> object is returned by this call, but it is still under construction so most of its methods and properties will error.<span class="Apple-converted-space">  </span>It will remain in this state until <span class="s3">initialize()</span> callbacks have completed, and will then become active and usable.<span class="Apple-converted-space">  </span>Until that point, there are only a handful of uses that are guaranteed to be allowed: storing it in a variable; remembering it with <span class="s3">defineConstant()</span>; using the methods and properties of its superclasses, notably <span class="s3">Dictionary</span>; setting SLiMgui display-related properties such as <span class="s3">colorSubstitution</span>; getting and setting its <span class="s3">tag</span> property; and accessing those of its properties that were passed to the <span class="s3">initializeChromosome()</span> call, specifically <span class="s3">id</span>, <span class="s3">symbol</span>, <span class="s3">name</span>, <span class="s3">type</span>, <span class="s3">length</span>, and <span class="s3">lastPosition</span>.<span class="Apple-converted-space">  </span>Its other properties, and all <span class="s3">Chromosome</span> methods, will raise an error while in this state.<span class="Apple-converted-space">  </span>This safeguard protects the new <span class="s3">Chromosome</span> object from being used while still in an inconsistent state.</p>
<p class="p4"><span class="s1">(void)initializeGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0], [logical$ redrawLengthsOnFailure = F])</span></p>
<p class="p3"><span class="s1">Calling this function switches the recombination model from a “simple crossover” model to a “double-stranded break (DSB)” model, and configures the details of the gene conversion tracts that will therefore be modeled.<span class="Apple-converted-space">  </span>The fraction of DSBs that will be modeled as non-crossover events is given by </span><span class="s2">nonCrossoverFraction</span><span class="s1">.<span class="Apple-converted-space">  </span>The mean length of gene conversion tracts (whether associated with crossover or non-crossover events) is given by </span><span class="s2">meanLength</span><span class="s1">; the actual extent of a gene conversion tract will be the sum of two independent draws from a geometric distribution with mean </span><span class="s2">meanLength/2</span><span class="s1">.<span class="Apple-converted-space">  </span>The fraction of gene conversion tracts that are modeled as “simple” is given by </span><span class="s2">simpleConversionFraction</span><span class="s1">; the remainder will be modeled as “complex”, involving repair of heteroduplex mismatches.<span class="Apple-converted-space">  </span>Finally, the </span><span class="s2">GC</span><span class="s1"> bias during heteroduplex mismatch repair is given by </span><span class="s2">bias</span><span class="s1">, with the default of </span><span class="s2">0.0</span><span class="s1"> indicating no bias, </span><span class="s2">1.0</span><span class="s1"> indicating an absolute preference for </span><span class="s2">G</span><span class="s1">/</span><span class="s2">C</span><span class="s1"> mutations over </span><span class="s2">A</span><span class="s1">/</span><span class="s2">T</span><span class="s1"> mutations, and </span><span class="s2">-1.0</span><span class="s1"> indicating an absolute preference for </span><span class="s2">A</span><span class="s1">/</span><span class="s2">T</span><span class="s1"> mutations over </span><span class="s2">G</span><span class="s1">/</span><span class="s2">C</span><span class="s1"> mutations.<span class="Apple-converted-space">  </span>A non-zero bias may only be set in nucleotide-based models.<span class="Apple-converted-space">  </span>This function, and the way that gene conversion is modeled, fundamentally changed in SLiM 3.3.</span></p>
<p class="p3">Beginning in SLiM 4.1, the <span class="s3">redrawLengthsOnFailure</span> parameter can be used to modify the internal mechanics of layout of gene conversion tracts.<span class="Apple-converted-space">  </span>If it is <span class="s3">F</span> (the default, and the only behavior supported before SLiM 4.1), then if an attempt to lay out gene conversion tracts fails (because the tracts overlap each other, or overlap the start or end of the chromosome), SLiM will try again by drawing new positions for the tracts – essentially shuffling the tracts around to try to find positions for them that don’t overlap.<span class="Apple-converted-space">  </span>If <span class="s3">redrawLengthsOnFailure</span> is <span class="s3">T</span>, then if an attempt to lay out gene conversion tracts fails, SLiM will try again by drawing new lengths for the tracts, as well as new positions.<span class="Apple-converted-space">  </span>This makes it more likely that layout will succeed, but risks biasing the realized mean tract length downward from the requested mean length (since layout of long tracts is more likely fail due to overlap).<span class="Apple-converted-space">  </span>In either case, if SLiM attempts to lay out gene conversion tracts 100 times without success, an error will result.<span class="Apple-converted-space">  </span>That error indicates that the specified constraints for gene conversion are difficult to satisfy – tracts may commonly be so long that it is difficult or impossible to find an acceptable layout for them within the specified chromosome length.<span class="Apple-converted-space">  </span>Setting <span class="s3">redrawLengthsOnFailure</span> to <span class="s3">T</span> may mitigate this problem, at the price of biasing the mean tract length downward as discussed.</p>
<p class="p4">(object&lt;GenomicElement&gt;)initializeGenomicElement(io&lt;GenomicElementType&gt; genomicElementType, [Ni start = NULL], [Ni end = NULL])</p>
<p class="p3"><span class="s1">Add a genomic element to the chromosome at initialization time.<span class="Apple-converted-space">  </span>The </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1"> parameters give the first and last base positions to be spanned by the new genomic element.<span class="Apple-converted-space">  </span>The new element will be based upon the genomic element type identified by </span><span class="s2">genomicElementType</span><span class="s1">, which can be either an </span><span class="s2">integer</span><span class="s1">, representing the ID of the desired element type, or an </span><span class="s2">object</span><span class="s1"> of type </span><span class="s2">GenomicElementType</span><span class="s1"> specified directly.</span></p>
<p class="p3"><span class="s1">Beginning in SLiM 3.3, this function is vectorized: the </span><span class="s2">genomicElementType</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, and </span><span class="s2">end</span><span class="s1"> parameters do not have to be singletons.<span class="Apple-converted-space">  </span>In particular, </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1"> may be of any length, but must be equal in length; each </span><span class="s2">start</span><span class="s1">/</span><span class="s2">end</span><span class="s1"> element pair will generate one new genomic element spanning the given base positions.<span class="Apple-converted-space">  </span>In this case, </span><span class="s2">genomicElementType</span><span class="s1"> may still be a singleton, providing the genomic element type to be used for all of the new genomic elements, or it may be equal in length to </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1">, providing an independent genomic element type for each new element.<span class="Apple-converted-space">  </span>When adding a large number of genomic elements, it will be much faster to add them in order of ascending position with a vectorized call.</span></p>
<p class="p3">Beginning in SLiM 5, passing <span class="s3">NULL</span> for <span class="s3">start</span> and <span class="s3">end</span> is allowed by <span class="s3">initializeGenomicElement()</span>, but only in one specific case: if the focal chromosome being configured was explicitly defined with <span class="s3">initializeChromosome()</span>, and that focal chromosome was given an explicit length (rather than a length of <span class="s3">NULL</span>).<span class="Apple-converted-space">  </span>In that case, <span class="s3">start</span> and <span class="s3">end</span> may be <span class="s3">NULL</span> (<i>both</i> of them, not just one of them), indicating that the genomic element created should span the entire length of the focal chromosome.<span class="Apple-converted-space">  </span>Since <span class="s3">NULL</span> is now the default value for <span class="s3">start</span> and <span class="s3">end</span>, this makes this common configuration very simple to set up.</p>
<p class="p3"><span class="s1">The return value provides the genomic element(s) created by the call, in the order in which they were specified in the parameters to </span><span class="s2">initializeGenomicElement()</span><span class="s1">.</span></p>
<p class="p2">(object&lt;GenomicElementType&gt;$)initializeGenomicElementType(is$ id, io&lt;MutationType&gt; mutationTypes, numeric proportions<span class="s5">, [Nf mutationMatrix = NULL]</span>)</p>
<p class="p6">Add a genomic element type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> must not already be used for any genomic element type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s3">mutationTypes</span> vector identifies the mutation types used by the genomic element, and the <span class="s3">proportions</span> vector should be of equal length, specifying the relative proportion of mutations that will be drawn from the corresponding mutation type (proportions do not need to add up to one; they are interpreted relatively).<span class="Apple-converted-space">  </span>The <span class="s3">id</span> parameter may be either an <span class="s3">integer</span> giving the ID of the new genomic element type, or a <span class="s3">string</span> giving the name of the new genomic element type (such as <span class="s3">"g5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>The <span class="s3">mutationTypes</span> parameter may be either an <span class="s3">integer</span> vector representing the IDs of the desired mutation types, or an <span class="s3">object</span> vector of <span class="s3">MutationType</span> elements specified directly.<span class="Apple-converted-space">  </span>The global symbol for the new genomic element type is immediately available; the return value also provides the new object.</p>
<p class="p3"><span class="s1">The </span><span class="s2">mutationMatrix</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> by default, and in non-nucleotide-based models it must be </span><span class="s2">NULL</span><span class="s1">.<span class="Apple-converted-space">  </span>In nucleotide-based models, on the other hand, it must be non-</span><span class="s2">NULL</span><span class="s1">, and therefore must be supplied.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">mutationMatrix</span><span class="s1"> should take one of two standard forms.<span class="Apple-converted-space">  </span>For sequence-based mutation rates that depend upon only the single nucleotide at a mutation site, </span><span class="s2">mutationMatrix</span><span class="s1"> should be a 4×4 </span><span class="s2">float</span><span class="s1"> matrix, specifying mutation rates for an existing nucleotide state (rows from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">3</span><span class="s1"> representing A/C/G/T) to each of the four possible derived nucleotide states (columns, with the same meaning).<span class="Apple-converted-space">  </span>The mutation rates in this matrix are absolute rates, per nucleotide per gamete; they will be used by SLiM directly unless they are multiplied by a factor from the hotspot map (see </span><span class="s2">initializeHotspotMap()</span><span class="s1">).<span class="Apple-converted-space">  </span>Rates in </span><span class="s2">mutationMatrix</span><span class="s1"> that involve the mutation of a nucleotide to itself (</span><span class="s2">A</span><span class="s1"> to </span><span class="s2">A</span><span class="s1">, </span><span class="s2">C</span><span class="s1"> to </span><span class="s2">C</span><span class="s1">, etc.) are not used by SLiM and must be </span><span class="s2">0.0</span><span class="s1"> by convention.</span></p>
<p class="p3"><span class="s1">It is important to note that the order of the rows and columns used in SLiM, A/C/G/T, is not a universal convention; other sources will present substitution-rate/transition-rate matrices using different conventions, and so care must be taken when importing such matrices into SLiM.</span></p>
<p class="p3"><span class="s1">For sequence-based mutation rates that depend upon the trinucleotide sequence centered upon a mutation site (the adjacent bases to the left and right, in other words, as well as the mutating nucleotide itself), </span><span class="s2">mutationMatrix</span><span class="s1"> should be a 64×4 </span><span class="s2">float</span><span class="s1"> matrix, specifying mutation rates for the central nucleotide of an existing trinucleotide sequence (rows from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">63</span><span class="s1">, representing codons as described in the documentation for the </span><span class="s2">ancestralNucleotides()</span><span class="s1"> method of </span><span class="s2">Chromosome</span><span class="s1">) to each of the four possible derived nucleotide states (columns from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">3</span><span class="s1"> for A/C/G/T as before).<span class="Apple-converted-space">  </span>Note that in every case it is the central nucleotide of the trinucleotide sequence that is mutating, but rates can be specified independently based upon the nucleotides in the first and third positions as well, with this type of mutation matrix.</span></p>
<p class="p3"><span class="s1">Several helper functions are defined to construct common types of mutation matrices, such as </span><span class="s2">mmJukesCantor()</span><span class="s1"> to create a mutation matrix for a Jukes–Cantor model.</span></p>
<p class="p4"><span class="s1">(void)initializeHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = "*"])</span></p>
<p class="p3"><span class="s1">In nucleotide-based models, set the mutation rate <i>multiplier</i> along the chromosome.<span class="Apple-converted-space">  </span>Nucleotide-based models define sequence-based mutation rates that are set up with the </span><span class="s2">mutationMatrix</span><span class="s1"> parameter to </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>If no hotspot map is specified by calling </span><span class="s2">initializeHotspotMap()</span><span class="s1">, a hotspot map with a multiplier of </span><span class="s2">1.0</span><span class="s1"> across the whole chromosome is assumed (and so the sequence-based rates are the absolute mutation rates used by SLiM).<span class="Apple-converted-space">  </span>A hotspot map modifies the sequence-based rates by scaling them up in some regions, with multipliers greater than </span><span class="s2">1.0</span><span class="s1"> (representing mutational hot spots), and/or scaling them down in some regions, with multipliers less than </span><span class="s2">1.0</span><span class="s1"> (representing mutational cold spots).</span></p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">multipliers</span><span class="s1"> must be a singleton value that specifies a single multiplier to be used along the entire chromosome (typically </span><span class="s2">1.0</span><span class="s1">, but not required to be).<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">multipliers</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">multipliers</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p7"><span class="s6"><span class="Apple-tab-span">	</span></span><span class="s1">initializeHotspotMap(c(1.0, 1.2), c(5000, 9999));</span></p>
<p class="p3"><span class="s1">then the result is that the mutation rate multiplier for bases </span><span class="s2">0</span><span class="s1">...</span><span class="s2">5000</span><span class="s1"> (inclusive) will be </span><span class="s2">1.0</span><span class="s1"> (and so the specified sequence-based mutation rates will be used verbatim), and the multiplier for bases </span><span class="s2">5001</span><span class="s1">...</span><span class="s2">9999</span><span class="s1"> (inclusive) will be </span><span class="s2">1.2</span><span class="s1"> (and so the sequence-based mutation rates will be multiplied by 1.2 within the region).</span></p>
<p class="p3"><span class="s1">Note that mutations are generated by SLiM only within genomic elements, regardless of the hotspot map.<span class="Apple-converted-space">  </span>In effect, the hotspot map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a multiplier of zero.<span class="Apple-converted-space">  </span>There is no harm in supplying a hotspot map that specifies multipliers for areas outside of the genomic elements defined; the excess information is simply not used.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied hotspot map is used only for that sex (i.e., when generating a gamete from a parent of that sex).<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeHotspotMap()</span><span class="s1">, one for each sex, even if a multiplier of </span><span class="s2">1.0</span><span class="s1"> is desired for the other sex; no default hotspot map is supplied.</span></p>
<p class="p2">(object&lt;InteractionType&gt;$)initializeInteractionType(is$ id, string$ spatiality, [logical$ reciprocal = F], [numeric$ maxDistance = INF], [string$ sexSegregation = "**"])</p>
<p class="p3">Add an interaction type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> must not already be used for any interaction type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> parameter may be either an <span class="s3">integer</span> giving the ID of the new interaction type, or a <span class="s3">string</span> giving the name of the new interaction type (such as <span class="s3">"i5"</span> to specify an ID of 5).</p>
<p class="p3">The <span class="s3">spatiality</span> may be <span class="s3">""</span>, for non-spatial interactions (i.e., interactions that do not depend upon the distance between individuals); <span class="s3">"x"</span>, <span class="s3">"y"</span>, or <span class="s3">"z"</span> for one-dimensional interactions; <span class="s3">"xy"</span>, <span class="s3">"xz"</span>, or <span class="s3">"yz"</span> for two-dimensional interactions; or <span class="s3">"xyz"</span> for three-dimensional interactions.<span class="Apple-converted-space">  </span>The dimensions referenced by spatiality must be defined as spatial dimensions with <span class="s3">initializeSLiMOptions()</span>; if the simulation has dimensionality <span class="s3">"xy"</span>, for example, then interactions in the simulation may have spatiality <span class="s3">""</span>, <span class="s3">"x"</span>, <span class="s3">"y"</span>, or <span class="s3">"xy"</span>, but may not reference spatial dimension <i>z</i> and thus may not have spatiality <span class="s3">"xz"</span>, <span class="s3">"yz"</span>, or <span class="s3">"xyz"</span>.<span class="Apple-converted-space">  </span>If no spatial dimensions have been configured, only non-spatial interactions may be defined.</p>
<p class="p3">The <span class="s3">reciprocal</span> flag may be <span class="s3">T</span>, in which case the interaction is guaranteed by the user to be <i>reciprocal</i>: whatever the interaction strength is for exerter B upon receiver A, it will be equal (in magnitude and sign) for exerter A upon receiver B.<span class="Apple-converted-space">  </span>In principle, this allows the <span class="s3">InteractionType</span> to reduce the amount of computation necessary by up to a factor of two (although it may or may not be used).<span class="Apple-converted-space">  </span>If <span class="s3">reciprocal</span> is <span class="s3">F</span>, the interaction is not guaranteed to be reciprocal and each interaction will be computed independently.<span class="Apple-converted-space">  </span>The built-in interaction formulas are all reciprocal, but if you implement an <span class="s3">interaction()</span> callback, you must consider whether the callback you have implemented preserves reciprocality or not.<span class="Apple-converted-space">  </span>For this reason, the default is <span class="s3">reciprocal=F</span>, so that bugs are not inadvertently introduced by an invalid assumption of reciprocality.<span class="Apple-converted-space">  </span>See below for a note regarding reciprocality in sexual simulations when using the <span class="s3">sexSegregation</span> flag.</p>
<p class="p3">The <span class="s3">maxDistance</span> parameter supplies the maximum distance over which interactions of this type will be evaluated; at greater distances, the interaction strength is considered to be zero (for efficiency).<span class="Apple-converted-space">  </span>The default value of <span class="s3">maxDistance</span>, <span class="s3">INF</span> (positive infinity), indicates that there is no maximum interaction distance; note that this can make some interaction queries much less efficient, and is therefore not recommended.<span class="Apple-converted-space">  </span>In SLiM 3.1 and later, a warning will be issued if a spatial interaction type is defined with no maximum distance to encourage a maximum distance to be defined.</p>
<p class="p3">The <span class="s3">sexSegregation</span> parameter governs the applicability of the interaction to each sex, in sexual simulations.<span class="Apple-converted-space">  </span>It does not affect distance calculations in any way; it only modifies the way in which interaction strengths are calculated.<span class="Apple-converted-space">  </span>The default, <span class="s3">"**"</span>, implies that the interaction is felt by both sexes (the first character of the <span class="s3">string</span> value) and is exerted by both sexes (the second character of the <span class="s3">string</span> value).<span class="Apple-converted-space">  </span>Either or both characters may be <span class="s3">M</span> or <span class="s3">F</span> instead; for example, <span class="s3">"MM"</span> would indicate a male-male interaction, such as male-male competition, whereas <span class="s3">"FM"</span> would indicate an interaction influencing only female receivers that is influenced only by male exerters, such as male mating displays that influence female attraction.<span class="Apple-converted-space">  </span>This parameter may be set only to <span class="s3">"**"</span> unless sex has been enabled with <span class="s3">initializeSex()</span>.<span class="Apple-converted-space">  </span>Note that a value of <span class="s3">sexSegregation</span> other than <span class="s3">"**"</span> may imply some degree of non-reciprocality, but it is not necessary to specify <span class="s3">reciprocal</span> to be <span class="s3">F</span> for this reason; SLiM will take the sex-segregation of the interaction into account for you.<span class="Apple-converted-space">  </span>The value of <span class="s3">reciprocal</span> may therefore be interpreted as meaning: in those cases, if any, in which A interacts with B and B interacts with A, is the interaction strength guaranteed to be the same in both directions?<span class="Apple-converted-space">  </span>The <span class="s3">sexSegregation</span> parameter is shorthand for setting sex constraints on the interaction type using the <span class="s3">setConstraints()</span> method; see that method for a more extensive set of constraints that may be used.</p>
<p class="p3">By default, the interaction strength is <span class="s3">1.0</span> for all interactions within <span class="s3">maxDistance</span>.<span class="Apple-converted-space">  </span>Often it is desirable to change the interaction function using <span class="s3">setInteractionFunction()</span>; modifying interaction strengths can also be achieved with <span class="s3">interaction()</span> callbacks if necessary.<span class="Apple-converted-space">  </span>In any case, interactions beyond <span class="s3">maxDistance</span> always have a strength of <span class="s3">0.0</span>, and the interaction strength of an individual with itself is always <span class="s3">0.0</span>, regardless of the interaction function or callbacks.</p>
<p class="p3">The global symbol for the new interaction type is immediately available; the return value also provides the new object.<span class="Apple-converted-space">  </span>Note that in multispecies models, <span class="s3">initializeInteractionType()</span> must be called from a non-species-specific <span class="s3">interaction()</span> callback (declared as <span class="s3">species all initialize()</span>), since interactions are managed at the community level.</p>
<p class="p2">(void)initializeMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p3">Set the mutation rate per base position per gamete.<span class="Apple-converted-space">  </span>To be precise, this mutation rate is the expected mean number of mutations that will occur per base position per gamete; note that this is different from how the recombination rate is defined (see <span class="s3">initializeRecombinationRate()</span>).<span class="Apple-converted-space">  </span>The number of mutations that actually occurs at a given base position when generating an offspring haplosome is, in effect, drawn from a Poisson distribution with that expected mean (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).<span class="Apple-converted-space">  </span>It is possible for this Poisson draw to indicate that two or more new mutations have arisen at the same base position, particularly when the mutation rate is very high; in this case, the new mutations will be added to the site one at a time, and as always the mutation stacking policy will be followed.</p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">rates</span><span class="s1"> must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p8"><span class="s7"><span class="Apple-tab-span">	</span></span>initializeMutationRate(c(1e-7, 2.5e-8), c(5000, 9999));</p>
<p class="p3"><span class="s1">then the result is that the mutation rate for bases </span><span class="s2">0</span><span class="s1">...</span><span class="s2">5000</span><span class="s1"> (inclusive) will be </span><span class="s2">1e-7</span><span class="s1">, and the rate for bases </span><span class="s2">5001</span><span class="s1">...</span><span class="s2">9999</span><span class="s1"> (inclusive) will be </span><span class="s2">2.5e-8</span><span class="s1">.</span></p>
<p class="p3"><span class="s1">Note that mutations are generated by SLiM only within genomic elements, regardless of the mutation rate map.<span class="Apple-converted-space">  </span>In effect, the mutation rate map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a mutation rate of zero.<span class="Apple-converted-space">  </span>There is no harm in supplying a mutation rate map that specifies rates for areas outside of the genomic elements defined; that rate information is simply not used.<span class="Apple-converted-space">  </span>The </span><span class="s2">overallMutationRate</span><span class="s1"> family of properties on </span><span class="s2">Chromosome</span><span class="s1"> provide the overall mutation rate after genomic element coverage has been taken into account, so it will reflect the rate at which new mutations will actually be generated in the simulation as configured.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied mutation rate map is used only for that sex (i.e., when generating a gamete from a parent of that sex).<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeMutationRate()</span><span class="s1">, one for each sex, even if a rate of zero is desired for the other sex; no default mutation rate map is supplied.</span></p>
<p class="p3"><span class="s1">In nucleotide-based models, </span><span class="s2">initializeMutationRate()</span><span class="s1"> may not be called.<span class="Apple-converted-space">  </span>Instead, the desired sequence-based mutation rate(s) should be expressed in the </span><span class="s2">mutationMatrix</span><span class="s1"> parameter to </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>If variation in the mutation rate along the chromosome is desired, </span><span class="s2">initializeHotspotMap()</span><span class="s1"> should be used.</span></p>
<p class="p3">The <span class="s3">initializeMutationRateFromFile()</span> function is a useful convenience function if you wish to read the mutation rate map from a file.</p>
<p class="p4">(void)initializeMutationRateFromFile(string$ path, integer$ lastPosition, [float$ scale = 1.0e-08], [string$ sep = "\t"], [string$ dec = "."])</p>
<p class="p3">Set a mutation rate map from data read from the file at <span class="s3">path</span>.<span class="Apple-converted-space">  </span>This function is essentially a wrapper for <span class="s3">initializeMutationRate()</span> that uses <span class="s3">readCSV()</span> and passes the data through.<span class="Apple-converted-space">  </span>The file is expected to contain two columns of data.<span class="Apple-converted-space">  </span>The first column must be <span class="s3">integer</span> start positions for rate map regions; the first region should start at position <span class="s3">0</span> if the map’s positions are <span class="s3">0</span>-based, or at position <span class="s3">1</span> if the map’s positions are <span class="s3">1</span>-based; in the latter case, <span class="s3">1</span> will be subtracted from every position since SLiM uses <span class="s3">0</span>-based positions.<span class="Apple-converted-space">  </span>The second column must be <span class="s3">float</span> rates, relative to the scaling factor specified in <span class="s3">scale</span>; for example, if a given rate is <span class="s3">1.2</span> and <span class="s3">scale</span> is <span class="s3">1e-8</span> (the default), the rate used will be <span class="s3">1.2e-8</span>.<span class="Apple-converted-space">  </span>No column header line should be present; the file should start immediately with numerical data.<span class="Apple-converted-space">  </span>The expected separator between columns is a tab character by default, but may be passed in <span class="s3">sep</span>; the expected decimal separator is a period by default, but may be passed in <span class="s3">dec</span>.<span class="Apple-converted-space">  </span>Once read, the map is converted into a rate map specified with end positions, rather than start positions, and the position given by <span class="s3">lastPosition</span> is used as the end of the last rate region; it should be the last position of the chromosome.</p>
<p class="p3">See <span class="s3">readCSV()</span> for further details on <span class="s3">sep</span> and <span class="s3">dec</span>, which are passed through to it; and see <span class="s3">initializeMutationRate()</span> for details on how the rate map is validated and used.</p>
<p class="p3">This function is written in Eidos, and its source code can be viewed with <span class="s3">functionSource()</span>, so you can copy and modify its code if you need to modify its functionality.</p>
<p class="p2">(object&lt;MutationType&gt;$)initializeMutationType(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)</p>
<p class="p3">Add a mutation type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> must not already be used for any mutation type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s3">id</span> parameter may be either an <span class="s3">integer</span> giving the ID of the new mutation type, or a <span class="s3">string</span> giving the name of the new mutation type (such as <span class="s3">"m5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>The dominanceCoeff parameter supplies the dominance coefficient for the mutation type; <span class="s3">0.0</span> produces no dominance, <span class="s3">1.0</span> complete dominance, and values greater than <span class="s3">1.0</span>, overdominance.<span class="Apple-converted-space">  </span>The <span class="s3">distributionType</span> may be <span class="s3">"f"</span>, in which case the ellipsis <span class="s3">...</span> should supply a <span class="s3">numeric$</span> fixed selection coefficient; <span class="s3">"e"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient for an exponential distribution; <span class="s3">"g"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient and a <span class="s3">numeric$</span> alpha shape parameter for a gamma distribution; <span class="s3">"n"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient and a <span class="s3">numeric$</span> sigma (standard deviation) parameter for a normal distribution; <span class="s3">"p"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> mean selection coefficient and a <span class="s3">numeric$</span> scale parameter for a Laplace distribution; <span class="s3">"w"</span>, in which case the ellipsis should supply a <span class="s3">numeric$</span> <span class="s7">λ</span> scale parameter and a <span class="s3">numeric$</span> k shape parameter for a Weibull distribution; or <span class="s3">"s"</span>, in which case the ellipsis should supply a <span class="s3">string$</span> Eidos script parameter.<span class="Apple-converted-space">  </span>The global symbol for the new mutation type is immediately available; the return value also provides the new object.</p>
<p class="p3"><span class="s1">Note that by default in WF models, all mutations of a given mutation type will be converted into </span><span class="s2">Substitution</span><span class="s1"> objects when they reach fixation, for efficiency reasons.<span class="Apple-converted-space">  </span>If you need to disable this conversion, to keep mutations of a given type active in the simulation even after they have fixed, you can do so by setting the </span><span class="s2">convertToSubstitution</span><span class="s1"> property of </span><span class="s2">MutationType</span><span class="s1"> to </span><span class="s2">F</span><span class="s1">.<span class="Apple-converted-space">  </span>In contrast, by default in nonWF models mutations will not be converted into </span><span class="s2">Substitution</span><span class="s1"> objects when they reach fixation; </span><span class="s2">convertToSubstitution</span><span class="s1"> is </span><span class="s2">F</span><span class="s1"> by default in nonWF models.<span class="Apple-converted-space">  </span>To enable conversion in nonWF models for neutral mutation types with no indirect fitness effects, you should therefore set </span><span class="s2">convertToSubstitution</span><span class="s1"> to </span><span class="s2">T</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(object&lt;MutationType&gt;$)initializeMutationTypeNuc(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)</span></p>
<p class="p3"><span class="s1">Add a nucleotide-based mutation type at initialization time.<span class="Apple-converted-space">  </span>This function is identical to </span><span class="s2">initializeMutationType()</span><span class="s1"> except that the new mutation type will be nucleotide-based – in other words, mutations belonging to the new mutation type will have an associated nucleotide.<span class="Apple-converted-space">  </span>This function may be called only in nucleotide-based models (as enabled by the </span><span class="s2">nucleotideBased</span><span class="s1"> parameter to </span><span class="s2">initializeSLiMOptions()</span><span class="s1">).</span></p>
<p class="p3"><span class="s1">Nucleotide-based mutations always use a </span><span class="s2">mutationStackGroup</span><span class="s1"> of </span><span class="s2">-1</span><span class="s1"> and a </span><span class="s2">mutationStackPolicy</span><span class="s1"> of </span><span class="s2">"l"</span><span class="s1">.<span class="Apple-converted-space">  </span>This ensures that a new nucleotide mutation always replaces any previously existing nucleotide mutation at a given position, regardless of the mutation types of the nucleotide mutations.<span class="Apple-converted-space">  </span>These values are set automatically by </span><span class="s2">initializeMutationTypeNuc()</span><span class="s1">, and may not be changed.</span></p>
<p class="p3"><span class="s1">See the documentation for </span><span class="s2">initializeMutationType()</span><span class="s1"> for all other discussion.</span></p>
<p class="p2">(void)initializeRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p3">Set the recombination rate per base position per gamete.<span class="Apple-converted-space">  </span>To be precise, this recombination rate is the probability that a breakpoint will occur between one base and the next base; note that this is different from how the mutation rate is defined (see <span class="s3">initializeMutationRate()</span>).<span class="Apple-converted-space">  </span>A recombination rate of 1 centimorgan/Mbp corresponds to a recombination rate of <span class="s3">1e-8</span> in the units used by SLiM.<span class="Apple-converted-space">  </span>All rates must be in the interval [<span class="s3">0.0</span>, <span class="s3">0.5</span>].<span class="Apple-converted-space">  </span>A rate of <span class="s3">0.5</span> implies complete independence between the adjacent bases, which might be used to implement unlinked loci.<span class="Apple-converted-space">  </span>Whether a breakpoint occurs between two bases is then, in effect, determined by a binomial draw with a single trial and the given rate as probability (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).<span class="Apple-converted-space">  </span>The recombinational process in SLiM will never generate more then one crossover between one base and the next (in one generation/haplosome), and a supplied rate of <span class="s3">0.5</span> will therefore result in an actual probability of <span class="s3">0.5</span> for a crossover at the relevant position.<span class="Apple-converted-space">  </span>(Note that this was not true in SLiM 2.x and earlier, however; their implementation of recombination resulted in a crossover probability of about 39.3% for a rate of <span class="s3">0.5</span>, due to the use of an inaccurate approximation method.<span class="Apple-converted-space">  </span>Recombination rates lower than about <span class="s3">0.01</span> would have been essentially exact, since the approximation error became large only as the rate approached <span class="s3">0.5</span>.)</p>
<p class="p3">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional <span class="s3">ends</span> parameter is <span class="s3">NULL</span> (the default), then <span class="s3">rates</span> must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, <span class="s3">ends</span> is supplied, then <span class="s3">rates</span> and <span class="s3">ends</span> must be the same length, and the values in <span class="s3">ends</span> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, <span class="s3">rates</span> and <span class="s3">ends</span> taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in <span class="s3">ends</span> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).</p>
<p class="p3">If the optional <span class="s3">sex</span> parameter is <span class="s3">"*"</span> (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations <span class="s3">sex</span> may be <span class="s3">"M"</span> or <span class="s3">"F"</span> instead, in which case the supplied recombination map is used only for that sex.<span class="Apple-converted-space">  </span>In this case, two calls must be made to <span class="s3">initializeRecombinationRate()</span>, one for each sex, even if a rate of zero is desired for the other sex; no default recombination map is supplied.</p>
<p class="p3">The <span class="s3">initializeRecombinationRateFromFile()</span> function is a useful convenience function if you wish to read the recombination rate map from a file.</p>
<p class="p4">(void)initializeRecombinationRateFromFile(string$ path, integer$ lastPosition, [float$ scale = 1.0e-08], [string$ sep = "\t"], [string$ dec = "."], [string$ sex = "*"])</p>
<p class="p3">Set a recombination rate map from data read from the file at <span class="s3">path</span>.<span class="Apple-converted-space">  </span>This function is essentially a wrapper for <span class="s3">initializeRecombinationRate()</span> that uses <span class="s3">readCSV()</span> and passes the data through.<span class="Apple-converted-space">  </span>The file is expected to contain two columns of data.<span class="Apple-converted-space">  </span>The first column must be <span class="s3">integer</span> start positions for rate map regions; the first region should start at position <span class="s3">0</span> if the map’s positions are <span class="s3">0</span>-based, or at position <span class="s3">1</span> if the map’s positions are <span class="s3">1</span>-based; in the latter case, <span class="s3">1</span> will be subtracted from every position since SLiM uses <span class="s3">0</span>-based positions.<span class="Apple-converted-space">  </span>The second column must be <span class="s3">float</span> rates, relative to the scaling factor specified in <span class="s3">scale</span>; for example, if a given rate is <span class="s3">1.2</span> and <span class="s3">scale</span> is <span class="s3">1e-8</span> (the default), the rate used will be <span class="s3">1.2e-8</span>.<span class="Apple-converted-space">  </span>No column header line should be present; the file should start immediately with numerical data.<span class="Apple-converted-space">  </span>The expected separator between columns is a tab character by default, but may be passed in <span class="s3">sep</span>; the expected decimal separator is a period by default, but may be passed in <span class="s3">dec</span>.<span class="Apple-converted-space">  </span>Once read, the map is converted into a rate map specified with end positions, rather than start positions, and the position given by <span class="s3">lastPosition</span> is used as the end of the last rate region; it should be the last position of the chromosome.</p>
<p class="p3">See <span class="s3">readCSV()</span> for further details on <span class="s3">sep</span> and <span class="s3">dec</span>, which are passed through to it; and see <span class="s3">initializeRecombinationRate()</span> for details on how the rate map is validated and used, and how the <span class="s3">sex</span> parameter is used.</p>
<p class="p3">This function is written in Eidos, and its source code can be viewed with <span class="s3">functionSource()</span>, so you can copy and modify its code if you need to modify its functionality.</p>
<p class="p4">(void)initializeSex([Ns$ chromosomeType = NULL])</p>
<p class="p3">Enable sex in the simulation.<span class="Apple-converted-space">  </span>Beginning in SLiM 5, this method should generally be passed <span class="s3">NULL</span>, simply indicating that sex should be enabled: individuals will then be male and female (rather than hermaphroditic), biparental crosses will be required to be between a female first parent and a male second parent, and selfing will not be allowed.<span class="Apple-converted-space">  </span>In this new configuration style, if a sexual simulation involving sex chromosomes is desired, the new <span class="s3">initializeChromosome()</span> call should be used to configure the chromosome setup for the simulation.</p>
<p class="p3">For backward compatibility, the old style of configuring a sexual simulation is still supported, however.<span class="Apple-converted-space">  </span>This implicitly defines a single chromosome, without a call to <span class="s3">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>With this old configuration approach, the <span class="s3">chromosomeType</span> parameter to <span class="s3">initializeSex()</span> gives the type of chromosome that should be simulated; this should be <span class="s3">"A"</span>, <span class="s3">"X"</span>, or <span class="s3">"Y"</span>, and this <span class="s3">chromosomeType</span> value will be used as the symbol (<span class="s3">"A"</span>, <span class="s3">"X"</span>, or <span class="s3">"Y"</span>) for the implicit chromosome.<span class="Apple-converted-space">  </span>These legacy chromosome types correspond to the new chromosome types <span class="s3">"A"</span>, <span class="s3">"X"</span>, and <span class="s3">"-Y"</span> respectively (note that it is <i>not</i> <span class="s3">"Y"</span>), when using <span class="s3">initializeChromosome()</span>.<span class="Apple-converted-space">  </span>The implicit chromosome’s <span class="s3">id</span> property is always <span class="s3">1</span>.<span class="Apple-converted-space">  </span>This old style of chromosome configuration is much less flexible, however, allowing only these three chromosome types, and only allowing a single chromosome to be set up.<span class="Apple-converted-space">  </span>This backward compatibility mode may be removed for SLiM in the future, and should be considered deprecated; new models should call <span class="s3">initializeChromosome()</span> explicitly instead.</p>
<p class="p3">There is no way to disable sex once it has been enabled; if you don’t want to have sex, don’t call this function.<span class="Apple-converted-space">  </span>If you require more flexibility with mating types and reproductive strategies than SLiM’s built-in support for sex provides, do not call <span class="s3">initializeSex()</span>; instead, track the sex or mating type of individuals yourself in script (with the <span class="s3">tag</span> property of <span class="s3">Individual</span>, for example), and manage the consequences of that in your script yourself, in terms of which individuals can mate with which, and exactly how the offspring is produced.</p>
<p class="p9"><span class="s8"><b>The </b></span><span class="s9"><b>xDominanceCoeff</b></span><span class="s8"><b> parameter has been deprecated and removed.</b><span class="Apple-converted-space">  </span>In SLiM 5 and later, use the </span><span class="s9">hemizygousDominanceCoeff</span><span class="s8"> property of </span><span class="s9">MutationType</span><span class="s8"> instead.<span class="Apple-converted-space">  </span></span>If the <span class="s3">chromosomeType</span> is <span class="s3">"X"</span>, the optional <span class="s3">xDominanceCoeff</span> parameter can supply the dominance coefficient used when a mutation is present in an XY male, and is thus “heterozygous” (but in a different sense than the heterozygosity of an XX female with one copy of the mutation).</p>
<p class="p2">(void)initializeSLiMModelType(string$ modelType)</p>
<p class="p3"><span class="s1">Configure the type of SLiM model used for the simulation.<span class="Apple-converted-space">  </span>At present, one of two model types may be selected.<span class="Apple-converted-space">  </span>If </span><span class="s2">modelType</span><span class="s1"> is </span><span class="s2">"WF"</span><span class="s1">, SLiM will use a Wright-Fisher (WF) model; this is the model type that has always been supported by SLiM, and is the model type used if </span><span class="s2">initializeSLiMModelType()</span><span class="s1"> is not called.<span class="Apple-converted-space">  </span>If </span><span class="s2">modelType</span><span class="s1"> is </span><span class="s2">"nonWF"</span><span class="s1">, SLiM will use a non-Wright-Fisher (nonWF) model instead; this is a new model type supported by SLiM 3.0 and above.</span></p>
<p class="p3"><span class="s1">If </span><span class="s2">initializeSLiMModelType()</span><span class="s1"> is called at all then it must be called before any other initialization function, so that SLiM knows from the outset which features are enabled and which are not.</span></p>
<p class="p2">(void)initializeSLiMOptions([logical$ keepPedigrees = F], [string$ dimensionality = ""], [string$ periodicity = ""], [logical$ doMutationRunExperiments = T], [logical$ preventIncidentalSelfing = F]<span class="s5">, [logical$ nucleotideBased = F], [logical$ randomizeCallbacks = T]</span><span class="s8">, [logical$ checkInfiniteLoops = T]</span>)</p>
<p class="p3"><span class="s1">Configure options for the simulation.<span class="Apple-converted-space">  </span>If </span><span class="s2">initializeSLiMOptions()</span><span class="s1"> is called at all then it must be called before any other initialization function (except </span><span class="s2">initializeSLiMModelType()</span><span class="s1">), so that SLiM knows from the outset which optional features are enabled and which are not.</span></p>
<p class="p3">If <span class="s3">keepPedigrees</span> is <span class="s3">T</span>, SLiM will keep pedigree information for every individual in the simulation, tracking the identity of its parents and grandparents.<span class="Apple-converted-space">  </span>This allows individuals to assess their degree of pedigree-based relatedness to other individuals (see <span class="s3">Individual</span>’s <span class="s3">relatedness()</span> and <span class="s3">sharedParentCount()</span> methods), as well as allowing a model to find “trios” (two parents and an offspring they generated) using the pedigree properties of <span class="s3">Individual</span>.<span class="Apple-converted-space">  </span>As a side effect of <span class="s3">keepPedigrees</span> being <span class="s3">T</span>, the <span class="s3">pedigreeID</span>, <span class="s3">pedigreeParentIDs</span>, and <span class="s3">pedigreeGrandparentIDs</span> properties of <span class="s3">Individual</span> will have defined values, as will the <span class="s3">haplosomePedigreeID</span> property of <span class="s3">Haplosome</span>.<span class="Apple-converted-space">  </span>Note that pedigree-based relatedness doesn’t necessarily correspond to genetic relatedness, due to effects such as assortment and recombination.<span class="Apple-converted-space">  </span>Beginning in SLiM 3.5, <span class="s3">keepPedigrees=T</span> also enables tracking of individual reproductive output, available through the <span class="s3">reproductiveOutput</span> property of <span class="s3">Individual</span> and the <span class="s3">lifetimeReproductiveOutput</span> property of <span class="s3">Subpopulation</span>.</p>
<p class="p6">If <span class="s3">dimensionality</span> is not <span class="s3">""</span>, SLiM will enable its optional “continuous space” facility.<span class="Apple-converted-space">  </span>Three values for <span class="s3">dimensionality</span> are presently supported: <span class="s3">"x"</span>, <span class="s3">"xy"</span>, and <span class="s3">"xyz"</span>, specifying that continuous space should be enabled for one, two, or three dimensions, respectively, using (<i>x</i>), (<i>x</i>, <i>y</i>), and (<i>x</i>, <i>y</i>, <i>z</i>) coordinates respectively.<span class="Apple-converted-space">  </span>This has a number of side effects.<span class="Apple-converted-space">  </span>First of all, it means that the specified properties of <span class="s3">Individual</span> (<span class="s3">x</span>, <span class="s3">y</span>, and/or <span class="s3">z</span>) will be interpreted by SLiM as spatial positions; in particular, SLiMgui will use those properties to display subpopulations spatially.<span class="Apple-converted-space">  </span>Second, it allows spatial interactions to be defined, evaluated, and queried using <span class="s3">initializeInteractionType()</span> and <span class="s3">interaction()</span> callbacks.<span class="Apple-converted-space">  </span>And third, it enables the use of any other properties and methods related to continuous space, such as setting the spatial boundaries of subpopulations, which would otherwise raise an error.</p>
<p class="p3"><span class="s1">If </span><span class="s2">periodicity</span><span class="s1"> is not </span><span class="s2">""</span><span class="s1">, SLiM will designate the specified spatial dimensions as being periodic – wrapping around at the edges of the spatial boundaries of that dimension.<span class="Apple-converted-space">  </span>This option may only be used if the </span><span class="s2">dimensionality</span><span class="s1"> parameter to </span><span class="s2">initializeSLiMOptions()</span><span class="s1"> has been used to enable spatiality in the model, and only spatial dimensions that were specified in the dimensionality of the model may be declared to be periodic (but if desired, it is permissible to make just a subset of those dimensions periodic; it is not an all-or-none proposition).<span class="Apple-converted-space">  </span>For example, if the specified dimensionality is </span><span class="s2">"xy"</span><span class="s1">, the model’s periodicity may be </span><span class="s2">"x"</span><span class="s1">, </span><span class="s2">"y"</span><span class="s1">, or </span><span class="s2">"xy"</span><span class="s1"> (or </span><span class="s2">""</span><span class="s1">, the default, to specify that there are no periodic dimensions).<span class="Apple-converted-space">  </span>A one-dimensional periodic model would model a space like the perimeter of a circle.<span class="Apple-converted-space">  </span>A two-dimensional model periodic in one of those dimensions would model a space like a cylinder without its end caps; if periodic in both dimensions, the modeled space is a torus.<span class="Apple-converted-space">  </span>The shapes of three-dimensional periodic models are harder to visualize, but are essentially higher-dimensional analogues of these concepts.<span class="Apple-converted-space">  </span>Periodic boundary conditions are commonly used to model spatial scenarios without “edge effects”, since there are no edges in the periodic spatial dimensions.<span class="Apple-converted-space">  </span>The </span><span class="s2">pointPeriodic()</span><span class="s1"> method of </span><span class="s2">Subpopulation</span><span class="s1"> is typically used in conjunction with this option, to actually implement the periodic boundary condition for the specified dimensions.</span></p>
<p class="p3">The <span class="s3">doMutationRunExperiments</span> parameter specifies whether SLiM should attempt to conduct experiments at runtime to determine the optimal number of mutation runs used in the model.<span class="Apple-converted-space">  </span>This is a performance optimization.<span class="Apple-converted-space">  </span>If <span class="s3">doMutationRunExperiments</span> is <span class="s3">T</span> (the default), this optimization is enabled for all chromosomes that do not have an explicitly specified mutation run count; this is generally desirable and may significantly improve performance.<span class="Apple-converted-space">  </span>If <span class="s3">doMutationRunExperiments</span> is <span class="s3">F</span>, this optimization is disabled and chromosomes that do not have an explicitly specified mutation run count will simply use a single mutation run.<span class="Apple-converted-space">  </span>See the documentation for <span class="s3">initializeChromosome()</span> for further discussion.<span class="Apple-converted-space">  </span>Note that this parameter used to be <span class="s3">[integer$ mutationRuns = 0]</span>, specifying the mutation run count directly.<span class="Apple-converted-space">  </span>That parameter has been moved to <span class="s3">initializeChromosome()</span>, allowing a different mutation run count to be specified for each chromosome in multi-chromosome models.</p>
<p class="p6">If <span class="s3">preventIncidentalSelfing</span> is <span class="s3">T</span>, incidental selfing in hermaphroditic models will be prevented by SLiM.<span class="Apple-converted-space">  </span>By default (i.e., if <span class="s3">preventIncidentalSelfing</span> is <span class="s3">F</span>), SLiM chooses the first and second parents in a biparental mating event independently.<span class="Apple-converted-space">  </span>It is therefore possible for the same individual to be chosen as both the first and second parent, resulting in selfing events even when the selfing rate is zero.<span class="Apple-converted-space">  </span>In many models this is unimportant, since it happens fairly infrequently and does not have large consequences.<span class="Apple-converted-space">  </span>This behavior is SLiM’s default because it is the simplest option, and produces results that most closely align with simple analytical population genetics models.<span class="Apple-converted-space">  </span>However, in some models this selfing can be undesirable and problematic.<span class="Apple-converted-space">  </span>In particular, models that involve very high variance in fitness or very small effective population sizes may see elevated rates of selfing that substantially influence model results.<span class="Apple-converted-space">  </span>If <span class="s3">preventIncidentalSelfing</span> is set to <span class="s3">T</span>, all such incidental selfing will be prevented (by choosing a new second parent if the first parent was chosen again).<span class="Apple-converted-space">  </span>Non-incidental selfing, as requested by the selfing rate, will still be permitted.<span class="Apple-converted-space">  </span>Note that if incidental selfing is prevented, SLiM will hang if it is unable to find a different second parent; there must always be at least two individuals in the population with non-zero fitness, and <span class="s3">mateChoice()</span> and <span class="s3">modifyChild()</span> callbacks must not absolutely prevent those two individuals from producing viable offspring.<span class="Apple-converted-space">  </span>Enforcement of the prohibition on incidental selfing will occur after <span class="s3">mateChoice()</span> callbacks have been called (and thus the default mating weights provided to <span class="s3">mateChoice()</span> callbacks will <i>not</i> exclude the first parent!), but will occur before <span class="s3">modifyChild()</span> callbacks are called (so those callbacks may assume that the first and second parents are distinct).</p>
<p class="p3"><span class="s1">If </span><span class="s2">nucleotideBased</span><span class="s1"> is </span><span class="s2">T</span><span class="s1">, the model will be nucleotide-based.<span class="Apple-converted-space">  </span>In this case, auto-generated mutations (i.e., mutation types used by genomic element types) must be nucleotide-based, and an ancestral nucleotide sequence must be supplied with </span><span class="s2">initializeAncestralNucleotides()</span><span class="s1">.<span class="Apple-converted-space">  </span>Non-nucleotide-based mutations may still be used, but may not be referenced by genomic element types.<span class="Apple-converted-space">  </span>A mutation rate (or rate map) may not be supplied with </span><span class="s2">initializeMutationRate()</span><span class="s1">; instead, a hotspot map may (optionally) be supplied with </span><span class="s2">initializeHotspotMap()</span><span class="s1">.<span class="Apple-converted-space">  </span>This choice has many consequences across SLiM.<span class="Apple-converted-space"> </span></span></p>
<p class="p3">If <span class="s3">randomizeCallbacks</span> is <span class="s3">T</span> (the default), the order in which individuals are processed in callbacks will be randomized to make it easier to avoid order-dependency bugs.<span class="Apple-converted-space">  </span>This flag exists because the order of individuals in each subpopulation is non-random; most notably, females always come before males in the individuals vector, but non-random ordering may also occur with respect to things like migrant versus non-migrant status, origin by selfing versus cloning versus biparental mating, and other factors.<span class="Apple-converted-space">  </span>When this option is <span class="s3">F</span>, individuals in a subpopulation are processed in the order of the individuals vector in each tick cycle stage, which may lead to order-dependency issues if there is an enabled callback whose behavior is not fully independent between calls.<span class="Apple-converted-space">  </span>Setting this option to <span class="s3">T</span> will cause individuals within each subpopulation to be processed in a randomized order in each tick cycle stage; specifically, this randomizes the order of calls to <span class="s3">mutationEffect()</span> callbacks in both WF and nonWF models, and calls to <span class="s3">reproduction()</span> and <span class="s3">survival()</span> callbacks in nonWF models.<span class="Apple-converted-space">  </span>Each subpopulation is still processed separately, in sequential order, so order-dependency issues between subpopulations are still possible if callbacks have effects that are not fully independent.<span class="Apple-converted-space">  </span>This feature was added in SLiM 4, breaking backward compatibility; to recover the behavior of previous versions of SLiM, pass <span class="s3">F</span> for this option (but then be very careful about order-dependency issues in your script).<span class="Apple-converted-space">  </span>The default of <span class="s3">T</span> is the safe option, but a small speed penalty is incurred by the randomization of the processing order – for most models the difference will be less than 1%, but in the worst case it may approach 10%.<span class="Apple-converted-space">  </span>Models that do not have any order-dependency issue may therefore run somewhat faster if this is set to <span class="s3">F</span>.<span class="Apple-converted-space">  </span>Note that anywhere that your script uses the <span class="s3">individuals</span> property of <span class="s3">Subpopulation</span>, the order of individuals returned will be non-random (regardless of the setting of this option); you should use <span class="s3">sample()</span> to shuffle the order of the individuals vector if necessary to avoid order-dependency issues in your script.</p>
<p class="p3">If <span class="s3">checkInfiniteLoops</span> is <span class="s3">T</span> (the default), SLiM and Eidos will check for infinite loops in various circumstances, such as <span class="s3">while</span> and <span class="s3">do–while</span> loops.<span class="Apple-converted-space">  </span>This check is conducted only when running in SLiMgui; at the command line, checks for infinite loops are never conducted regardless of the value of this flag.<span class="Apple-converted-space">  </span>When checking is enabled, an error will be raised if any loop executes more than 10 million times, preventing SLiMgui’s user interface from freezing.<span class="Apple-converted-space">  </span>Normally this is desirable, but if you actually want to execute a loop more than 10 million times, this checking will prove inconvenient.<span class="Apple-converted-space">  </span>In that case, you can pass <span class="s3">F</span> for <span class="s3">checkInfiniteLoops</span> to disable these checks.<span class="Apple-converted-space">  </span>There is no way to turn these checks on or off for individual loops; it is a global setting.</p>
<p class="p6">This function will likely be extended with further options in the future, added on to the end of the argument list.<span class="Apple-converted-space">  </span>Using named arguments with this call is recommended for readability.<span class="Apple-converted-space">  </span>Note that turning on optional features may increase the runtime and memory footprint of SLiM.</p>
<p class="p4">(void)initializeSpecies([integer$ tickModulo = 1], [integer$ tickPhase = 1], [string$ avatar = ""], [string$ color = ""])</p>
<p class="p3">Configure options for the species being initialized.<span class="Apple-converted-space">  </span>This initialization function may only be called in multispecies models (i.e., models with explicit species declarations); in single-species models, the default values are assumed and cannot be changed.</p>
<p class="p3">The <span class="s3">tickModulo</span> and <span class="s3">tickPhase</span> parameters determine the activation schedule for the species.<span class="Apple-converted-space">  </span>The <span class="s3">active</span> property of the species will be set to <span class="s3">T</span> (thus activating the species) every <span class="s3">tickModulo</span> ticks, beginning in tick <span class="s3">tickPhase</span>.<span class="Apple-converted-space">  </span>(However, when the species is activated in a given tick, the <span class="s3">skipTick()</span> method may still be called in a <span class="s3">first()</span> event to deactivate it.)<span class="Apple-converted-space">  </span>See the <span class="s3">active</span> property of <span class="s3">Species</span> for more details.</p>
<p class="p3">The <span class="s3">avatar</span> parameter, if not <span class="s3">""</span>, sets a <span class="s3">string</span> value used to represent the species graphically, particularly in SLiMgui but perhaps in other contexts also.<span class="Apple-converted-space">  </span>The <span class="s3">avatar</span> should generally be a single character – usually an emoji corresponding to the species, such as <span class="s3">"</span><span class="s10">🦊</span><span class="s3">"</span> for foxes or <span class="s3">"</span><span class="s10">🐭</span><span class="s3">"</span> for mice.<span class="Apple-converted-space">  </span>If <span class="s3">avatar</span> is the empty string, <span class="s3">""</span>, SLiMgui will choose a default avatar.</p>
<p class="p3">The <span class="s3">color</span> parameter, if not <span class="s3">""</span>, sets a <span class="s3">string</span> color value used to represent the species in SLiMgui.<span class="Apple-converted-space">  </span>Colors may be specified by name, or with hexadecimal RGB values of the form <span class="s3">"#RRGGBB"</span> (see the Eidos manual for details).<span class="Apple-converted-space">  </span>If <span class="s3">color</span> is the empty string, <span class="s3">""</span>, SLiMgui will choose a default color.</p>
<p class="p4"><span class="s1">(void)initializeTreeSeq([logical$ recordMutations = T], [Nif$ simplificationRatio = NULL], [Ni$ simplificationInterval = NULL], [logical$ checkCoalescence = F], [logical$ runCrosschecks = F], [logical$ </span>retainCoalescentOnly<span class="s1"> = T]</span>, [Ns$ timeUnit = NULL]<span class="s1">)</span></p>
<p class="p3">Configure options for tree sequence recording.<span class="Apple-converted-space">  </span>Calling this function turns on tree sequence recording, as a side effect, for later reconstruction of the simulation’s evolutionary dynamics; if you do not want tree sequence recording to be enabled, do not call this function.<span class="Apple-converted-space">  </span>Note that tree-sequence recording internally uses SLiM’s “pedigree tracking” feature to uniquely identify individuals and haplosomes; however, if you want to use pedigree tracking in your script you must still enable it yourself with <span class="s3">initializeSLiMOptions(keepPedigrees=T)</span>.<span class="Apple-converted-space">  </span>A separate tree sequence will be recorded for each chromosome in the simulation, as configured with <span class="s3">initializeChromosome()</span>.</p>
<p class="p3">The <span class="s3">recordMutations</span> flag controls whether information about individual mutations is recorded or not.<span class="Apple-converted-space">  </span>Such recording takes time and memory, and so can be turned off if only the tree sequence itself is needed, but it is turned on by default since mutation recording is generally useful.</p>
<p class="p3">The <span class="s3">simplificationRatio</span> and <span class="s3">simplificationInterval</span> parameters control how often automatic simplification of the recorded tree sequence occurs.<span class="Apple-converted-space">  </span>This is a speed–memory tradeoff: more frequent simplification (lower <span class="s3">simplificationRatio</span> or smaller <span class="s3">simplificationInterval</span>) means the stored tree sequences will use less memory, but at a cost of somewhat longer run times.<span class="Apple-converted-space">  </span>Conversely, a larger <span class="s3">simplificationRatio</span> or <span class="s3">simplificationInterval</span> means that SLiM will wait longer between simplifications.<span class="Apple-converted-space">  </span>There are three ways these parameters can be used.<span class="Apple-converted-space">  </span>With the first option, with a non-<span class="s3">NULL</span> <span class="s3">simplificationRatio</span> and a <span class="s3">NULL</span> value for <span class="s3">simplificationInterval</span>, SLiM will try to find an optimal tick interval for simplification such that the ratio of the memory used by the tree sequence tables, (before:after) simplification, is close to the requested ratio. The default of <span class="s3">10</span> (used if both <span class="s3">simplificationRatio</span> and <span class="s3">simplificationInterval</span> are <span class="s3">NULL</span>) thus requests that SLiM try to find a tick interval such that the maximum size of the stored tree sequences is ten times the size after simplification. <span class="s3">INF</span> may be supplied to indicate that automatic simplification should never occur; <span class="s3">0</span> may be supplied to indicate that automatic simplification should be performed at the end of every tick.<span class="Apple-converted-space">  </span>Alternatively – the second option – <span class="s3">simplificationRatio</span> may be <span class="s3">NULL</span> and <span class="s3">simplificationInterval</span> may be set to the interval, in ticks, between simplifications.<span class="Apple-converted-space">  </span>This may provide more reliable performance, but the interval must be chosen carefully to avoid exceeding the available memory.<span class="Apple-converted-space">  </span>The <span class="s3">simplificationInterval</span> value may be a very large number to specify that simplification should never occur (not <span class="s3">INF</span>, though, since it is an <span class="s3">integer</span> value), or <span class="s3">1</span> to simplify every tick.<span class="Apple-converted-space">  </span>Finally – the third option – both parameters may be non-<span class="s3">NULL</span>, in which case <span class="s3">simplificationRatio</span> is used as described above, while <span class="s3">simplificationInterval</span> provides the <i>initial</i> interval first used by SLiM (and then subsequently increased or decreased to try to match the requested simplification ratio).<span class="Apple-converted-space">  </span>The default initial interval, used when <span class="s3">simplificationInterval</span> is <span class="s3">NULL</span>, is usually <span class="s3">20</span>; this is chosen to be relatively frequent, and thus unlikely to lead to a memory overflow, but it can result in rather slow spool-up for models where the equilibrium simplification interval, as determined by the simplification ratio, is much longer.<span class="Apple-converted-space">  </span>It can therefore be helpful to set a larger initial interval so that the early part of the model run is not excessively bogged down in simplification.</p>
<p class="p3">The <span class="s3">checkCoalescence</span> parameter controls whether a check for full coalescence is conducted after each simplification.<span class="Apple-converted-space">  </span>If a model will call <span class="s3">treeSeqCoalesced()</span> to check for coalescence during its execution, <span class="s3">checkCoalescence</span> should be set to <span class="s3">T</span>.<span class="Apple-converted-space">  </span>Since the coalescence checks entail a performance penalty, the default of <span class="s3">F</span> is preferable otherwise.<span class="Apple-converted-space">  </span>See the documentation for <span class="s3">treeSeqCoalesced()</span> for further discussion.</p>
<p class="p3">The <span class="s3">runCrosschecks</span> parameter controls whether cross-checks between SLiM’s internal data structures and the tree-sequence recording data structures will be conducted.<span class="Apple-converted-space">  </span>These two sets of data structures record much the same thing (mutations in haplosomes), but using completely different representations, so such cross-checks can be useful to confirm that the two data structures do indeed represent the same conceptual state.<span class="Apple-converted-space">  </span>This slows down the model considerably, however, and would normally be turned on only for debugging purposes, so it is turned off by default.</p>
<p class="p3">The <span class="s3">retainCoalescentOnly</span> parameter controls how, exactly, simplification of the tree-sequence data is performed in SLiM (both for auto-simplification and for calls to <span class="s3">treeSeqSimplify()</span>).<span class="Apple-converted-space">  </span>More specifically, this parameter controls the behavior of simplification for individuals and haplosomes that have been “retained” by calling <span class="s3">treeSeqRememberIndividuals()</span> with the parameter <span class="s3">permanent=F</span>.<span class="Apple-converted-space">  </span>The default of <span class="s3">retainCoalescentOnly=T</span> helps to keep the number of retained individuals relatively small, which is helpful if your simulation regularly flags many individuals for retaining.<span class="Apple-converted-space">  </span>In this case, changing <span class="s3">retainCoalescentOnly</span> to <span class="s3">F</span> may dramatically increase memory usage and runtime, in a similar way to permanently remembering all the individuals.<span class="Apple-converted-space">  </span>See the documentation of <span class="s3">treeSeqRememberIndividuals()</span> for further discussion.</p>
<p class="p3">The <span class="s3">timeUnit</span> parameter controls the time unit stated in the tree sequence when it is saved (which can be accessed through <span class="s3">tskit</span> APIs); it has no effect on the running simulation whatsoever.<span class="Apple-converted-space">  </span>The default value, <span class="s3">NULL</span>, means that a time unit of <span class="s3">"ticks"</span> will be used for all model types.<span class="Apple-converted-space">  </span>(In SLiM 3.7 / 3.7.1, <span class="s3">NULL</span> implied a time unit of <span class="s3">"generations"</span> for WF models, but <span class="s3">"ticks"</span> for nonWF models; given the new multispecies timescale parameters in SLiM 4, a default of <span class="s3">"ticks"</span> makes sense in all cases since now even in WF models one tick might not equal one biological generation.)<span class="Apple-converted-space">  </span>It may be helpful to set <span class="s3">timeUnit</span> to <span class="s3">"generations"</span> explicitly when modeling non-overlapping generations in which one tick equals one generation, to tell <span class="s3">tskit</span> that the time unit does in fact represent biological generations; doing so may avoid warnings from <span class="s3">tskit</span> or <span class="s3">msprime</span> regarding the time unit, in cases such as recapitation where the simulation timescale is important.</p>
<p class="p1"><b>3.2.<span class="Apple-converted-space">  </span>Nucleotide utilities</b></p>
<p class="p4"><span class="s1">(is)codonsToAminoAcids(integer codons, [li$ long = F], [logical$ paste = T])</span></p>
<p class="p3">Returns the amino acid sequence corresponding to the codon sequence in <span class="s3">codons</span>.<span class="Apple-converted-space">  </span>Codons should be represented with values in [<span class="s3">0</span>, <span class="s3">63</span>] where AAA is <span class="s3">0</span>, AAC is <span class="s3">1</span>, AAG is <span class="s3">2</span>, and TTT is <span class="s3">63</span>; see <span class="s3">ancestralNucleotides()</span> for discussion of this encoding.<span class="Apple-converted-space">  </span>If <span class="s3">long</span> is <span class="s3">F</span> (the default), the standard single-letter codes for amino acids will be used (where Serine is <span class="s3">"S"</span>, etc.); if <span class="s3">long</span> is <span class="s3">T</span>, the standard three-letter codes will be used instead (where Serine is <span class="s3">"Ser"</span>, etc.).<span class="Apple-converted-space">  </span>Beginning in SLiM 3.5, if <span class="s3">long</span> is <span class="s3">0</span>, <span class="s3">integer</span> codes will be used as follows (and <span class="s3">paste</span> will be ignored):</p>
<p class="p10">stop (TAA, TAG, TGA)<span class="Apple-tab-span">	</span><span class="s3">0</span><br>
Alanine<span class="Apple-tab-span">	</span><span class="s3">1</span><br>
Arginine<span class="Apple-tab-span">	</span><span class="s3">2</span><br>
Asparagine<span class="Apple-tab-span">	</span><span class="s3">3</span><br>
Aspartic acid (Aspartate)<span class="Apple-tab-span">	</span><span class="s3">4</span><br>
Cysteine<span class="Apple-tab-span">	</span><span class="s3">5</span><br>
Glutamine<span class="Apple-tab-span">	</span><span class="s3">6</span><br>
Glutamic acid (Glutamate)<span class="Apple-tab-span">	</span><span class="s3">7</span><br>
Glycine<span class="Apple-tab-span">	</span><span class="s3">8</span><br>
Histidine<span class="Apple-tab-span">	</span><span class="s3">9</span><br>
Isoleucine<span class="Apple-tab-span">	</span><span class="s3">10</span><br>
Leucine<span class="Apple-tab-span">	</span><span class="s3">11</span><br>
Lysine<span class="Apple-tab-span">	</span><span class="s3">12</span><br>
Methionine<span class="Apple-tab-span">	</span><span class="s3">13</span><br>
Phenylalanine<span class="Apple-tab-span">	</span><span class="s3">14</span><br>
Proline<span class="Apple-tab-span">	</span><span class="s3">15</span><br>
Serine<span class="Apple-tab-span">	</span><span class="s3">16</span><br>
Threonine<span class="Apple-tab-span">	</span><span class="s3">17</span><br>
Tryptophan<span class="Apple-tab-span">	</span><span class="s3">18</span><br>
Tyrosine<span class="Apple-tab-span">	</span><span class="s3">19</span><br>
Valine<span class="Apple-tab-span">	</span><span class="s3">20</span></p>
<p class="p3">There does not seem to be a widely used standard for integer coding of amino acids, so SLiM just numbers them alphabetically, making stop codons <span class="s3">0</span>.<span class="Apple-converted-space">  </span>If you want a different coding, you can make your own 64-element vector and use it to convert codons to whatever integer codes you need.<span class="Apple-converted-space">  </span>Other <span class="s3">integer</span> values of <span class="s3">long</span> are reserved for future use (to support other codings), and will currently produce an error.</p>
<p class="p3">When <span class="s3">long</span> is <span class="s3">T</span> or <span class="s3">F</span> and <span class="s3">paste</span> is <span class="s3">T</span> (the default), the amino acid sequence returned will be a singleton <span class="s3">string</span>, such as <span class="s3">"LYATI"</span> (when <span class="s3">long</span> is <span class="s3">F</span>) or <span class="s3">"Leu-Tyr-Ala-Thr-Ile"</span> (when <span class="s3">long</span> is <span class="s3">T</span>).<span class="Apple-converted-space">  </span>When <span class="s3">long</span> is <span class="s3">T</span> or <span class="s3">F</span> and <span class="s3">paste</span> is <span class="s3">F</span>, the amino acid sequence will instead be returned as a <span class="s3">string</span> vector, with one element per amino acid, such as <span class="s3">"L" "Y" "A" "T" "I"</span> (when <span class="s3">long</span> is <span class="s3">F</span>) or <span class="s3">"Leu" "Tyr" "Ala" "Thr" "Ile"</span> (when <span class="s3">long</span> is <span class="s3">T</span>).<span class="Apple-converted-space">  </span>Using the <span class="s3">paste=T</span> option is considerably faster than using <span class="s3">paste()</span> in script.</p>
<p class="p3"><span class="s1">This function interprets the supplied codon sequence as the <i>sense</i> strand (i.e., the strand that is <i>not</i> transcribed, and which mirrors the mRNA’s sequence).<span class="Apple-converted-space">  </span>This uses the standard DNA codon table directly.<span class="Apple-converted-space">  </span>For example, if the nucleotide sequence is CAA TTC, that will correspond to a codon vector of </span><span class="s2">16 61</span><span class="s1">, and will result in the amino acid sequence Gln-Phe (</span><span class="s2">"QF"</span><span class="s1">).</span></p>
<p class="p4"><span class="s1">(is)codonsToNucleotides(integer codons, [string$ format = "string"])</span></p>
<p class="p3"><span class="s1">Returns the nucleotide sequence corresponding to the codon sequence supplied in </span><span class="s2">codons</span><span class="s1">.<span class="Apple-converted-space">  </span>Codons should be represented with values in [</span><span class="s2">0</span><span class="s1">, </span><span class="s2">63</span><span class="s1">] where AAA is </span><span class="s2">0</span><span class="s1">, AAC is </span><span class="s2">1</span><span class="s1">, AAG is </span><span class="s2">2</span><span class="s1">, and TTT is </span><span class="s2">63</span><span class="s1">; see </span><span class="s2">ancestralNucleotides()</span><span class="s1"> for discussion of this encoding.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">format</span><span class="s1"> parameter controls the format of the returned sequence.<span class="Apple-converted-space">  </span>It may be </span><span class="s2">"string"</span><span class="s1"> to obtain the sequence as a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATACG"</span><span class="s1">), </span><span class="s2">"char"</span><span class="s1"> to obtain it as a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"C"</span><span class="s1">, </span><span class="s2">"G"</span><span class="s1">), or </span><span class="s2">"integer"</span><span class="s1"> to obtain it as an </span><span class="s2">integer</span><span class="s1"> vector (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">1</span><span class="s1">, </span><span class="s2">2</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)mm16To256(float mutationMatrix16)</span></p>
<p class="p3"><span class="s1">Returns a 64×4 mutation matrix that is functionally identical to the supplied 4×4 mutation matrix in </span><span class="s2">mutationMatrix16</span><span class="s1">.<span class="Apple-converted-space">  </span>The mutation rate for each of the 64 trinucleotides will depend only upon the central nucleotide of the trinucleotide, and will be taken from the corresponding entry for the same nucleotide in </span><span class="s2">mutationMatrix16</span><span class="s1">.<span class="Apple-converted-space">  </span>This function can be used to easily construct a simple trinucleotide-based mutation matrix which can then be modified so that specific trinucleotides sustain a mutation rate that does not depend only upon their central nucleotide.</span></p>
<p class="p3"><span class="s1">See the documentation for </span><span class="s2">initializeGenomicElementType()</span><span class="s1"> for further discussion of how these 64×4 mutation matrices are interpreted and used.</span></p>
<p class="p4"><span class="s1">(float)mmJukesCantor(float$ alpha)</span></p>
<p class="p3"><span class="s1">Returns a mutation matrix representing a Jukes–Cantor (1969) model with mutation rate </span><span class="s2">alpha</span><span class="s1"> to each possible alternative nucleotide at a site.<span class="Apple-converted-space">  </span>This 2×2 matrix is suitable for use with </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>Note that the actual mutation rate produced by this matrix is </span><span class="s2">3*alpha</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)mmKimura(float$ alpha, float$ beta)</span></p>
<p class="p3"><span class="s1">Returns a mutation matrix representing a Kimura (1980) model with transition rate </span><span class="s2">alpha</span><span class="s1"> and transversion rate </span><span class="s2">beta</span><span class="s1">.<span class="Apple-converted-space">  </span>This 2×2 matrix is suitable for use with </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>Note that the actual mutation rate produced by this model is </span><span class="s2">alpha+2*beta</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(integer)nucleotideCounts(is sequence)</span></p>
<p class="p3"><span class="s1">A convenience function that returns an </span><span class="s2">integer</span><span class="s1"> vector of length four, providing the number of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.<span class="Apple-converted-space">  </span>The parameter sequence may be a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector (e.g., 3, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)nucleotideFrequencies(is sequence)</span></p>
<p class="p3"><span class="s1">A convenience function that returns a </span><span class="s2">float</span><span class="s1"> vector of length four, providing the frequencies of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.<span class="Apple-converted-space">  </span>The parameter sequence may be a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector (e.g., 3, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(integer)nucleotidesToCodons(is sequence)</span></p>
<p class="p3"><span class="s1">Returns the codon sequence corresponding to the nucleotide sequence in </span><span class="s2">sequence</span><span class="s1">.<span class="Apple-converted-space">  </span>The codon sequence is an </span><span class="s2">integer</span><span class="s1"> vector with values from </span><span class="s2">0</span><span class="s1"> to </span><span class="s2">63</span><span class="s1">, based upon successive nucleotide triplets in the nucleotide sequence.<span class="Apple-converted-space">  </span>The codon value for a given nucleotide triplet XYZ is 16X + 4Y + Z, where X, Y, and Z have the usual values A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>For example, the triplet AAA has a codon value of </span><span class="s2">0</span><span class="s1">, AAC is </span><span class="s2">1</span><span class="s1">, AAG is </span><span class="s2">2</span><span class="s1">, AAT is </span><span class="s2">3</span><span class="s1">, ACA is </span><span class="s2">4</span><span class="s1">, and on upward to TTT which is </span><span class="s2">63</span><span class="s1">.<span class="Apple-converted-space">  </span>If the nucleotide sequence AACACATTT is passed in, the codon vector </span><span class="s2">1 4 63</span><span class="s1"> will therefore be returned.<span class="Apple-converted-space">  </span>These codon values can be useful in themselves; they can also be passed to </span><span class="s2">codonsToAminoAcids()</span><span class="s1"> to translate them into the corresponding amino acid sequence if desired.</span></p>
<p class="p3"><span class="s1">The nucleotide sequence in </span><span class="s2">sequence</span><span class="s1"> may be supplied in any of three formats: a </span><span class="s2">string</span><span class="s1"> vector with single-letter nucleotides (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), a singleton </span><span class="s2">string</span><span class="s1"> of nucleotide letters (e.g., </span><span class="s2">"TATA"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector of nucleotide values (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">) using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>If the choice of format is not driven by other considerations, such as ease of manipulation, then the singleton </span><span class="s2">string</span><span class="s1"> format will certainly be the most memory-efficient for long sequences, and will probably also be the fastest.<span class="Apple-converted-space">  </span>The nucleotide sequence provided must be a multiple of three in length, so that it translates to an integral number of codons.</span></p>
<p class="p2">(is)randomNucleotides(integer$ length, [Nif basis = NULL], [string$ format = "string"])</p>
<p class="p3"><span class="s1">Generates a new random nucleotide sequence with </span><span class="s2">length</span><span class="s1"> bases.<span class="Apple-converted-space">  </span>The four nucleotides ACGT are equally probable if </span><span class="s2">basis</span><span class="s1"> is </span><span class="s2">NULL</span><span class="s1"> (the default); otherwise, </span><span class="s2">basis</span><span class="s1"> may be a 4-element </span><span class="s2">integer</span><span class="s1"> or </span><span class="s2">float</span><span class="s1"> vector providing relative fractions for A, C, G, and T respectively (these need not sum to </span><span class="s2">1.0</span><span class="s1">, as they will be normalized).<span class="Apple-converted-space">  </span>More complex generative models such as Markov processes are not supported intrinsically in SLiM at this time, but arbitrary generated sequences may always be loaded from files on disk.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">format</span><span class="s1"> parameter controls the format of the returned sequence.<span class="Apple-converted-space">  </span>It may be </span><span class="s2">"string"</span><span class="s1"> to obtain the generated sequence as a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), </span><span class="s2">"char"</span><span class="s1"> to obtain it as a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or </span><span class="s2">"integer"</span><span class="s1"> to obtain it as an </span><span class="s2">integer</span><span class="s1"> vector (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3, 0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>For passing directly to </span><span class="s2">initializeAncestralNucleotides()</span><span class="s1">, format </span><span class="s2">"string"</span><span class="s1"> (a singleton string) will certainly be the most memory-efficient, and probably also the fastest.<span class="Apple-converted-space">  </span>Memory efficiency can be a significant consideration; the nucleotide sequence for a chromosome of length 10</span><span class="s11"><sup>9</sup></span><span class="s1"> will occupy approximately 1 GB of memory when stored as a singleton string (with one byte per nucleotide), and much more if stored in the other formats.<span class="Apple-converted-space">  </span>However, the other formats can be easier to work with in Eidos, and so may be preferable for relatively short chromosomes if you are manipulating the generated sequence.</span></p>
<p class="p1"><b>3.3.<span class="Apple-converted-space">  </span>Population genetics utilities</b></p>
<p class="p4">(float$)calcDxy(object&lt;Haplosome&gt; haplosomes1, object&lt;Haplosome&gt; haplosomes2, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL], [logical$ normalize = F])</p>
<p class="p3">Calculates the estimated <i>D</i><span class="s4"><sub>xy</sub></span> between two <span class="s3">Haplosome</span> vectors for the set of mutations given in <span class="s3">muts</span>.<span class="Apple-converted-space">  </span><i>D</i><span class="s4"><sub>xy</sub></span> is the expected number of differences between two sequences, typically drawn from two different subpopulations whose haplosomes are given in <span class="s3">haplosomes1</span> and <span class="s3">haplosomes2</span>.<span class="Apple-converted-space">  </span>It is therefore a metric of genetic divergence, comparable in some respects to <i>F</i><span class="s4"><sub>ST</sub></span>; see Cruickshank and Hahn (2014, Molecular Ecology) for a discussion of <i>F</i><span class="s4"><sub>ST</sub></span> versus <i>D</i><span class="s4"><sub>xy</sub></span>.<span class="Apple-converted-space">  </span>This method implements <i>D</i><span class="s4"><sub>xy</sub></span> as defined by Nei (1987) in Molecular Evolutionary Genomics (eq. 10.20), with optimizations for computational efficiency based upon an assumption that that multiallelic loci are rare (this is compatible with the infinite-sites model).</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full haplosomes – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the haplosome-wide <i>D</i><span class="s4"><sub>xy</sub></span>.</p>
<p class="p3">If <span class="s3">normalize</span> is <span class="s3">F</span> (the default), the returned <span class="s3">float</span> value is simply the expected number of differences, following Nei.<span class="Apple-converted-space">  </span>Often, however, it will be desirable to normalize that value by dividing by the length of the sequence considered, yielding the expected number of differences <i>per site</i>, a metric that then does not depend upon the sequence length; passing <span class="s3">normalize=T</span> will return that normalized value, and that is probably what most users of this function will want.</p>
<p class="p3">The implementation of <span class="s3">calcDxy()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation in <span class="s3">muts</span> as independent in its calculations (similar to <span class="s3">calcPi()</span>); in other words, if mutations are stacked, the <i>D</i><span class="s4"><sub>xy</sub></span> value calculated is <i>by mutation</i>, not <i>by site</i>.<span class="Apple-converted-space">  </span>Similarly, if multiple <span class="s3">Mutation</span> objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each <span class="s3">Mutation</span> object is treated separately for purposes of the calculation, just as if they were at different sites.<span class="Apple-converted-space">  </span>One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of these choices will be negligible; however, in some models these distinctions may be important.<span class="Apple-converted-space">  </span>See <span class="s3">calcPairHeterozygosity()</span> for further discussion.</p>
<p class="p3">All haplosomes and mutations must be associated with the same chromosome.<span class="Apple-converted-space">  </span>If <span class="s3">muts</span> is <span class="s3">NULL</span> (the default), all mutations in the population associated with the same chromosome as the given haplosomes will be used.</p>
<p class="p3">This function was written by Vitor Sudbrack (currently affiliated with University of Lausanne).</p>
<p class="p4">(float$)calcFST(object&lt;Haplosome&gt; haplosomes1, object&lt;Haplosome&gt; haplosomes2, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates the <i>F</i><span class="s4"><sub>ST</sub></span> between two <span class="s3">Haplosome</span> vectors – typically, but not necessarily, the haplosomes that constitute two different subpopulations (which we will assume for the purposes of this discussion).<span class="Apple-converted-space">  </span>In general, higher <i>F</i><span class="s4"><sub>ST</sub></span> indicates greater genetic divergence between subpopulations.<span class="Apple-converted-space">  </span>The haplosomes may be associated with more than one chromosome, in a multi-chromosome model; if so, <span class="s3">haplosomes1</span> and <span class="s3">haplosomes2</span> must be associated with the same set of chromosomes, defining the focal set of chromosomes for the calculation.</p>
<p class="p3">The calculation is done using only the mutations in <span class="s3">muts</span>; if <span class="s3">muts</span> is <span class="s3">NULL</span>, all mutations associated with the focal chromosomes are used.<span class="Apple-converted-space">  </span>The <span class="s3">muts</span> parameter can be used to calculate the <i>F</i><span class="s4"><sub>ST</sub></span> only for a particular mutation type (by passing only mutations of that type), for example; it can focus the calculation on particular mutations of interest.<span class="Apple-converted-space">  </span>The mutations in <span class="s3">muts</span> must always be associated with the focal chromosomes.</p>
<p class="p3">If there is a single focal chromosome, the calculation can be narrowed to apply to only a window – a subrange of the focal chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the chromosome-wide <i>F</i><span class="s4"><sub>ST</sub></span>, which is often used to assess the overall level of genetic divergence between sister species or allopatric subpopulations.</p>
<p class="p3">The code for <span class="s3">calcFST()</span> is, roughly, an Eidos implementation of Wright’s definition of <i>F</i><span class="s4"><sub>ST</sub></span> (but see below for further discussion and clarification):</p>
<p class="p3"><i>F</i><span class="s4"><sub>ST</sub></span><span class="s1"> = 1 - <i>H</i></span><span class="s4"><sub>S</sub></span><span class="s1"> / <i>H</i></span><span class="s4"><sub>T</sub></span></p>
<p class="p3">where <i>H</i><span class="s4"><i><sub>S</sub></i></span> is the average heterozygosity in the two subpopulations, and <i>H</i><span class="s4"><i><sub>T </sub></i></span>is the total heterozygosity when both subpopulations are combined.<span class="Apple-converted-space">  </span>In this implementation, the two haplosome vectors are weighted equally, not weighted by their size.<span class="Apple-converted-space">  </span>In SLiM 3, the implementation followed Wright’s definition closely, and returned the <i>average of ratios</i>: <span class="s3">mean(1.0 - H_s/H_t)</span>, in the Eidos code.<span class="Apple-converted-space">  </span>In SLiM 4, it returns the <i>ratio of averages</i> instead: <span class="s3">1.0 - mean(H_s)/mean(H_t)</span>.<span class="Apple-converted-space">  </span>In other words, the <i>F</i><span class="s4"><sub>ST</sub></span> value reported by SLiM 4 is an average across the specified mutations in the two sets of haplosomes, where <span class="s3">H_s</span> and <span class="s3">H_t</span> are first averaged across all specified mutations prior to taking the ratio of the two.<span class="Apple-converted-space">  </span>This ratio of averages is less biased than the average of ratios, and and is generally considered to be best practice (see, e.g., Bhatia et al., 2013).<span class="Apple-converted-space">  </span>This means that the behavior of <span class="s3">calcFST()</span> differs between SLiM 3 and SLiM 4.</p>
<p class="p3">As can be seen from its equation, the <i>F</i><span class="s4"><sub>ST</sub></span> is undefined if <i>H</i><span class="s4"><i><sub>T</sub></i></span> is zero, which occurs if no mutations are present in the haplosomes provided (given the optionally specified window and set of mutations).<span class="Apple-converted-space">  </span>In that case, <span class="s3">calcFST()</span> will return <span class="s3">NAN</span>.<span class="Apple-converted-space">  </span>It is up to the caller to detect this with <span class="s3">isNAN()</span> and handle it as necessary.</p>
<p class="p3">The implementation of <span class="s3">calcFST()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation in <span class="s3">muts</span> as independent in the heterozygosity calculations; in other words, if mutations are stacked, the heterozygosity calculated is <i>by mutation</i>, not <i>by site</i>.<span class="Apple-converted-space">  </span>Similarly, if multiple <span class="s3">Mutation</span> objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each <span class="s3">Mutation</span> object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.<span class="Apple-converted-space">  </span>One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of these choices will be negligible; however, in some models these distinctions may be important.</p>
<p class="p4">(float$)calcHeterozygosity(object&lt;Haplosome&gt; haplosomes, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates the heterozygosity for a vector of haplosomes (containing at least one element), based upon the frequencies of mutations in the haplosomes.<span class="Apple-converted-space">  </span>The result is the <i>expected</i> heterozygosity, for the individuals to which the haplosomes belong, assuming that they are under Hardy-Weinberg equilibrium; this can be compared to the <i>observed</i> heterozygosity of an individual, as calculated by <span class="s3">calcPairHeterozygosity()</span>.<span class="Apple-converted-space">  </span>Often <span class="s3">haplosomes</span> will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.<span class="Apple-converted-space">  </span>By default, with <span class="s3">muts=NULL</span>, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for <span class="s3">muts</span>.</p>
<p class="p3">In multi-chromosome models, all of the haplosomes and mutations passed in <span class="s3">haplosomes</span> and <span class="s3">muts</span> must all be associated with the same single chromosome.<span class="Apple-converted-space">  </span>If you wish to calculate heterozygosity across multiple chromosomes, you can simply write a <span class="s3">for</span> loop that calculates it for each chromosome and combines the results; but it is not entirely clear how to weight the chromosomes to produce a single number, especially when sex chromosomes and other chromosomes of variable ploidy might be represented in <span class="s3">haplosomes</span>, so it is not done automatically by this function.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the haplosome-wide heterozygosity.</p>
<p class="p3">The implementation of <span class="s3">calcHeterozygosity()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations.<span class="Apple-converted-space">  </span>One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>See <span class="s3">calcPairHeterozygosity()</span> for further discussion.</p>
<p class="p4">(float$)calcInbreedingLoad(object&lt;Haplosome&gt; haplosomes, [Nio&lt;MutationType&gt;$ mutType = NULL])</p>
<p class="p3">Calculates inbreeding load (the haploid number of lethal equivalents, or <i>B</i>) for a vector of haplosomes (containing at least one element) passed in <span class="s3">haplosomes</span>.<span class="Apple-converted-space">  </span>The calculation can be limited to a focal mutation type passed in <span class="s3">mutType</span> (which may be either an <span class="s3">integer</span> representing the ID of the desired mutation type, or a <span class="s3">MutationType</span> object specified directly); if <span class="s3">mutType</span> is <span class="s3">NULL</span> (the default), all of the mutations for the focal species will be considered.<span class="Apple-converted-space">  </span>In any case, only deleterious mutations (those with a negative selection coefficient) will be included in the final calculation.</p>
<p class="p3">The inbreeding load is a measure of the quantity of recessive deleterious variation that is heterozygous in a population and can contribute to fitness declines under inbreeding.<span class="Apple-converted-space">  </span>This function implements the following equation from Morton et al. (1956), which assumes no epistasis and random mating:</p>
<p class="p11"><i>B</i> = sum(<i>qs</i>) − sum(<i>q</i><span class="s12"><sup>2</sup></span><i>s</i>) − 2sum(<i>q</i>(1−<i>q</i>)<i>sh</i>)</p>
<p class="p3">where <i>q</i> is the frequency of a given deleterious allele, <i>s</i> is the absolute value of the selection coefficient, and <i>h</i> is its dominance coefficient.<span class="Apple-converted-space">  </span>Note that the implementation, viewable with <span class="s3">functionSource()</span>, sets a maximum |<i>s</i>| of <span class="s3">1.0</span> (i.e., a lethal allele); |<i>s</i>| can sometimes be greater than <span class="s3">1.0</span> when <i>s</i> is drawn from a distribution, but in practice an allele with <i>s</i> &lt; <span class="s3">-1.0</span> has the same lethal effect as when <i>s</i> = <span class="s3">-1.0</span>.<span class="Apple-converted-space">  </span>Also note that this implementation will not work when the model changes the dominance coefficients of mutations using <span class="s3">mutationEffect()</span> callbacks, since it relies on the <span class="s3">dominanceCoeff</span> property of <span class="s3">MutationType</span>. Finally, note that, to estimate the diploid number of lethal equivalents (2<i>B</i>), the result from this function can simply be multiplied by two.</p>
<p class="p3">This function was contributed by Chris Kyriazis; thanks, Chris!</p>
<p class="p4">(float)calcLD_D(object&lt;Mutation&gt;$ mut1, [No&lt;Mutation&gt; mut2 = NULL], [No&lt;Haplosome&gt; haplosomes = NULL])</p>
<p class="p3">Calculates the linkage disequilibrium (LD) coefficient <i>D</i> between a focal mutation <span class="s3">mut1</span> and one or more mutations in <span class="s3">mut2</span>, evaluated across a set of haplosomes given by <span class="s3">haplosomes</span>.<span class="Apple-converted-space">  </span>The result is a <span class="s3">float</span> vector that matches the size and order of <span class="s3">mut2</span>.<span class="Apple-converted-space">  </span>The implementation of this function, viewable with <span class="s3">functionSource()</span>, calculates <i>D</i> as defined by Hill and Robertson (1968, p. 226).<span class="Apple-converted-space">  </span>The coefficient <i>D</i> is within [−<i>p</i>(1−<i>p</i>), <i>p</i>(1−<i>p</i>)], where <i>p</i> is the frequency of the more common mutation (that is, <i>p</i> = max(<i>f</i><span class="s4"><sub>1</sub></span>, <i>f</i><span class="s4"><sub>2</sub></span>) where <i>f</i><span class="s4"><sub>1</sub></span> and <i>f</i><span class="s4"><sub>2</sub></span> are the frequencies of the two mutations for which <i>D</i> is being calculated); for the normalized LD metric <i>r</i><span class="s4"><sup>2</sup></span>, which is within [0, 1], see <span class="s3">calcLD_Rsquared()</span>.<span class="Apple-converted-space">  </span>Departures of <i>D</i> from zero indicate LD; more specifically, <i>D</i> &gt; 0 indicates that the mutations occur together more often than expected by chance (positive linkage), whereas <i>D</i> &lt; 0 indicates they occur together less often than expected by chance (negative linkage).</p>
<p class="p3">All mutations in <span class="s3">mut2</span> must be associated with the same chromosome as <span class="s3">mut1</span>; this function does not currently calculate LD between mutations associated with different chromosomes.<span class="Apple-converted-space">  </span>If <span class="s3">mut2</span> is <span class="s3">NULL</span> (the default), all such mutations in the population (including <span class="s3">mut1</span> itself) will be used.<span class="Apple-converted-space">  </span>Similarly, all haplosomes must be associated with the same chromosome as <span class="s3">mut1</span>.<span class="Apple-converted-space">  </span>If the <span class="s3">haplosomes</span> parameter is <span class="s3">NULL</span> (the default), all such haplosomes in the population will be used.</p>
<p class="p3">This function was written by Vitor Sudbrack (currently affiliated with University of Lausanne).</p>
<p class="p4">(float)calcLD_Rsquared(object&lt;Mutation&gt;$ mut1, [No&lt;Mutation&gt; mut2 = NULL], [No&lt;Haplosome&gt; haplosomes = NULL], [logical$ squared = T])</p>
<p class="p3">Calculates the linkage disequilibrium (LD) squared correlation coefficient <i>r</i><span class="s4"><sup>2</sup></span> between a focal mutation <span class="s3">mut1</span> and one or more mutations in <span class="s3">mut2</span>, evaluated across a set of haplosomes given by <span class="s3">haplosomes</span>.<span class="Apple-converted-space">  </span>The result is a <span class="s3">float</span> vector that matches the size and order of <span class="s3">mut2</span>.<span class="Apple-converted-space">  </span>The implementation of this function, viewable with <span class="s3">functionSource()</span>, calculates <i>r</i><span class="s4"><sup>2</sup></span> as defined by Hill and Robertson (1968, p. 227).<span class="Apple-converted-space">  </span>The squared correlation coefficient <i>r</i><span class="s4"><sup>2</sup></span> is a normalized measure of LD within [0, 1] (for the unnormalized LD coefficient <i>D</i>, see <span class="s3">calcLD_D()</span>).<span class="Apple-converted-space">  </span>When <i>r</i><span class="s4"><sup>2</sup></span> = 0, there is no statistical association between the mutations; they co-occur as expected by chance.<span class="Apple-converted-space">  </span>A value of <i>r</i><span class="s4"><sup>2</sup></span> = 1 indicates complete correlation: the mutations either always appear together or never appear together, depending on the sign of the underlying correlation coefficient <i>r</i>.<span class="Apple-converted-space">  </span>To obtain the raw (signed) <i>r</i> value instead of <i>r</i><span class="s4"><sup>2</sup></span>, you can pass <span class="s3">squared=F</span> instead of the default of <span class="s3">T</span>.</p>
<p class="p3">All mutations in <span class="s3">mut2</span> must be associated with the same chromosome as <span class="s3">mut1</span>; this function does not currently calculate LD between mutations associated with different chromosomes.<span class="Apple-converted-space">  </span>If <span class="s3">mut2</span> is <span class="s3">NULL</span> (the default), all such mutations in the population (including <span class="s3">mut1</span> itself) will be used.<span class="Apple-converted-space">  </span>Similarly, all haplosomes must be associated with the same chromosome as <span class="s3">mut1</span>.<span class="Apple-converted-space">  </span>If the <span class="s3">haplosomes</span> parameter is <span class="s3">NULL</span> (the default), all such haplosomes in the population will be used.</p>
<p class="p3">This function was written by Vitor Sudbrack (currently affiliated with University of Lausanne).</p>
<p class="p4">(float$)calcMeanFroh(object&lt;Individual&gt; individuals, [integer$ minimumLength = 1000000], [Niso&lt;Chromosome&gt;$ chromosome = NULL])</p>
<p class="p3">Calculates the mean value of the <i>F</i><span class="s4"><sub>roh</sub></span> statistic across the individuals passed in <span class="s3">individuals</span>.<span class="Apple-converted-space">  </span>This statistic is a measure of individual autozygosity, likely resulting from inbreeding, and is calculated based upon “runs of homozygosity”, or ROH, in the genome of an individual.<span class="Apple-converted-space">  </span>Broadly speaking, <i>F</i><span class="s4"><sub>roh</sub></span> is the proportion of an individual’s genome that is spanned by ROH longer than a given threshold length.<span class="Apple-converted-space">  </span>However, it should be noted that there are many different ways of calculating <i>F</i><span class="s4"><sub>roh</sub></span>, producing different results.<span class="Apple-converted-space">  </span>For example, the threshold length might be a given constant, or might be determined statistically from the characteristics of the population.<span class="Apple-converted-space">  </span>Furthermore, some heterozygous sites might be discarded (to compensate for genotyping errors), a minimum SNP density might be required within a sliding window for an ROH to be diagnosed, and so forth – it can get quite complex, as seen in the software PLINK (Purcell et al., 2007) and GARLIC (Szpiech, Blant and Pemberton, 2017).<span class="Apple-converted-space">  </span>The method used by <span class="s3">calcMeanFroh()</span> is the simplest possible method, assessing ROH for each individual directly from the simulated mutations without filtering or modification, and applying a given constant threshold length.<span class="Apple-converted-space">  </span>If a more sophisticated <i>F</i><span class="s4"><sub>roh</sub></span> algorithm is desired, one could modify the implementation of <span class="s3">calcMeanFroh()</span>, which is viewable with <span class="s3">functionSource()</span>, or one could output VCF data from SLiM and analyze it with other tools, perhaps calling out from the running SLiM script with <span class="s3">system()</span>.</p>
<p class="p3">The threshold ROH length used by <span class="s3">calcMeanFroh()</span> is supplied by the parameter <span class="s3">minimumLength</span>.<span class="Apple-converted-space">  </span>It defaults to <span class="s3">1e6</span>, or 1 Mbp, since that is a length commonly used in the literature, but can be adjusted as desired.</p>
<p class="p3">The <span class="s3">chromosome</span> parameter can be supplied to focus the <i>F</i><span class="s4"><sub>roh</sub></span> calculation on a specific chromosome; otherwise, the calculation spans all chromosomes for which the individual is actually diploid (without a null haplosome).<span class="Apple-converted-space">  </span>If <i>F</i><span class="s4"><sub>roh</sub></span> cannot be calculated for an individual (due to the presence of null haplosomes for every intrinsically diploid chromosome being analyzed), that individual is omitted from the mean <i>F</i><span class="s4"><sub>roh</sub></span> calculation; for example, if an X chromosome is the focal chromosome being analyzed, all males will be omitted from the mean <i>F</i><span class="s4"><sub>roh</sub></span> calculation.<span class="Apple-converted-space">  </span>If all individuals are omitted from the mean <i>F</i><span class="s4"><sub>roh</sub></span> calculation for this reason, <span class="s3">NAN</span> is returned.</p>
<p class="p3">This function was developed with advice from Ryan Chaffee.<span class="Apple-converted-space">  </span>Thanks, Ryan!</p>
<p class="p4">(float$)calcPairHeterozygosity(object&lt;Haplosome&gt;$ haplosome1, object&lt;Haplosome&gt;$ haplosome2, [Ni$ start = NULL], [Ni$ end = NULL], [logical$ infiniteSites = T])</p>
<p class="p3">Calculates the heterozygosity for a pair of haplosomes; these will typically be two homologous haplosomes of the same diploid individual, but any two haplosomes associated with the same chromosome may be supplied.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the haplosome-wide heterozygosity.</p>
<p class="p3">The implementation <span class="s3">calcPairHeterozygosity()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations by default (i.e., with <span class="s3">infiniteSites=T</span>).<span class="Apple-converted-space">  </span>If mutations are stacked, the heterozygosity calculated therefore depends upon the number of <i>unshared mutations</i>, not the number of <i>differing sites</i>.<span class="Apple-converted-space">  </span>Similarly, if multiple <span class="s3">Mutation</span> objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each <span class="s3">Mutation</span> object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.<span class="Apple-converted-space">  </span>One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>The behavior of <span class="s3">calcPairHeterozygosity()</span> can be switched to calculate based upon the number of differing sites, rather than the number of unshared mutations, by passing <span class="s3">infiniteSites=F</span>.</p>
<p class="p4">(float$)calcPi(object&lt;Haplosome&gt; haplosomes, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates <span class="s7"><i>π</i></span> (nucleotide diversity, a metric of genetic diversity) for a vector of haplosomes (containing at least two elements), based upon the mutations in the haplosomes.<span class="Apple-converted-space">  </span><span class="s7"><i>π</i></span> is computed by calculating the mean number of pairwise differences at each site, summing across all sites, and dividing by the number of sites.<span class="Apple-converted-space">  </span>Therefore, it is interpretable as the number of differences per site expected between two randomly chosen sequences.<span class="Apple-converted-space">  </span>The mathematical formulation (as an estimator of the population parameter <span class="s7"><i>θ</i></span>) is based on work in Nei and Li (1979), Nei and Tajima (1981), and Tajima (1983; equation A3).<span class="Apple-converted-space">  </span>The exact formula used here is common in textbooks (e.g., equations 9.1–9.5 in Li 1997, equation 3.3 in Hahn 2018, or equation 2.2 in Coop 2020).</p>
<p class="p3">Often <span class="s3">haplosomes</span> will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.<span class="Apple-converted-space">  </span>By default, with <span class="s3">muts=NULL</span>, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for <span class="s3">muts</span>.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the haplosome-wide value of <span class="s7"><i>π</i></span>.</p>
<p class="p3">The implementation of <span class="s3">calcPi()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations.<span class="Apple-converted-space">  </span>One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with <span class="s3">calcHeterozygosity()</span>.<span class="Apple-converted-space">  </span>Indeed, finite-sites models of <span class="s7"><i>π</i></span> have been derived (Tajima 1996) though are not used here.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>See <span class="s3">calcPairHeterozygosity()</span> for further discussion.<span class="Apple-converted-space">  </span>This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph and Chase Nelson.</p>
<p class="p4">(numeric)calcSFS([Ni$ binCount = NULL], [No&lt;Haplosome&gt; haplosomes = NULL], [No&lt;Mutation&gt; muts = NULL], [string$ metric = "density"], [logical$ fold = F])</p>
<p class="p3">Calculates the site frequency spectrum, or SFS, for the mutations specified by <span class="s3">muts</span>, within the haplosomes specified by <span class="s3">haplosomes</span>.<span class="Apple-converted-space">  </span>The site frequency spectrum or SFS (sometimes called the allele frequency spectrum, although some authors distinguish between the two) is essentially a histogram of the frequencies of the mutations within the haplosomes; the first bin spans the lowest range of frequencies (down to a frequency of <span class="s3">0.0</span>, or a count of <span class="s3">1</span>), whereas the last bin spans the highest range of frequencies (up to a frequency of <span class="s3">1.0</span>, or a count equal to number of haplosomes minus one).<span class="Apple-converted-space">  </span>The idea was introduced by Watterson (1975), and will be discussed in any population genetics textbook (e.g., A. Cutter, 2019, pp. 50–52).<span class="Apple-converted-space">  </span>This histogram can be returned as a <span class="s3">float</span> vector of density values for each bin by specifying <span class="s3">"density"</span> for <span class="s3">metric</span> (the default), or as an <span class="s3">integer</span> vector of count values for each bin by specifying <span class="s3">"count"</span>.</p>
<p class="p3">There are two modes of operation for <span class="s3">calcSFS()</span>.<span class="Apple-converted-space">  </span>If a specific number of bins is passed for <span class="s3">binCount</span>, then the frequency range <span class="s3">[0.0, 1.0]</span> is subdivided into <span class="s3">binCount</span> intervals of equal width, and the mutations are tallied into those bins according to their frequencies within the haplosomes to produce the histogram.<span class="Apple-converted-space">  </span>In this mode, there will be exactly <span class="s3">binCount</span> elements in the returned vector.<span class="Apple-converted-space">  </span>Note that either <span class="s3">"density"</span> or <span class="s3">"count"</span> can be chosen in this mode; you can return the frequency bin tallies as either densities or counts.</p>
<p class="p3">In the other mode of operation, chosen with a <span class="s3">binCount</span> value of <span class="s3">NULL</span>, the bins instead represent the count of the number of occurrences for each mutation, and range from a count of <span class="s3">1</span> (the bin for mutations that occur only once in the haplosomes, sometimes called “singletons”) up to a count of <span class="s3">N-1</span> where <span class="s3">N</span> is the number of haplosomes.<span class="Apple-converted-space">  </span>(Note that mutations occurring in all <span class="s3">N</span> haplosomes are not included in the tally, since they would not be empirically observable.)<span class="Apple-converted-space">  </span>In this mode, there will be exactly <span class="s3">N-1</span> elements in the returned vector.<span class="Apple-converted-space">  </span>Again, either <span class="s3">"density"</span> or <span class="s3">"count"</span> can be chosen in this mode; you can return the count bin tallies as either densities or counts (it’s a bit confusing, but we’re talking about two different kinds of “counts”, the count of the number of times a mutation occurs in the haplosomes versus the count of the number of mutations that were tallied into a particular count bin).</p>
<p class="p3">The <span class="s3">haplosomes</span> parameter can be either a vector of <span class="s3">Haplosome</span> objects or <span class="s3">NULL</span>.<span class="Apple-converted-space">  </span>If <span class="s3">NULL</span> is passed, <span class="s3">calcSFS()</span> will calculate the SFS across the whole species, using all non-null haplosomes present (and thus there must be only a single species in the model, since an SFS cannot be calculated across multiple species).<span class="Apple-converted-space">  </span>Otherwise, <span class="s3">haplosomes</span> can contain any set of haplosomes desired, such as from the individuals of one subpopulation, several subpopulations, or an entire species.<span class="Apple-converted-space">  </span>However, they must all belong to the same species, and null haplosomes will be automatically and silently excluded from the set.</p>
<p class="p3">The <span class="s3">muts</span> parameter can be either a vector of <span class="s3">Mutation</span> objects or <span class="s3">NULL</span>.<span class="Apple-converted-space">  </span>If <span class="s3">NULL</span> is passed, <span class="s3">calcSFS()</span> will calculate the SFS across all mutations belonging to the focal species (as determined from the species of the haplosomes).<span class="Apple-converted-space">  </span>Otherwise, <span class="s3">muts</span> can contain any set of mutations desired, such as mutations belonging to a specific mutation type, mutations within a specific range of positions along the chromosome, or all of the mutations in the focal species.</p>
<p class="p3">The <span class="s3">binCount</span> and <span class="s3">metric</span> parameters have already been discussed.<span class="Apple-converted-space">  </span>Finally, the <span class="s3">fold</span> parameter, if <span class="s3">T</span>, “folds” the calculated SFS, adding the first and last bins, the second and next-to-last bins, etc., until the center is reached.<span class="Apple-converted-space">  </span>Folding is common when working with empirical data, where one often doesn’t know the “polarity” – which allele at a site is ancestral and which is derived.<span class="Apple-converted-space">  </span>Folding solves this problem, because the polarity then doesn’t matter; the tally for a given mutation ends up in the same bin regardless.<span class="Apple-converted-space">  </span>If the number of bins is even, folding can be performed without ambiguity; the final number of bins is exactly half the original number of bins, and each final bin is the sum of two original bins.<span class="Apple-converted-space">  </span>If the number of bins is odd, the correct treatment of the central bin is somewhat ambiguous.<span class="Apple-converted-space">  </span>In <span class="s3">calcFST()</span>, the central bin is added to itself – doubled – and the number of bins is equal to half the original number of bins rounded up.<span class="Apple-converted-space">  </span>If you would prefer to exclude the central bin altogether – another population treatment – then when the original number of bins is odd, you can simply discard the final value in the returned vector (and, if you wish to work with densities rather than counts, re-normalize the result to sum to 1.0).</p>
<p class="p3">The implementation of <span class="s3">calcSFS()</span>, viewable with <span class="s3">functionSource()</span>, tallies each mutation separately, even if more than one mutation occurs at the same position (or is even stacked with another mutation).<span class="Apple-converted-space">  </span>One could regard this choice as embodying an infinite-sites interpretation of the SFS, perhaps; in any case, it follows SLiM’s behavior in other population-genetics utility functions.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.</p>
<p class="p3">This function is compatible with multi-chromosome models, in the following sense.<span class="Apple-converted-space">  </span>When <span class="s3">binCount</span> is specified with an <span class="s3">integer</span> value, mutations are binned according to their frequencies, as described above.<span class="Apple-converted-space">  </span>In a multi-chromosome model, the haplosomes and mutations used by <span class="s3">calcSFS()</span> may be associated with more than one chromosome, and the frequency assessed for each mutation is its frequency specifically within the haplosomes associated with its chromosome (as you would expect).<span class="Apple-converted-space">  </span>Mutations occurring in different chromosomes can therefore be tallied together into the same frequency bins, and combined into a single SFS; this produces a meaningful SFS.<span class="Apple-converted-space">  </span>(If you want an SFS for just a single chromosome, then of course you can pass just those haplosomes and mutations to <span class="s3">calcSFS()</span>.)<span class="Apple-converted-space">  </span>When <span class="s3">binCount</span> is <span class="s3">NULL</span>, on the other hand, mutations are binned according to their counts, as described above.<span class="Apple-converted-space">  </span>In a multi-chromosome model, it would not make sense to bin counts together from different chromosomes, since those counts might not be on the same scale – the number of haplosomes associated with the various chromosomes might not be equal.<span class="Apple-converted-space">  </span>In this case, <span class="s3">calcSFS()</span> will raise an error if haplosomes from more than one chromosome are supplied, or if haplosomes is <span class="s3">NULL</span> (since it doesn’t know which chromosome to choose).<span class="Apple-converted-space">  </span>If you wish to tally according to counts, with <span class="s3">binCount=NULL</span>, you must pass in a vector of haplosomes associated with a single chromosome.<span class="Apple-converted-space">  </span>(If you know what you are doing and wish to combine counts across multiple chromosomes, you can simply call <span class="s3">calcSFS()</span> once per chromosome, and combine the resulting vectors by adding them together.)</p>
<p class="p3">Thanks to Ryan Chaffee and Chase Nelson for helpful input.</p>
<p class="p4">(float$)calcTajimasD(object&lt;Haplosome&gt; haplosomes, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates Tajima’s <i>D</i> (a test of neutrality based on the allele frequency spectrum) for a vector of haplosomes (containing at least four elements), based upon the mutations in the haplosomes.<span class="Apple-converted-space">  </span>The mathematical formulation is given in Tajima 1989 (equation 38) and remains unchanged (e.g., equations 2.30 in Durrett 2008, 8.4 in Hahn 2018, and 4.44 in Coop 2020).<span class="Apple-converted-space">  </span>Often <span class="s3">haplosomes</span> will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.<span class="Apple-converted-space">  </span>By default, with <span class="s3">muts=NULL</span>, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for <span class="s3">muts</span>.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the haplosome-wide Tajima’s <i>D</i>.</p>
<p class="p3">If the genetic diversity contained within the haplosomes is insufficient for the calculation, <span class="s3">calcTajimasD()</span> may return <span class="s3">NAN</span>.<span class="Apple-converted-space">  </span>It is up to the caller to detect this with <span class="s3">isNAN()</span> and handle it as necessary.</p>
<p class="p3">The implementation of <span class="s3">calcTajimasD()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations.<span class="Apple-converted-space">  </span>One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with <span class="s3">calcHeterozygosity()</span>.<span class="Apple-converted-space">  </span>Indeed, Tajima’s <i>D</i> can be modified with finite-sites models of <span class="s7"><i>π</i></span> and <span class="s7"><i>θ</i></span> (Misawa and Tajima 1997) though these are not used here.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>See <span class="s3">calcPairHeterozygosity()</span> for further discussion.<span class="Apple-converted-space">  </span>This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph.</p>
<p class="p4">(float$)calcVA(object&lt;Individual&gt; individuals, io&lt;MutationType&gt;$ mutType)</p>
<p class="p3">Calculates <i>V</i><span class="s4"><sub>A</sub></span>, the additive genetic variance, among a vector of individuals (containing at least two elements) passed in <span class="s3">individuals</span>, in a particular mutation type <span class="s3">mutType</span> that represents quantitative trait loci (QTLs) influencing a quantitative phenotypic trait.<span class="Apple-converted-space">  </span>The <span class="s3">mutType</span> parameter may be either an <span class="s3">integer</span> representing the ID of the desired mutation type, or a <span class="s3">MutationType</span> object specified directly.</p>
<p class="p3">This function assumes that mutations of type <span class="s3">mutType</span> encode their effect size upon the quantitative trait in their <span class="s3">selectionCoeff</span> property, as is fairly standard in SLiM.<span class="Apple-converted-space">  </span>The implementation of <span class="s3">calcVA()</span>, which is viewable with <span class="s3">functionSource()</span>, is quite simple; if effect sizes are stored elsewhere (such as with <span class="s3">setValue()</span>), a new user-defined function following the pattern of <span class="s3">calcVA()</span> can easily be written.</p>
<p class="p4">(float$)calcWattersonsTheta(object&lt;Haplosome&gt; haplosomes, [No&lt;Mutation&gt; muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])</p>
<p class="p3">Calculates Watterson’s theta (a metric of genetic diversity comparable to heterozygosity) for a vector of haplosomes (containing at least one element), based upon the mutations in the haplosomes.<span class="Apple-converted-space">  </span>Often <span class="s3">haplosomes</span> will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.<span class="Apple-converted-space">  </span>By default, with <span class="s3">muts=NULL</span>, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for <span class="s3">muts</span>.</p>
<p class="p3">The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [<span class="s3">start</span>, <span class="s3">end</span>] for the desired window.<span class="Apple-converted-space">  </span>In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.<span class="Apple-converted-space">  </span>The default behavior, with <span class="s3">start</span> and <span class="s3">end</span> of <span class="s3">NULL</span>, provides the haplosome-wide Watterson’s theta.</p>
<p class="p3">The implementation of <span class="s3">calcWattersonsTheta()</span>, viewable with <span class="s3">functionSource()</span>, treats every mutation as independent in the heterozygosity calculations.<span class="Apple-converted-space">  </span>One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with <span class="s3">calcHeterozygosity()</span>.<span class="Apple-converted-space">  </span>In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.<span class="Apple-converted-space">  </span>See <span class="s3">calcPairHeterozygosity()</span> for further discussion.</p>
<p class="p1"><b>3.4.<span class="Apple-converted-space">  </span>Other utilities</b></p>
<p class="p4">(float)summarizeIndividuals(object&lt;Individual&gt; individuals, integer dim, numeric spatialBounds, string$ operation, [Nlif$ empty = 0.0], [logical$ perUnitArea = F], [Ns$ spatiality = NULL])</p>
<p class="p3">Returns a vector, matrix, or array that summarizes spatial patterns of information related to the individuals in <span class="s3">individuals</span>.<span class="Apple-converted-space">  </span>In essence, those individuals are assigned into <i>bins</i> according to their spatial position, and then a summary value for each bin is calculated based upon the individuals each bin contains.<span class="Apple-converted-space">  </span>The individuals might be binned in one dimension (resulting in a vector of summary values), in two dimensions (resulting in a matrix), or in three dimensions (resulting in an array).<span class="Apple-converted-space">  </span>Typically the spatiality of the result (the dimensions into which the individuals are binned) will match the dimensionality of the model, as indicated by the default value of <span class="s3">NULL</span> for the optional <span class="s3">spatiality</span> parameter; for example, a two-dimensional (<span class="s3">"xy"</span>) model would by default produce a two-dimensional matrix as a summary.<span class="Apple-converted-space">  </span>However, a spatiality that is more restrictive than the model dimensionality may be passed; for example, in a two-dimensional (<span class="s3">"xy"</span>) model a <span class="s3">spatiality</span> of <span class="s3">"y"</span> could be passed to summarize individuals into a vector, rather than a matrix, assigning them to bins based only upon their <i>y</i> position (i.e., the value of their <span class="s3">y</span> property).<span class="Apple-converted-space">  </span>Whatever spatiality is chosen, the parameter <span class="s3">dim</span> provides the dimensions of the desired result, in the same form that the <span class="s3">dim()</span> function does: first the number of rows, then the number of columns, and then the number of planes, as needed (see the Eidos manual for discussion of matrices, arrays, and <span class="s3">dim()</span>).<span class="Apple-converted-space">  </span>The length of <span class="s3">dims</span> must match the requested spatiality; for spatiality <span class="s3">"xy"</span>, for example, <span class="s3">dims</span> might be <span class="s3">c(50,100)</span> to request that the returned matrix have <span class="s3">50</span> rows and <span class="s3">100</span> columns.<span class="Apple-converted-space">  </span>The result vector/matrix/array is in the correct orientation to be directly usable as a spatial map, by passing it to the <span class="s3">defineSpatialMap()</span> method of <span class="s3">Subpopulation</span>.<span class="Apple-converted-space">  </span>For further discussion of dimensionality and spatiality, see <span class="s3">initializeInteractionType()</span> and <span class="s3">InteractionType</span>.</p>
<p class="p3">The <span class="s3">spatialBounds</span> parameter defines the spatial boundaries within which the individuals are binned.<span class="Apple-converted-space">  </span>Typically this is the spatial bounds of a particular subpopulation, within which the individuals reside; for individuals in <span class="s3">p1</span>, for example, you would likely pass <span class="s3">p1.spatialBounds</span> for this.<span class="Apple-converted-space">  </span>However, this is not required; individuals may come from any or all subpopulations in the model, and <span class="s3">spatialBounds</span> may be any bounds of non-zero area (if an individual falls outside of the given spatial bounds, it is excluded, as if it were not in <span class="s3">individuals</span> at all).<span class="Apple-converted-space">  </span>If you have multiple subpopulations that conceptually reside within the same overall coordinate space, for example, that can be accommodated here.<span class="Apple-converted-space">  </span>The bounds are supplied in the dimensionality of the model, in the same form as for <span class="s3">Subpopulation</span>; for an <span class="s3">"xy"</span> model, for example, they are supplied as a four-element vector of the form <span class="s3">c(x0, y0, x1, y1)</span> even if the summary is being produced with spatiality <span class="s3">"y"</span>.<span class="Apple-converted-space">  </span>To produce the result, a grid with dimensions defined by <span class="s3">dims</span> is conceptually stretched out across the given spatial bounds, such that the <i>centers</i> of the edge and corner grid squares are aligned with the limits of the spatial bounds.<span class="Apple-converted-space">  </span>This matches the way that <span class="s3">defineSpatialMap()</span> defines its maps.</p>
<p class="p3">The particular summary produced depends upon the parameters <span class="s3">operation</span> and <span class="s3">empty</span>.<span class="Apple-converted-space">  </span>Consider a single grid square represented by a single element in the result.<span class="Apple-converted-space">  </span>That grid square contains zero or more of the individuals in <span class="s3">individuals</span>.<span class="Apple-converted-space">  </span>If it contains zero individuals <i>and</i> <span class="s3">empty</span> is not <span class="s3">NULL</span>, the <span class="s3">empty</span> value is used for the result, regardless of <span class="s3">operation</span>, providing specific, separate control over the treatment of empty grid squares.<span class="Apple-converted-space">  </span>If <span class="s3">empty</span> is <span class="s3">NULL</span>, this separate control over the treatment of empty grid squares is declined; empty grid squares will be handled through the standard mechanism described next.<span class="Apple-converted-space">  </span>In all other cases for the given grid square – when it contains more than zero individuals, or when <span class="s3">empty</span> is <span class="s3">NULL</span> – <span class="s3">operation</span> is executed as an Eidos <i>lambda</i>, a small snippet of code, supplied as a singleton <span class="s3">string</span>, that is executed in a manner similar to a function call.<span class="Apple-converted-space">  </span>Within the execution of the <span class="s3">operation</span> lambda, a constant named <span class="s3">individuals</span> is defined to be the focal individuals being evaluated – all of the individuals within that grid square.<span class="Apple-converted-space">  </span>This lambda should evaluate to a singleton <span class="s3">logical</span>, <span class="s3">integer</span>, or <span class="s3">float</span> value, comprising the result value for the grid square; these types will all be coerced to <span class="s3">float</span> (<span class="s3">T</span> being <span class="s3">1</span> and <span class="s3">F</span> being <span class="s3">0</span>).</p>
<p class="p3">Two examples may illustrate the use of <span class="s3">empty</span> and <span class="s3">operation</span>.<span class="Apple-converted-space">  </span>To produce a summary indicating presence/absence, simply use the default of <span class="s3">0.0</span> for <span class="s3">empty</span>, and <span class="s3">"1.0;</span> <span class="s3">"</span> (or <span class="s3">"1;"</span>, or <span class="s3">"T;"</span>) for <span class="s3">operation</span>.<span class="Apple-converted-space">  </span>This will produce <span class="s3">0.0</span> for empty grid squares, and <span class="s3">1.0</span> for those that contain at least one individual.<span class="Apple-converted-space">  </span>Note that the use of <span class="s3">empty</span> is essential here, because <span class="s3">operation</span> doesn’t even check whether individuals are present or not.<span class="Apple-converted-space">  </span>To produce a summary with a count of the number of individuals in each grid square, again use the default of <span class="s3">0.0</span> for <span class="s3">empty</span>, but now use an <span class="s3">operation</span> of <span class="s3">"individuals.size();"</span>, counting the number of individuals in each grid square.<span class="Apple-converted-space">  </span>In this case, <span class="s3">empty</span> could be <span class="s3">NULL</span> instead and <span class="s3">operation</span> would still produce the correct result; but using <span class="s3">empty</span> makes <span class="s3">summarizeIndividuals()</span> more efficient since it allows the execution of <span class="s3">operation</span> to be skipped for those squares.</p>
<p class="p3">Lambdas are not limited in their complexity; they can use <span class="s3">if</span>, <span class="s3">for</span>, etc., and can call methods and functions.<span class="Apple-converted-space">  </span>A typical <span class="s3">operation</span> to compute the mean phenotype in a quantitative genetic model that stores phenotype values in <span class="s3">tagF</span>, for example, would be <span class="s3">"mean(individuals.tagF);"</span>, and this is still quite simple compared to what is possible.<span class="Apple-converted-space">  </span>However, keep in mind that the lambda will be evaluated for every grid cell (or at least those that are non-empty), so efficiency can be a concern, and you may wish to pre-calculate values shared by all of the lambda calls, making them available to your lambda code using <span class="s3">defineGlobal()</span> or <span class="s3">defineConstant()</span>.</p>
<p class="p3">There is one last twist, if <span class="s3">perUnitArea</span> is <span class="s3">T</span>: values are divided by the area (or length, in 1D, or volume, in 3D) that their corresponding grid cell comprises, so that each value is in units of “per unit area” (or “per unit length”, or “per unit volume”).<span class="Apple-converted-space">  </span>The total area of the grid is defined by the spatial bounds, and the area of a given grid cell is defined by the portion of the spatial bounds that is within that cell.<span class="Apple-converted-space">  </span>This is not the same for all grid cells; grid cells that fall partially outside <span class="s3">spatialBounds</span> (because, remember, the <i>centers</i> of the edge/corner grid cells are aligned with the limits of <span class="s3">spatialBounds</span>) will have a smaller area inside the bounds.<span class="Apple-converted-space">  </span>For an <span class="s3">"xy"</span> spatiality summary, for example, corner cells have only a quarter of their area inside <span class="s3">spatialBounds</span>, while edge elements have half of their area inside <span class="s3">spatialBounds</span>; for purposes of <span class="s3">perUnitArea</span>, then, their respective areas are ¼ and ½ the area of an interior grid cell.<span class="Apple-converted-space">  </span>By default, <span class="s3">perUnitArea</span> is <span class="s3">F</span>, and no scaling is performed.<span class="Apple-converted-space">  </span>Whether you want <span class="s3">perUnitArea</span> to be <span class="s3">F</span> or <span class="s3">T</span> depends upon whether the summary you are producing is, conceptually, “per unit area”, such as density (individuals per unit area) or local competition strength (total interaction strength per unit area), or is not, such as “mean individual age”, or “maximum <span class="s3">tag</span> value”.<span class="Apple-converted-space">  </span>For the previous example of counting individuals with an operation of <span class="s3">"individuals.size();"</span>, a value of <span class="s3">F</span> for <span class="s3">perUnitArea</span> (the default) will produce a simple <i>count</i> of individuals in each grid square, whereas with <span class="s3">T</span> it would produce the <i>density</i> of individuals in each grid square.</p>
<p class="p4">(object&lt;Dictionary&gt;$)treeSeqMetadata(string$ filePath, [logical$ userData = T])</p>
<p class="p3">Returns a <span class="s3">Dictionary</span> containing top-level metadata from the <span class="s3">.trees</span> (tree-sequence) file at <span class="s3">filePath</span>.<span class="Apple-converted-space">  </span>If <span class="s3">userData</span> is <span class="s3">T</span> (the default), the top-level metadata under the <span class="s3">SLiM/user_metadata</span> key is returned; this is the same metadata that can optionally be supplied to <span class="s3">treeSeqOutput()</span> in its <span class="s3">metadata</span> parameter, so it makes it easy to recover metadata that you attached to the tree sequence when it was saved.<span class="Apple-converted-space">  </span>If <span class="s3">userData</span> is <span class="s3">F</span>, the entire top-level metadata <span class="s3">Dictionary</span> object is returned; this can be useful for examining the values of other keys under the <span class="s3">SLiM</span> key, or values inside the top-level dictionary itself that might have been placed there by <span class="s3">msprime</span> or other software.</p>
<p class="p3">This function can be used to read in parameter values or other saved state (<span class="s3">tag</span> property values, for example), in order to resuscitate the complete state of a simulation that was written to a <span class="s3">.trees</span> file.<span class="Apple-converted-space">  </span>It could be used for more esoteric purposes too, such as to search through <span class="s3">.trees</span> files in a directory (with the help of the Eidos function <span class="s3">filesAtPath()</span>) to find those files that satisfy some metadata criterion.</p>
</body>
</html>
