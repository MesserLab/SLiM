<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.3">
  <style type="text/css">
    p.p1 {margin: 18.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo}
    p.p3 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima; color: #000000}
    p.p4 {margin: 9.0px 0.0px 3.0px 36.0px; text-indent: -22.3px; font: 9.0px Menlo; color: #000000}
    p.p5 {margin: 3.0px 0.0px 3.0px 27.4px; font: 10.0px Optima}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Menlo; color: #000000}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Menlo}
    span.s1 {font-kerning: none}
    span.s2 {font: 9.0px Menlo; font-kerning: none}
    span.s3 {font-kerning: none; color: #000000}
    span.s4 {font: 9.0px Menlo}
    span.s5 {font: 10.0px Optima; font-kerning: none}
    span.s6 {font: 10.0px 'Times New Roman'}
    span.s7 {font: 9.0px Menlo; font-kerning: none; color: #000000}
    span.s8 {font: 10.0px Helvetica}
    span.s9 {font: 6.7px Optima; font-kerning: none}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><b>3.1.<span class="Apple-converted-space">  </span>Initialization functions</b></p>
<p class="p2">(integer$)initializeAncestralNucleotides(is sequence)</p>
<p class="p3"><span class="s1">This function, which may be called only in nucleotide-based models, supplies an ancestral nucleotide sequence for the model.<span class="Apple-converted-space">  </span>The </span><span class="s2">sequence</span><span class="s1"> parameter may be an </span><span class="s2">integer</span><span class="s1"> vector providing nucleotide values (A=0, C=1, G=2, T=3), or a </span><span class="s2">string</span><span class="s1"> vector providing single-character nucleotides (</span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"C"</span><span class="s1">, </span><span class="s2">"G"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">), or a singleton </span><span class="s2">string</span><span class="s1"> providing the sequence as one string (</span><span class="s2">"ACGT..."</span><span class="s1">), or a singleton </span><span class="s2">string</span><span class="s1"> providing the filesystem path of a FASTA file which will be read in to provide the sequence (if the file contains than one sequence, the first sequence will be used).<span class="Apple-converted-space">  </span>Only A/C/G/T nucleotide values may be provided; other symbols, such as those for amino acids, gaps, or nucleotides of uncertain identity, are not allowed.<span class="Apple-converted-space">  </span>The two semantic meanings of </span><span class="s2">sequence</span><span class="s1"> that involve a singleton </span><span class="s2">string</span><span class="s1"> value are distinguished heuristically; a singleton </span><span class="s2">string</span><span class="s1"> that contains only the letters ACGT will be assumed to be a nucleotide sequence rather than a filename.<span class="Apple-converted-space">  </span>The length of the ancestral sequence is returned.</span></p>
<p class="p3"><span class="s1">A utility function, </span><span class="s2">randomNucleotides()</span><span class="s1">, is provided by SLiM to assist in generating simple random nucleotide sequences.</span></p>
<p class="p4"><span class="s1">(void)initializeGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0])</span></p>
<p class="p3"><span class="s1">Calling this function switches the recombination model from a “simple crossover” model to a “double-stranded break (DSB)” model, and configures the details of the gene conversion tracts that will therefore be modeled.<span class="Apple-converted-space">  </span>The fraction of DSBs that will be modeled as non-crossover events is given by </span><span class="s2">nonCrossoverFraction</span><span class="s1">.<span class="Apple-converted-space">  </span>The mean length of gene conversion tracts (whether associated with crossover or non-crossover events) is given by </span><span class="s2">meanLength</span><span class="s1">; the actual extent of a gene conversion tract will be the sum of two independent draws from a geometric distribution with mean </span><span class="s2">meanLength/2</span><span class="s1">.<span class="Apple-converted-space">  </span>The fraction of gene conversion tracts that are modeled as “simple” is given by </span><span class="s2">simpleConversionFraction</span><span class="s1">; the remainder will be modeled as “complex”, involving repair of heteroduplex mismatches.<span class="Apple-converted-space">  </span>Finally, the </span><span class="s2">GC</span><span class="s1"> bias during heteroduplex mismatch repair is given by </span><span class="s2">bias</span><span class="s1">, with the default of </span><span class="s2">0.0</span><span class="s1"> indicating no bias, </span><span class="s2">1.0</span><span class="s1"> indicating an absolute preference for </span><span class="s2">G</span><span class="s1">/</span><span class="s2">C</span><span class="s1"> mutations over </span><span class="s2">A</span><span class="s1">/</span><span class="s2">T</span><span class="s1"> mutations, and </span><span class="s2">-1.0</span><span class="s1"> indicating an absolute preference for </span><span class="s2">A</span><span class="s1">/</span><span class="s2">T</span><span class="s1"> mutations over </span><span class="s2">G</span><span class="s1">/</span><span class="s2">C</span><span class="s1"> mutations.<span class="Apple-converted-space">  </span>A non-zero bias may only be set in nucleotide-based models.<span class="Apple-converted-space">  </span>This function, and the way that gene conversion is modeled, fundamentally changed in SLiM 3.3.</span></p>
<p class="p2">(object&lt;GenomicElement&gt;)initializeGenomicElement(io&lt;GenomicElementType&gt; genomicElementType, integer start, integer end)</p>
<p class="p3"><span class="s1">Add a genomic element to the chromosome at initialization time.<span class="Apple-converted-space">  </span>The </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1"> parameters give the first and last base positions to be spanned by the new genomic element.<span class="Apple-converted-space">  </span>The new element will be based upon the genomic element type identified by </span><span class="s2">genomicElementType</span><span class="s1">, which can be either an </span><span class="s2">integer</span><span class="s1">, representing the ID of the desired element type, or an </span><span class="s2">object</span><span class="s1"> of type </span><span class="s2">GenomicElementType</span><span class="s1"> specified directly.</span></p>
<p class="p3"><span class="s1">Beginning in SLiM 3.3, this function is vectorized: the </span><span class="s2">genomicElementType</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, and </span><span class="s2">end</span><span class="s1"> parameters do not have to be singletons.<span class="Apple-converted-space">  </span>In particular, </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1"> may be of any length, but must be equal in length; each </span><span class="s2">start</span><span class="s1">/</span><span class="s2">end</span><span class="s1"> element pair will generate one new genomic element spanning the given base positions.<span class="Apple-converted-space">  </span>In this case, </span><span class="s2">genomicElementType</span><span class="s1"> may still be a singleton, providing the genomic element type to be used for all of the new genomic elements, or it may be equal in length to </span><span class="s2">start</span><span class="s1"> and </span><span class="s2">end</span><span class="s1">, providing an independent genomic element type for each new element.<span class="Apple-converted-space">  </span>When adding a large number of genomic elements, it will be much faster to add them in order of ascending position with a vectorized call.</span></p>
<p class="p3"><span class="s1">The return value provides the genomic element(s) created by the call, in the order in which they were specified in the parameters to </span><span class="s2">initializeGenomicElement()</span><span class="s1">.</span></p>
<p class="p2">(object&lt;GenomicElementType&gt;$)initializeGenomicElementType(is$ id, io&lt;MutationType&gt; mutationTypes, numeric proportions<span class="s3">, [Nf mutationMatrix = NULL]</span>)</p>
<p class="p5">Add a genomic element type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s4">id</span> must not already be used for any genomic element type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s4">mutationTypes</span> vector identifies the mutation types used by the genomic element, and the <span class="s4">proportions</span> vector should be of equal length, specifying the relative proportion of mutations that will be drawn from the corresponding mutation type (proportions do not need to add up to one; they are interpreted relatively).<span class="Apple-converted-space">  </span>The <span class="s4">id</span> parameter may be either an <span class="s4">integer</span> giving the ID of the new genomic element type, or a <span class="s4">string</span> giving the name of the new genomic element type (such as <span class="s4">"g5"</span> to specify an ID of 5).<span class="Apple-converted-space">  </span>The <span class="s4">mutationTypes</span> parameter may be either an <span class="s4">integer</span> vector representing the IDs of the desired mutation types, or an <span class="s4">object</span> vector of <span class="s4">MutationType</span> elements specified directly.<span class="Apple-converted-space">  </span>The global symbol for the new genomic element type is immediately available; the return value also provides the new object.</p>
<p class="p3"><span class="s1">The </span><span class="s2">mutationMatrix</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> by default, and in non-nucleotide-based models it must be </span><span class="s2">NULL</span><span class="s1">.<span class="Apple-converted-space">  </span>In nucleotide-based models, on the other hand, it must be non-</span><span class="s2">NULL</span><span class="s1">, and therefore must be supplied.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">mutationMatrix</span><span class="s1"> should take one of two standard forms.<span class="Apple-converted-space">  </span>For sequence-based mutation rates that depend upon only the single nucleotide at a mutation site, </span><span class="s2">mutationMatrix</span><span class="s1"> should be a 4×4 </span><span class="s2">float</span><span class="s1"> matrix, specifying mutation rates for an existing nucleotide state (rows from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">3</span><span class="s1"> representing A/C/G/T) to each of the four possible derived nucleotide states (columns, with the same meaning).<span class="Apple-converted-space">  </span>The mutation rates in this matrix are absolute rates, per nucleotide per generation; they will be used by SLiM directly unless they are multiplied by a factor from the hotspot map (see </span><span class="s2">initializeHotspotMap()</span><span class="s1">).<span class="Apple-converted-space">  </span>Rates in </span><span class="s2">mutationMatrix</span><span class="s1"> that involve the mutation of a nucleotide to itself (</span><span class="s2">A</span><span class="s1"> to </span><span class="s2">A</span><span class="s1">, </span><span class="s2">C</span><span class="s1"> to </span><span class="s2">C</span><span class="s1">, etc.) are not used by SLiM and must be </span><span class="s2">0.0</span><span class="s1"> by convention.</span></p>
<p class="p3"><span class="s1">It is important to note that the order of the rows and columns used in SLiM, A/C/G/T, is not a universal convention; other sources will present substitution-rate/transition-rate matrices using different conventions, and so care must be taken when importing such matrices into SLiM.</span></p>
<p class="p3"><span class="s1">For sequence-based mutation rates that depend upon the trinucleotide sequence centered upon a mutation site (the adjacent bases to the left and right, in other words, as well as the mutating nucleotide itself), </span><span class="s2">mutationMatrix</span><span class="s1"> should be a 64×4 </span><span class="s2">float</span><span class="s1"> matrix, specifying mutation rates for the central nucleotide of an existing trinucleotide sequence (rows from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">63</span><span class="s1">, representing codons as described in the documentation for the </span><span class="s2">ancestralNucleotides()</span><span class="s1"> method of </span><span class="s2">Chromosome</span><span class="s1">) to each of the four possible derived nucleotide states (columns from </span><span class="s2">0</span><span class="s1">–</span><span class="s2">3</span><span class="s1"> for A/C/G/T as before).<span class="Apple-converted-space">  </span>Note that in every case it is the central nucleotide of the trinucleotide sequence that is mutating, but rates can be specified independently based upon the nucleotides in the first and third positions as well, with this type of mutation matrix.</span></p>
<p class="p3"><span class="s1">Several helper functions are defined to construct common types of mutation matrices, such as </span><span class="s2">mmJukesCantor()</span><span class="s1"> to create a mutation matrix for a Jukes–Cantor model.</span></p>
<p class="p4"><span class="s1">(void)initializeHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = "*"])</span></p>
<p class="p3"><span class="s1">In nucleotide-based models, set the mutation rate <i>multiplier</i> along the chromosome.<span class="Apple-converted-space">  </span>Nucleotide-based models define sequence-based mutation rates that are set up with the </span><span class="s2">mutationMatrix</span><span class="s1"> parameter to </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>If no hotspot map is specified by calling </span><span class="s2">initializeHotspotMap()</span><span class="s1">, a hotspot map with a multiplier of </span><span class="s2">1.0</span><span class="s1"> across the whole chromosome is assumed (and so the sequence-based rates are the absolute mutation rates used by SLiM).<span class="Apple-converted-space">  </span>A hotspot map modifies the sequence-based rates by scaling them up in some regions, with multipliers greater than </span><span class="s2">1.0</span><span class="s1"> (representing mutational hot spots), and/or scaling them down in some regions, with multipliers less than </span><span class="s2">1.0</span><span class="s1"> (representing mutational cold spots).</span></p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">multipliers</span><span class="s1"> must be a singleton value that specifies a single multiplier to be used along the entire chromosome (typically </span><span class="s2">1.0</span><span class="s1">, but not required to be).<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">multipliers</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">multipliers</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p6"><span class="s5"><span class="Apple-tab-span">	</span></span><span class="s1">initializeHotspotMap(c(1.0, 1.2), c(5000, 9999));</span></p>
<p class="p3"><span class="s1">then the result is that the mutation rate multiplier for bases </span><span class="s2">0</span><span class="s1">...</span><span class="s2">5000</span><span class="s1"> (inclusive) will be </span><span class="s2">1.0</span><span class="s1"> (and so the specified sequence-based mutation rates will be used verbatim), and the multiplier for bases </span><span class="s2">5001</span><span class="s1">...</span><span class="s2">9999</span><span class="s1"> (inclusive) will be </span><span class="s2">1.2</span><span class="s1"> (and so the sequence-based mutation rates will be multiplied by 1.2 within the region).</span></p>
<p class="p3"><span class="s1">Note that mutations are generated by SLiM only within genomic elements, regardless of the hotspot map.<span class="Apple-converted-space">  </span>In effect, the hotspot map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a multiplier of zero.<span class="Apple-converted-space">  </span>There is no harm in supplying a hotspot map that specifies multipliers for areas outside of the genomic elements defined; the excess information is simply not used.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied hotspot map is used only for that sex (i.e., when generating a gamete from a parent of that sex).<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeHotspotMap()</span><span class="s1">, one for each sex, even if a multiplier of </span><span class="s2">1.0</span><span class="s1"> is desired for the other sex; no default hotspot map is supplied.</span></p>
<p class="p2">(object&lt;InteractionType&gt;$)initializeInteractionType(is$ id, string$ spatiality, [logical$ reciprocal = F], [numeric$ maxDistance = INF], [string$ sexSegregation = "**"])</p>
<p class="p5">Add an interaction type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s4">id</span> must not already be used for any interaction type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s4">id</span> parameter may be either an <span class="s4">integer</span> giving the ID of the new interaction type, or a <span class="s4">string</span> giving the name of the new interaction type (such as <span class="s4">"i5"</span> to specify an ID of 5).</p>
<p class="p5">The <span class="s4">spatiality</span> may be <span class="s4">""</span>, for non-spatial interactions (i.e., interactions that do not depend upon the distance between individuals); <span class="s4">"x"</span><span class="s6">,</span> <span class="s4">"y"</span>, or <span class="s4">"z"</span> for one-dimensional interactions; <span class="s4">"xy"</span>, <span class="s4">"xz"</span>, or <span class="s4">"yz"</span> for two-dimensional interactions; or <span class="s4">"xyz"</span> for three-dimensional interactions.<span class="Apple-converted-space">  </span>The dimensions referenced by spatiality must have been previously defined as spatial dimensions with <span class="s4">initializeSLiMOptions()</span>; if the simulation has dimensionality <span class="s4">"xy"</span>, for example, then interactions in the simulation may have spatiality <span class="s4">""</span>, <span class="s4">"x"</span>, <span class="s4">"y"</span>, or <span class="s4">"xy"</span>, but may not reference spatial dimension <i>z</i> and thus may not have spatiality <span class="s4">"xz"</span>, <span class="s4">"yz"</span>, or <span class="s4">"xyz"</span><span class="s6">.</span><span class="Apple-converted-space">  </span>If no spatial dimensions have been configured, only non-spatial interactions may be defined.</p>
<p class="p5">The <span class="s4">reciprocal</span> flag may be <span class="s4">T</span>, in which case the interaction is guaranteed by the user to be <i>reciprocal</i>: whatever the interaction strength is for individual B upon individual A, it will be equal (in magnitude and sign) for A upon B.<span class="Apple-converted-space">  </span>This allows the <span class="s4">InteractionType</span> to reduce the amount of computation necessary by up to a factor of two.<span class="Apple-converted-space">  </span>If <span class="s4">reciprocal</span> is <span class="s4">F</span>, the interaction is not guaranteed to be reciprocal and each interaction will be computed independently.<span class="Apple-converted-space">  </span>The built-in interaction formulas are all reciprocal, but if you implement an <span class="s4">interaction()</span> callback, you must consider whether the callback you have implemented preserves reciprocality or not.<span class="Apple-converted-space">  </span>For this reason, the default is <span class="s4">reciprocal=F</span>, so that bugs are not inadvertently introduced by an invalid assumption of reciprocality.<span class="Apple-converted-space">  </span>See below for a note regarding reciprocality in sexual simulations when using the <span class="s4">sexSegregation</span> flag.</p>
<p class="p5">Note that even if an interaction is reciprocal, it may occasionally be slightly faster for <span class="s4">reciprocal</span> to be set to <span class="s4">F</span>.<span class="Apple-converted-space">  </span>This is most likely when the amount of computation per interaction is very small (particularly if no <span class="s4">interaction()</span> callbacks are involved), and when it is unlikely that the reciprocal of a queried interaction will also be queried.<span class="Apple-converted-space">  </span>Even in such cases, however, the slowdown for <span class="s4">reciprocal=T</span> should be fairly small.<span class="Apple-converted-space">  </span>In most usage cases, setting <span class="s4">reciprocal</span> to <span class="s4">T</span> (when the interaction is in fact reciprocal) will result in at least equal performance, if not better; with a very slow <span class="s4">interaction()</span> callback, the performance can be as much as double, making it generally worthwhile to use <span class="s4">reciprocal=T</span> when possible.<span class="Apple-converted-space">  </span>However, for maximal performance one might wish to time and compare runs with reciprocality enabled and disabled (using the same random number seed).</p>
<p class="p5">The <span class="s4">maxDistance</span> parameter supplies the maximum distance over which interactions of this type will be evaluated; at greater distances, the interaction strength is considered to be zero (for efficiency).<span class="Apple-converted-space">  </span>The default value of <span class="s4">maxDistance</span>, <span class="s4">INF</span> (positive infinity), indicates that there is no maximum interaction distance; note that this can make some interaction queries much less efficient, and is therefore not recommended.</p>
<p class="p5">The <span class="s4">sexSegregation</span> parameter governs the applicability of the interaction to each sex, in sexual simulations.<span class="Apple-converted-space">  </span>It does not affect distance calculations in any way; it only modifies the way in which interaction strengths are calculated.<span class="Apple-converted-space">  </span>The default, <span class="s4">"**"</span>, implies that the interaction is felt by both sexes (the first character of the <span class="s4">string</span> value) and is exerted by both sexes (the second character of the <span class="s4">string</span> value).<span class="Apple-converted-space">  </span>Either or both characters may be <span class="s4">M</span> or <span class="s4">F</span> instead; for example, <span class="s4">"MM"</span> would indicate a male-male interaction, such as male-male competition, whereas <span class="s4">"FM"</span> would indicate an interaction influencing only females that is influenced only by males, such as male mating displays that influence female attraction.<span class="Apple-converted-space">  </span>This parameter may be set only to <span class="s4">"**"</span> unless sex has been enabled with <span class="s4">initializeSex()</span><span class="s6">.</span><span class="Apple-converted-space">  </span>Note that a value of <span class="s4">sexSegregation</span> other than <span class="s4">"**"</span> may imply some degree of non-reciprocality, but it is not necessary to specify <span class="s4">reciprocal</span> to be <span class="s4">F</span> for this reason; SLiM will take the sex-segregation of the interaction into account for you.<span class="Apple-converted-space">  </span>The value of <span class="s4">reciprocal</span> may therefore be interpreted as meaning: in those cases, if any, in which A interacts with B and B interacts with A, is the interaction strength guaranteed to be the same in both directions?</p>
<p class="p5">By default, the interaction strength is <span class="s4">1.0</span> for all interactions within <span class="s4">maxDistance</span>.<span class="Apple-converted-space">  </span>Often it is desirable to change the interaction function using <span class="s4">setInteractionFunction()</span>; modifying interaction strengths can also be achieved with <span class="s4">interaction()</span> callbacks if necessary.<span class="Apple-converted-space">  </span>In any case, interactions beyond <span class="s4">maxDistance</span> always have a strength of <span class="s4">0.0</span>, and the interaction strength of an individual with itself is always <span class="s4">0.0</span>, regardless of the interaction function or callbacks.</p>
<p class="p5">The global symbol for the new interaction type is immediately available; the return value also provides the new object.</p>
<p class="p2">(void)initializeMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p3"><span class="s1">Set the mutation rate per base position per generation along the chromosome.<span class="Apple-converted-space">  </span>To be precise, this mutation rate is the expected mean number of mutations that will occur per base position per generation (per new offspring genome being generated); note that this is different from how the recombination rate is defined (see </span><span class="s2">initializeRecombinationRate()</span><span class="s1">).<span class="Apple-converted-space">  </span>The number of mutations that actually occurs at a given base position when generating an offspring genome is, in effect, drawn from a Poisson distribution with that expected mean (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).<span class="Apple-converted-space">  </span>It is possible for this Poisson draw to indicate that two or more new mutations have arisen at the same base position, particularly when the mutation rate is very high; in this case, the new mutations will be added to the site one at a time, and as always the mutation stacking policy will be followed.</span></p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">rates</span><span class="s1"> must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p7"><span class="s6"><span class="Apple-tab-span">	</span></span>initializeMutationRate(c(1e-7, 2.5e-8), c(5000, 9999));</p>
<p class="p3"><span class="s1">then the result is that the mutation rate for bases </span><span class="s2">0</span><span class="s1">...</span><span class="s2">5000</span><span class="s1"> (inclusive) will be </span><span class="s2">1e-7</span><span class="s1">, and the rate for bases </span><span class="s2">5001</span><span class="s1">...</span><span class="s2">9999</span><span class="s1"> (inclusive) will be </span><span class="s2">2.5e-8</span><span class="s1">.</span></p>
<p class="p3"><span class="s1">Note that mutations are generated by SLiM only within genomic elements, regardless of the mutation rate map.<span class="Apple-converted-space">  </span>In effect, the mutation rate map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a mutation rate of zero.<span class="Apple-converted-space">  </span>There is no harm in supplying a mutation rate map that specifies rates for areas outside of the genomic elements defined; that rate information is simply not used.<span class="Apple-converted-space">  </span>The </span><span class="s2">overallMutationRate</span><span class="s1"> family of properties on </span><span class="s2">Chromosome</span><span class="s1"> provide the overall mutation rate after genomic element coverage has been taken into account, so it will reflect the rate at which new mutations will actually be generated in the simulation as configured.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied mutation rate map is used only for that sex (i.e., when generating a gamete from a parent of that sex).<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeMutationRate()</span><span class="s1">, one for each sex, even if a rate of zero is desired for the other sex; no default mutation rate map is supplied.</span></p>
<p class="p3"><span class="s1">In nucleotide-based models, </span><span class="s2">initializeMutationRate()</span><span class="s1"> may not be called.<span class="Apple-converted-space">  </span>Instead, the desired sequence-based mutation rate(s) should be expressed in the </span><span class="s2">mutationMatrix</span><span class="s1"> parameter to </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>If variation in the mutation rate along the chromosome is desired, </span><span class="s2">initializeHotspotMap()</span><span class="s1"> should be used.</span></p>
<p class="p2">(object&lt;MutationType&gt;$)initializeMutationType(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)</p>
<p class="p5">Add a mutation type at initialization time.<span class="Apple-converted-space">  </span>The <span class="s4">id</span> must not already be used for any mutation type in the simulation.<span class="Apple-converted-space">  </span>The <span class="s4">id</span> parameter may be either an <span class="s4">integer</span> giving the ID of the new mutation type, or a <span class="s4">string</span> giving the name of the new mutation type (such as <span class="s4">"m5"</span> to specify an ID of 5).<span class="s3"><span class="Apple-converted-space">  </span>The dominanceCoeff parameter supplies the dominance coefficient for the mutation type; </span><span class="s7">0.0</span><span class="s3"> produces no dominance, </span><span class="s7">1.0</span><span class="s3"> complete dominance, and values greater than </span><span class="s7">1.0</span><span class="s3">, overdominance.</span><span class="Apple-converted-space">  </span>The <span class="s4">distributionType</span> may be <span class="s4">"f"</span>, in which case the ellipsis <span class="s4">...</span> should supply a <span class="s4">numeric$</span> fixed selection coefficient; <span class="s4">"e"</span>, in which case the ellipsis should supply a <span class="s4">numeric$</span> mean selection coefficient for an exponential distribution; <span class="s4">"g"</span>, in which case the ellipsis should supply a <span class="s4">numeric$</span> mean selection coefficient and a <span class="s4">numeric$</span> alpha shape parameter for a gamma distribution; <span class="s4">"n"</span>, in which case the ellipsis should supply a <span class="s4">numeric$</span> mean selection coefficient and a <span class="s4">numeric$</span> sigma (standard deviation) parameter for a normal distribution; <span class="s4">"w"</span>, in which case the ellipsis should supply a <span class="s4">numeric$</span> <span class="s8">λ</span> scale parameter and a <span class="s4">numeric$</span> k shape parameter for a Weibull distribution; or <span class="s4">"s"</span>, in which case the ellipsis should supply a <span class="s4">string$</span> Eidos script parameter.<span class="Apple-converted-space">  </span>The global symbol for the new mutation type is immediately available; the return value also provides the new object.</p>
<p class="p3"><span class="s1">Note that by default in WF models, all mutations of a given mutation type will be converted into </span><span class="s2">Substitution</span><span class="s1"> objects when they reach fixation, for efficiency reasons.<span class="Apple-converted-space">  </span>If you need to disable this conversion, to keep mutations of a given type active in the simulation even after they have fixed, you can do so by setting the </span><span class="s2">convertToSubstitution</span><span class="s1"> property of </span><span class="s2">MutationType</span><span class="s1"> to </span><span class="s2">F</span><span class="s1">.<span class="Apple-converted-space">  </span>In contrast, by default in nonWF models mutations will not be converted into </span><span class="s2">Substitution</span><span class="s1"> objects when they reach fixation; </span><span class="s2">convertToSubstitution</span><span class="s1"> is </span><span class="s2">F</span><span class="s1"> by default in nonWF models.<span class="Apple-converted-space">  </span>To enable conversion in nonWF models for neutral mutation types with no indirect fitness effects, you should therefore set </span><span class="s2">convertToSubstitution</span><span class="s1"> to </span><span class="s2">T</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(object&lt;MutationType&gt;$)initializeMutationTypeNuc(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)</span></p>
<p class="p3"><span class="s1">Add a nucleotide-based mutation type at initialization time.<span class="Apple-converted-space">  </span>This function is identical to </span><span class="s2">initializeMutationType()</span><span class="s1"> except that the new mutation type will be nucleotide-based – in other words, mutations belonging to the new mutation type will have an associated nucleotide.<span class="Apple-converted-space">  </span>This function may be called only in nucleotide-based models (as enabled by the </span><span class="s2">nucleotideBased</span><span class="s1"> parameter to </span><span class="s2">initializeSLiMOptions()</span><span class="s1">).</span></p>
<p class="p3"><span class="s1">Nucleotide-based mutations always use a </span><span class="s2">mutationStackGroup</span><span class="s1"> of </span><span class="s2">-1</span><span class="s1"> and a </span><span class="s2">mutationStackPolicy</span><span class="s1"> of </span><span class="s2">"l"</span><span class="s1">.<span class="Apple-converted-space">  </span>This ensures that a new nucleotide mutation always replaces any previously existing nucleotide mutation at a given position, regardless of the mutation types of the nucleotide mutations.<span class="Apple-converted-space">  </span>These values are set automatically by </span><span class="s2">initializeMutationTypeNuc()</span><span class="s1">, and may not be changed.</span></p>
<p class="p3"><span class="s1">See the documentation for </span><span class="s2">initializeMutationType()</span><span class="s1"> for all other discussion.</span></p>
<p class="p2">(void)initializeRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = "*"])</p>
<p class="p3"><span class="s1">Set the recombination rate per base position per generation along the chromosome.<span class="Apple-converted-space">  </span>To be precise, this recombination rate is the probability that a breakpoint will occur between one base and the next base; note that this is different from how the mutation rate is defined (see </span><span class="s2">initializeMutationRate()</span><span class="s1">).<span class="Apple-converted-space">  </span>All rates must be in the interval [</span><span class="s2">0.0</span><span class="s1">, </span><span class="s2">0.5</span><span class="s1">].<span class="Apple-converted-space">  </span>A rate of </span><span class="s2">0.5</span><span class="s1"> implies complete independence between the adjacent bases, which might be used to implement independent assortment of loci located on different chromosomes (see the example below).<span class="Apple-converted-space">  </span>Whether a breakpoint occurs between two bases is then, in effect, determined by a binomial draw with a single trial and the given rate as probability (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).<span class="Apple-converted-space">  </span>Unlike the mutational process in SLiM, then, which can generate more than one mutation at a given site (in one generation/genome), the recombinational process in SLiM will never generate more then one crossover between one base and the next (in one generation/genome), and a supplied rate of </span><span class="s2">0.5</span><span class="s1"> will therefore result in an actual probability of </span><span class="s2">0.5</span><span class="s1"> for a crossover at the relevant position.<span class="Apple-converted-space">  </span>(Note that this was not true in SLiM 2.x and earlier, however; their implementation of recombination resulted in a crossover probability of about 39.3% for a rate of </span><span class="s2">0.5</span><span class="s1">, due to the use of an inaccurate approximation method.<span class="Apple-converted-space">  </span>Recombination rates lower than about </span><span class="s2">0.01</span><span class="s1"> would have been essentially exact, since the approximation error became large only as the rate approached </span><span class="s2">0.5</span><span class="s1">.)</span></p>
<p class="p3"><span class="s1">There are two ways to call this function.<span class="Apple-converted-space">  </span>If the optional </span><span class="s2">ends</span><span class="s1"> parameter is </span><span class="s2">NULL</span><span class="s1"> (the default), then </span><span class="s2">rates</span><span class="s1"> must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.<span class="Apple-converted-space">  </span>If, on the other hand, </span><span class="s2">ends</span><span class="s1"> is supplied, then </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> must be the same length, and the values in </span><span class="s2">ends</span><span class="s1"> must be specified in ascending order.<span class="Apple-converted-space">  </span>In that case, </span><span class="s2">rates</span><span class="s1"> and </span><span class="s2">ends</span><span class="s1"> taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in </span><span class="s2">ends</span><span class="s1"> should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).<span class="Apple-converted-space">  </span>Note that a recombination rate of 1 centimorgan/Mbp corresponds to a recombination rate of </span><span class="s2">1e-8</span><span class="s1"> in the units used by SLiM.</span></p>
<p class="p3"><span class="s1">For example, if the following call is made:</span></p>
<p class="p7"><span class="s6"><span class="Apple-tab-span">	</span></span>initializeRecombinationRate(c(0, 0.5, 0), c(5000, 5001, 9999));</p>
<p class="p3"><span class="s1">then the result is that the recombination rates between bases </span><span class="s2">0</span><span class="s1"> / </span><span class="s2">1</span><span class="s1">, </span><span class="s2">1</span><span class="s1"> / </span><span class="s2">2</span><span class="s1">, ..., </span><span class="s2">4999</span><span class="s1"> / </span><span class="s2">5000</span><span class="s1"> will be </span><span class="s2">0</span><span class="s1">, the rate between bases </span><span class="s2">5000</span><span class="s1"> / </span><span class="s2">5001</span><span class="s1"> will be </span><span class="s2">0.5</span><span class="s1">, and the rate between bases </span><span class="s2">5001</span><span class="s1"> / </span><span class="s2">5002</span><span class="s1"> onward (up to </span><span class="s2">9998</span><span class="s1"> / </span><span class="s2">9999</span><span class="s1">) will again be </span><span class="s2">0</span><span class="s1">.<span class="Apple-converted-space">  </span>Setting the recombination rate between one specific pair of bases to </span><span class="s2">0.5</span><span class="s1"> forces recombination to occur with a probability of </span><span class="s2">0.5</span><span class="s1"> between those bases, which effectively breaks the simulated locus into separate chromosomes at that point; this example effectively has one simulated chromosome from base position </span><span class="s2">0</span><span class="s1"> to </span><span class="s2">5000</span><span class="s1">, and another from </span><span class="s2">5001</span><span class="s1"> to </span><span class="s2">9999</span><span class="s1">.</span></p>
<p class="p3"><span class="s1">If the optional </span><span class="s2">sex</span><span class="s1"> parameter is </span><span class="s2">"*"</span><span class="s1"> (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).<span class="Apple-converted-space">  </span>In sexual simulations </span><span class="s2">sex</span><span class="s1"> may be </span><span class="s2">"M"</span><span class="s1"> or </span><span class="s2">"F"</span><span class="s1"> instead, in which case the supplied recombination map is used only for that sex.<span class="Apple-converted-space">  </span>In this case, two calls must be made to </span><span class="s2">initializeRecombinationRate()</span><span class="s1">, one for each sex, even if a rate of zero is desired for the other sex; no default recombination map is supplied.</span></p>
<p class="p2">(void)initializeSex(string$ chromosomeType, [numeric$ xDominanceCoeff = 1])</p>
<p class="p5">Enable and configure sex in the simulation.<span class="Apple-converted-space">  </span>The argument <span class="s4">chromosomeType</span> gives the type of chromosome to be simulated; this should be <span class="s4">"A"</span>, <span class="s4">"X"</span>, or <span class="s4">"Y"</span>.<span class="Apple-converted-space">  </span>If the <span class="s4">chromosomeType</span> is <span class="s4">"X"</span><span class="s6">,</span> the optional <span class="s4">xDominanceCoeff</span> parameter can supply the dominance coefficient used when a mutation is present in an XY male, and is thus “heterozygous” (but in a different sense than the heterozygosity of an XX female with one copy of the mutation).<span class="Apple-converted-space">  </span>Calling this function has the side effect of enabling sex in the simulation; individuals will be male and female (rather than hermaphroditic) regardless of the <span class="s4">chromosomeType</span> chosen for simulation.<span class="Apple-converted-space">  </span>There is no way to disable sex once it has been enabled; if you don’t want to have sex, don’t call this function.</p>
<p class="p2">(void)initializeSLiMModelType(string$ modelType)</p>
<p class="p3"><span class="s1">Configure the type of SLiM model used for the simulation.<span class="Apple-converted-space">  </span>At present, one of two model types may be selected.<span class="Apple-converted-space">  </span>If </span><span class="s2">modelType</span><span class="s1"> is </span><span class="s2">"WF"</span><span class="s1">, SLiM will use a Wright-Fisher (WF) model; this is the model type that has always been supported by SLiM, and is the model type used if </span><span class="s2">initializeSLiMModelType()</span><span class="s1"> is not called.<span class="Apple-converted-space">  </span>If </span><span class="s2">modelType</span><span class="s1"> is </span><span class="s2">"nonWF"</span><span class="s1">, SLiM will use a non-Wright-Fisher (nonWF) model instead; this is a new model type supported by SLiM 3.0 and above.</span></p>
<p class="p3"><span class="s1">If </span><span class="s2">initializeSLiMModelType()</span><span class="s1"> is called at all then it must be called before any other initialization function, so that SLiM knows from the outset which features are enabled and which are not.</span></p>
<p class="p2">(void)initializeSLiMOptions([logical$ keepPedigrees = F], [string$ dimensionality = ""], [string$ periodicity = ""], [integer$ mutationRuns = 0], [logical$ preventIncidentalSelfing = F]<span class="s3">, [logical$ nucleotideBased = F]</span>)</p>
<p class="p3"><span class="s1">Configure options for the simulation.<span class="Apple-converted-space">  </span>If </span><span class="s2">initializeSLiMOptions()</span><span class="s1"> is called at all then it must be called before any other initialization function (except </span><span class="s2">initializeSLiMModelType()</span><span class="s1">), so that SLiM knows from the outset which optional features are enabled and which are not.</span></p>
<p class="p5">If <span class="s4">keepPedigrees</span> is <span class="s4">T</span>, SLiM will keep pedigree information for every individual in the simulation, tracking the identity of its parents and grandparents.<span class="Apple-converted-space">  </span>This allows individuals to assess their degree of pedigree-based relatedness to other individuals (see <span class="s4">Individual</span>’s <span class="s4">relatedness()</span> method), as well as allowing a model to find “trios” (two parents and an offspring they generated) using the pedigree properties of <span class="s4">Individual</span>.<span class="Apple-converted-space">  </span><span class="s3">As a side effect of </span><span class="s7">keepPedigrees</span><span class="s3"> being </span><span class="s7">T</span><span class="s3">, the </span><span class="s7">pedigreeID</span><span class="s3">, </span><span class="s7">pedigreeParentIDs</span><span class="s3">, and </span><span class="s7">pedigreeGrandparentIDs</span><span class="s3"> properties of </span><span class="s7">Individual</span><span class="s3"> will have defined values, as will the </span><span class="s7">genomePedigreeID</span><span class="s3"> property of </span><span class="s7">Genome</span><span class="s3">.<span class="Apple-converted-space">  </span></span>Note that pedigree-based relatedness doesn’t necessarily correspond to genetic relatedness, due to effects such as assortment and recombination.</p>
<p class="p5">If <span class="s4">dimensionality</span> is not <span class="s4">""</span>, SLiM will enable its optional “continuous space” facility.<span class="Apple-converted-space">  </span>Three values for <span class="s4">dimensionality</span> are presently supported: <span class="s4">"x"</span>, <span class="s4">"xy"</span>, and <span class="s4">"xyz"</span>, specifying that continuous space should be enabled for one, two, or three dimensions, respectively, using (<i>x</i>), (<i>x</i>, <i>y</i>), and (<i>x</i>, <i>y</i>, <i>z</i>) coordinates respectively.<span class="Apple-converted-space">  </span>This has a number of side effects.<span class="Apple-converted-space">  </span>First of all, it means that the specified properties of <span class="s4">Individual</span> (<span class="s4">x</span>, <span class="s4">y</span>, and/or <span class="s4">z</span>) will be interpreted by SLiM as spatial positions; in particular, SLiMgui will use those properties to display subpopulations spatially.<span class="Apple-converted-space">  </span>Second, it allows spatial interactions to be defined, evaluated, and queried using <span class="s4">initializeInteractionType()</span> and <span class="s4">interaction()</span> callbacks.<span class="Apple-converted-space">  </span>And third, it enables the use of any other properties and methods related to continuous space, such as setting the spatial boundaries of subpopulations, which would otherwise raise an error.</p>
<p class="p3"><span class="s1">If </span><span class="s2">periodicity</span><span class="s1"> is not </span><span class="s2">""</span><span class="s1">, SLiM will designate the specified spatial dimensions as being periodic – wrapping around at the edges of the spatial boundaries of that dimension.<span class="Apple-converted-space">  </span>This option may only be used if the </span><span class="s2">dimensionality</span><span class="s1"> parameter to </span><span class="s2">initializeSLiMOptions()</span><span class="s1"> has been used to enable spatiality in the model, and only spatial dimensions that were specified in the dimensionality of the model may be declared to be periodic (but if desired, it is permissible to make just a subset of those dimensions periodic; it is not an all-or-none proposition).<span class="Apple-converted-space">  </span>For example, if the specified dimensionality is </span><span class="s2">"xy"</span><span class="s1">, the model’s periodicity may be </span><span class="s2">"x"</span><span class="s1">, </span><span class="s2">"y"</span><span class="s1">, or </span><span class="s2">"xy"</span><span class="s1"> (or </span><span class="s2">""</span><span class="s1">, the default, to specify that there are no periodic dimensions).<span class="Apple-converted-space">  </span>A one-dimensional periodic model would model a space like the perimeter of a circle.<span class="Apple-converted-space">  </span>A two-dimensional model periodic in one of those dimensions would model a space like a cylinder without its end caps; if periodic in both dimensions, the modeled space is a torus.<span class="Apple-converted-space">  </span>The shapes of three-dimensional periodic models are harder to visualize, but are essentially higher-dimensional analogues of these concepts.<span class="Apple-converted-space">  </span>Periodic boundary conditions are commonly used to model spatial scenarios without “edge effects”, since there are no edges in the periodic spatial dimensions.<span class="Apple-converted-space">  </span>The </span><span class="s2">pointPeriodic()</span><span class="s1"> method of </span><span class="s2">Subpopulation</span><span class="s1"> is typically used in conjunction with this option, to actually implement the periodic boundary condition for the specified dimensions.</span></p>
<p class="p5">If <span class="s4">mutationRuns</span> is not <span class="s4">0</span>, SLiM will use the value given as the number of mutation runs inside <span class="s4">Genome</span> objects; if it is <span class="s4">0</span> (the default), SLiM will calculate a number of mutation runs that it estimates will work well.<span class="Apple-converted-space">  </span>Internally, SLiM divides genomes into a sequence of consecutive mutation runs, allowing more efficient internal computations.<span class="Apple-converted-space">  </span>The optimal mutation run length is short enough that each mutation run is relatively unlikely to be modified by mutation/recombination events when inherited, but long enough that each mutation run is likely to contain a relatively large number of mutations; these priorities are in tension, so an intermediate balance between them is generally desirable.<span class="Apple-converted-space">  </span>The optimal number of mutation runs will depend upon the machine and even the compiler used to build SLiM, so SLiM’s default value may not be optimal; for maximal performance it can thus be beneficial to experiment with different values and find the optimal value for the simulation.<span class="Apple-converted-space">  </span>Specifying the number of mutation runs is an advanced technique, but in certain cases it can improve performance significantly; in particular, if a simulation involves a very long chromosome but only a small portion of that chromosome is actually used by the simulation, it may be beneficial to specify that a single mutation run be used with <span class="s4">mutationRuns=1</span><span class="s6">.</span></p>
<p class="p5">If <span class="s4">preventIncidentalSelfing</span> is <span class="s4">T</span>, incidental selfing in hermaphroditic models will be prevented by SLiM.<span class="Apple-converted-space">  </span>By default (i.e., if <span class="s4">preventIncidentalSelfing</span> is <span class="s4">F</span>), SLiM chooses the first and second parents in a biparental mating event independently.<span class="Apple-converted-space">  </span>It is therefore possible for the same individual to be chosen as both the first and second parent, resulting in selfing events even when the selfing rate is zero.<span class="Apple-converted-space">  </span>In many models this is unimportant, since it happens fairly infrequently and does not have large consequences.<span class="Apple-converted-space">  </span>This behavior is SLiM’s default because it is the simplest option, and produces results that most closely align with simple analytical population genetics models.<span class="Apple-converted-space">  </span>However, in some models this selfing can be undesirable and problematic.<span class="Apple-converted-space">  </span>In particular, models that involve very high variance in fitness or very small effective population sizes may see elevated rates of selfing that substantially influence model results.<span class="Apple-converted-space">  </span>If <span class="s4">preventIncidentalSelfing</span> is set to <span class="s4">T</span>, all such incidental selfing will be prevented (by choosing a new second parent if the first parent was chosen again).<span class="Apple-converted-space">  </span>Non-incidental selfing, as requested by the selfing rate, will still be permitted.<span class="Apple-converted-space">  </span>Note that if incidental selfing is prevented, SLiM will hang if it is unable to find a different second parent; there must always be at least two individuals in the population with non-zero fitness, and <span class="s4">mateChoice()</span> and <span class="s4">modifyChild()</span> callbacks must not absolutely prevent those two individuals from producing viable offspring.<span class="Apple-converted-space">  </span>Enforcement of the prohibition on incidental selfing will occur after <span class="s4">mateChoice()</span> callbacks have been called (and thus the default mating weights provided to <span class="s4">mateChoice()</span> callbacks will <i>not</i> exclude the first parent!), but will occur before <span class="s4">modifyChild()</span> callbacks are called (so those callbacks may assume that the first and second parents are distinct).</p>
<p class="p3"><span class="s1">If </span><span class="s2">nucleotideBased</span><span class="s1"> is </span><span class="s2">T</span><span class="s1">, the model will be nucleotide-based.<span class="Apple-converted-space">  </span>In this case, auto-generated mutations (i.e., mutation types used by genomic element types) must be nucleotide-based, and an ancestral nucleotide sequence must be supplied with </span><span class="s2">initializeAncestralNucleotides()</span><span class="s1">.<span class="Apple-converted-space">  </span>Non-nucleotide-based mutations may still be used, but may not be referenced by genomic element types.<span class="Apple-converted-space">  </span>A mutation rate (or rate map) may not be supplied with </span><span class="s2">initializeMutationRate()</span><span class="s1">; instead, a hotspot map may (optionally) be supplied with </span><span class="s2">initializeHotspotMap()</span><span class="s1">.<span class="Apple-converted-space">  </span>This choice has many consequences across SLiM.<span class="Apple-converted-space"> </span></span></p>
<p class="p5">This function will likely be extended with further options in the future, added on to the end of the argument list.<span class="Apple-converted-space">  </span>Using named arguments with this call is recommended for readability.<span class="Apple-converted-space">  </span>Note that turning on optional features may increase the runtime and memory footprint of SLiM.</p>
<p class="p4"><span class="s1">(void)initializeTreeSeq([logical$ recordMutations = T], [Nif$ simplificationRatio = NULL], [Ni$ simplificationInterval = NULL], [logical$ checkCoalescence = F], [logical$ runCrosschecks = F])</span></p>
<p class="p3"><span class="s1">Configure options for tree sequence recording.<span class="Apple-converted-space">  </span>Calling this function turns on tree sequence recording, as a side effect, for later reconstruction of the simulation’s evolutionary dynamics; if you do not want tree sequence recording to be enabled, do not call this function.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">recordMutations</span><span class="s1"> flag controls whether information about individual mutations is recorded or not.<span class="Apple-converted-space">  </span>Such recording takes time and memory, and so can be turned off if only the tree sequence itself is needed, but it is turned on by default since mutation recording is generally useful.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">simplificationRatio</span><span class="s1"> and </span><span class="s2">simplificationInterval</span><span class="s1"> parameters control how often automatic simplification of the recorded tree sequence occurs.<span class="Apple-converted-space">  </span>This is a speed–memory tradeoff: more frequent simplification (lower </span><span class="s2">simplificationRatio</span><span class="s1"> or smaller </span><span class="s2">simplificationInterval</span><span class="s1">) means the stored tree sequences will use less memory, but at a cost of somewhat longer run times.<span class="Apple-converted-space">  </span>Conversely, a larger </span><span class="s2">simplificationRatio</span><span class="s1"> or </span><span class="s2">simplificationInterval</span><span class="s1"> means that SLiM will wait longer between simplifications.<span class="Apple-converted-space">  </span>There are three ways these parameters can be used.<span class="Apple-converted-space">  </span>With the first option, with a non-</span><span class="s2">NULL</span><span class="s1"> </span><span class="s2">simplificationRatio</span><span class="s1"> and a </span><span class="s2">NULL</span><span class="s1"> value for </span><span class="s2">simplificationInterval</span><span class="s1">, SLiM will try to find an optimal generation interval for simplification such that the ratio of the memory used by the tree sequence tables, (before:after) simplification, is close to the requested ratio. The default of </span><span class="s2">10</span><span class="s1"> (used if both </span><span class="s2">simplificationRatio</span><span class="s1"> and </span><span class="s2">simplificationInterval</span><span class="s1"> are </span><span class="s2">NULL</span><span class="s1">) thus requests that SLiM try to find a generation interval such that the maximum size of the stored tree sequences is ten times the size after simplification. </span><span class="s2">INF</span><span class="s1"> may be supplied to indicate that automatic simplification should never occur; </span><span class="s2">0</span><span class="s1"> may be supplied to indicate that automatic simplification should be performed at the end of every generation.<span class="Apple-converted-space">  </span>Alternatively – the second option – </span><span class="s2">simplificationRatio</span><span class="s1"> may be </span><span class="s2">NULL</span><span class="s1"> and </span><span class="s2">simplificationInterval</span><span class="s1"> may be set to the interval, in generations, between simplifications.<span class="Apple-converted-space">  </span>This may provide more reliable performance, but the interval must be chosen carefully to avoid exceeding the available memory.<span class="Apple-converted-space">  </span>Again, </span><span class="s2">simplificationInterval</span><span class="s1"> may be a very large number to specify that simplification should never occur (not </span><span class="s2">INF</span><span class="s1">, though, since it is an </span><span class="s2">integer</span><span class="s1"> value), or </span><span class="s2">0</span><span class="s1"> (or </span><span class="s2">1</span><span class="s1">) to simplify every generation.<span class="Apple-converted-space">  </span>Finally – the third option – both parameters may be non-</span><span class="s2">NULL</span><span class="s1">, in which case </span><span class="s2">simplificationRatio</span><span class="s1"> is used as described above, while </span><span class="s2">simplificationInterval</span><span class="s1"> provides the <i>initial</i> interval first used by SLiM (and then subsequently increased or decreased to try to match the requested simplification ratio).<span class="Apple-converted-space">  </span>The default initial interval, used when </span><span class="s2">simplificationInterval</span><span class="s1"> is </span><span class="s2">NULL</span><span class="s1">, is usually </span><span class="s2">20</span><span class="s1">; this is chosen to be relatively frequent, and thus unlikely to lead to a memory overflow, but it can result in rather slow spool-up for models where the equilibrium simplification interval, as determined by the simplification ratio, is much longer.<span class="Apple-converted-space">  </span>It can therefore be helpful to set a larger initial interval so that the early part of the model run is not excessively bogged down in simplification.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">runCrosschecks</span><span class="s1"> parameter controls whether cross-checks between SLiM’s internal data structures and the tree-sequence recording data structures will be conducted.<span class="Apple-converted-space">  </span>These two sets of data structures record much the same thing (mutations in genomes), but using completely different representations, so such cross-checks can be useful to confirm that the two data structures do indeed represent the same conceptual state.<span class="Apple-converted-space">  </span>This slows down the model considerably, however, and would normally be turned on only for debugging purposes, so it is turned off by default.</span></p>
<p class="p1"><b>3.2.<span class="Apple-converted-space">  </span>Nucleotide utilities</b></p>
<p class="p4"><span class="s1">(string)codonsToAminoAcids(integer codons, [logical$ long = F], [logical$ paste = T])</span></p>
<p class="p3"><span class="s1">Returns the amino acid sequence corresponding to the codon sequence in </span><span class="s2">codons</span><span class="s1">.<span class="Apple-converted-space">  </span>Codons should be represented with values in [</span><span class="s2">0</span><span class="s1">, </span><span class="s2">63</span><span class="s1">] where AAA is </span><span class="s2">0</span><span class="s1">, AAC is </span><span class="s2">1</span><span class="s1">, AAG is </span><span class="s2">2</span><span class="s1">, and TTT is </span><span class="s2">63</span><span class="s1">; see </span><span class="s2">ancestralNucleotides()</span><span class="s1"> for discussion of this encoding.<span class="Apple-converted-space">  </span>If </span><span class="s2">long</span><span class="s1"> is </span><span class="s2">F</span><span class="s1"> (the default), the standard single-letter codes for amino acids will be used (where Serine is </span><span class="s2">"S"</span><span class="s1">, etc.); if </span><span class="s2">long</span><span class="s1"> is </span><span class="s2">T</span><span class="s1">, the standard three-letter codes will be used instead (where Serine is </span><span class="s2">"Ser"</span><span class="s1">, etc.).</span></p>
<p class="p3"><span class="s1">When </span><span class="s2">paste</span><span class="s1"> is </span><span class="s2">T</span><span class="s1"> (the default), the amino acid sequence returned will be a singleton </span><span class="s2">string</span><span class="s1">, such as </span><span class="s2">"LYATI"</span><span class="s1"> (when </span><span class="s2">long</span><span class="s1"> is </span><span class="s2">F</span><span class="s1">) or </span><span class="s2">"Leu-Tyr-Ala-Thr-Ile"</span><span class="s1"> (when </span><span class="s2">long</span><span class="s1"> is </span><span class="s2">T</span><span class="s1">).<span class="Apple-converted-space">  </span>When </span><span class="s2">paste</span><span class="s1"> is </span><span class="s2">F</span><span class="s1">, the amino acid sequence will instead be returned as a </span><span class="s2">string</span><span class="s1"> vector, with one element per amino acid, such as </span><span class="s2">"L" "Y" "A" "T" "I"</span><span class="s1"> (when </span><span class="s2">long</span><span class="s1"> is </span><span class="s2">F</span><span class="s1">) or </span><span class="s2">"Leu" "Tyr" "Ala" "Thr" "Ile"</span><span class="s1"> (when </span><span class="s2">long</span><span class="s1"> is </span><span class="s2">T</span><span class="s1">).<span class="Apple-converted-space">  </span>Using the </span><span class="s2">paste=T</span><span class="s1"> option is considerably faster than using </span><span class="s2">paste()</span><span class="s1"> in script.</span></p>
<p class="p3"><span class="s1">This function interprets the supplied codon sequence as the <i>sense</i> strand (i.e., the strand that is <i>not</i> transcribed, and which mirrors the mRNA’s sequence).<span class="Apple-converted-space">  </span>This uses the standard DNA codon table directly.<span class="Apple-converted-space">  </span>For example, if the nucleotide sequence is CAA TTC, that will correspond to a codon vector of </span><span class="s2">16 61</span><span class="s1">, and will result in the amino acid sequence Gln-Phe (</span><span class="s2">"QF"</span><span class="s1">).</span></p>
<p class="p4"><span class="s1">(is)codonsToNucleotides(integer codons, [string$ format = "string"])</span></p>
<p class="p3"><span class="s1">Returns the nucleotide sequence corresponding to the codon sequence supplied in </span><span class="s2">codons</span><span class="s1">.<span class="Apple-converted-space">  </span>Codons should be represented with values in [</span><span class="s2">0</span><span class="s1">, </span><span class="s2">63</span><span class="s1">] where AAA is </span><span class="s2">0</span><span class="s1">, AAC is </span><span class="s2">1</span><span class="s1">, AAG is </span><span class="s2">2</span><span class="s1">, and TTT is </span><span class="s2">63</span><span class="s1">; see </span><span class="s2">ancestralNucleotides()</span><span class="s1"> for discussion of this encoding.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">format</span><span class="s1"> parameter controls the format of the returned sequence.<span class="Apple-converted-space">  </span>It may be </span><span class="s2">"string"</span><span class="s1"> to obtain the sequence as a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATACG"</span><span class="s1">), </span><span class="s2">"char"</span><span class="s1"> to obtain it as a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"C"</span><span class="s1">, </span><span class="s2">"G"</span><span class="s1">), or </span><span class="s2">"integer"</span><span class="s1"> to obtain it as an </span><span class="s2">integer</span><span class="s1"> vector (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">1</span><span class="s1">, </span><span class="s2">2</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)mm16To256(float mutationMatrix16)</span></p>
<p class="p3"><span class="s1">Returns a 64×4 mutation matrix that is functionally identical to the supplied 4×4 mutation matrix in </span><span class="s2">mutationMatrix16</span><span class="s1">.<span class="Apple-converted-space">  </span>The mutation rate for each of the 64 trinucleotides will depend only upon the central nucleotide of the trinucleotide, and will be taken from the corresponding entry for the same nucleotide in </span><span class="s2">mutationMatrix16</span><span class="s1">.<span class="Apple-converted-space">  </span>This function can be used to easily construct a simple trinucleotide-based mutation matrix which can then be modified so that specific trinucleotides sustain a mutation rate that does not depend only upon their central nucleotide.</span></p>
<p class="p3"><span class="s1">See the documentation for </span><span class="s2">initializeGenomicElementType()</span><span class="s1"> for further discussion of how these 64×4 mutation matrices are interpreted and used.</span></p>
<p class="p4"><span class="s1">(float)mmJukesCantor(float$ alpha)</span></p>
<p class="p3"><span class="s1">Returns a mutation matrix representing a Jukes–Cantor (1969) model with mutation rate </span><span class="s2">alpha</span><span class="s1"> to each possible alternative nucleotide at a site.<span class="Apple-converted-space">  </span>This 2×2 matrix is suitable for use with </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>Note that the actual mutation rate produced by this matrix is </span><span class="s2">3*alpha</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)mmKimura(float$ alpha, float$ beta)</span></p>
<p class="p3"><span class="s1">Returns a mutation matrix representing a Kimura (1980) model with transition rate </span><span class="s2">alpha</span><span class="s1"> and transversion rate </span><span class="s2">beta</span><span class="s1">.<span class="Apple-converted-space">  </span>This 2×2 matrix is suitable for use with </span><span class="s2">initializeGenomicElementType()</span><span class="s1">.<span class="Apple-converted-space">  </span>Note that the actual mutation rate produced by this model is </span><span class="s2">alpha+2*beta</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(integer)nucleotideCounts(is sequence)</span></p>
<p class="p3"><span class="s1">A convenience function that returns an </span><span class="s2">integer</span><span class="s1"> vector of length four, providing the number of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.<span class="Apple-converted-space">  </span>The parameter sequence may be a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector (e.g., 3, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(float)nucleotideFrequencies(is sequence)</span></p>
<p class="p3"><span class="s1">A convenience function that returns a </span><span class="s2">float</span><span class="s1"> vector of length four, providing the frequencies of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.<span class="Apple-converted-space">  </span>The parameter sequence may be a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector (e.g., 3, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.</span></p>
<p class="p4"><span class="s1">(integer)nucleotidesToCodons(is sequence)</span></p>
<p class="p3"><span class="s1">Returns the codon sequence corresponding to the nucleotide sequence in </span><span class="s2">sequence</span><span class="s1">.<span class="Apple-converted-space">  </span>The codon sequence is an </span><span class="s2">integer</span><span class="s1"> vector with values from </span><span class="s2">0</span><span class="s1"> to </span><span class="s2">63</span><span class="s1">, based upon successive nucleotide triplets in the nucleotide sequence.<span class="Apple-converted-space">  </span>The codon value for a given nucleotide triplet XYZ is 16X + 4Y + Z, where X, Y, and Z have the usual values A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>For example, the triplet AAA has a codon value of </span><span class="s2">0</span><span class="s1">, AAC is </span><span class="s2">1</span><span class="s1">, AAG is </span><span class="s2">2</span><span class="s1">, AAT is </span><span class="s2">3</span><span class="s1">, ACA is </span><span class="s2">4</span><span class="s1">, and on upward to TTT which is </span><span class="s2">63</span><span class="s1">.<span class="Apple-converted-space">  </span>If the nucleotide sequence AACACATTT is passed in, the codon vector </span><span class="s2">1 4 63</span><span class="s1"> will therefore be returned.<span class="Apple-converted-space">  </span>These codon values can be useful in themselves; they can also be passed to </span><span class="s2">codonsToAminoAcids()</span><span class="s1"> to translate them into the corresponding amino acid sequence if desired.</span></p>
<p class="p3"><span class="s1">The nucleotide sequence in </span><span class="s2">sequence</span><span class="s1"> may be supplied in any of three formats: a </span><span class="s2">string</span><span class="s1"> vector with single-letter nucleotides (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), a singleton </span><span class="s2">string</span><span class="s1"> of nucleotide letters (e.g., </span><span class="s2">"TATA"</span><span class="s1">), or an </span><span class="s2">integer</span><span class="s1"> vector of nucleotide values (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">) using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>If the choice of format is not driven by other considerations, such as ease of manipulation, then the singleton </span><span class="s2">string</span><span class="s1"> format will certainly be the most memory-efficient for long sequences, and will probably also be the fastest.<span class="Apple-converted-space">  </span>The nucleotide sequence provided must be a multiple of three in length, so that it translates to an integral number of codons.</span></p>
<p class="p2">(is)randomNucleotides(integer$ length, [Nif basis = NULL], [string$ format = "string"])</p>
<p class="p3"><span class="s1">Generates a new random nucleotide sequence with </span><span class="s2">length</span><span class="s1"> bases.<span class="Apple-converted-space">  </span>The four nucleotides ACGT are equally probable if </span><span class="s2">basis</span><span class="s1"> is </span><span class="s2">NULL</span><span class="s1"> (the default); otherwise, </span><span class="s2">basis</span><span class="s1"> may be a 4-element </span><span class="s2">integer</span><span class="s1"> or </span><span class="s2">float</span><span class="s1"> vector providing relative fractions for A, C, G, and T respectively (these need not sum to </span><span class="s2">1.0</span><span class="s1">, as they will be normalized).<span class="Apple-converted-space">  </span>More complex generative models such as Markov processes are not supported intrinsically in SLiM at this time, but arbitrary generated sequences may always be loaded from files on disk.</span></p>
<p class="p3"><span class="s1">The </span><span class="s2">format</span><span class="s1"> parameter controls the format of the returned sequence.<span class="Apple-converted-space">  </span>It may be </span><span class="s2">"string"</span><span class="s1"> to obtain the generated sequence as a singleton </span><span class="s2">string</span><span class="s1"> (e.g., </span><span class="s2">"TATA"</span><span class="s1">), </span><span class="s2">"char"</span><span class="s1"> to obtain it as a </span><span class="s2">string</span><span class="s1"> vector of single characters (e.g., </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">, </span><span class="s2">"T"</span><span class="s1">, </span><span class="s2">"A"</span><span class="s1">), or </span><span class="s2">"integer"</span><span class="s1"> to obtain it as an </span><span class="s2">integer</span><span class="s1"> vector (e.g., </span><span class="s2">3</span><span class="s1">, </span><span class="s2">0</span><span class="s1">, </span><span class="s2">3, 0</span><span class="s1">), using SLiM’s standard code of A=</span><span class="s2">0</span><span class="s1">, C=</span><span class="s2">1</span><span class="s1">, G=</span><span class="s2">2</span><span class="s1">, T=</span><span class="s2">3</span><span class="s1">.<span class="Apple-converted-space">  </span>For passing directly to </span><span class="s2">initializeAncestralNucleotides()</span><span class="s1">, format </span><span class="s2">"string"</span><span class="s1"> (a singleton string) will certainly be the most memory-efficient, and probably also the fastest.<span class="Apple-converted-space">  </span>Memory efficiency can be a significant consideration; the nucleotide sequence for a chromosome of length 10</span><span class="s9"><sup>9</sup></span><span class="s1"> will occupy approximately 1 GB of memory when stored as a singleton string (with one byte per nucleotide), and much more if stored in the other formats.<span class="Apple-converted-space">  </span>However, the other formats can be easier to work with in Eidos, and so may be preferable for relatively short chromosomes if you are manipulating the generated sequence.</span></p>
</body>
</html>
