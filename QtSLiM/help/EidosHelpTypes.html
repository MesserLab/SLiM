<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1671.6">
  <style type="text/css">
    p.p1 {margin: 6.0px 0.0px 3.0px 0.0px; font: 11.0px Optima}
    p.p2 {margin: 2.0px 0.0px 2.0px 0.0px; text-indent: 13.7px; font: 11.0px Optima}
    span.s1 {font: 9.0px Menlo}
    span.s2 {font: 11.0px 'Times New Roman'}
    span.s3 {font: 11.0px 'Lucida Grande'}
    span.s4 {font: 8.0px Optima}
  </style>
</head>
<body>
<p class="p1"><i>2.1.1<span class="Apple-converted-space">  </span>ITEM: 1. type </i><span class="s1"><i>integer</i></span></p>
<p class="p2">The <span class="s1">integer</span> type is used in Eidos to represent integers – whole numbers, with no fractional component.<span class="Apple-converted-space">  </span>Unlike in many languages, exponential notation may be used to specify <span class="s1">integer</span> literals (“literals” means values stated literally in the script, rather than derived through calculations).</p>
<p class="p2">The <span class="s1">integer</span> type is advantageous primarily because it is exact; it does not suffer from any sort of roundoff error. Exact comparison with integer constants is therefore safe; roundoff error will not lead to problems caused by <span class="s1">0.999999999</span> being deemed to be unequal to <span class="s1">1</span><span class="s2">.</span><span class="Apple-converted-space">  </span>However, <span class="s1">integer</span> is disadvantageous because it can only represent a limited range of values, and beyond that range, results will be unpredictable.<span class="Apple-converted-space">  </span>Eidos uses 64 bits to store <span class="s1">integer</span> values, so that range is quite wide; to <span class="s1">−9223372036854775806</span> to <span class="s1">9223372036854775807</span>, to be exact.<span class="Apple-converted-space">  </span>That is broad, but it is still enormously narrower than the range of numbers representable with <span class="s1">float</span><span class="s2">.</span></p>
<p class="p1"><i>2.1.2<span class="Apple-converted-space">  </span>ITEM: 2. type </i><span class="s1"><i>float</i></span></p>
<p class="p2">The <span class="s1">float</span> type is used in Eidos to represent all non-<span class="s1">integer</span> numbers – fractions and real numbers.<span class="Apple-converted-space">  </span>Exponential notation may be used to specify <span class="s1">float</span> literals; in particular; literals with a decimal point or a negative exponent are taken to be of type <span class="s1">float</span>.</p>
<p class="p2">Note that this rule means that some literals are represented using <span class="s1">float</span> even though they could also be represented using <span class="s1">integer</span><span class="s2">.</span></p>
<p class="p2">The <span class="s1">float</span> type is advantageous primarily because it can represent an enormously wide range of values.<span class="Apple-converted-space">  </span>Eidos uses C++’s <span class="s1">double</span> type to represent its <span class="s1">float</span> values; the range of values allowed will depend upon your computer’s settings, but it will be vast.<span class="Apple-converted-space">  </span>If that range is exceeded, or if numerical problems occur, type <span class="s1">float</span> can also represent values as infinity or as “Not A Number” (<span class="s1">INF</span> and <span class="s1">NAN</span>, respectively, in Eidos).<span class="Apple-converted-space">  </span>The <span class="s1">float</span> type is thus more robust for operations that might produce such values.<span class="Apple-converted-space">  </span>The disadvantage of <span class="s1">float</span> is that it is inexact; some values cannot be represented exactly (just as 1/3 in base 10 cannot be represented exactly, and must be written as 0.3333333...).<span class="Apple-converted-space">  </span>Roundoff can thus cause comparison errors, overflow and underflow errors, and the accumulation of numerical error.</p>
<p class="p2">Several <span class="s1">float</span> constants are defined in Eidos; besides <span class="s1">INF</span> and <span class="s1">NAN</span>, <span class="s1">PI</span> is defined as <span class="s3">π</span> (3.14159...), and <span class="s1">E</span> is defined as <span class="s2"><i>e</i></span> (2.71828...).</p>
<p class="p1"><i>2.1.3<span class="Apple-converted-space">  </span>ITEM: 3. type </i><span class="s1"><i>logical</i></span></p>
<p class="p2">The <span class="s1">logical</span> type represents true and false values, such as those from comparisons.<span class="Apple-converted-space">  </span>In many languages this type is called something like <span class="s1">boolean</span> or <span class="s1">BOOL</span>; Eidos follows R in using the name <span class="s1">logical</span> instead.</p>
<p class="p2">There are no <span class="s1">logical</span> literals in Eidos.<span class="Apple-converted-space">  </span>However, there are defined constants that behave in essentially the same way as literals.<span class="Apple-converted-space">  </span>In particular, <span class="s1">T</span> is defined as true, and <span class="s1">F</span> is defined as false.<span class="Apple-converted-space">  </span>These are the only two values that the <span class="s1">logical</span> type can take.<span class="Apple-converted-space">  </span>As in a great many other languages, these <span class="s1">logical</span> values have equivalent numerical values; <span class="s1">F</span> is <span class="s1">0</span>, and <span class="s1">T</span> is <span class="s1">1</span> (and in fact any non-zero value is considered to be true if converted to <span class="s1">logical</span> type).<span class="Apple-converted-space">  </span>Values of type <span class="s1">integer</span> or <span class="s1">float</span> may therefore be converted to <span class="s1">logical</span>, and vice-versa.</p>
<p class="p1"><i>2.1.4<span class="Apple-converted-space">  </span>ITEM: 4. type </i><span class="s1"><i>string</i></span></p>
<p class="p2">The <span class="s1">string</span> type represents a string of characters – a word, a sentence, a paragraph, the complete works of Shakespeare.<span class="Apple-converted-space">  </span>There is no formatting on a <span class="s1">string</span> – no <span class="s2">font</span>, no <span class="s4">point size</span>, no <b>bold</b> or <i>italic</i>.<span class="Apple-converted-space">  </span>Instead, it is just a character stream.<span class="Apple-converted-space">  </span>A <span class="s1">string</span> literal must be enclosed by either single or double quotation marks, <span class="s1">'</span> or <span class="s1">"</span>.<span class="Apple-converted-space">  </span>This choice simplifies writing Eidos strings that themselves contain quote characters, because you can delimit the string with the opposite kind of quote.<span class="Apple-converted-space">  </span>For example, <span class="s1">'You say, "Ere thrice the sun done salutation to the dawn"'</span> is a string that contains double quotes, whereas <span class="s1">"Quoth the Raven, 'nevermore'.”</span> is a string that contains single quotes.<span class="Apple-converted-space">  </span>Apart from this consideration, it does not matter whether you use single or double quotes; the internal representation is the same.<span class="Apple-converted-space">  </span>The suggested convention is to prefer double quotes, all else being equal, since they are more universally used in other programming languages.</p>
<p class="p2">A complication arises if one wishes to include both single and double quotation marks within a <span class="s1">string</span>; whichever delimiter you choose, one or the other quote character will terminate the <span class="s1">string</span> literal.<span class="Apple-converted-space">  </span>In this case, the quotation mark must be “escaped” by preceding it with a backslash, <span class="s1">\</span>.<span class="Apple-converted-space">  </span>The backslash can be used to “escape” various other characters; to include a newline in a string, for example, use <span class="s1">\n</span>, and to include a tab, use <span class="s1">\t</span>.<span class="Apple-converted-space">  </span>Since the backslash has this special meaning, backslashes themselves must be escaped as <span class="s1">\\</span>.<span class="Apple-converted-space">  </span>An alternative to dealing with escape sequences is to use the “here document” style of string literal; see the Eidos manual for details on this.</p>
<p class="p1"><i>2.7.2<span class="Apple-converted-space">  </span>ITEM: 5. type </i><span class="s1"><i>NULL</i></span></p>
<p class="p2">The <span class="s1">NULL</span> type two primary uses: as a return value, and as a parameter.</p>
<p class="p2">As a return value, <span class="s1">NULL</span> is used to indicate that a function had nothing useful to return.<span class="Apple-converted-space">  </span>Some functions always return <span class="s1">NULL</span>, such as <span class="s1">print()</span>; <span class="s1">print()</span> sends its output directly to the Eidos console.<span class="Apple-converted-space">  </span>It has nothing useful to return, so it returns <span class="s1">NULL</span>.<span class="Apple-converted-space">  </span>(That <span class="s1">NULL</span> value does not normally get printed out by Eidos because it is marked as an “invisible” return, a side topic not really worth getting into here; invisible returns work much as they do in R).</p>
<p class="p2">Some functions will return a useful value if they can, but will return <span class="s1">NULL</span> if they can’t. Often a <span class="s1">NULL</span> return is a result of passing <span class="s1">NULL</span> in as an argument; garbage in, garbage out, as they say.<span class="Apple-converted-space">  </span>For example, the <span class="s1">readFile()</span> function will return <span class="s1">NULL</span> if an error occurs that prevents the file read operation from completing.<span class="Apple-converted-space">  </span>The calling code could then detect that <span class="s1">NULL</span> return and act accordingly – it might try to read from a different path, print an error, or terminate execution with <span class="s1">stop()</span>, or it might just ignore the problem, if reading the file was optional anyway (such as an optional configuration file to modify the default behavior of a script).</p>
<p class="p2">The other use of <span class="s1">NULL</span>, as mentioned above, is as an argument to a function. Passing <span class="s1">NULL</span> is occasionally a way of signaling that you don’t want to supply a value for an argument, or that you want a default behavior from the function rather than telling it more specifically what to do.</p>
<p class="p2"><span class="s1">NULL</span> cannot be an element of a vector of some other type; it cannot be used to mark missing or unknown values, for example.<span class="Apple-converted-space">  </span>Instead, <span class="s1">NULL</span> is its own type of vector in Eidos, always of zero length.<span class="Apple-converted-space">  </span>(There is also no <span class="s1">NA</span> value in Eidos like the one in R, while we’re on the topic of marking missing values.<span class="Apple-converted-space">  </span>Not having to worry about missing values makes Eidos substantially simpler and faster, and Eidos – unlike R – is not designed to be used for doing statistical analysis, so marking missing values is not expected to be important.<span class="Apple-converted-space">  </span>Eidos does support <span class="s1">NAN</span> – Not A Number – values in <span class="s1">float</span> vectors, however, which could conceivably be used to mark missing values if necessary.)</p>
<p class="p2">The basic philosophy of how Eidos handles <span class="s1">NULL</span> values in expressions and computations is that <span class="s1">NULL</span> in such situations represents a non-fatal error or an unknown value.<span class="Apple-converted-space">  </span>If using the <span class="s1">NULL</span> value in some meaningful way could lead to potentially misleading or incorrect results, Eidos will generate a fatal error.<span class="Apple-converted-space">  </span>The idea is to give Eidos code an opportunity to detect a <span class="s1">NULL</span>, and thus to catch and handle the non-fatal error; but if the code does not handle the <span class="s1">NULL</span>, using the <span class="s1">NULL</span> in further operations will result in a fatal error before the functioning of the code is seriously compromised.<span class="Apple-converted-space">  </span><span class="s1">NULL</span> values are thus a sort of third rail; there’s a good reason they exist, but you have to be very careful around them.<span class="Apple-converted-space">  </span>They are a bit like zero-valued pointers in C (<span class="s1">NULL</span>), C++ (<span class="s1">nullptr</span>), Objective-C (<span class="s1">nil</span>), and similar languages; they are widely used, but if you ever use one the wrong way it is an immediate and fatal error.<span class="Apple-converted-space">  </span>For further details, please consult the Eidos manual.</p>
<p class="p1"><i>2.8.1<span class="Apple-converted-space">  </span>ITEM: 6. type </i><span class="s1"><i>object</i></span></p>
<p class="p2">An <span class="s1">object</span> is a vector that contains elements; it is a container, a bag of stuff.<span class="Apple-converted-space">  </span>In this way, it is similar to Eidos’s other types; a <span class="s1">float</span> in Eidos is a vector containing floating-point elements, whereas an <span class="s1">object</span> is a vector containing <span class="s1">object</span>-elements (often just called “elements” in general).<span class="Apple-converted-space">  </span>An <span class="s1">object</span> can also embody <i>behavior</i>: it has operations that it can perform using the elements it contains.<span class="Apple-converted-space">  </span>The <span class="s1">object</span> type in Eidos is thus similar to objects in other languages such as Java, C++, or R – except much more limited.<span class="Apple-converted-space">  </span>In Eidos you cannot define your own classes of <span class="s1">object</span> type; you work only with the predefined <span class="s1">object</span> types supplied by SLiM or whatever other Context you might be using Eidos within.<span class="Apple-converted-space">  </span>These predefined <span class="s1">object</span> types generally contain Context-dependent elements related to the task performed by the Context; in SLiM, the elements are things such as mutations, genomic elements, and mutation types (described in SLiM’s documentation).</p>
<p class="p2">The behaviors of objects in Eidos manifest in two ways: objects can have <i>properties</i> (also called instance variables or member variables in some languages) that can be read from and written to, and they can have <i>methods</i> (also sometimes called member functions).<span class="Apple-converted-space">  </span>The properties of an <span class="s1">object</span> in Eidos are determined by the type of element the <span class="s1">object</span> contains; an Eidos <span class="s1">object</span> will always contain only one type of element (just as a <span class="s1">float</span> cannot contain <span class="s1">string</span><span class="s2">-</span>elements, for example).</p>
<p class="p2">Instances of particular <span class="s1">object</span> classes – particular kinds of objects – are obtained via built-in functions and/or global constants and variables.<span class="Apple-converted-space">  </span>For example, in SLiM there is a global constant called <span class="s1">sim</span> that represents the current simulation as an instance of the <span class="s1">SLiMSim</span> class.</p>
</body>
</html>
