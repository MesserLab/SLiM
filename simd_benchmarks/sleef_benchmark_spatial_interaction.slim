// Benchmark for SIMD-accelerated spatial interaction kernels
// Tests Gaussian (normal) and Exponential kernel performance
// These kernels use exp() internally, now SIMD-accelerated via SLEEF
//
// Run with SIMD: ./build/slim simd_benchmarks/sleef_benchmark_spatial_interaction.slim
// Run without SIMD: ./build_no_simd/slim simd_benchmarks/sleef_benchmark_spatial_interaction.slim

initialize() {
    initializeSLiMModelType("WF");
    initializeSLiMOptions(dimensionality="xy");

    // Large population for intensive benchmarking
    defineConstant("POP_SIZE", 5000);
    defineConstant("W", 10.0);
    defineConstant("SI", 1.0);  // larger interaction distance = more neighbors
    defineConstant("GENS", 30);

    initializeMutationRate(0);
    initializeRecombinationRate(0);
    initializeMutationType("m1", 0.5, "f", 0.0);
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, 99);

    // Gaussian kernel: strength = fmax * exp(-distance^2 / 2*sigma^2)
    initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SI * 3);
    i1.setInteractionFunction("n", 1.0, SI);

    // Exponential kernel: strength = fmax * exp(-lambda * distance)
    initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SI * 3);
    i2.setInteractionFunction("e", 1.0, 1.0/SI);
}

1 early() {
    sim.addSubpop("p1", POP_SIZE);
    p1.setSpatialBounds(c(0, 0, W, W));

    for (ind in p1.individuals) {
        ind.setSpatialPosition(p1.pointUniform());
    }

    catn("========================================");
    catn("Spatial Interaction Kernel Benchmark");
    catn("========================================");
    catn("Population: " + POP_SIZE);
    catn("World: " + W + "x" + W);
    catn("Interaction distance: " + SI);
    catn("Generations: " + GENS);

    // Estimate neighbors
    density = POP_SIZE / (W * W);
    avg_neighbors = density * PI * (SI*3)^2;
    catn("Est. neighbors/ind: ~" + format("%.0f", avg_neighbors));
    catn("----------------------------------------");

    defineGlobal("start_time", clock());
    defineGlobal("gaussian_time", 0.0);
    defineGlobal("exp_time", 0.0);
}

early() {
    // Gaussian kernel
    t0 = clock();
    i1.evaluate(p1);
    s1 = i1.totalOfNeighborStrengths(p1.individuals);
    defineGlobal("gaussian_time", gaussian_time + (clock() - t0));

    // Exponential kernel
    t1 = clock();
    i2.evaluate(p1);
    s2 = i2.totalOfNeighborStrengths(p1.individuals);
    defineGlobal("exp_time", exp_time + (clock() - t1));

    // Use strengths for fitness
    p1.individuals.fitnessScaling = 1.0 / (1 + 0.001 * (s1 + s2));
}

late() {
    // Reshuffle positions each generation
    for (ind in p1.individuals) {
        ind.setSpatialPosition(p1.pointUniform());
    }
}

30 late() {
    elapsed = clock() - start_time;

    catn("\n========================================");
    catn("RESULTS (SIMD spatial interaction kernels)");
    catn("========================================");
    catn("Total time: " + format("%.3f", elapsed) + " s");
    catn("Gaussian kernel: " + format("%.3f", gaussian_time) + " s");
    catn("Exponential kernel: " + format("%.3f", exp_time) + " s");
    catn("========================================");
    sim.simulationFinished();
}
