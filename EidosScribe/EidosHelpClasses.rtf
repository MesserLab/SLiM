{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Optima-Bold;\f1\fswiss\fcharset0 Optima-Italic;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fswiss\fcharset0 Optima-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 5.1  Class Object\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf2 5.1.1  
\f2\fs18 Object
\f1\fs22  properties\
5.1.2  
\f2\fs18 Object
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 +\'a0(integer$)length(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the size (e.g., length) of the receiving object.  This is equivalent to the 
\f3\fs18 length()
\f4\fs20  (or 
\f3\fs18 size()
\f4\fs20 ) function; in other words, for any 
\f3\fs18 object
\f4\fs20  
\f3\fs18 x
\f4\fs20 , the return value of the function call 
\f3\fs18 length(x)
\f4\fs20  equals the return value of the class method call 
\f3\fs18 x.length()
\f4\fs20 .  This method is provided solely for syntactic convenience.  Note that 
\f3\fs18 +length()
\f4\fs20  is a synonym for 
\f3\fs18 +size()
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(void)methodSignature([Ns$\'a0methodName\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Prints the method signature for the method specified by 
\f3\fs18 methodName
\f4\fs20 , or for all methods supported by the receiving object if 
\f3\fs18 methodName
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(void)propertySignature([Ns$\'a0propertyName\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Prints the property signature for the property specified by 
\f3\fs18 propertyName
\f4\fs20 , or for all properties supported by the receiving object if 
\f3\fs18 propertyName
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(integer$)size(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the size of the receiving object.  This is equivalent to the 
\f3\fs18 size()
\f4\fs20  (or 
\f3\fs18 length()
\f4\fs20 ) function; in other words, for any 
\f3\fs18 object
\f4\fs20  
\f3\fs18 x
\f4\fs20 , the return value of the function call 
\f3\fs18 size(x)
\f4\fs20  equals the return value of the class method call 
\f3\fs18 x.size()
\f4\fs20 .  This method is provided solely for syntactic convenience.  Note that 
\f3\fs18 +length()
\f4\fs20  is a synonym for 
\f3\fs18 +size()
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)str(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Prints the internal property structure of the receiving object; in particular, the element type of the object is printed, followed, on successive lines, by all of the properties supported by the object, their types, and a sample of their values.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(string$)stringRepresentation(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a singleton 
\f3\fs18 string
\f4\fs20  value that represents the receiving object.  By default, this is simply the name of the class of the receiving object; however, many subclasses of 
\f3\fs18 Object
\f4\fs20  provide a different string representation.  The value returned by 
\f3\fs18 stringRepresentation()
\f4\fs20  is the same string that would be printed by 
\f3\fs18 print()
\f4\fs20  for the object, so 
\f3\fs18 stringRepresentation()
\f4\fs20  allows the same representation to be used in other contexts such as 
\f3\fs18 paste()
\f4\fs20  and 
\f3\fs18 cat()
\f4\fs20 .\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 5.2  Class DataFrame\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\b0\fs18 \cf2 (object<DataFrame>$)DataFrame(...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The 
\f3\fs18 DataFrame
\f4\fs20  constructor can be called in the same ways as the constructor for 
\f3\fs18 Dictionary
\f4\fs20  (its superclass): with no parameters to make an empty 
\f3\fs18 DataFrame
\f4\fs20 , with key-value pairs, with a singleton 
\f3\fs18 Dictionary
\f4\fs20  (or a subclass of 
\f3\fs18 Dictionary
\f4\fs20 , like 
\f3\fs18 DataFrame
\f4\fs20 ) to make a copy, or with a singleton string in JSON format.  See the 
\f3\fs18 Dictionary
\f4\fs20  class for further documentation.  However, note that 
\f3\fs18 DataFrame
\f4\fs20  can only use 
\f3\fs18 string
\f4\fs20  keys; 
\f3\fs18 integer
\f4\fs20  keys are not allowed.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.2.1  
\f2\fs18 DataFrame
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 colNames => (string)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A vector containing all of the 
\f3\fs18 string
\f4\fs20  column names in the 
\f3\fs18 DataFrame
\f4\fs20 , in order.  This property is currently an alias for the 
\f3\fs18 Dictionary
\f4\fs20  property 
\f3\fs18 allKeys
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 dim => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A two-element vector containing the dimensions of the 
\f3\fs18 DataFrame
\f4\fs20 .  The 
\f3\fs18 0
\f4\fs20 th element is the number of rows (as provided by 
\f3\fs18 nrow
\f4\fs20 ), and the 
\f3\fs18 1
\f4\fs20 st element is the number of columns (as provided by 
\f3\fs18 ncol
\f4\fs20 ).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 ncol => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The number of columns in the 
\f3\fs18 DataFrame
\f4\fs20 ; this will be equal to the length of 
\f3\fs18 colNames
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 nrow => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The number of rows in the 
\f3\fs18 DataFrame
\f4\fs20  (i.e., the number of elements in a column).  This will be the same for every column, by definition.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.2.2  
\f2\fs18 DataFrame
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(*)asMatrix(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a matrix representation of the 
\f3\fs18 DataFrame
\f4\fs20 .  The matrix will have the same type as the elements of the 
\f3\fs18 DataFrame
\f4\fs20 ; if the 
\f3\fs18 DataFrame
\f4\fs20  contains more than one type of element, an error will be raised.  The order of the columns of the 
\f3\fs18 DataFrame
\f4\fs20  will be preserved.  This method is useful, for example, if you wish to read in a text file as a matrix; you can use 
\f3\fs18 readCSV()
\f4\fs20  to read the file as a 
\f3\fs18 DataFrame
\f4\fs20 , and then convert it to a matrix with 
\f3\fs18 asMatrix()
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)cbind(object\'a0source, ...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds all of the columns contained by 
\f3\fs18 source
\f4\fs20  (which must be a 
\f3\fs18 Dictionary
\f4\fs20  or a subclass of 
\f3\fs18 Dictionary
\f4\fs20  such as 
\f3\fs18 DataFrame
\f4\fs20 ) to the receiver.  This method makes the target 
\f3\fs18 DataFrame
\f4\fs20  wider, by adding new columns.  If 
\f3\fs18 source
\f4\fs20  contains a column name that is already defined in the target, an error will result.  As always for 
\f3\fs18 DataFrame
\f4\fs20 , the columns of the resulting 
\f3\fs18 DataFrame
\f4\fs20  must all be the same length.\
The 
\f3\fs18 source
\f4\fs20  parameter may be a non-singleton vector containing multiple 
\f3\fs18 Dictionary
\f4\fs20  objects, and additional 
\f3\fs18 Dictionary
\f4\fs20  vectors may be supplied (thus the ellipsis in the signature).  Each 
\f3\fs18 Dictionary
\f4\fs20  supplied will be added to the target, in the order supplied.\
This method is similar to the 
\f3\fs18 Dictionary
\f4\fs20  method 
\f3\fs18 addKeysAndValuesFrom()
\f4\fs20 , which may be used instead if replacement of duplicate columns is desired.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)rbind(object\'a0source, ...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Appends all of the columns contained by 
\f3\fs18 source
\f4\fs20  (which must be a 
\f3\fs18 Dictionary
\f4\fs20  or a subclass of 
\f3\fs18 Dictionary
\f4\fs20  such as 
\f3\fs18 DataFrame
\f4\fs20 ) to the receiver.  This method makes the 
\f3\fs18 DataFrame
\f4\fs20  taller, by adding new rows.  If the source and target do not contain the same column names in the same order, an error will result.  As always for 
\f3\fs18 DataFrame
\f4\fs20 , the columns of the resulting 
\f3\fs18 DataFrame
\f4\fs20  must all be the same length.\
The 
\f3\fs18 source
\f4\fs20  parameter may be a non-singleton vector containing multiple 
\f3\fs18 Dictionary
\f4\fs20  objects, and additional 
\f3\fs18 Dictionary
\f4\fs20  vectors may be supplied (thus the ellipsis in the signature).  Each 
\f3\fs18 Dictionary
\f4\fs20  supplied will be appended to the target, in the order supplied.\
This method is similar to the 
\f3\fs18 Dictionary
\f4\fs20  method 
\f3\fs18 appendKeysAndValuesFrom()
\f4\fs20 , which may be used instead if one wishes the append to work even when the columns are in different orders, or other such situations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(*)subset([Nli\'a0rows\'a0=\'a0NULL], [Nlis\'a0cols\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the elements in the selected rows and columns of the target 
\f3\fs18 DataFrame
\f4\fs20 .  The selection logic is based upon that for 
\f3\fs18 subsetRows()
\f4\fs20  and 
\f3\fs18 subsetColumns()
\f4\fs20 , respectively; in short, rows may be selected by 
\f3\fs18 integer
\f4\fs20  indices or by a 
\f3\fs18 logical
\f4\fs20  vector, and columns may be selected by 
\f3\fs18 integer
\f4\fs20  indices, by a 
\f3\fs18 logical
\f4\fs20  vector, or by a 
\f3\fs18 string
\f4\fs20  vector of column names.  In addition, however, 
\f3\fs18 NULL
\f4\fs20  may be passed for either 
\f3\fs18 rows
\f4\fs20  or 
\f3\fs18 cols
\f4\fs20  to select all of the rows or all of the columns, respectively; this is the default for both parameters.  If you want entire rows (rather than selecting particular columns), pass 
\f3\fs18 NULL
\f4\fs20  for 
\f3\fs18 cols
\f4\fs20 ; if you want entire columns (rather than selecting particular rows), pass 
\f3\fs18 NULL
\f4\fs20  for 
\f3\fs18 rows
\f4\fs20 .\
The first step performed by 
\f3\fs18 subset()
\f4\fs20  is to produce a 
\f3\fs18 DataFrame
\f4\fs20  that contains the selected rows and columns.  If that 
\f3\fs18 DataFrame
\f4\fs20  contains more than one column, it is simply returned, and the behavior of 
\f3\fs18 subset()
\f4\fs20  is identical to calling 
\f3\fs18 subsetRows()
\f4\fs20  and 
\f3\fs18 subsetColumns()
\f4\fs20  in sequence (in either order).  If, however, the resulting 
\f3\fs18 DataFrame
\f4\fs20  contains only a single column, then 
\f3\fs18 subset()
\f4\fs20  will return a vector containing the elements in that column \'96 unlike the behavior of 
\f3\fs18 subsetRows()
\f4\fs20  and 
\f3\fs18 subsetColumns()
\f4\fs20 , which always return a 
\f3\fs18 DataFrame
\f4\fs20 .  This method is therefore a convenient way to get a single value, or multiple values from the same column, from a 
\f3\fs18 DataFrame
\f4\fs20 .  (Note that the 
\f3\fs18 Dictionary
\f4\fs20  method 
\f3\fs18 getValue()
\f4\fs20  can also be used to get all of the values from a given 
\f3\fs18 DataFrame
\f4\fs20  column.)\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<DataFrame>$)subsetColumns(lis\'a0index)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a new 
\f3\fs18 DataFrame
\f4\fs20  containing values for the selected columns of the target 
\f3\fs18 DataFrame
\f4\fs20 .  The selection logic described below is similar to how the subset operator 
\f3\fs18 []
\f4\fs20  in Eidos works, selecting the columns of the target 
\f3\fs18 DataFrame
\f4\fs20 .\
The index parameter may be either 
\f3\fs18 integer
\f4\fs20 , 
\f3\fs18 logical
\f4\fs20 , or 
\f3\fs18 string
\f4\fs20 ; we will discuss the 
\f3\fs18 integer
\f4\fs20  case first.  If 
\f3\fs18 index
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20 , the returned 
\f3\fs18 DataFrame
\f4\fs20  will contain the 
\f3\fs18 index
\f4\fs20 \'92th column of the target (counting from the left, from 
\f3\fs18 0
\f4\fs20 ).  If 
\f3\fs18 index
\f4\fs20  is a non-singleton 
\f3\fs18 integer
\f4\fs20  vector, the returned 
\f3\fs18 DataFrame
\f4\fs20  will contains all of the selected columns, in the order that they are selected by 
\f3\fs18 index
\f4\fs20 .  If any 
\f3\fs18 index
\f4\fs20  value is out of range for the target 
\f3\fs18 DataFrame
\f4\fs20  (such that the 
\f3\fs18 DataFrame
\f4\fs20  does not have an 
\f3\fs18 index
\f4\fs20 \'92th column), an error will result.  If the same column is specified more than once, unique column names will be automatically generated for the additional copies of the column.\
If 
\f3\fs18 index
\f4\fs20  is a 
\f3\fs18 string
\f4\fs20  vector, the returned 
\f3\fs18 DataFrame
\f4\fs20  will contain copies of the columns in the target named by 
\f3\fs18 index
\f4\fs20 .  As with an 
\f3\fs18 integer
\f4\fs20  vector, it is an error if a given column does not exist in the target; and unique column names will be generated for additional copies of a column.\
Finally, if 
\f3\fs18 index
\f4\fs20  is a 
\f3\fs18 logical
\f4\fs20  vector, the length of 
\f3\fs18 index
\f4\fs20  must be equal to the number of columns in the target.  In this case, the 
\f3\fs18 T
\f4\fs20  values in 
\f3\fs18 index
\f4\fs20  select the columns which will be included in the returned 
\f3\fs18 DataFrame
\f4\fs20 .  The columns in the returned 
\f3\fs18 DataFrame
\f4\fs20  will be in the same order as in the target.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<DataFrame>$)subsetRows(li\'a0index, [logical$\'a0drop\'a0=\'a0F])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a new 
\f3\fs18 DataFrame
\f4\fs20  containing values for selected rows of the target 
\f3\fs18 DataFrame
\f4\fs20 .  The selection logic described below works exactly as the subset operator 
\f3\fs18 []
\f4\fs20  does in Eidos, selecting the rows of the target 
\f3\fs18 DataFrame
\f4\fs20 .\
The 
\f3\fs18 index
\f4\fs20  parameter may be either 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 logical
\f4\fs20 ; we will discuss the 
\f3\fs18 integer
\f4\fs20  case first.  If 
\f3\fs18 index
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20 , the returned 
\f3\fs18 DataFrame
\f4\fs20  will contain the 
\f3\fs18 index
\f4\fs20 \'92th element of the value of each key of the target, under the same keys; this is a single row of the target 
\f3\fs18 DataFrame
\f4\fs20 .  If 
\f3\fs18 index
\f4\fs20  is a non-singleton 
\f3\fs18 integer
\f4\fs20  vector, the returned 
\f3\fs18 DataFrame
\f4\fs20  will contain the values for all of the selected rows, in the order that they are selected by 
\f3\fs18 index
\f4\fs20 .  If any index value in 
\f3\fs18 index
\f4\fs20  is out of range for the target 
\f3\fs18 DataFrame
\f4\fs20  (such that that DataFrame does not have an 
\f3\fs18 index
\f4\fs20 \'92th row), an error will result.\
If 
\f3\fs18 index
\f4\fs20  is 
\f3\fs18 logical
\f4\fs20 , the length of 
\f3\fs18 index
\f4\fs20  must be equal to the number of rows in the target.  In this case, the 
\f3\fs18 T
\f4\fs20  values in 
\f3\fs18 index
\f4\fs20  select the rows which will be included in the returned 
\f3\fs18 DataFrame
\f4\fs20 .  The values of each column in the returned 
\f3\fs18 DataFrame
\f4\fs20  will be in the same order as in the target.\
If the values of 
\f3\fs18 index
\f4\fs20  are such that 
\f1\i no
\f4\i0  value for a given key is selected, the 
\f3\fs18 drop
\f4\fs20  parameter controls the resulting behavior.  If 
\f3\fs18 drop
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), the key will be included in the returned dictionary with a zero-length value of matching type, such as 
\f3\fs18 integer(0)
\f4\fs20  or 
\f3\fs18 string(0)
\f4\fs20 .  If 
\f3\fs18 drop
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , the key will be omitted from the returned dictionary.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 5.3  Class Dictionary\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\b0\fs18 \cf2 (object<Dictionary>$)Dictionary(...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Creates a new 
\f3\fs18 Dictionary
\f4\fs20  object.  Called without arguments, as 
\f3\fs18 Dictionary()
\f4\fs20 , this creates a new empty 
\f3\fs18 Dictionary
\f4\fs20 .\
Alternatively, key-value pairs can be passed to set up the initial state of the new 
\f3\fs18 Dictionary
\f4\fs20 .  These are set, sequentially, on the new 
\f3\fs18 Dictionary
\f4\fs20 , just as 
\f3\fs18 setValue()
\f4\fs20  would do.  For example, calling 
\f3\fs18 Dictionary("a", 0:3, "b", c("foo", "bar"))
\f4\fs20  is equivalent to calling 
\f3\fs18 Dictionary()
\f4\fs20  and then calling 
\f3\fs18 setValue("a", 0:3)
\f4\fs20  and then 
\f3\fs18 setValue("b", c("foo", "bar"))
\f4\fs20  on it; it is just a shorthand for convenience.  Keys may be of type 
\f3\fs18 string
\f4\fs20  or 
\f3\fs18 integer
\f4\fs20 , but must all be of the same type; 
\f3\fs18 Dictionary
\f4\fs20  supports using either 
\f3\fs18 string
\f4\fs20  or 
\f3\fs18 integer
\f4\fs20  keys, but they cannot be mixed in a single 
\f3\fs18 Dictionary
\f4\fs20  object.\
Another alternative is to call 
\f3\fs18 Dictionary()
\f4\fs20  with a singleton 
\f3\fs18 Dictionary
\f4\fs20  as its only argument; this creates a new 
\f3\fs18 Dictionary
\f4\fs20  that is a copy of the 
\f3\fs18 Dictionary
\f4\fs20  passed, containing the same keys and values.  This is equivalent to creating a new empty 
\f3\fs18 Dictionary
\f4\fs20  and then calling 
\f3\fs18 addKeysAndValuesFrom()
\f4\fs20  to copy key-value pairs over; it is just a shorthand for convenience.\
A final alternative is to call 
\f3\fs18 Dictionary()
\f4\fs20  with a singleton 
\f3\fs18 string
\f4\fs20  as its only argument; this creates a new 
\f3\fs18 Dictionary
\f4\fs20  from the string, assuming that it is a data archive in JSON format.  Note that a JSON string can be generated from the 
\f3\fs18 serialize()
\f4\fs20  method of 
\f3\fs18 Dictionary
\f4\fs20 ; together with this way of creating a 
\f3\fs18 Dictionary
\f4\fs20 , this provides the ability to persist arbitrary information to a string (perhaps a file on disk) and back again.  The recreated 
\f3\fs18 Dictionary
\f4\fs20  should be identical to the original, except that zero length vectors such as 
\f3\fs18 integer(0)
\f4\fs20 , 
\f3\fs18 float(0)
\f4\fs20 , 
\f3\fs18 logical(0)
\f4\fs20 , and 
\f3\fs18 string(0)
\f4\fs20  will all be serialized as 
\f3\fs18 "[]"
\f4\fs20  and recreated as 
\f3\fs18 integer(0)
\f4\fs20  since JSON does not provide a way to specify the type of a zero-length array.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.3.1  
\f2\fs18 Dictionary
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 allKeys => (is)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A vector containing all of the 
\f3\fs18 string
\f4\fs20  or 
\f3\fs18 integer
\f4\fs20  keys that have been assigned values using 
\f3\fs18 setValue()
\f4\fs20 , in sorted (ascending alphabetic or numeric) order.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.3.2  
\f2\fs18 Dictionary
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(void)addKeysAndValuesFrom(object$\'a0source)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds all of the key-value pairs contained by 
\f3\fs18 source
\f4\fs20  (which must be a 
\f3\fs18 Dictionary
\f4\fs20  or a subclass of 
\f3\fs18 Dictionary
\f4\fs20 ) to the receiver.  If the target already contains a key that is defined in 
\f3\fs18 source
\f4\fs20 , the target\'92s value for that key will be 
\f1\i replaced
\f4\i0  by the value in 
\f3\fs18 source
\f4\fs20  (contrast this with 
\f3\fs18 appendKeysAndValuesFrom()
\f4\fs20 ).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)appendKeysAndValuesFrom(object\'a0source)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Appends all of the key-value pairs contained by 
\f3\fs18 source
\f4\fs20  (which must be a 
\f3\fs18 Dictionary
\f4\fs20  or a subclass of 
\f3\fs18 Dictionary
\f4\fs20 ) to the receiver.  If the target already contains a key that is defined in source, the value from source will be 
\f1\i appended
\f4\i0  to the target\'92s existing value, which must be of the same type (contrast this with 
\f3\fs18 addKeysAndValuesFrom()
\f4\fs20 ); if the target does not already contain a key that is defined in source, that key-value pair will simply be added to the target.\
In the current implementation, it is an error for either of the values involved in an append to be a matrix or array; values in these 
\f3\fs18 Dictionary
\f4\fs20  objects should be simple vectors.  This limitation preserves the future option to expand this method\'92s functionality to do smart things with matrices and arrays.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)clearKeysAndValues(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Removes all key-value pairs from the receiver.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(integer)compactIndices([logical$\'a0preserveOrder\'a0=\'a0F])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Compacts the receiver, which must use 
\f3\fs18 integer
\f4\fs20  keys.  After this operation, the receiver will contain only values that have a length greater than zero (discarding all key\'96value pairs for which the value is a zero-length vector).  In addition, the keys used will be compacted down to begin at 
\f3\fs18 0
\f4\fs20  and count upward sequentially.  If 
\f3\fs18 preserveOrder
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), the keys may end up in a different numerical order; this allows the compaction to be performed more efficiently.  If 
\f3\fs18 preserveOrder
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , on the other hand, the numerical order of the keys will be preserved.  The returned 
\f3\fs18 integer
\f4\fs20  vector contains the original keys that were kept across the compaction operation, in the order in which they were used in the compaction; keys that were not kept (because their value was zero-length) are omitted from this result vector.\
For example, with a dictionary that contains key\'96value pairs 
\f3\fs18 -5="a"
\f4\fs20 , 
\f3\fs18 17="b"
\f4\fs20 , 
\f3\fs18 37="c"
\f4\fs20 , 
\f3\fs18 53=integer(0)
\f4\fs20 , and 
\f3\fs18 82="d"
\f4\fs20 , 
\f3\fs18 compactIndices(preserveOrder=T)
\f4\fs20  will transform the dictionary to contain 
\f3\fs18 0="a"
\f4\fs20 , 
\f3\fs18 1="b"
\f4\fs20 , 
\f3\fs18 2="c"
\f4\fs20 , and 
\f3\fs18 3="d"
\f4\fs20 , while key 
\f3\fs18 53
\f4\fs20  (and its zero-length value) is dropped; the returned vector will be (
\f3\fs18 5
\f4\fs20 , 
\f3\fs18 17
\f4\fs20 , 
\f3\fs18 37
\f4\fs20 , 
\f3\fs18 82
\f4\fs20 ).  The result from 
\f3\fs18 compactIndices(preserveOrder=F)
\f4\fs20  has a non-deterministic order, but one possibility for the same example inout is that it would transform the dictionary to contain key\'96value pairs 
\f3\fs18 0="c"
\f4\fs20 , 
\f3\fs18 1="d"
\f4\fs20 , 
\f3\fs18 2="a"
\f4\fs20 , and 
\f3\fs18 3="b"
\f4\fs20 , with a returned vector of (
\f3\fs18 37
\f4\fs20 , 
\f3\fs18 82
\f4\fs20 , 
\f3\fs18 5
\f4\fs20 , 
\f3\fs18 17
\f4\fs20 ); the same key\'96value pairs are kept, and they are again placed in sequential keys beginning with 
\f3\fs18 0
\f4\fs20 , but their order is no longer preserved across the compaction.\
This method is particularly useful when you have a 
\f3\fs18 Dictionary
\f4\fs20  
\f3\fs18 d
\f4\fs20  that contains results from some operation on a vector 
\f3\fs18 x
\f4\fs20 , such that each key 
\f3\fs18 n
\f4\fs20  in 
\f3\fs18 d
\f4\fs20  has a value that is the result of processing the 
\f3\fs18 n
\f4\fs20 \'92th element of 
\f3\fs18 x
\f4\fs20 .  In this case, 
\f3\fs18 order=d.compactIndices(preserveOrder=F)
\f4\fs20  will transmogrify 
\f3\fs18 d
\f4\fs20  to contain only the non-zero-length results, in sequential indices counting from 
\f3\fs18 0
\f4\fs20 , and 
\f3\fs18 x[order]
\f4\fs20  provides the elements of 
\f3\fs18 x
\f4\fs20  that produced those results, in the same order as in 
\f3\fs18 d
\f4\fs20  after compaction.  Using 
\f3\fs18 preserveOrder=T
\f4\fs20  additionally keeps 
\f3\fs18 d
\f4\fs20  in the same order as the original order of 
\f3\fs18 x
\f4\fs20 , for cases in which that ordering is important.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Dictionary>$)getRowValues(li\'a0index, [logical$\'a0drop\'a0=\'a0F])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a new 
\f3\fs18 Dictionary
\f4\fs20  containing values for selected \'93rows\'94 of the target 
\f3\fs18 Dictionary
\f4\fs20 , allowing 
\f3\fs18 Dictionary
\f4\fs20  to act similarly to a 
\f3\fs18 DataFrame
\f4\fs20 .  See the 
\f3\fs18 subsetRows()
\f4\fs20  method of class 
\f3\fs18 DataFrame
\f4\fs20  for comparison; the main utility of 
\f3\fs18 getRowValues()
\f4\fs20  is that it can be used on a 
\f3\fs18 Dictionary
\f4\fs20  that has ragged \'93rows\'94.  The selection logic described below works similarly to the subset operator 
\f3\fs18 []
\f4\fs20  in Eidos, selecting the \'93rows\'94 of the target 
\f3\fs18 Dictionary
\f4\fs20 .\
The 
\f3\fs18 index
\f4\fs20  parameter may be either 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 logical
\f4\fs20 ; we will discuss the 
\f3\fs18 integer
\f4\fs20  case first.  If 
\f3\fs18 index
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20 , the returned 
\f3\fs18 Dictionary
\f4\fs20  will contain the 
\f3\fs18 index
\f4\fs20 \'92th element of the value of each key of the target, under the same keys; this is a single \'93row\'94 of the target 
\f3\fs18 Dictionary
\f4\fs20 .  If 
\f3\fs18 index
\f4\fs20  is a non-singleton 
\f3\fs18 integer
\f4\fs20  vector, the returned 
\f3\fs18 Dictionary
\f4\fs20  will contain the values for all of the selected rows, in the order that they are selected by 
\f3\fs18 index
\f4\fs20 .  If any index value in 
\f3\fs18 index
\f4\fs20  is out of range for any key of the target 
\f3\fs18 Dictionary
\f4\fs20  (such that that key does not have an 
\f3\fs18 index
\f4\fs20 \'92th value), the returned dictionary will simply not have a value for that \'93row\'94 of that key.\
If 
\f3\fs18 index
\f4\fs20  is 
\f3\fs18 logical
\f4\fs20 , the 
\f3\fs18 T
\f4\fs20  values in 
\f3\fs18 index
\f4\fs20  select the \'93rows\'94 which will be included in the returned 
\f3\fs18 Dictionary
\f4\fs20 .  The values within each column in the returned 
\f3\fs18 Dictionary
\f4\fs20  will be in the same order as in the target.  The length of 
\f3\fs18 index
\f4\fs20  need not match any column of the 
\f3\fs18 Dictionary
\f4\fs20 ; excess \'93rows\'94 beyond the length of 
\f3\fs18 index
\f4\fs20  will not be selected, and excess values in 
\f3\fs18 index
\f4\fs20  beyond the end of the longest \'93column\'94 will have no effect.\
If the values of 
\f3\fs18 index
\f4\fs20  are such that 
\f1\i no
\f4\i0  value for a given key is selected, the 
\f3\fs18 drop
\f4\fs20  parameter controls the resulting behavior.  If 
\f3\fs18 drop
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), the key will be included in the returned dictionary with a zero-length value of matching type, such as 
\f3\fs18 integer(0)
\f4\fs20  or 
\f3\fs18 string(0)
\f4\fs20 .  If 
\f3\fs18 drop
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , the key will be omitted from the returned dictionary.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(*)getValue(is$\'a0key)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the value previously set for the dictionary entry identifier 
\f3\fs18 key
\f4\fs20  using 
\f3\fs18 setValue()
\f4\fs20 , or 
\f3\fs18 NULL
\f4\fs20  if no value has been set.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(logical$)identicalContents(object$\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns 
\f3\fs18 T
\f4\fs20  if the target 
\f3\fs18 Dictionary
\f4\fs20  is equal to 
\f3\fs18 x
\f4\fs20  in all respects \'96 containing the same keys, with values that are identical in the sense defined by the 
\f3\fs18 identical()
\f4\fs20  function in Eidos \'96 or returns 
\f3\fs18 F
\f4\fs20  otherwise.\
Note that if 
\f3\fs18 Dictionary
\f4\fs20  objects are contained, as values, by the dictionaries being tested for equality, they will be compared according to the standards of 
\f3\fs18 identical()
\f4\fs20 , and must therefore actually be the 
\f1\i same
\f4\i0  
\f3\fs18 Dictionary
\f4\fs20  object, shared by both dictionaries, for 
\f3\fs18 isEqual()
\f4\fs20  to return 
\f3\fs18 T
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(string)serialize([string$\'a0format\'a0=\'a0"slim"])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a serialized form of the dictionary\'92s contents as a 
\f3\fs18 string
\f4\fs20  singleton or vector.  Four formats are supported at present, as chosen with the 
\f3\fs18 format
\f4\fs20  parameter: 
\f3\fs18 "slim"
\f4\fs20  and 
\f3\fs18 \'93json"
\f4\fs20  produce a singleton string, whereas 
\f3\fs18 "csv"
\f4\fs20  and 
\f3\fs18 "tsv"
\f4\fs20  produce a 
\f3\fs18 string
\f4\fs20  vector.  These serializations can be written to disk with 
\f3\fs18 writeFile()
\f4\fs20  or 
\f3\fs18 writeTempFile()
\f4\fs20 , written to the output stream with 
\f3\fs18 cat()
\f4\fs20 , or used in any other way.\
The default 
\f3\fs18 "slim"
\f4\fs20  format is intended for simple, informal use where a very easily parseable string is desired.  For a simple dictionary containing only keys with singleton non-object values, this will be a semicolon-delimited string like 
\f3\fs18 '"string1"=value1;"string2"=value2;'
\f4\fs20  or 
\f3\fs18 'int1=value1;int2=value2;'
\f4\fs20 .  Values of type 
\f3\fs18 string
\f4\fs20  will be quoted, and will be escaped with backslash escape sequences, including 
\f3\fs18 \\\\
\f4\fs20 , 
\f3\fs18 \\"
\f4\fs20 , 
\f3\fs18 \\'
\f4\fs20 , 
\f3\fs18 \\t
\f4\fs20 , 
\f3\fs18 \\r
\f4\fs20 , and 
\f3\fs18 \\n
\f4\fs20 .  Values that are not singleton will be separated by spaces, such as 
\f3\fs18 '"string1"=1 2 3;'
\f4\fs20 , while values that are themselves dictionaries will be delimited by braces, such as 
\f3\fs18 '"string1"=\{int1=value1;int2=value2;\};'
\f4\fs20 .  Keys that are of type 
\f3\fs18 string
\f4\fs20  will be quoted (always; note that this is a change in behavior starting in SLiM 4.1) and backslash-escaped (as needed, as for 
\f3\fs18 string
\f4\fs20  values); keys that are of type 
\f3\fs18 integer
\f4\fs20  are not quoted.  No facility for parsing 
\f3\fs18 "slim"
\f4\fs20  serializations back into Eidos is presently provided.\
The 
\f3\fs18 "json"
\f4\fs20  format, introduced in Eidos 2.7 (SLiM 3.7), provides serialization of the 
\f3\fs18 Dictionary
\f4\fs20  into the standard JSON format, which may not be quite as brief or human-readable, but which can be used as a standard interchange format and read by the 
\f3\fs18 Dictionary()
\f4\fs20  constructor in Eidos as well as by many other programs.  For example, a 
\f3\fs18 Dictionary
\f4\fs20  with a key 
\f3\fs18 "key1"
\f4\fs20  with 
\f3\fs18 integer
\f4\fs20  value 
\f3\fs18 1:3
\f4\fs20  and key 
\f3\fs18 "key2"
\f4\fs20  with 
\f3\fs18 string
\f4\fs20  value 
\f3\fs18 "value2"
\f4\fs20  would produce the JSON serialization 
\f3\fs18 '\{"key1":[1,2,3],"key2":["value2"]\}'
\f4\fs20 , where the outer single quotes are not part of the serialization itself, but are indicating that the serialization is a 
\f3\fs18 string
\f4\fs20  value.  Note that since all Eidos values are vectors, even singleton values are serialized into JSON as arrays by Eidos; the hope is that this will make automated parsing of these JSON strings easier, since the singleton case will not have to be special-cased.  For example, 
\f3\fs18 Dictionary("a", 1, "b", Dictionary("x", 2))
\f4\fs20  would be serialized into JSON as 
\f3\fs18 '\{"a":[1],"b":[\{"x":[2]\}]\}'
\f4\fs20 .  Note that dictionaries that use 
\f3\fs18 integer
\f4\fs20  keys cannot be serialized into JSON, because JSON does not support 
\f3\fs18 integer
\f4\fs20  keys.  Documentation on the JSON format can be found online.\
The 
\f3\fs18 "csv"
\f4\fs20  and 
\f3\fs18 "tsv"
\f4\fs20  formats produce standard comma-separated value (CSV) or tab-separated value (TSV) data.  These formats are primarily intended for output from 
\f3\fs18 DataFrame
\f4\fs20 , since that class is used to represent the sort of data tables that CSV/TSV are typically used for; but it may be used with 
\f3\fs18 Dictionary
\f4\fs20  too, particularly if it is being used to represent a data table with ragged columns (missing values will just be skipped over, producing two commas or two tabs in sequence).  Values of type 
\f3\fs18 string
\f4\fs20  will always be quoted, with double quotes (with a repeated double quote used to indicate the presence of a double quote inside a 
\f3\fs18 string
\f4\fs20  value, as usual in CSV); values of other types never will.  Decimal points (not decimal commas, regardless of system localization) will always be used for 
\f3\fs18 float
\f4\fs20  values, and will never be used for 
\f3\fs18 integer
\f4\fs20  values.  Values of logical type will be serialized as 
\f3\fs18 TRUE
\f4\fs20  or 
\f3\fs18 FALSE
\f4\fs20 , without quotes.  A header line providing the names of the columns (i.e., the keys of the target 
\f3\fs18 Dictionary
\f4\fs20 ) will always be generated; those column names will also be quoted (if the keys of the dictionary are type 
\f3\fs18 string
\f4\fs20 ; 
\f3\fs18 integer
\f4\fs20  keys are not quoted).  One 
\f3\fs18 string
\f4\fs20  element will be generated for each row of the target, plus one 
\f3\fs18 string
\f4\fs20  element for the header line; newlines will not be present in the resulting 
\f3\fs18 string
\f4\fs20  vector unless newlines were present within the 
\f3\fs18 string
\f4\fs20  values in the 
\f3\fs18 Dictionary
\f4\fs20 .  The resulting data, if written to a file, should be readable in Eidos using 
\f3\fs18 readCSV()
\f4\fs20  (as long as there are no ragged columns or missing values), as well as in other software such as R and Excel.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)setValue(is$\'a0key, *\'a0value)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Sets a value for the dictionary entry identifier 
\f3\fs18 key
\f4\fs20 .  The key may be a 
\f3\fs18 string
\f4\fs20  or an 
\f3\fs18 integer
\f4\fs20 ; either is allowed, unless the target dictionary has already begun using keys of a given type, in which case it must continue using the same key type (a given dictionary cannot have both 
\f3\fs18 string
\f4\fs20  and 
\f3\fs18 integer
\f4\fs20  keys).  The value, which may be of any type, can be fetched later using 
\f3\fs18 getValue()
\f4\fs20 .  Setting a key to a value of 
\f3\fs18 NULL
\f4\fs20  removes that key from the dictionary.\
If 
\f3\fs18 value
\f4\fs20  is of type 
\f3\fs18 object
\f4\fs20 , any 
\f3\fs18 object
\f4\fs20  class is allowed; all objects may be added as values to a dictionary.  However, additional scoping restrictions may apply if the 
\f3\fs18 object
\f4\fs20  class is not under an internal memory-management scheme called \'93retain-release\'94; in particular, it may not be legal to keep an object in a dictionary \'93long term\'94 if it is not under retain-release, where \'93long term\'94 is a scoping semantic defined by the Context.  All object classes defined by Eidos itself (
\f3\fs18 Dictionary
\f4\fs20 , 
\f3\fs18 DataFrame
\f4\fs20 , 
\f3\fs18 Image
\f4\fs20 ) are under retain-release, so this restriction does not affect pure Eidos code.  See the SLiM manual (section \'93SLiM scoping rules\'94) for further discussion of this topic.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 5.4  Class Image\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\b0\fs18 \cf2 (object<Image>$)Image(...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Creates a new 
\f3\fs18 Image
\f4\fs20  object.  This can be called in a few different ways.\
Passed a singleton 
\f3\fs18 string
\f4\fs20 , as 
\f3\fs18 Image(string$ filePath)
\f4\fs20 , it creates a new 
\f3\fs18 Image
\f4\fs20  from the PNG file at 
\f3\fs18 filePath
\f4\fs20 .  If the file represents a grayscale image, an 8-bit grayscale (K) 
\f3\fs18 Image
\f4\fs20  will be created; all other PNG files will yield a 24-bit color (RGB) 
\f3\fs18 Image
\f4\fs20 .\
Passed an 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  vector, as 
\f3\fs18 Image(numeric matrix)
\f4\fs20 , it creates a new grayscale 
\f3\fs18 Image
\f4\fs20  from the values in 
\f3\fs18 matrix
\f4\fs20 , which must be a matrix as its name suggests.  If 
\f3\fs18 matrix
\f4\fs20  is 
\f3\fs18 integer
\f4\fs20 , its values must be in [
\f3\fs18 0
\f4\fs20 , 
\f3\fs18 255
\f4\fs20 ], and will be used directly as 8-bit pixel values without translation; if 
\f3\fs18 matrix
\f4\fs20  is 
\f3\fs18 float
\f4\fs20 , its values must be in [
\f3\fs18 0.0
\f4\fs20 , 
\f3\fs18 1.0
\f4\fs20 ], and will be translated into 8-bit pixel values.  The dimensions of the image, in pixels, will be equal to the dimensions of the matrix.  The orientation of the image will match that of the matrix, in the sense that the image will appear as the matrix does when printed in the Eidos console; internally this requires a transposition of values, as discussed further below.  For the 
\f3\fs18 integer
\f4\fs20  case, the 
\f3\fs18 integerK
\f4\fs20  property of the resulting image will recover the original matrix exactly; for the 
\f3\fs18 float
\f4\fs20  case, the 
\f3\fs18 floatK
\f4\fs20  property will only approximately recover the original matrix since the translation into 8-bit pixel values involves quantization, but values of 
\f3\fs18 0.0
\f4\fs20  and 
\f3\fs18 1.0
\f4\fs20  will be recovered exactly.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.4.1  
\f2\fs18 Image
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 width => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The width of the image, in pixels.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 height => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The height of the image, in pixels.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 isGrayscale => (logical$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This flag is 
\f3\fs18 T
\f4\fs20  if the image is grayscale, with only a K channel; it is 
\f3\fs18 F
\f4\fs20  if the image is color, with R/G/B channels.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 bitsPerChannel => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The number of bits used to represent a single pixel, in one channel of the image.  At present this is always 8; grayscale (K) images are 8-bit, color (RGB) images are 24-bit.  It could be extended to support 16-bit channels in future.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerR => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The red (R) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatR
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerG => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The green (G) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatG
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerB => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The blue (R) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatB
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerK => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The gray (K) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatK
\f4\fs20  property for an alternative representation.  If the image is color, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatR => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The red (R) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerR
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerR
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatG => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The green (G) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerG
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerG
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatB => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The blue (B) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerB
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerB
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatK => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The gray (K) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerK
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerK
\f4\fs20  property for an alternative representation.  If the image is color, this property is unavailable.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.4.2  
\f2\fs18 Image
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(void)write(string$\'a0filePath)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Writes the image to the given filesystem path 
\f3\fs18 filePath
\f4\fs20  as PNG data.  It is suggested, but not required, that 
\f3\fs18 filePath
\f4\fs20  should end in a 
\f3\fs18 .png
\f4\fs20  or 
\f3\fs18 .PNG
\f4\fs20  filename extension.  If the file cannot be written, an error will result.  At present, since 
\f3\fs18 bitsPerChannel
\f4\fs20  is always 8, grayscale data will be written as an 8-bit grayscale PNG while color (RGB) data will be written as a 24-bit color PNG without alpha.\
}