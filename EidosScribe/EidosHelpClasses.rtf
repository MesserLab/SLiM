{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Optima-Bold;\f1\fswiss\fcharset0 Optima-Italic;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fswiss\fcharset0 Optima-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 5.1  Class Object\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf2 5.1.1  
\f2\fs18 Object
\f1\fs22  properties\
5.1.2  
\f2\fs18 Object
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 +\'a0(integer$)length(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the size (e.g., length) of the receiving object.  This is equivalent to the 
\f3\fs18 length()
\f4\fs20  (or 
\f3\fs18 size()
\f4\fs20 ) function; in other words, for any 
\f3\fs18 object
\f4\fs20  
\f3\fs18 x
\f4\fs20 , the return value of the function call 
\f3\fs18 length(x)
\f4\fs20  equals the return value of the class method call 
\f3\fs18 x.length()
\f4\fs20 .  This method is provided solely for syntactic convenience.  Note that 
\f3\fs18 +length()
\f4\fs20  is a synonym for 
\f3\fs18 +size()
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(void)methodSignature([Ns$\'a0methodName\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Prints the method signature for the method specified by 
\f3\fs18 methodName
\f4\fs20 , or for all methods supported by the receiving object if 
\f3\fs18 methodName
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(void)propertySignature([Ns$\'a0propertyName\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Prints the property signature for the property specified by 
\f3\fs18 propertyName
\f4\fs20 , or for all properties supported by the receiving object if 
\f3\fs18 propertyName
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(integer$)size(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the size of the receiving object.  This is equivalent to the 
\f3\fs18 size()
\f4\fs20  (or 
\f3\fs18 length()
\f4\fs20 ) function; in other words, for any 
\f3\fs18 object
\f4\fs20  
\f3\fs18 x
\f4\fs20 , the return value of the function call 
\f3\fs18 size(x)
\f4\fs20  equals the return value of the class method call 
\f3\fs18 x.size()
\f4\fs20 .  This method is provided solely for syntactic convenience.  Note that 
\f3\fs18 +length()
\f4\fs20  is a synonym for 
\f3\fs18 +size()
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)str(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Prints the internal property structure of the receiving object; in particular, the element type of the object is printed, followed, on successive lines, by all of the properties supported by the object, their types, and a sample of their values.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 5.2  Class Dictionary\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\b0\fs18 \cf2 (object<Dictionary>$)Dictionary(...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Creates a new 
\f3\fs18 Dictionary
\f4\fs20  object.  Called without arguments, as 
\f3\fs18 Dictionary()
\f4\fs20 , this creates a new empty 
\f3\fs18 Dictionary
\f4\fs20 .\
Alternatively, key-value pairs can be passed to set up the initial state of the new 
\f3\fs18 Dictionary
\f4\fs20 .  These are set, sequentially, on the new 
\f3\fs18 Dictionary
\f4\fs20 , just as 
\f3\fs18 setValue()
\f4\fs20  would do.  For example, calling 
\f3\fs18 Dictionary("a", 0:3, "b", c("foo", "bar"))
\f4\fs20  is equivalent to calling 
\f3\fs18 Dictionary()
\f4\fs20  and then calling 
\f3\fs18 setValue("a", 0:3)
\f4\fs20  and then 
\f3\fs18 setValue("b", c("foo", "bar"))
\f4\fs20  on it; it is just a shorthand for convenience.\
Another alternative is to call 
\f3\fs18 Dictionary()
\f4\fs20  with a singleton 
\f3\fs18 Dictionary
\f4\fs20  as its only argument; this creates a new 
\f3\fs18 Dictionary
\f4\fs20  that is a copy of the 
\f3\fs18 Dictionary
\f4\fs20  passed, containing the same keys and values.  This is equivalent to creating a new empty 
\f3\fs18 Dictionary
\f4\fs20  and then calling 
\f3\fs18 addKeysAndValuesFrom()
\f4\fs20  to copy key-value pairs over; it is just a shorthand for convenience.\
A final alternative is to call 
\f3\fs18 Dictionary()
\f4\fs20  with a singleton 
\f3\fs18 string
\f4\fs20  as its only argument; this creates a new 
\f3\fs18 Dictionary
\f4\fs20  from the string, assuming that it is a data archive in JSON format.  Note that a JSON string can be generated from the 
\f3\fs18 serialize()
\f4\fs20  method of 
\f3\fs18 Dictionary
\f4\fs20 ; together with this way of creating a 
\f3\fs18 Dictionary
\f4\fs20 , this provides the ability to persist arbitrary information to a string (perhaps a file on disk) and back again.  The recreated 
\f3\fs18 Dictionary
\f4\fs20  should be identical to the original, except that zero length vectors such as 
\f3\fs18 integer(0)
\f4\fs20 , 
\f3\fs18 float(0)
\f4\fs20 , 
\f3\fs18 logical(0)
\f4\fs20 , and 
\f3\fs18 string(0)
\f4\fs20  will all be serialized as 
\f3\fs18 "[]"
\f4\fs20  and recreated as 
\f3\fs18 integer(0)
\f4\fs20  since JSON does not provide a way to specify the type of a zero-length array.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.2.1  
\f2\fs18 Dictionary
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 allKeys => (string)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A vector containing all of the string keys that have been assigned values using 
\f3\fs18 setValue()
\f4\fs20 , in sorted (alphabetical) order.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.2.2  
\f2\fs18 Dictionary
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(void)addKeysAndValuesFrom(object$\'a0source)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds all of the key-value pairs contained by 
\f3\fs18 source
\f4\fs20  (which must be a 
\f3\fs18 Dictionary
\f4\fs20  or a subclass of 
\f3\fs18 Dictionary
\f4\fs20 ) to the receiver.  If the target already contains a key that is defined in 
\f3\fs18 source
\f4\fs20 , the target\'92s value for that key will be 
\f1\i replaced
\f4\i0  by the value in 
\f3\fs18 source
\f4\fs20  (contrast this with 
\f3\fs18 appendKeysAndValuesFrom()
\f4\fs20 ).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)appendKeysAndValuesFrom(object\'a0source)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Appends all of the key-value pairs contained by 
\f3\fs18 source
\f4\fs20  (which must be a 
\f3\fs18 Dictionary
\f4\fs20  or a subclass of 
\f3\fs18 Dictionary
\f4\fs20 ) to the receiver.  If the target already contains a key that is defined in source, the value from source will be 
\f1\i appended
\f4\i0  to the target\'92s existing value, which must be of the same type (contrast this with 
\f3\fs18 addKeysAndValuesFrom()
\f4\fs20 ); if the target does not already contain a key that is defined in source, that key-value pair will simply be added to the target.\
In the current implementation, it is an error for either of the values involved in an append to be a matrix or array; values in these 
\f3\fs18 Dictionary
\f4\fs20  objects should be simple vectors.  This limitation preserves the future option to expand this method\'92s functionality to do smart things with matrices and arrays.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)clearKeysAndValues(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Removes all key-value pairs from the receiver.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Dictionary>$)getRowValues(li\'a0index)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a new 
\f3\fs18 Dictionary
\f4\fs20  containing values for selected \'93rows\'94 of the target 
\f3\fs18 Dictionary
\f4\fs20 , allowing 
\f3\fs18 Dictionary
\f4\fs20  to act similarly to a dataframe (see the 
\f3\fs18 Dictionary
\f4\fs20  class documentation for discussion).  From this perspective, the selection logic described below works exactly as the subset operator 
\f3\fs18 []
\f4\fs20  does in Eidos, selecting the \'93rows\'94 of the target 
\f3\fs18 Dictionary
\f4\fs20 .\
The 
\f3\fs18 index
\f4\fs20  parameter may be either 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 logical
\f4\fs20 ; we will discuss the 
\f3\fs18 integer
\f4\fs20  case first.  If 
\f3\fs18 index
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20 , the returned 
\f3\fs18 Dictionary
\f4\fs20  will contain the 
\f3\fs18 index
\f4\fs20 \'92th element of the value of each key of the target, under the same keys; this is a single \'93row\'94 of the target 
\f3\fs18 Dictionary
\f4\fs20 .  If 
\f3\fs18 index
\f4\fs20  is a non-singleton 
\f3\fs18 integer
\f4\fs20  vector, the returned 
\f3\fs18 Dictionary
\f4\fs20  will contain the values for all of the selected rows, in the order that they are selected by 
\f3\fs18 index
\f4\fs20 .  If any index value in 
\f3\fs18 index
\f4\fs20  is out of range for any key of the target 
\f3\fs18 Dictionary
\f4\fs20  (such that that key does not have an 
\f3\fs18 index
\f4\fs20 \'92th value), an error will result.\
If 
\f3\fs18 index
\f4\fs20  is 
\f3\fs18 logical
\f4\fs20 , the target 
\f3\fs18 Dictionary
\f4\fs20  must not be \'93ragged\'94 (the length of the values for all of its keys must be equal), and the length of 
\f3\fs18 index
\f4\fs20  must be equal to the number of \'93rows\'94 in the target.  In this case, the 
\f3\fs18 T
\f4\fs20  values in 
\f3\fs18 index
\f4\fs20  select the \'93rows\'94 which will be included in the returned 
\f3\fs18 Dictionary
\f4\fs20 .  The values of each column in the returned 
\f3\fs18 Dictionary
\f4\fs20  will be in the same order as in the target.\
In the current implementation, it is an error for any value in the target 
\f3\fs18 Dictionary
\f4\fs20  to be a matrix or array; values in the target should be simple vectors.  This limitation preserves the future option to expand this method\'92s functionality to do smart things with matrices and arrays.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(*)getValue(string$\'a0key)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the value previously set for the dictionary entry identifier 
\f3\fs18 key
\f4\fs20  using 
\f3\fs18 setValue()
\f4\fs20 , or 
\f3\fs18 NULL
\f4\fs20  if no value has been set.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(logical$)identicalContents(object$\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns 
\f3\fs18 T
\f4\fs20  if the target 
\f3\fs18 Dictionary
\f4\fs20  is equal to 
\f3\fs18 x
\f4\fs20  in all respects \'96 containing the same keys, with values that are identical in the sense defined by the 
\f3\fs18 identical()
\f4\fs20  function in Eidos \'96 or returns 
\f3\fs18 F
\f4\fs20  otherwise.\
Note that if 
\f3\fs18 Dictionary
\f4\fs20  objects are contained, as values, by the dictionaries being tested for equality, they will be compared according to the standards of 
\f3\fs18 identical()
\f4\fs20 , and must therefore actually be the 
\f1\i same
\f4\i0  
\f3\fs18 Dictionary
\f4\fs20  object, shared by both dictionaries, for 
\f3\fs18 isEqual()
\f4\fs20  to return 
\f3\fs18 T
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(string$)serialize([string$\'a0format\'a0=\'a0"slim"])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a serialized form of the dictionary\'92s contents as a singleton 
\f3\fs18 string
\f4\fs20 .  Two formats are supported at present, as chosen with the 
\f3\fs18 format
\f4\fs20  parameter: 
\f3\fs18 "slim"
\f4\fs20  and 
\f3\fs18 "json"
\f4\fs20 .\
The default 
\f3\fs18 "slim"
\f4\fs20  format is intended for simple, informal use where a very easily parseable string is desired.  For a simple dictionary containing only keys with singleton non-object values, this will be a semicolon-delimited string like 
\f3\fs18 "key1=value1;key2=value2;"
\f4\fs20 .  Values of type 
\f3\fs18 string
\f4\fs20  will be quoted, and will be escaped with backslash escape sequences, including 
\f3\fs18 \\\\
\f4\fs20 , 
\f3\fs18 \\"
\f4\fs20 , 
\f3\fs18 \\'
\f4\fs20 , 
\f3\fs18 \\t
\f4\fs20 , 
\f3\fs18 \\r
\f4\fs20 , and 
\f3\fs18 \\n
\f4\fs20 .  Values that are not singleton will be separated by spaces, such as 
\f3\fs18 "key1=1 2 3;"
\f4\fs20 , while values that are themselves dictionaries will be delimited by braces, such as 
\f3\fs18 "key1=\{key1=value1;key2=value2;\};"
\f4\fs20 .  Keys, since they are also of type 
\f3\fs18 string
\f4\fs20 , will be quoted and backslash-escaped if necessary, but simple keys that do not require that treatment will be serialized without quotes for simplicity.\
The 
\f3\fs18 "json"
\f4\fs20  format, introduced in Eidos 2.7 (SLiM 3.7), provides serialization of the 
\f3\fs18 Dictionary
\f4\fs20  into the standard JSON format, which may not be quite as brief or human-readable, but which can be used as a standard interchange format and read by many other programs.  For example, a 
\f3\fs18 Dictionary
\f4\fs20  with a key 
\f3\fs18 "key1"
\f4\fs20  with 
\f3\fs18 integer
\f4\fs20  value 
\f3\fs18 1:3
\f4\fs20  and key 
\f3\fs18 "key2"
\f4\fs20  with 
\f3\fs18 string
\f4\fs20  value 
\f3\fs18 "value2"
\f4\fs20  would produce the JSON serialization 
\f3\fs18 '\{"key1":[1,2,3],"key2":["value2"]\}'
\f4\fs20 , where the outer single quotes are not part of the serialization itself, but are indicating that the serialization is a 
\f3\fs18 string
\f4\fs20  value.  Note that since all Eidos values are vectors, even singleton values are serialized into JSON as arrays by Eidos; the hope is that this will make automated parsing of these JSON strings easier, since the singleton case will not have to be special-cased.  Documentation on the JSON format can be found online.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)setValue(string$\'a0key, *\'a0value)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Sets a value for the dictionary entry identifier 
\f3\fs18 key
\f4\fs20 .  The value, which may be of any type, can be fetched later using 
\f3\fs18 getValue()
\f4\fs20 .  If 
\f3\fs18 value
\f4\fs20  is of type 
\f3\fs18 object
\f4\fs20 , the object class must internally be under retain-release memory management; among SLiM\'92s Eidos classes, only 
\f3\fs18 Chromosome
\f4\fs20 , 
\f3\fs18 Mutation
\f4\fs20 , and 
\f3\fs18 Substitution
\f4\fs20  presently are (see the Eidos manual\'92s documentation for 
\f3\fs18 defineConstant()
\f4\fs20  for further discussion).  Setting a key to a value of 
\f3\fs18 NULL
\f4\fs20  removes that key from the dictionary.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 5.3  Class Image\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\b0\fs18 \cf2 (object<Image>$)Image(string$\'a0filePath)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Creates a new 
\f3\fs18 Image
\f4\fs20  object from the PNG file at 
\f3\fs18 filePath
\f4\fs20 .  If the file represents a grayscale image, an 8-bit grayscale (K) 
\f3\fs18 Image
\f4\fs20  will be created; all other PNG files will yield a 24-bit color (RGB) 
\f3\fs18 Image
\f4\fs20 .\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.3.1  
\f2\fs18 Image
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 width => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The width of the image, in pixels.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 height => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The height of the image, in pixels.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 isGrayscale => (logical$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This flag is 
\f3\fs18 T
\f4\fs20  if the image is grayscale, with only a K channel; it is 
\f3\fs18 F
\f4\fs20  if the image is color, with R/G/B channels.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 bitsPerChannel => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The number of bits used to represent a single pixel, in one channel of the image.  At present this is always 8; grayscale (K) images are 8-bit, color (RGB) images are 24-bit.  It could be extended to support 16-bit channels in future.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerR => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The red (R) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatR
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerG => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The green (G) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatG
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerB => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The blue (R) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatB
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 integerK => (integer)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The gray (K) channel of the image, represented as a 2D 
\f3\fs18 integer
\f4\fs20  matrix.  Values will be in [0,255].  See the 
\f3\fs18 floatK
\f4\fs20  property for an alternative representation.  If the image is color, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatR => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The red (R) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerR
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerR
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatG => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The green (G) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerG
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerG
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatB => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The blue (B) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerB
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerB
\f4\fs20  property for an alternative representation.  If the image is grayscale, this property is unavailable.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 floatK => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The gray (K) channel of the image, represented as a 2D 
\f3\fs18 float
\f4\fs20  matrix.  Values will be in [0,1], obtained by dividing the 
\f3\fs18 integerK
\f4\fs20  layer by 255.  See the 
\f3\fs18 integerK
\f4\fs20  property for an alternative representation.  If the image is color, this property is unavailable.\
\pard\pardeftab720\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.3.2  
\f2\fs18 Image
\f1\fs22  methods\
}