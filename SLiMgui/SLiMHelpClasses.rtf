{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Optima-Bold;\f1\fswiss\fcharset0 Optima-Italic;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fswiss\fcharset0 Optima-Regular;\f5\froman\fcharset0 TimesNewRomanPSMT;
\f6\froman\fcharset0 TimesNewRomanPS-ItalicMT;\f7\fnil\fcharset0 LucidaGrande;\f8\fswiss\fcharset0 Helvetica-Oblique;
\f9\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c100000;}
\margl1440\margr1440\vieww9000\viewh19740\viewkind0
\deftab720
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.2  Class Chromosome\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.2.1  
\f2\fs18 Chromosome
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 colorSubstitution <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The color used to display substitutions in SLiMgui when both mutations and substitutions are being displayed in the chromosome view.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f3\fs18 "#RRGGBB"
\f4\fs20 .  If 
\f3\fs18 colorSubstitution
\f4\fs20  is the empty string, 
\f3\fs18 ""
\f4\fs20 , SLiMgui will defer to the color scheme of each 
\f3\fs18 MutationType
\f4\fs20 , just as it does when only substitutions are being displayed.  The default, 
\f3\fs18 "3333FF"
\f4\fs20 , causes all substitutions to be shown as dark blue when displayed in conjunction with mutations, to prevent the view from becoming too noisy.  Note that when substitutions are displayed without mutations also being displayed, this value is ignored by SLiMgui and the substitutions use the color scheme of each 
\f3\fs18 MutationType
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
geneConversionEnabled => (logical$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 When gene conversion has been enabled by calling 
\f3\fs18 initializeGeneConversion()
\f4\fs20 , switching to the DSB recombination model, this property is 
\f3\fs18 T
\f4\fs20 ; otherwise, when using the crossover breakpoints model, it is 
\f3\fs18 F
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 geneConversionGCBias => (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The gene conversion bias coefficient, which expresses a bias in the resolution of heteroduplex mismatches in complex gene conversion tracts.  When gene conversion has not been enabled by calling 
\f3\fs18 initializeGeneConversion()
\f4\fs20 , this property will be unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 geneConversionNonCrossoverFraction => (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The fraction of double-stranded breaks that result in non-crossover events.  When gene conversion has not been enabled by calling 
\f3\fs18 initializeGeneConversion()
\f4\fs20 , this property will be unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 geneConversionMeanLength => (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The mean length of a gene conversion tract (in base positions).  When gene conversion has not been enabled by calling 
\f3\fs18 initializeGeneConversion()
\f4\fs20 , this property will be unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 geneConversionSimpleConversionFraction => (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The fraction of gene conversion tracts that are \'93simple\'94 (i.e., not involving resolution of heteroduplex mismatches); the remainder will be \'93complex\'94.  When gene conversion has not been enabled by calling 
\f3\fs18 initializeGeneConversion()
\f4\fs20 , this property will be unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 genomicElements => (object<GenomicElement>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 All of the 
\f3\fs18 GenomicElement
\f4\fs20  objects that comprise the chromosome.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
hotspotEndPositions => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The end positions for hotspot map regions along the chromosome.  Each hotspot map region is assumed to start at the position following the end of the previous hotspot map region; in other words, the regions are assumed to be contiguous.  When using sex-specific hotspot maps, this property will unavailable; see 
\f3\fs18 hotspotEndPositionsF
\f4\fs20  and 
\f3\fs18 hotspotEndPositionsM
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 hotspotEndPositionsF => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The end positions for hotspot map regions for females, when using sex-specific hotspot maps; unavailable otherwise.  See 
\f3\fs18 hotspotEndPositions
\f4\fs20  for further explanation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 hotspotEndPositionsM => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The end positions for hotspot map regions for males, when using sex-specific hotspot maps; unavailable otherwise.  See 
\f3\fs18 hotspotEndPositions
\f4\fs20  for further explanation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 hotspotMultipliers => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The hotspot multiplier for each of the hotspot map regions specified by 
\f3\fs18 hotspotEndPositions
\f4\fs20 .  When using sex-specific hotspot maps, this property will be unavailable; see 
\f3\fs18 hotspotMultipliersF
\f4\fs20  and 
\f3\fs18 hotspotMultipliersM
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 hotspotMultipliersF => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The hotspot multiplier for each of the hotspot map regions specified by 
\f3\fs18 hotspotEndPositionsF
\f4\fs20 , when using sex-specific hotspot maps; unavailable otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 hotspotMultipliersM => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The hotspot multiplier for each of the hotspot map regions specified by 
\f3\fs18 hotspotEndPositionsM
\f4\fs20 , when using sex-specific hotspot maps; unavailable otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 lastPosition => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The last valid position in the chromosome; its length, essentially.\cf2   Note that the chromosome length is determined by the 
\f1\i maximum
\f4\i0  of the end of the last genomic element, the end of the last recombination region, and the end of the last mutation map region (or hotspot map region).
\f5 \cf0 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutationEndPositions => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for mutation rate regions along the chromosome.  Each mutation rate region is assumed to start at the position following the end of the previous mutation rate region; in other words, the regions are assumed to be contiguous.  When using sex-specific mutation rate maps, this property will unavailable; see 
\f3\fs18 mutationEndPositionsF
\f4\fs20  and 
\f3\fs18 mutationEndPositionsM
\f4\fs20 .\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationEndPositionsF => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for mutation rate regions for females, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f3\fs18 mutationEndPositions
\f4\fs20  for further explanation.\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationEndPositionsM => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for mutation rate regions for males, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f3\fs18 mutationEndPositions
\f4\fs20  for further explanation.\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationRates => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The mutation rate for each of the mutation rate regions specified by 
\f3\fs18 mutationEndPositions
\f4\fs20 .  When using sex-specific mutation rate maps, this property will be unavailable; see 
\f3\fs18 mutationRatesF
\f4\fs20  and 
\f3\fs18 mutationRatesM
\f4\fs20 .\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationRatesF => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The mutation rate for each of the mutation rate regions specified by 
\f3\fs18 mutationEndPositionsF
\f4\fs20 , when using sex-specific mutation rate maps; unavailable otherwise.\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationRatesM => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The mutation rate for each of the mutation rate regions specified by 
\f3\fs18 mutationEndPositionsM
\f4\fs20 , when using sex-specific mutation rate maps; unavailable otherwise.\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 overallMutationRate => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall mutation rate across the whole chromosome determining the overall number of mutation events that will occur anywhere in the chromosome, as calculated from the individual mutation ranges and rates as well as the coverage of the chromosome by genomic elements (since mutations are only generated within genomic elements, regardless of the mutation rate map).  When using sex-specific mutation rate maps, this property will unavailable; see 
\f3\fs18 overallMutationRateF
\f4\fs20  and 
\f3\fs18 overallMutationRateM
\f4\fs20 .\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 overallMutationRateF => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall mutation rate for females, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f3\fs18 overallMutationRate
\f4\fs20  for further explanation.\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 overallMutationRateM => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall mutation rate for males, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f3\fs18 overallMutationRate
\f4\fs20  for further explanation.\
This property is unavailable in nucleotide-based models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 overallRecombinationRate => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall recombination rate across the whole chromosome determining the overall number of recombination events that will occur anywhere in the chromosome, as calculated from the individual recombination ranges and rates.  When using sex-specific recombination maps, this property will unavailable; see 
\f3\fs18 overallRecombinationRateF
\f4\fs20  and 
\f3\fs18 overallRecombinationRateM
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 overallRecombinationRateF => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall recombination rate for females, when using sex-specific recombination maps; unavailable otherwise.  See 
\f3\fs18 overallRecombinationRate
\f4\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 overallRecombinationRateM => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall recombination rate for males, when using sex-specific recombination maps; unavailable otherwise.  See 
\f3\fs18 overallRecombinationRate
\f4\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationEndPositions => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for recombination regions along the chromosome.  Each recombination region is assumed to start at the position following the end of the previous recombination region; in other words, the regions are assumed to be contiguous.  When using sex-specific recombination maps, this property will unavailable; see 
\f3\fs18 recombinationEndPositionsF
\f4\fs20  and 
\f3\fs18 recombinationEndPositionsM
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationEndPositionsF => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for recombination regions for females, when using sex-specific recombination maps; unavailable otherwise.  See 
\f3\fs18 recombinationEndPositions
\f4\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationEndPositionsM => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for recombination regions for males, when using sex-specific recombination maps; unavailable otherwise.  See 
\f3\fs18 recombinationEndPositions
\f4\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationRates => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The recombination rate for each of the recombination regions specified by 
\f3\fs18 recombinationEndPositions
\f4\fs20 .  When using sex-specific recombination maps, this property will unavailable; see 
\f3\fs18 recombinationRatesF
\f4\fs20  and 
\f3\fs18 recombinationRatesM
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationRatesF => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The recombination rate for each of the recombination regions specified by 
\f3\fs18 recombinationEndPositionsF
\f4\fs20 , when using sex-specific recombination maps; unavailable otherwise.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationRatesM => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The recombination rate for each of the recombination regions specified by 
\f3\fs18 recombinationEndPositionsM
\f4\fs20 , when using sex-specific recombination maps; unavailable otherwise.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 species => (object<Species>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The species to which the target object belongs.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.
\f5 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.2.2  
\f2\fs18 Chromosome
\f1\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(is)ancestralNucleotides([Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL], [string$\'a0format\'a0=\'a0"string"])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the ancestral nucleotide sequence originally supplied to 
\f3\fs18 initializeAncestralNucleotides()
\f4\fs20 , including any sequence changes due to nucleotide mutations that have fixed and substituted.  This nucleotide sequence is the reference sequence for positions in a genome that do not contain a nucleotide-based mutation.  The range of the returned sequence may be constrained by a start position given in 
\f3\fs18 start
\f4\fs20  and/or an end position given in 
\f3\fs18 end
\f4\fs20 ; nucleotides will be returned from 
\f3\fs18 start
\f4\fs20  to 
\f3\fs18 end
\f4\fs20 , inclusive.  The default value of 
\f3\fs18 NULL
\f4\fs20  for 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  represent the first and last base positions of the chromosome, respectively.\
The format of the returned sequence is controlled by the 
\f3\fs18 format
\f4\fs20  parameter.  A format of 
\f3\fs18 "string"
\f4\fs20  will return the sequence as a singleton 
\f3\fs18 string
\f4\fs20  (e.g., 
\f3\fs18 "TATA"
\f4\fs20 ).  A format of 
\f3\fs18 "char"
\f4\fs20  will return a 
\f3\fs18 string
\f4\fs20  vector with one element per nucleotide (e.g., 
\f3\fs18 "T"
\f4\fs20 , 
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "T"
\f4\fs20 , 
\f3\fs18 "A"
\f4\fs20 ).  A format of 
\f3\fs18 "integer"
\f4\fs20  will return an 
\f3\fs18 integer
\f4\fs20  vector with values A=
\f3\fs18 0
\f4\fs20 , C=
\f3\fs18 1
\f4\fs20 , G=
\f3\fs18 2
\f4\fs20 , T=
\f3\fs18 3
\f4\fs20  (e.g., 
\f3\fs18 3
\f4\fs20 , 
\f3\fs18 0
\f4\fs20 , 
\f3\fs18 3
\f4\fs20 , 
\f3\fs18 0
\f4\fs20 ).  If the sequence returned is likely to be long, the 
\f3\fs18 "string"
\f4\fs20  format will be the most memory-efficient, and may also be the fastest (but may be harder to work with).\
For purposes related to interpreting the nucleotide sequence as a coding sequence, a format of 
\f3\fs18 "codon"
\f4\fs20  is also supported.  This format will return an 
\f3\fs18 integer
\f4\fs20  vector with values from 
\f3\fs18 0
\f4\fs20  to 
\f3\fs18 63
\f4\fs20 , based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three).  The codon value for a given nucleotide triplet XYZ is 16X\'a0+\'a04Y\'a0+\'a0Z, where X, Y, and Z have the usual values A=
\f3\fs18 0
\f4\fs20 , C=
\f3\fs18 1
\f4\fs20 , G=
\f3\fs18 2
\f4\fs20 , T=
\f3\fs18 3
\f4\fs20 .  For example, the triplet AAA has a codon value of 
\f3\fs18 0
\f4\fs20 , AAC is 
\f3\fs18 1
\f4\fs20 , AAG is 
\f3\fs18 2
\f4\fs20 , AAT is 
\f3\fs18 3
\f4\fs20 , ACA is 
\f3\fs18 4
\f4\fs20 , and on upward to TTT which is 
\f3\fs18 63
\f4\fs20 .  If the nucleotide sequence AACACATTT is requested in codon format, the codon vector 
\f3\fs18 1 4 63
\f4\fs20  will therefore be returned.  These codon values can be useful in themselves; they can also be passed to 
\f3\fs18 codonToAminoAcid()
\f4\fs20  to translate them into the corresponding amino acid sequence if desired.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0\cf2 \expnd0\expndtw0\kerning0
(integer)drawBreakpoints([No<Individual>$\'a0parent\'a0=\'a0NULL], [Ni$\'a0n\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Draw recombination breakpoints, using the chromosome\'92s recombination rate map, the current gene conversion parameters, and (in some cases \'96 see below) any active and applicable 
\f3\fs18 recombination()
\f4\fs20  callbacks.  The number of breakpoints to generate, 
\f3\fs18 n
\f4\fs20 , may be supplied; if it is 
\f3\fs18 NULL
\f4\fs20  (the default), the number of breakpoints will be drawn based upon the overall recombination rate and the chromosome length (following the standard procedure in SLiM).  Note that if the double-stranded breaks model has been chosen, the number of breakpoints generated will probably not be equal to the number requested, because most breakpoints will entail gene conversion tracts, which entail additional crossover breakpoints.\
It is generally recommended that the parent individual be supplied to this method, but 
\f3\fs18 parent
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  by default.  The individual supplied in 
\f3\fs18 parent
\f4\fs20  is used for two purposes.  First, in sexual models that define separate recombination rate maps for males versus females, the sex of 
\f3\fs18 parent
\f4\fs20  will be used to determine which map is used; in this case, a non-
\f3\fs18 NULL
\f4\fs20  value 
\f1\i must
\f4\i0  be supplied for 
\f3\fs18 parent
\f4\fs20 , since the choice of recombination rate map must be determined.  Second, in models that define 
\f3\fs18 recombination()
\f4\fs20  callbacks, 
\f3\fs18 parent
\f4\fs20  is used to determine the various pseudo-parameters that are passed to 
\f3\fs18 recombination()
\f4\fs20  callbacks (
\f3\fs18 individual
\f4\fs20 , 
\f3\fs18 genome1
\f4\fs20 , 
\f3\fs18 genome2
\f4\fs20 , 
\f3\fs18 subpop
\f4\fs20 ), and the subpopulation to which 
\f3\fs18 parent
\f4\fs20  belongs is used to select which 
\f3\fs18 recombination()
\f4\fs20  callbacks are applicable; given the necessity of this information, 
\f3\fs18 recombination()
\f4\fs20  callbacks will not be called as a side effect of this method if 
\f3\fs18 parent
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20 .  Apart from these two uses, 
\f3\fs18 parent
\f4\fs20  is not used, and the caller does not guarantee that the generated breakpoints will actually be used to recombine the genomes of 
\f3\fs18 parent
\f4\fs20  in particular.\kerning1\expnd0\expndtw0   If a 
\f3\fs18 recombination()
\f4\fs20  callback is called, 
\f3\fs18 genome1
\f4\fs20  for that callback will always be 
\f3\fs18 parent.genome1
\f4\fs20 ; in other words, 
\f3\fs18 drawBreakpoints()
\f4\fs20  will always treat 
\f3\fs18 parent.genome1
\f4\fs20  as the initial copy strand.  If the caller wishes to randomly choose an initial copy strand (which is usually desirable), they should do that themselves.\expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(integer$)setAncestralNucleotides(is\'a0sequence)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This method, which may be called only in nucleotide-based models, replaces the ancestral nucleotide sequence for the model.  The 
\f3\fs18 sequence
\f4\fs20  parameter is interpreted exactly as it is in the 
\f3\fs18 initializeAncestralSequence()
\f4\fs20  function; see that documentation for details.  The length of the ancestral sequence is returned.\
It is unusual to replace the ancestral sequence in a running simulation, since the nucleotide states of segregating and fixed mutations will depend upon the original ancestral sequence.  It can be useful when loading a new population state with 
\f3\fs18 readFromMS()
\f4\fs20  or 
\f3\fs18 readFromVCF()
\f4\fs20 , such as when resetting the simulation state to an earlier state in a conditional simulation; however, that is more commonly done using 
\f3\fs18 readFromPopulationFile()
\f4\fs20  with a SLiM or 
\f3\fs18 .trees
\f4\fs20  file.
\f1\i \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(void)setGeneConversion(numeric$\'a0nonCrossoverFraction, numeric$\'a0meanLength, numeric$\'a0simpleConversionFraction, [numeric$\'a0bias\'a0=\'a00])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This method switches the recombination model to the \'93double-stranded break (DSB)\'94 model (if it is not already set to that), and configures the details of the gene conversion tracts that will therefore be modeled.  The meanings and effects of the parameters exactly mirror the 
\f3\fs18 initializeGeneConversion()
\f4\fs20  function.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)setHotspotMap(numeric\'a0multipliers, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 In nucleotide-based models, set the mutation rate 
\f1\i multiplier
\f4\i0  along the chromosome.  There are two ways to call this method.  If the optional 
\f3\fs18 ends
\f4\fs20  parameter is 
\f3\fs18 NULL
\f4\fs20  (the default), then 
\f3\fs18 multipliers
\f4\fs20  must be a singleton value that specifies a single multiplier to be used along the entire chromosome.  If, on the other hand, 
\f3\fs18 ends
\f4\fs20  is supplied, then 
\f3\fs18 multipliers
\f4\fs20  and 
\f3\fs18 ends
\f4\fs20  must be the same length, and the values in 
\f3\fs18 ends
\f4\fs20  must be specified in ascending order.  In that case, 
\f3\fs18 multipliers
\f4\fs20  and 
\f3\fs18 ends
\f4\fs20  taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f3\fs18 ends
\f4\fs20  should extend to the end of the chromosome (as previously determined, during simulation initialization).  See the 
\f3\fs18 initializeHotspotMap()
\f4\fs20  function for further discussion of precisely how these multipliers and positions are interpreted.\
If the optional 
\f3\fs18 sex
\f4\fs20  parameter is 
\f3\fs18 "*"
\f4\fs20  (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f3\fs18 sex
\f4\fs20  may be 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  instead, in which case the supplied hotspot map is used only for that sex.  Note that whether sex-specific hotspot maps will be used is set by the way that the simulation is initially configured with 
\f3\fs18 initializeHotspot()
\f4\fs20 , and cannot be changed with this method; so if the simulation was set up to use sex-specific hotspot maps then sex must be 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  here, whereas if it was set up not to, then sex must be 
\f3\fs18 "*"
\f4\fs20  or unsupplied here.  If a simulation needs sex-specific hotspot maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.\
The hotspot map is normally constant in simulations, so be sure you know what you are doing.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)setMutationRate(numeric\'a0rates, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the mutation rate per base position per \cf2 \expnd0\expndtw0\kerning0
gamete\cf0 \kerning1\expnd0\expndtw0 .  There are two ways to call this method.  If the optional 
\f3\fs18 ends
\f4\fs20  parameter is 
\f3\fs18 NULL
\f4\fs20  (the default), then 
\f3\fs18 rates
\f4\fs20  must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.  If, on the other hand, 
\f3\fs18 ends
\f4\fs20  is supplied, then 
\f3\fs18 rates
\f4\fs20  and 
\f3\fs18 ends
\f4\fs20  must be the same length, and the values in 
\f3\fs18 ends
\f4\fs20  must be specified in ascending order.  In that case, 
\f3\fs18 rates
\f4\fs20  and 
\f3\fs18 ends
\f4\fs20  taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f3\fs18 ends
\f4\fs20  should extend to the end of the chromosome (as previously determined, during simulation initialization).  See the 
\f3\fs18 initializeMutationRate()
\f4\fs20  function for further discussion of precisely how these rates and positions are interpreted.\
If the optional 
\f3\fs18 sex
\f4\fs20  parameter is 
\f3\fs18 "*"
\f4\fs20  (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f3\fs18 sex
\f4\fs20  may be 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  instead, in which case the supplied mutation rate map is used only for that sex.  Note that whether sex-specific mutation rate maps will be used is set by the way that the simulation is initially configured with 
\f3\fs18 initializeMutationRate()
\f4\fs20 , and cannot be changed with this method; so if the simulation was set up to use sex-specific mutation rate maps then sex must be 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  here, whereas if it was set up not to, then sex must be 
\f3\fs18 "*"
\f4\fs20  or unsupplied here.  If a simulation needs sex-specific mutation rate maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.\
The mutation rate intervals are normally a constant in simulations, so be sure you know what you are doing.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In nucleotide-based models, 
\f3\fs18 setMutationRate()
\f4\fs20  may not be called.  If variation in the mutation rate along the chromosome is desired, 
\f3\fs18 setHotspotMap()
\f4\fs20  should be used.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)setRecombinationRate(numeric\'a0rates, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the recombination rate per base position per \cf2 \expnd0\expndtw0\kerning0
gamete\cf0 \kerning1\expnd0\expndtw0 .  \cf2 \expnd0\expndtw0\kerning0
All rates must be in the interval [
\f3\fs18 0.0
\f4\fs20 , 
\f3\fs18 0.5
\f4\fs20 ].  \cf0 \kerning1\expnd0\expndtw0 There are two ways to call this method.  If the optional 
\f3\fs18 ends
\f4\fs20  parameter is 
\f3\fs18 NULL
\f4\fs20  (the default), then 
\f3\fs18 rates
\f4\fs20  must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.  If, on the other hand, 
\f3\fs18 ends
\f4\fs20  is supplied, then 
\f3\fs18 rates
\f4\fs20  and 
\f3\fs18 ends
\f4\fs20  must be the same length, and the values in 
\f3\fs18 ends
\f4\fs20  must be specified in ascending order.  In that case, 
\f3\fs18 rates
\f4\fs20  and 
\f3\fs18 ends
\f4\fs20  taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f3\fs18 ends
\f4\fs20  should extend to the end of the chromosome (as previously determined, during simulation initialization).  See the 
\f3\fs18 initializeRecombinationRate()
\f4\fs20  function for further discussion of precisely how these rates and positions are interpreted.\
If the optional 
\f3\fs18 sex
\f4\fs20  parameter is 
\f3\fs18 "*"
\f4\fs20  (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f3\fs18 sex
\f4\fs20  may be 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  instead, in which case the supplied recombination map is used only for that sex.  Note that whether sex-specific recombination maps will be used is set by the way that the simulation is initially configured with 
\f3\fs18 initializeRecombinationRate()
\f4\fs20 , and cannot be changed with this method; so if the simulation was set up to use sex-specific recombination maps then sex must be 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  here, whereas if it was set up not to, then sex must be 
\f3\fs18 "*"
\f4\fs20  or unsupplied here.  If a simulation needs sex-specific recombination maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.\
The recombination intervals are normally a constant in simulations, so be sure you know what you are doing.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.3  Class Community\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.3.1  
\f2\fs18 Community
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 allGenomicElementTypes => (object<GenomicElementType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All of the 
\f3\fs18 GenomicElementType
\f4\fs20  objects defined in the simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 allInteractionTypes => (object<InteractionType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All of the 
\f3\fs18 InteractionType
\f4\fs20  objects defined in the simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 allMutationTypes => (object<MutationType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All of the 
\f3\fs18 MutationType
\f4\fs20  objects defined in the simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 allScriptBlocks => (object<SLiMEidosBlock>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects in the simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 allSpecies => (object<Species>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All of the 
\f3\fs18 Species
\f4\fs20  objects defined in the simulation (in species declaration order).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 allSubpopulations => (object<Subpopulation>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All of the 
\f3\fs18 Subpopulation
\f4\fs20  objects defined in the simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 cycleStage => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The current cycle stage, as a 
\f3\fs18 string
\f4\fs20 .  The values of this property essentially mirror the cycle stages of WF and nonWF models.  Common values include 
\f3\fs18 "first"
\f4\fs20  (during execution of 
\f3\fs18 first()
\f4\fs20  events), 
\f3\fs18 "early"
\f4\fs20  (during execution of 
\f3\fs18 early()
\f4\fs20  events), 
\f3\fs18 "reproduction"
\f4\fs20  (during offspring generation), 
\f3\fs18 "fitness"
\f4\fs20  (during fitness evaluation), 
\f3\fs18 "survival"
\f4\fs20  (while applying selection and mortality in nonWF models), and 
\f3\fs18 "late"
\f4\fs20  (during execution of 
\f3\fs18 late()
\f4\fs20  events).\
Other possible values include 
\f3\fs18 "begin"
\f4\fs20  (during internal setup before each cycle), 
\f3\fs18 "tally"
\f4\fs20  (while tallying mutation reference counts and removing fixed mutations), 
\f3\fs18 "swap"
\f4\fs20  (while swapping the offspring generation into the parental generation in WF models), 
\f3\fs18 "end"
\f4\fs20  (during internal bookkeeping after each cycle), and 
\f3\fs18 "console"
\f4\fs20  (during the in-between-ticks state in which commands in SLiMgui\'92s Eidos console are executed).  It would probably be a good idea not to use this latter set of values; they are probably not user-visible during ordinary model execution anyway.\
During execution of 
\f3\fs18 initialize()
\f4\fs20  callbacks, no 
\f3\fs18 Community
\f4\fs20  object yet exists and so this property cannot be accessed.  To detect this state, use 
\f3\fs18 exists("community")
\f4\fs20 ; if that is 
\f3\fs18 F
\f4\fs20 , 
\f3\fs18 community
\f4\fs20  does not exist, and therefore your code is executing during 
\f3\fs18 initialize()
\f4\fs20  callbacks (or outside of SLiM entirely, in some other Eidos-based context).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 logFiles => (object<LogFile>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The 
\f3\fs18 LogFile
\f4\fs20  objects being used in the simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 modelType => (string$)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The type of model being simulated, as specified in 
\f3\fs18 initializeSLiMModelType()
\f4\fs20 .  This will be 
\f3\fs18 "WF"
\f4\fs20  for WF models (Wright-Fisher models, the default), or 
\f3\fs18 "nonWF"
\f4\fs20  for nonWF models (non-Wright-Fisher models).\kerning1\expnd0\expndtw0   This must be the same for all species in the community; it is therefore a property on 
\f3\fs18 Community
\f4\fs20 , not 
\f3\fs18 Species
\f4\fs20 .\expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to the simulation.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tick <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The current tick number.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 verbosity <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The verbosity level, for SLiM\'92s logging of information about the simulation.  This is 
\f3\fs18 1
\f4\fs20  by default, but can be changed at the command line with the 
\f3\fs18 -l[ong]
\f4\fs20  option.  It is provided here so that scripts can consult it to govern the level of verbosity of their own output, or set the verbosity level for particular sections of their code.  A verbosity level of 0 suppresses most of SLiM\'92s optional output; 2 adds some extra output beyond SLiM\'92s standard output.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.3.2  
\f2\fs18 Community
\f1\fs22  methods\
\pard\pardeftab529\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(object<LogFile>$)createLogFile(string$\'a0filePath, [Ns\'a0initialContents\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F], [logical$\'a0compress\'a0=\'a0F], [string$\'a0sep\'a0=\'a0","], [Ni$\'a0logInterval\'a0=\'a0NULL], [Ni$\'a0flushInterval\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Creates and returns a new 
\f3\fs18 LogFile
\f4\fs20  object that logs data from the simulation (see the documentation for the 
\f3\fs18 LogFile
\f4\fs20  class for details).  Logged data will be written to the file at 
\f3\fs18 filePath
\f4\fs20 , overwriting any existing file at that path by default, or appending to it instead if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f4\fs20  (successive rows of the log table will always be appended to the previously written content, of course).  Before the header line for the log is written out, any 
\f3\fs18 string
\f4\fs20  elements in 
\f3\fs18 initialContents
\f4\fs20  will be written first, separated by newlines, allowing for a user-defined file header.  If 
\f3\fs18 compress
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , the contents will be compressed with 
\f3\fs18 zlib
\f4\fs20  as they are written, and the standard 
\f3\fs18 .gz
\f4\fs20  extension for gzip-compressed files will be appended to the filename in 
\f3\fs18 filePath
\f4\fs20  if it is not already present.\
The 
\f3\fs18 sep
\f4\fs20  parameter specifies the separator between data values within a row.  The default of 
\f3\fs18 ","
\f4\fs20  will generate a \'93comma-separated value\'94 (CSV) file, while passing 
\f3\fs18 sep="\\t"
\f4\fs20  will use a tab separator instead to generate a \'93tab-separated value\'94 (TSV) file.  Other values for 
\f3\fs18 sep
\f4\fs20  may also be used, but are less standard.\
LogTable supports periodic automatic logging of a new row of data, enabled by supplying a non-
\f3\fs18 NULL
\f4\fs20  value for 
\f3\fs18 logInterval
\f4\fs20 .  In this case, a new row will be logged (as if 
\f3\fs18 logRow()
\f4\fs20  were called on the 
\f3\fs18 LogFile
\f4\fs20 ) at the end of every 
\f3\fs18 logInterval
\f4\fs20  ticks (just before the tick counter increments, in both WF and nonWF models), starting at the end of the tick in which the 
\f3\fs18 LogFile
\f4\fs20  was created.  A 
\f3\fs18 logInterval
\f4\fs20  of 
\f3\fs18 1
\f4\fs20  will cause automatic logging at the end of every tick, whereas a 
\f3\fs18 logInterval
\f4\fs20  of 
\f3\fs18 NULL
\f4\fs20  disables automatic logging.  Automatic logging can always be disabled or reconfigured later with the 
\f3\fs18 LogFile
\f4\fs20  method 
\f3\fs18 setLogInterval()
\f4\fs20 , or logging can be triggered manually by calling 
\f3\fs18 logRow()
\f4\fs20 .\
When compression is enabled, 
\f3\fs18 LogFile
\f4\fs20  flushes new data lazily by default, for performance reasons, buffering data for multiple rows before writing to disk.  Passing a non-
\f3\fs18 NULL
\f4\fs20  value for 
\f3\fs18 flushInterval
\f4\fs20  requests a flush every 
\f3\fs18 flushInterval
\f4\fs20  rows (with a value of 
\f3\fs18 1
\f4\fs20  providing unbuffered operation).  Note that flushing very frequently will likely result in both lower performance and a larger final file size (in one simple test, 
\f3\fs18 48943
\f4\fs20  bytes instead of 
\f3\fs18 4280
\f4\fs20  bytes, or more than a 10\'d7 increase in size).  Alternatively, passing a very large value for 
\f3\fs18 flushInterval
\f4\fs20  will effectively disable automatic flushing, except at the end of the simulation (but be aware that this may use a large amount of memory for large log files).  In any case, the log file will be created immediately, with its requested initial contents; the initial write is not buffered.  When compression is not enabled, the 
\f3\fs18 flushInterval
\f4\fs20  setting is ignored.\
The 
\f3\fs18 LogFile
\f4\fs20  documentation discusses how to configure and use 
\f3\fs18 LogFile
\f4\fs20  to write out the data you are interested in from your simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)deregisterScriptBlock(io<SLiMEidosBlock>\'a0scriptBlocks)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 All 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects specified by 
\f3\fs18 scriptBlocks
\f4\fs20  (either with 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects or with 
\f3\fs18 integer
\f4\fs20  identifiers) will be scheduled for deregistration.  The deregistered blocks remain valid, and may even still be executed in the current stage of the current tick; the blocks are not actually deregistered and deallocated until sometime after the currently executing script block has completed.  To immediately prevent a script block from executing, even when it is scheduled to execute in the current stage of the current tick, use the 
\f3\fs18 active
\f4\fs20  property of the script block.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<GenomicElementType>)genomicElementTypesWithIDs(integer\'a0ids)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Find and return the 
\f3\fs18 GenomicElementType
\f4\fs20  objects with 
\f3\fs18 id
\f4\fs20  values matching the values in 
\f3\fs18 ids
\f4\fs20 .  If no matching 
\f3\fs18 GenomicElementType
\f4\fs20  object can be found with a given 
\f3\fs18 id
\f4\fs20 , an error results.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<InteractionType>)interactionTypesWithIDs(integer\'a0ids)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Find and return the 
\f3\fs18 InteractionType
\f4\fs20  objects with 
\f3\fs18 id
\f4\fs20  values matching the values in 
\f3\fs18 ids
\f4\fs20 .  If no matching 
\f3\fs18 InteractionType
\f4\fs20  object can be found with a given 
\f3\fs18 id
\f4\fs20 , an error results.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<MutationType>)mutationTypesWithIDs(integer\'a0ids)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Find and return the 
\f3\fs18 MutationType
\f4\fs20  objects with 
\f3\fs18 id
\f4\fs20  values matching the values in 
\f3\fs18 ids
\f4\fs20 .  If no matching 
\f3\fs18 MutationType
\f4\fs20  object can be found with a given 
\f3\fs18 id
\f4\fs20 , an error results.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(void)outputUsage(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Output the current memory usage of the simulation to Eidos\'92s output stream.  The specifics of what is printed, and in what format, should not be relied upon as they may change from version to version of SLiM.  This method is primarily useful for understanding where the memory usage of a simulation predominantly resides, for debugging or optimization.  Note that it does not capture 
\f1\i all
\f4\i0  memory usage by the process; rather, it summarizes the memory usage by SLiM and Eidos in directly allocated objects and buffers.  To get the same memory usage reported by 
\f3\fs18 outputUsage()
\f4\fs20 , but as a 
\f3\fs18 float$
\f4\fs20  value, use the 
\f3\fs18 Community
\f4\fs20  method 
\f3\fs18 usage()
\f4\fs20 .  To get the 
\f1\i total
\f4\i0  memory usage of the running process (either current or peak), use the Eidos function 
\f3\fs18 usage()
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerEarlyEvent(Nis$\'a0id, string$\'a0source, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL]\cf2 , [No<Species>$\'a0ticksSpec\'a0=\'a0NULL]\cf0 )\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 early()
\f4\fs20  event in the current simulation, with optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks\cf2  (and, for multispecies models, optional ticks specifier 
\f3\fs18 ticksSpec
\f4\fs20 )\cf0  limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered event is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SLiMEidosBlock>$)registerFirstEvent(Nis$\'a0id, string$\'a0source, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL], [No<Species>$\'a0ticksSpec\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 first()
\f4\fs20  event in the current simulation, with optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks (and, for multispecies models, optional ticks specifier 
\f3\fs18 ticksSpec
\f4\fs20 ) limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered event is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerInteractionCallback(Nis$\'a0id, string$\'a0source, io<InteractionType>$\'a0intType, [Nio<Subpopulation>$\'a0subpop
\f5 \'a0
\f3 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 interaction()
\f4\fs20  callback in the current simulation\cf2  (global to the community)\cf0 , with a required interaction type 
\f3\fs18 intType
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  identifier), optional exerter subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may also be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations), and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it will be eligible to execute the next time an 
\f3\fs18 InteractionType
\f4\fs20  is evaluated.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerLateEvent(Nis$\'a0id, string$\'a0source, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL]\cf2 , [No<Species>$\'a0ticksSpec\'a0=\'a0NULL]\cf0 )\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 late()
\f4\fs20  event in the current simulation, with optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks\cf2  (and, for multispecies models, optional ticks specifier 
\f3\fs18 ticksSpec
\f4\fs20 )\cf0  limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered event is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>)rescheduleScriptBlock(io<SLiMEidosBlock>$
\f5 \'a0
\f3 block, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL], [Ni\'a0ticks\'a0=\'a0NULL])
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Reschedule the target script block given by 
\f3\fs18 block
\f4\fs20  to execute in a specified set of ticks.\cf2   The 
\f3\fs18 block
\f4\fs20  parameter may be either an 
\f3\fs18 integer
\f4\fs20  representing the ID of the desired script block, or a 
\f3\fs18 SLiMScriptBlock
\f4\fs20  specified directly.\cf0 \
The first way to specify the tick set is with 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  parameter values; 
\f3\fs18 block
\f4\fs20  will then execute from 
\f3\fs18 start
\f4\fs20  to 
\f3\fs18 end
\f4\fs20 , inclusive.  In this case, 
\f3\fs18 block
\f4\fs20  is returned.\
The second way to specify the tick set is using the 
\f3\fs18 ticks
\f4\fs20  parameter; this is more flexible but more complicated.  Since script blocks execute across a contiguous span of ticks defined by their 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  properties, this may result in the duplication of 
\f3\fs18 block
\f4\fs20 ; one script block will be used for each contiguous span of ticks in 
\f3\fs18 ticks
\f5\fs20 .
\f4   The 
\f3\fs18 block
\f4\fs20  object itself will be rescheduled to cover the first such span, whereas duplicates of 
\f3\fs18 block
\f4\fs20  will be created to cover subsequent contiguous spans.  A vector containing all of the script blocks scheduled by this method, including 
\f3\fs18 block
\f4\fs20 , will be returned; this vector is guaranteed to be sorted by the (ascending) scheduled execution order of the blocks.  Any duplicates of 
\f3\fs18 block
\f4\fs20  created will be given values for the 
\f3\fs18 active
\f4\fs20 , 
\f3\fs18 source
\f4\fs20 , 
\f3\fs18 tag
\f4\fs20 , and 
\f3\fs18 type
\f4\fs20  properties equal to the current values for 
\f3\fs18 block
\f4\fs20 , but will be given an 
\f3\fs18 id
\f4\fs20  of 
\f3\fs18 -1
\f4\fs20  since script block identifiers must be unique; if it is necessary to find the duplicated blocks again later, their 
\f3\fs18 tag
\f4\fs20  property should be used.  The vector supplied for 
\f3\fs18 ticks
\f4\fs20  does not need to be in sorted order, but it must not contain any duplicates.\
Because this method can create a large number of duplicate script blocks, it can sometimes be better to handle script block scheduling in other ways.  If an 
\f3\fs18 early()
\f4\fs20  event needs to execute every tenth tick over the whole duration of a long model run, for example, it would not be advisable to use a call like 
\f3\fs18 community.rescheduleScriptBlock(s1, ticks=seq(10, 100000, 10))
\f4\fs20  for that purpose, since that would result in thousands of duplicate script blocks.  Instead, it would be preferable to add a test such as 
\f3\fs18 if (community.tick % 10 != 0) return;
\f4\fs20  at the beginning of the event.  It is legal to reschedule a script block while the block is executing; a call like 
\f3\fs18 community.rescheduleScriptBlock(self, community.tick + 10, community.tick + 10);
\f4\fs20  made inside a given block would therefore also cause the block to execute every tenth tick, although this sort of self-rescheduling code is probably harder to read, maintain, and debug.\
Whichever way of specifying the tick set is used, 
\f3\fs18 block
\f4\fs20  may continue to be executed during the current tick cycle stage even after it has been rescheduled, unless it is made inactive using its 
\f3\fs18 active
\f4\fs20  property, and similarly, the block may not execute during the current tick cycle stage if it was not already scheduled to do so.  Rescheduling script blocks during the tick and tick cycle stage in which they are executing, or in which they are intended to execute, should be avoided.\cf2   Also, script blocks which are open-ended (i.e., with no specified end tick), are not used in determining whether the end of the simulation has been reached (because then the simulation would run forever); if you reschedule a block to be open-ended, and to start after the end of the last closed-ended block, the rescheduled block will therefore not run at all (just as such a block would not run at all in other circumstances, too).\cf0 \
Note that new script blocks can also be created and scheduled using the 
\f3\fs18 register...()
\f4\fs20  methods of 
\f3\fs18 Community
\f4\fs20  and 
\f3\fs18 Species
\f4\fs20 ; by using the same source as a template script block, the template can be duplicated and scheduled for different ticks.  In fact, 
\f3\fs18 rescheduleScriptBlock()
\f4\fs20  does essentially that internally.\cf2   In multispecies models, note that all new script blocks created as a side effect of 
\f3\fs18 rescheduleScriptBlock()
\f4\fs20  will have the same 
\f3\fs18 species
\f4\fs20  and 
\f3\fs18 ticks
\f4\fs20  specifier as 
\f3\fs18 block
\f4\fs20 ; use the 
\f3\fs18 register...()
\f4\fs20  methods to create a new block with a different 
\f3\fs18 species
\f4\fs20  or 
\f3\fs18 ticks
\f4\fs20  specifier.
\f5 \cf0 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SLiMEidosBlock>)scriptBlocksWithIDs(integer\'a0ids)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Find and return the 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects with 
\f3\fs18 id
\f4\fs20  values matching the values in 
\f3\fs18 ids
\f4\fs20 .  If no matching 
\f3\fs18 SLiMEidosBlock
\f4\fs20  object can be found with a given 
\f3\fs18 id
\f4\fs20 , an error results.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)simulationFinished(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Declare the current simulation finished.  Normally SLiM ends a simulation when, at the end of a tick, there are no script events or callbacks registered for any future tick (excluding scripts with no declared end tick).  If you wish to end a simulation before this condition is met, a call to 
\f3\fs18 simulationFinished()
\f4\fs20  will cause the current simulation to end at the end of the current tick.  For example, a simulation might self-terminate if a test for a dynamic equilibrium condition is satisfied.  Note that the current tick will finish executing; if you want the simulation to stop immediately, you can use the Eidos method 
\f3\fs18 stop()
\f4\fs20 , which raises an error condition.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Species>)speciesWithIDs(integer\'a0ids)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Find and return the 
\f3\fs18 Species
\f4\fs20  objects with 
\f3\fs18 id
\f4\fs20  values matching the values in 
\f3\fs18 ids
\f4\fs20 .  If no matching 
\f3\fs18 Species
\f4\fs20  object can be found with a given 
\f3\fs18 id
\f4\fs20 , an error results.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Subpopulation>)subpopulationsWithIDs(integer\'a0ids)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Find and return the 
\f3\fs18 Subpopulation
\f4\fs20  objects with 
\f3\fs18 id
\f4\fs20  values matching the values in 
\f3\fs18 ids
\f4\fs20 .  If no matching 
\f3\fs18 Subpopulation
\f4\fs20  object can be found with a given 
\f3\fs18 id
\f4\fs20 , an error results.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float$)usage(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Return the current memory usage of the simulation.  The specifics of what is totalled up should not be relied upon as it may change from version to version of SLiM.  This method is primarily useful for understanding where the memory usage of a simulation predominantly resides, for debugging or optimization.  Note that it does not capture 
\f1\i all
\f4\i0  memory usage by the process; rather, it summarizes the memory usage by SLiM and Eidos in directly allocated objects and buffers.  To see details of this internal memory usage, use the 
\f3\fs18 Community
\f4\fs20  method 
\f3\fs18 outputUsage()
\f4\fs20 .  To get the 
\f1\i total
\f4\i0  memory usage of the running process (either current or peak), use the Eidos function 
\f3\fs18 usage()
\f4\fs20 .\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.4  Class Genome\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.4.1  
\f2\fs18 Genome
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \expnd0\expndtw0\kerning0
genomePedigreeID => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 genomePedigreeID
\f4\fs20  is a unique non-negative identifier for each genome in a simulation, never re-used throughout the duration of the simulation run.  Furthermore, the 
\f3\fs18 genomePedigreeID
\f4\fs20  of a given genome will be equal to either 
\f3\fs18 (2*pedigreeID)
\f4\fs20  or 
\f3\fs18 (2*pedigreeID + 1)
\f4\fs20  of the individual that the genome belongs to (the former for the first genome of the individual, the latter for the second genome of the individual); this invariant relationship is guaranteed.  If pedigree tracking is not enabled, this property is unavailable.\expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 genomeType => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The type of chromosome represented by this genome; one of 
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "X"
\f4\fs20 , or 
\f3\fs18 "Y"
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
individual => (object<Individual>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The 
\f3\fs18 Individual
\f4\fs20  object to which this genome belongs.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 isNullGenome => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 T
\f4\fs20  if the genome is a \'93null\'94 genome, 
\f3\fs18 F
\f4\fs20  if it is an ordinary genome object.  When a sex chromosome (X or Y) is simulated, the other sex chromosome also exists in the simulation, but it is a \'93null\'94 genome that does not carry any mutations.  Instead, it is a placeholder, present to allow SLiM\'92s code to operate in much the same way as it does when an autosome is simulated.  Null genomes should not be accessed or manipulated.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutations => (object<Mutation>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 All of the 
\f3\fs18 Mutation
\f4\fs20  objects present in this genome.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  Note that the 
\f3\fs18 Genome
\f4\fs20  objects used by SLiM are new with every new individual, so the 
\f3\fs18 tag
\f4\fs20  value of each new offspring generated in each tick will be initially undefined.
\f5 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.4.2  
\f2\fs18 Genome
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 +\'a0(void)addMutations(object<Mutation>\'a0mutations)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Add the existing mutations in 
\f3\fs18 mutations
\f4\fs20  to the genome, if they are not already present (if they are already present, they will be ignored), and if the addition is not prevented by the mutation stacking policy (see the 
\f3\fs18 mutationStackPolicy
\f4\fs20  property of 
\f3\fs18 MutationType
\f4\fs20 ).\
Calling this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the 
\f3\fs18 age
\f4\fs20  of the individual is greater than 
\f3\fs18 0
\f4\fs20 ), to prevent the possibility of inconsistencies in the recorded tree sequence.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 +\'a0(object<Mutation>)addNewDrawnMutation(io<MutationType>\'a0mutationType, integer\'a0position, [Nio<Subpopulation>\'a0originSubpop\'a0=\'a0NULL]\cf2 \expnd0\expndtw0\kerning0
, [Nis\'a0nucleotide\'a0=\'a0NULL]\cf0 \kerning1\expnd0\expndtw0 )
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Add new mutations to the target genome(s) with the specified 
\f3\fs18 mutationType
\f4\fs20  (specified by the 
\f3\fs18 MutationType
\f4\fs20  object or by 
\f3\fs18 integer
\f4\fs20  identifier), 
\f3\fs18 position
\f4\fs20 , and 
\f3\fs18 originSubpop
\f4\fs20  (specified by the 
\f3\fs18 Subpopulation
\f4\fs20  object or by 
\f3\fs18 integer
\f4\fs20  identifier, or by 
\f3\fs18 NULL
\f4\fs20 , the default, to specify the subpopulation to which the first target genome belongs).  If 
\f3\fs18 originSubpop
\f4\fs20  is supplied as an 
\f3\fs18 integer
\f4\fs20 , it is intentionally not checked for validity; you may use arbitrary values of 
\f3\fs18 originSubpop
\f4\fs20  to \'93tag\'94 the mutations that you create.  The selection coefficients of the mutations are drawn from their mutation types; 
\f3\fs18 addNewMutation()
\f4\fs20  may be used instead if you wish to specify selection coefficients.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In non-nucleotide-based models, 
\f3\fs18 mutationType
\f4\fs20  will always be a non-nucleotide-based mutation type, and so 
\f3\fs18 nucleotide
\f4\fs20  must be 
\f3\fs18 NULL
\f4\fs20  (the default).  In a nucleotide-based model, 
\f3\fs18 mutationType
\f4\fs20  might still be non-nucleotide-based (in which case 
\f3\fs18 nucleotide
\f4\fs20  must still be 
\f3\fs18 NULL
\f4\fs20 ), or 
\f3\fs18 mutationType
\f4\fs20  might be nucleotide-based, in which case a non-
\f3\fs18 NULL
\f4\fs20  value must be supplied for 
\f3\fs18 nucleotide
\f4\fs20 , specifying the nucleotide(s) to be associated with the new mutation(s).  Nucleotides may be specified with string values (
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "C"
\f4\fs20 , 
\f3\fs18 "G"
\f4\fs20 , or 
\f3\fs18 "T"
\f4\fs20 ), or with integer values (A=
\f3\fs18 0
\f4\fs20 , C=
\f3\fs18 1
\f4\fs20 , G=
\f3\fs18 2
\f4\fs20 , T=
\f3\fs18 3
\f4\fs20 ).  If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.  No check is performed that a new mutation\'92s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 Beginning in SLiM 2.5 this method is vectorized, so all of these parameters may be singletons (in which case that single value is used for all mutations created by the call) or non-singleton vectors (in which case one element is used for each corresponding mutation created).  Non-singleton parameters must match in length, since their elements need to be matched up one-to-one.\
The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the 
\f3\fs18 mutationStackPolicy
\f4\fs20  property of 
\f3\fs18 MutationType
\f4\fs20 ).  However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the 
\f3\fs18 position
\f4\fs20  parameter is specified in ascending order.  In other words, pre-sorting the parameters to this method into ascending order by position, using 
\f3\fs18 order()
\f4\fs20  and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.\
Beginning in SLiM 2.1, this is a class method, not an instance method.  This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation objects to all of the elements of the receiver.  Before SLiM 2.1, to add the same mutations to multiple genomes, it was necessary to call 
\f3\fs18 addNewDrawnMutation()
\f4\fs20  on one of the genomes, and then add the returned 
\f3\fs18 Mutation
\f4\fs20  object to all of the other genomes using 
\f3\fs18 addMutations()
\f5\fs20 .
\f4   That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).  Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).\
\pard\pardeftab720\li547\ri720\sa60\partightenfactor0
\cf2 Before SLiM 4, this method also took a 
\f3\fs18 originGeneration
\f4\fs20  parameter.  This was deprecated (the origin generation was then required to be equal to the current generation, for internal consistency), and was removed in SLiM 4.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 Calling this will normally affect the fitness values calculated at the end of the current tick (but not sooner); if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the 
\f3\fs18 age
\f4\fs20  of the individual is greater than 
\f3\fs18 0
\f4\fs20 ), to prevent the possibility of inconsistencies in the recorded tree sequence.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 +\'a0(object<Mutation>)addNewMutation(io<MutationType>\'a0mutationType, numeric\'a0selectionCoeff, integer\'a0position, [Nio<Subpopulation>\'a0originSubpop\'a0=\'a0NULL]\cf2 \expnd0\expndtw0\kerning0
, [Nis\'a0nucleotide\'a0=\'a0NULL]\cf0 \kerning1\expnd0\expndtw0 )
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Add new mutations to the target genome(s) with the specified 
\f3\fs18 mutationType
\f4\fs20  (specified by the 
\f3\fs18 MutationType
\f4\fs20  object or by 
\f3\fs18 integer
\f4\fs20  identifier), 
\f3\fs18 selectionCoeff
\f4\fs20 , 
\f3\fs18 position
\f4\fs20 , and 
\f3\fs18 originSubpop
\f4\fs20  (specified by the 
\f3\fs18 Subpopulation
\f4\fs20  object or by 
\f3\fs18 integer
\f4\fs20  identifier, or by 
\f3\fs18 NULL
\f4\fs20 , the default, to specify the subpopulation to which the first target genome belongs).  If 
\f3\fs18 originSubpop
\f4\fs20  is supplied as an 
\f3\fs18 integer
\f4\fs20 , it is intentionally not checked for validity; you may use arbitrary values of 
\f3\fs18 originSubpop
\f4\fs20  to \'93tag\'94 the mutations that you create.  The 
\f3\fs18 addNewDrawnMutation()
\f4\fs20  method may be used instead if you wish selection coefficients to be drawn from the mutation types of the mutations.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In non-nucleotide-based models, 
\f3\fs18 mutationType
\f4\fs20  will always be a non-nucleotide-based mutation type, and so 
\f3\fs18 nucleotide
\f4\fs20  must be 
\f3\fs18 NULL
\f4\fs20  (the default).  In a nucleotide-based model, 
\f3\fs18 mutationType
\f4\fs20  might still be non-nucleotide-based (in which case 
\f3\fs18 nucleotide
\f4\fs20  must still be 
\f3\fs18 NULL
\f4\fs20 ), or 
\f3\fs18 mutationType
\f4\fs20  might be nucleotide-based, in which case a non-
\f3\fs18 NULL
\f4\fs20  value must be supplied for 
\f3\fs18 nucleotide
\f4\fs20 , specifying the nucleotide(s) to be associated with the new mutation(s).  Nucleotides may be specified with string values (
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "C"
\f4\fs20 , 
\f3\fs18 "G"
\f4\fs20 , or 
\f3\fs18 "T"
\f4\fs20 ), or with integer values (A=
\f3\fs18 0
\f4\fs20 , C=
\f3\fs18 1
\f4\fs20 , G=
\f3\fs18 2
\f4\fs20 , T=
\f3\fs18 3
\f4\fs20 ).  If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.  No check is performed that a new mutation\'92s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the 
\f3\fs18 mutationStackPolicy
\f4\fs20  property of 
\f3\fs18 MutationType
\f4\fs20 ).  However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the 
\f3\fs18 position
\f4\fs20  parameter is specified in ascending order.  In other words, pre-sorting the parameters to this method into ascending order by position, using 
\f3\fs18 order()
\f4\fs20  and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.\
Beginning in SLiM 2.1, this is a class method, not an instance method.  This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation object to all of the elements of the receiver.  Before SLiM 2.1, to add the same mutation to multiple genomes, it was necessary to call 
\f3\fs18 addNewMutation()
\f4\fs20  on one of the genomes, and then add the returned 
\f3\fs18 Mutation
\f4\fs20  object to all of the other genomes using 
\f3\fs18 addMutations()
\f5\fs20 .
\f4   That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).  Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).\
\pard\pardeftab720\li547\ri720\sa60\partightenfactor0
\cf2 Before SLiM 4, this method also took a 
\f3\fs18 originGeneration
\f4\fs20  parameter.  This was deprecated (the origin generation was then required to be equal to the current generation, for internal consistency), and was removed in SLiM 4.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 Calling this will normally affect the fitness values calculated at the end of the current tick (but not sooner); if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the 
\f3\fs18 age
\f4\fs20  of the individual is greater than 
\f3\fs18 0
\f4\fs20 ), to prevent the possibility of inconsistencies in the recorded tree sequence.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (\cf2 \expnd0\expndtw0\kerning0
Nlo<Mutation>$\cf0 \kerning1\expnd0\expndtw0 )containsMarkerMutation(io<MutationType>$\'a0mutType, integer$
\f5 \'a0
\f3 position\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0returnMutation\'a0=\'a0F]\cf0 \kerning1\expnd0\expndtw0 )
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns 
\f3\fs18 T
\f4\fs20  if the genome contains a mutation of type 
\f3\fs18 mutType
\f4\fs20  at 
\f3\fs18 position
\f4\fs20 , 
\f3\fs18 F
\f4\fs20  otherwise\cf2 \expnd0\expndtw0\kerning0
 (if 
\f3\fs18 returnMutation
\f4\fs20  has its default value of 
\f3\fs18 F
\f4\fs20 ; see below)\cf0 \kerning1\expnd0\expndtw0 .  This method is, as its name suggests, intended for checking for \'93marker mutations\'94: mutations of a special mutation type that are not literally mutations in the usual sense, but instead are added in to particular genomes to mark them as possessing some property.  Marker mutations are not typically added by SLiM\'92s mutation-generating machinery; instead they are added explicitly with 
\f3\fs18 addNewMutation()
\f4\fs20  or 
\f3\fs18 addNewDrawnMutation()
\f4\fs20  at a known, constant position in the genome.  This method provides a check for whether a marker mutation of a given type exists in a particular genome; because the position to check is known in advance, that check can be done much faster than the equivalent check with 
\f3\fs18 containsMutations()
\f4\fs20  or 
\f3\fs18 countOfMutationsOfType()
\f4\fs20 , using a binary search of the genome.
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 \expnd0\expndtw0\kerning0
If 
\f3\fs18 returnMutation
\f4\fs20  is 
\f3\fs18 T
\f4\fs20  (an option added in SLiM 3), this method returns the actual mutation found, rather than just 
\f3\fs18 T
\f4\fs20  or 
\f3\fs18 F
\f4\fs20 .  More specifically, the 
\f1\i first
\f4\i0  mutation found of 
\f3\fs18 mutType
\f4\fs20  at 
\f3\fs18 position
\f4\fs20  will be returned; if more than one such mutation exists in the target genome, which one is returned is not defined.  If 
\f3\fs18 returnMutation
\f4\fs20  is T and no mutation of 
\f3\fs18 mutType
\f4\fs20  is found at 
\f3\fs18 position
\f4\fs20 , 
\f3\fs18 NULL
\f4\fs20  will be returned.\
\pard\pardeftab529\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(logical)containsMutations(object<Mutation>\'a0mutations)
\f5 \
\pard\pardeftab529\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns a 
\f3\fs18 logical
\f4\fs20  vector indicating whether each of the mutations in 
\f3\fs18 mutations
\f4\fs20  is present in the genome; each element in the returned vector indicates whether the corresponding mutation is present (
\f3\fs18 T
\f4\fs20 ) or absent (
\f3\fs18 F
\f4\fs20 ).  This method is provided for speed; it is much faster than the corresponding Eidos code.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (integer$)countOfMutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns the number of mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations in the genome.  If you need a vector of the matching 
\f3\fs18 Mutation
\f4\fs20  objects, rather than just a count, use 
\f3\fs18 -mutationsOfType()
\f5\fs20 .
\f4   This method is provided for speed; it is much faster than the corresponding Eidos code.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(integer)mutationCountsInGenomes([No<Mutation>\'a0mutations\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Return an 
\f3\fs18 integer
\f4\fs20  vector with the frequency counts of all of the 
\f3\fs18 Mutation
\f4\fs20  objects passed in 
\f3\fs18 mutations
\f4\fs20 , within the target 
\f3\fs18 Genome
\f4\fs20  vector.  If the optional 
\f3\fs18 mutations
\f4\fs20  argument is 
\f3\fs18 NULL
\f4\fs20  (the default), frequency counts will be returned for all of the active 
\f3\fs18 Mutation
\f4\fs20  objects in the simulation \'96 the same 
\f3\fs18 Mutation
\f4\fs20  objects, and in the same order, as would be returned by the 
\f3\fs18 mutations
\f4\fs20  property of 
\f3\fs18 sim
\f4\fs20 , in other words.\
See the 
\f3\fs18 +mutationFrequenciesInGenomes()
\f4\fs20  method to obtain 
\f3\fs18 float
\f4\fs20  frequencies instead of 
\f3\fs18 integer
\f4\fs20  counts.  See also the 
\f3\fs18 Species
\f4\fs20  methods 
\f3\fs18 mutationCounts()
\f4\fs20  and 
\f3\fs18 mutationFrequencies()
\f4\fs20 , which may be more efficient for getting counts/frequencies for whole subpopulations or for the whole simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(float)mutationFrequenciesInGenomes([No<Mutation>\'a0mutations\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Return a 
\f3\fs18 float
\f4\fs20  vector with the frequencies of all of the 
\f3\fs18 Mutation
\f4\fs20  objects passed in 
\f3\fs18 mutations
\f4\fs20 , within the target 
\f3\fs18 Genome
\f4\fs20  vector.  If the optional 
\f3\fs18 mutations
\f4\fs20  argument is 
\f3\fs18 NULL
\f4\fs20  (the default), frequencies will be returned for all of the active 
\f3\fs18 Mutation
\f4\fs20  objects in the simulation \'96 the same 
\f3\fs18 Mutation
\f4\fs20  objects, and in the same order, as would be returned by the 
\f3\fs18 mutations
\f4\fs20  property of 
\f3\fs18 sim
\f4\fs20 , in other words.\
See the 
\f3\fs18 +mutationCountsInGenomes()
\f4\fs20  method to obtain 
\f3\fs18 integer
\f4\fs20  counts instead of 
\f3\fs18 float
\f4\fs20  frequencies.  See also the 
\f3\fs18 Species
\f4\fs20  methods 
\f3\fs18 mutationCounts()
\f4\fs20  and 
\f3\fs18 mutationFrequencies()
\f4\fs20 , which may be more efficient for getting counts/frequencies for whole subpopulations or for the whole simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (object<Mutation>)mutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns an 
\f3\fs18 object
\f4\fs20  vector of all the mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations in the genome.  If you just need a count of the matching 
\f3\fs18 Mutation
\f4\fs20  objects, rather than a vector of the matches, use 
\f3\fs18 -countOfMutationsOfType()
\f4\fs20 ; if you need just the positions of matching 
\f3\fs18 Mutation
\f4\fs20  objects, use 
\f3\fs18 -positionsOfMutationsOfType()
\f4\fs20 ; and if you are aiming for a sum of the selection coefficients of matching 
\f3\fs18 Mutation
\f4\fs20  objects, use 
\f3\fs18 -sumOfMutationsOfType()
\f5\fs20 .
\f4   This method is provided for speed; it is much faster than the corresponding Eidos code.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(is)nucleotides([Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL], [string$\'a0format\'a0=\'a0"string"])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the nucleotide sequence for the genome.  This is the current ancestral sequence, as would be returned by the 
\f3\fs18 Chromosome
\f4\fs20  method 
\f3\fs18 ancestralNucleotides()
\f4\fs20 , with the nucleotides for any nucleotide-based mutations in the genome overlaid.  The range of the returned sequence may be constrained by a start position given in 
\f3\fs18 start
\f4\fs20  and/or an end position given in 
\f3\fs18 end
\f4\fs20 ; nucleotides will be returned from 
\f3\fs18 start
\f4\fs20  to 
\f3\fs18 end
\f4\fs20 , inclusive.  The default value of 
\f3\fs18 NULL
\f4\fs20  for 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  represent the first and last base positions of the chromosome, respectively.\
The format of the returned sequence is controlled by the 
\f3\fs18 format
\f4\fs20  parameter.  A format of 
\f3\fs18 "string"
\f4\fs20  will return the sequence as a singleton 
\f3\fs18 string
\f4\fs20  (e.g., 
\f3\fs18 "TATA"
\f4\fs20 ).  A format of 
\f3\fs18 "char"
\f4\fs20  will return a 
\f3\fs18 string
\f4\fs20  vector with one element per nucleotide (e.g., 
\f3\fs18 "T"
\f4\fs20 , 
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "T"
\f4\fs20 , 
\f3\fs18 "A"
\f4\fs20 ).  A format of 
\f3\fs18 "integer"
\f4\fs20  will return an 
\f3\fs18 integer
\f4\fs20  vector with values A=
\f3\fs18 0
\f4\fs20 , C=
\f3\fs18 1
\f4\fs20 , G=
\f3\fs18 2
\f4\fs20 , T=
\f3\fs18 3
\f4\fs20  (e.g., 
\f3\fs18 3
\f4\fs20 , 
\f3\fs18 0
\f4\fs20 , 
\f3\fs18 3
\f4\fs20 , 
\f3\fs18 0
\f4\fs20 ).  A format of 
\f3\fs18 "codon"
\f4\fs20  will return an 
\f3\fs18 integer
\f4\fs20  vector with values from 
\f3\fs18 0
\f4\fs20  to 
\f3\fs18 63
\f4\fs20 , based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three); see the 
\f3\fs18 ancestralNucleotides()
\f4\fs20  documentation for details.  If the sequence returned is likely to be long, the 
\f3\fs18 "string"
\f4\fs20  format will be the most memory-efficient, and may also be the fastest (but may be harder to work with).\
Several helper functions are provided for working with sequences, such as 
\f3\fs18 nucleotideCounts()
\f4\fs20  to get the counts of A/C/G/T nucleotides in a sequence, 
\f3\fs18 nucleotideFrequencies()
\f4\fs20  to get the same information as frequencies, and 
\f3\fs18 codonsToAminoAcids()
\f4\fs20  to convert a codon sequence (such as provided by the codon format described above) to an amino acid sequence.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 +\'a0(void)output([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output the target genomes in SLiM\'92s native format.  This low-level output method may be used to output any sample of 
\f3\fs18 Genome
\f4\fs20  objects (the Eidos function 
\f3\fs18 sample()
\f4\fs20  may be useful for constructing custom samples, as may the SLiM class 
\f3\fs18 Individual
\f4\fs20 ).  For output of a sample from a single 
\f3\fs18 Subpopulation
\f4\fs20 , the 
\f3\fs18 outputSample()
\f4\fs20  of 
\f3\fs18 Subpopulation
\f4\fs20  may be more straightforward to use.  If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output is directed to SLiM\'92s standard output.  Otherwise, the output is sent to the file specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .\

\f4 See 
\f3\fs18 outputMS()
\f4\fs20  and 
\f3\fs18 outputVCF()
\f4\fs20  for other output formats.  Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 +\'a0(void)outputMS([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F]\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0filterMonomorphic\'a0=\'a0F]\cf0 \kerning1\expnd0\expndtw0 )
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output the target genomes in MS format.  This low-level output method may be used to output any sample of 
\f3\fs18 Genome
\f4\fs20  objects (the Eidos function 
\f3\fs18 sample()
\f4\fs20  may be useful for constructing custom samples, as may the SLiM class 
\f3\fs18 Individual
\f4\fs20 ).  For output of a sample from a single 
\f3\fs18 Subpopulation
\f4\fs20 , the 
\f3\fs18 outputMSSample()
\f4\fs20  of 
\f3\fs18 Subpopulation
\f4\fs20  may be more straightforward to use.  If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output is directed to SLiM\'92s standard output.  Otherwise, the output is sent to the file specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .
\f4   Positions in the output will span the interval [0,1].\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
If 
\f3\fs18 filterMonomorphic
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), all mutations that are present in the sample will be included in the output.  This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in 
\f1\i every
\f4\i0  sampled genome, and are thus apparently fixed).  These may be filtered out with 
\f3\fs18 filterMonomorphic = T
\f4\fs20  if desired; note that this option means that some mutations that do exist in the sampled genomes might not be included in the output, simply because they exist in every sampled genome.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 See 
\f3\fs18 output()
\f4\fs20  and 
\f3\fs18 outputVCF()
\f4\fs20  for other output formats.  Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 +\'a0(void)outputVCF([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0outputMultiallelics\'a0=\'a0T], [logical$\'a0append\'a0=\'a0F]\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0simplifyNucleotides\'a0=\'a0F], [logical$\'a0outputNonnucleotides\'a0=\'a0T]\cf0 \kerning1\expnd0\expndtw0 )
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output the target genomes in VCF format.  The target genomes are treated as pairs comprising individuals for purposes of structuring the VCF output, so an even number of genomes is required.  This low-level output method may be used to output any sample of 
\f3\fs18 Genome
\f4\fs20  objects (the Eidos function 
\f3\fs18 sample()
\f4\fs20  may be useful for constructing custom samples, as may the SLiM class 
\f3\fs18 Individual
\f4\fs20 ).  For output of a sample from a single 
\f3\fs18 Subpopulation
\f4\fs20 , the 
\f3\fs18 outputVCFSample()
\f4\fs20  of 
\f3\fs18 Subpopulation
\f4\fs20  may be more straightforward to use.  If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output is directed to SLiM\'92s standard output.  Otherwise, the output is sent to the file specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 \expnd0\expndtw0\kerning0
The parameters 
\f3\fs18 outputMultiallelics
\f4\fs20 , 
\f3\fs18 simplifyNucleotides
\f4\fs20 , and 
\f3\fs18 outputNonnucleotides
\f4\fs20  affect the format of the output produced; see the reference documentation for further discussion.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 See 
\f3\fs18 outputMS()
\f4\fs20  and 
\f3\fs18 output()
\f4\fs20  for other output formats.  Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(integer)positionsOfMutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns the positions of mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations in the genome.  If you need a vector of the matching 
\f3\fs18 Mutation
\f4\fs20  objects, rather than just positions, use 
\f3\fs18 -mutationsOfType()
\f4\fs20 .  This method is provided for speed; it is much faster than the corresponding Eidos code.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
+\'a0(\cf0 \kerning1\expnd0\expndtw0 object\cf2 \expnd0\expndtw0\kerning0
<Mutation>)readFromMS(string$\'a0filePath, io<MutationType>$\'a0mutationType)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Read new mutations from the MS format file at 
\f3\fs18 filePath
\f4\fs20  and add them to the target genomes.  The number of target genomes must match the number of genomes represented in the MS file.  To read into all of the genomes in a given subpopulation 
\f3\fs18 pN
\f4\fs20 , simply call 
\f3\fs18 pN.genomes.readFromMS()
\f4\fs20 , assuming the subpopulation\'92s size matches that of the MS file.  A vector containing all of the mutations created by 
\f3\fs18 readFromMS()
\f4\fs20  is returned.\
Each mutation is created at the position specified in the file, using the mutation type given by 
\f3\fs18 mutationType
\f4\fs20 .  Positions are expected to be in [0,1], and are scaled to the length of the chromosome by multiplying by the last valid base position of the chromosome (i.e., one less than the chromosome length).  Selection coefficients are drawn from the mutation type.  The population of origin for each mutation is set to 
\f3\fs18 -1
\f4\fs20 , and the tick of origin is set to the current tick.  In a nucleotide-based model, if 
\f3\fs18 mutationType
\f4\fs20  is nucleotide-based, a random nucleotide different from the ancestral nucleotide at the position will be chosen with equal probability.\
The target genomes correspond, in order, to the call lines in the MS file.  In sex-based models that simulate the X or Y chromosome, null genomes in the target vector will be skipped, and will not be used to correspond to any call line; however, care should be taken in this case that the lines in the MS file correspond to the target genomes in the manner desired.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(\cf0 \kerning1\expnd0\expndtw0 object\cf2 \expnd0\expndtw0\kerning0
<Mutation>)readFromVCF(string$\'a0filePath, [Nio<MutationType>$\'a0mutationType\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Read new mutations from the VCF format file at 
\f3\fs18 filePath
\f4\fs20  and add them to the target genomes.  The number of target genomes must match the number of genomes represented in the VCF file (i.e., two times the number of samples, if each sample is diploid).  To read into all of the genomes in a given subpopulation 
\f3\fs18 pN
\f4\fs20 , simply call 
\f3\fs18 pN.genomes.readFromVCF()
\f4\fs20 , assuming the subpopulation\'92s size matches that of the VCF file taking ploidy into account.  A vector containing all of the mutations created by 
\f3\fs18 readFromVCF()
\f4\fs20  is returned.\
SLiM\'92s VCF parsing is quite primitive.  The header is parsed only inasmuch as SLiM looks to see whether SLiM-specific VCF fields are defined or not; the rest of the header information is ignored.  Call lines are assumed to follow the format:\

\f3\fs18 #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT i0...iN\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 The 
\f3\fs18 CHROM
\f4\fs20 , 
\f3\fs18 ID
\f4\fs20 , 
\f3\fs18 QUAL
\f4\fs20 , 
\f3\fs18 FILTER
\f4\fs20 , and 
\f3\fs18 FORMAT
\f4\fs20  fields are ignored, and information in the genotype fields beyond the 
\f3\fs18 GT
\f4\fs20  genotype subfield are also ignored.  SLiM\'92s own VCF annotations are honored; in particular, mutations will be created using the given values of 
\f3\fs18 MID
\f4\fs20 , 
\f3\fs18 S
\f4\fs20 , 
\f3\fs18 PO
\f4\fs20 , 
\f3\fs18 TO
\f4\fs20 , and 
\f3\fs18 MT
\f4\fs20  if those subfields are present, and 
\f3\fs18 DOM
\f4\fs20 , if it is present, must match the dominance coefficient of the mutation type.  The parameter 
\f3\fs18 mutationType
\f4\fs20  (a 
\f3\fs18 MutationType
\f4\fs20  object or id) will be used for any mutations that have no supplied mutation type id in the 
\f3\fs18 MT
\f4\fs20  subfield; if 
\f3\fs18 mutationType
\f4\fs20  would be used but is 
\f3\fs18 NULL
\f4\fs20  an error will result.  Mutation IDs supplied in 
\f3\fs18 MID
\f4\fs20  will be used if no mutation IDs have been used in the simulation so far; if any have been used, it is difficult for SLiM to guarantee that there are no conflicts, so a warning will be emitted and the 
\f3\fs18 MID
\f4\fs20  values will be ignored.  If selection coefficients are not supplied with the 
\f3\fs18 S
\f4\fs20  subfield, they will be drawn from the mutation type used for the mutation.  If a population of origin is not supplied with the 
\f3\fs18 PO
\f4\fs20  subfield, 
\f3\fs18 -1
\f4\fs20  will be used.  If a tick of origin is not supplied with the 
\f3\fs18 TO
\f4\fs20  subfield (or a generation of origin 
\f3\fs18 GO
\f4\fs20  field, which was the SLiM convention before SLiM 4), the current tick will be used.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
REF
\f4\fs20  and 
\f3\fs18 ALT
\f4\fs20  must always be comprised of simple nucleotides (
\f3\fs18 A
\f4\fs20 /
\f3\fs18 C
\f4\fs20 /
\f3\fs18 G
\f4\fs20 /
\f3\fs18 T
\f4\fs20 ) rather than values representing indels or other complex states.  Beyond this, the handling of the 
\f3\fs18 REF
\f4\fs20  and 
\f3\fs18 ALT
\f4\fs20  fields depends upon several factors.  First of all, these fields are ignored in non-nucleotide-based models, although they are still checked for conformance.  In nucleotide-based models, when a header definition for SLiM\'92s 
\f3\fs18 NONNUC
\f4\fs20  tag is present (as when nucleotide-based output is generated by SLiM): Second, if a 
\f3\fs18 NONNUC
\f4\fs20  field is present in the 
\f3\fs18 INFO
\f4\fs20  field the call line is taken to represent a non-nucleotide-based mutation, and 
\f3\fs18 REF
\f4\fs20  and 
\f3\fs18 ALT
\f4\fs20  are again ignored.  In this case the mutation type used must be non-nucleotide-based.  Third, if 
\f3\fs18 NONNUC
\f4\fs20  is 
\f1\i not
\f4\i0  present the call line is taken to represent a nucleotide-based mutation.  In this case, the mutation type used must be nucleotide-based.  Also, in this case, the specified reference nucleotide must match the existing ancestral nucleotide at the given position.  In nucleotide-based models, when a header definition for SLiM\'92s 
\f3\fs18 NONNUC
\f4\fs20  tag is not present (as when loading a non-SLiM-generated VCF file): The mutation type will govern the way nucleotides are handled.  If the mutation type used for a mutation is nucleotide-based, the nucleotide provided in the VCF file for that allele will be used.  If the mutation type is non-nucleotide-based, the nucleotide provided will be ignored.\
If multiple alleles using the same nucleotide at the same position are specified in the VCF file, a separate mutation will be created for each, mirroring SLiM\'92s behavior with independent mutational lineages when writing VCF.  The 
\f3\fs18 MULTIALLELIC
\f4\fs20  flag is ignored by 
\f3\fs18 readFromVCF()
\f4\fs20 ; call lines for mutations at the same base position in the same genome will result in stacked mutations whether or not 
\f3\fs18 MULTIALLELIC
\f4\fs20  is present.\
The target genomes correspond, in order, to the haploid or diploid calls provided for 
\f3\fs18 i0
\f4\fs20 \'85
\f3\fs18 iN
\f4\fs20  (the sample IDs) in the VCF file.  In sex-based models that simulate the X or Y chromosome, null genomes in the target vector will be skipped, and will not be used to correspond to any of 
\f3\fs18 i0
\f4\fs20 \'85
\f3\fs18 iN
\f4\fs20 ; however, care should be taken in this case that the genomes in the VCF file correspond to the target genomes in the manner desired.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 +\'a0(void)removeMutations([No<Mutation>\'a0mutations\'a0=\'a0NULL], [logical$\'a0substitute\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Remove the mutations in 
\f3\fs18 mutations
\f4\fs20  from the target genome(s), if they are present (if they are not present, they will be ignored).  If 
\f3\fs18 NULL
\f4\fs20  is passed for 
\f3\fs18 mutations
\f4\fs20  (which is the default), then all mutations will be removed from the target genomes; in this case, 
\f3\fs18 substitute
\f4\fs20  must be 
\f3\fs18 F
\f4\fs20  (a specific vector of mutations to be substituted is required).  Note that the 
\f3\fs18 Mutation
\f4\fs20  objects removed remain valid, and will still be in the simulation\'92s mutation registry (i.e., will be returned by the 
\f3\fs18 Species
\f4\fs20  property 
\f3\fs18 mutations
\f4\fs20 ), until the next tick.\
Removing mutations will normally affect the fitness values calculated at the end of the current tick; if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
The optional parameter 
\f3\fs18 substitute
\f4\fs20  was added in SLiM 2.2, with a default of 
\f3\fs18 F
\f4\fs20  for backward compatibility.  If 
\f3\fs18 substitute
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , 
\f3\fs18 Substitution
\f4\fs20  objects will be created for all of the removed mutations so that they are recorded in the simulation as having fixed, just as if they had reached fixation and been removed by SLiM\'92s own internal machinery.  This will occur regardless of whether the mutations have in fact fixed, regardless of the 
\f3\fs18 convertToSubstitution
\f4\fs20  property of the relevant mutation types, and regardless of whether all copies of the mutations have even been removed from the simulation (making it possible to create 
\f3\fs18 Substitution
\f4\fs20  objects for mutations that are still segregating).  It is up to the caller to perform whatever checks are necessary to preserve the integrity of the simulation\'92s records.  Typically 
\f3\fs18 substitute
\f4\fs20  will only be set to 
\f3\fs18 T
\f4\fs20  in the context of calls like 
\f3\fs18 sim.subpopulations.genomes.removeMutations(muts, T)
\f4\fs20 , such that the substituted mutations are guaranteed to be entirely removed from circulation.  As mentioned above, 
\f3\fs18 substitute
\f4\fs20  may not be 
\f3\fs18 T
\f4\fs20  if 
\f3\fs18 mutations
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96
\f5 \'a0
\f3 (float$)sumOfMutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns the sum of the selection coefficients of all mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations in the genome.  This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, 
\f3\fs18 sumOfMutationsOfType()
\f4\fs20  will provide the sum of the additive effects of the QTLs for the given mutation type.  This method is provided for speed; it is much faster than the corresponding Eidos code.  Note that this method also exists on 
\f3\fs18 Individual
\f4\fs20 , for cases in which the sum across both genomes of an individual is desired.
\f5 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.5  Class GenomicElement\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.5.1  
\f2\fs18 GenomicElement
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 endPosition => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The last position in the chromosome contained by this genomic element.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 genomicElementType => (object<GenomicElementType>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 GenomicElementType
\f4\fs20  object that defines the behavior of this genomic element.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 startPosition => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The first position in the chromosome contained by this genomic element.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.
\f5 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.5.2  
\f2\fs18 GenomicElement
\f1\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 \'96\'a0(void)setGenomicElementType(io<GenomicElementType>$\'a0genomicElementType)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the genomic element type used for a genomic element.  The genomicElementType parameter should supply the new genomic element type for the element, either as a 
\f3\fs18 GenomicElementType
\f4\fs20  object or as an 
\f3\fs18 integer
\f4\fs20  identifier.  The genomic element type for a genomic element is normally a constant in simulations, so be sure you know what you are doing.
\f5 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.6  Class GenomicElementType\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.6.1  
\f2\fs18 GenomicElementType
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 color <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The color used to display genomic elements of this type in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f3\fs18 "#RRGGBB"
\f4\fs20 .  If 
\f3\fs18 color
\f4\fs20  is the empty string, 
\f3\fs18 ""
\f4\fs20 , SLiMgui\'92s default color scheme is used; this is the default for new 
\f3\fs18 GenomicElementType
\f4\fs20  objects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier for this genomic element type; for genomic element type 
\f3\fs18 g3
\f4\fs20 , for example, this is 
\f3\fs18 3
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutationFractions => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 For each 
\f3\fs18 MutationType
\f4\fs20  represented in this genomic element type, this property has the corresponding fraction of all mutations that will be drawn from that 
\f3\fs18 MutationType
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
mutationMatrix => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The nucleotide mutation matrix used for this genomic element type, set up by 
\f3\fs18 initializeGenomicElementType()
\f4\fs20  and 
\f3\fs18 setMutationMatrix()
\f4\fs20 .  This property is only defined in nucleotide-based models; it is unavailable otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationTypes => (object<MutationType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 MutationType
\f4\fs20  instances used by this genomic element type.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 species => (object<Species>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The species to which the target object belongs.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to genomic element types.
\f5 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.6.2  
\f2\fs18 GenomicElementType
\f1\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 \'96\'a0(void)setMutationFractions(io<MutationType>\'a0mutationTypes, numeric\'a0proportions)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the mutation type fractions contributing to a genomic element type.  The 
\f3\fs18 mutationTypes
\f4\fs20  vector should supply the mutation types used by the genomic element (either as 
\f3\fs18 MutationType
\f4\fs20  objects or as 
\f3\fs18 integer
\f4\fs20  identifiers), and the 
\f3\fs18 proportions
\f4\fs20  vector should be of equal length, specifying the relative proportion of mutations that will be drawn from each corresponding type.  This is normally a constant in simulations, so be sure you know what you are doing.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(void)setMutationMatrix(float\'a0mutationMatrix)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Sets a new nucleotide mutation matrix for the genomic element type.  This replaces the mutation matrix originally set by 
\f3\fs18 initializeGenomicElementType()
\f4\fs20 .  This method may only be called in nucleotide-based models.\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 \kerning1\expnd0\expndtw0 5.7  Class Individual\
\pard\pardeftab397\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.7.1  
\f2\fs18 Individual
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 age \cf2 \expnd0\expndtw0\kerning0
<\'96>\cf0 \kerning1\expnd0\expndtw0  (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The age of the individual, measured in cycles.  A newly generated offspring individual will have an age of 
\f3\fs18 0
\f4\fs20  in the same tick in which it was created.  The age of every individual is incremented by one at the same point that its species cycle counter is incremented, at the end of the tick cycle, 
\f1\i if and only if
\f4\i0  its species was active in that tick.  The age of individuals may be changed; usually this only makes sense when setting up the initial state of a model, however.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 color <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The color used to display the individual in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f3\fs18 "#RRGGBB"
\f4\fs20  (see the Eidos manual).  If 
\f3\fs18 color
\f4\fs20  is the empty string, 
\f3\fs18 ""
\f4\fs20 , SLiMgui\'92s default (fitness-based) color scheme is used; this is the default for new 
\f3\fs18 Individual
\f4\fs20  objects.  Note that named colors will be converted to RGB internally, so the value of this property will always be a hexadecimal RGB color string (or 
\f3\fs18 ""
\f4\fs20 ).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
fitnessScaling <\'96> (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A 
\f3\fs18 float
\f4\fs20  scaling factor applied to the individual\'92s fitness (i.e., the fitness value computed for the individual will be multiplied by this value).  This provides a simple, fast way to modify the fitness of an individual; conceptually it is similar to returning a fitness effect for the individual from a 
\f3\fs18 fitnessEffect()
\f4\fs20  callback, but without the complexity and performance overhead of implementing such a callback.  To scale the fitness of all individuals in a subpopulation by the same factor, see the 
\f3\fs18 fitnessScaling
\f4\fs20  property of 
\f3\fs18 Subpopulation
\f4\fs20 .\
The value of 
\f3\fs18 fitnessScaling
\f4\fs20  is reset to 
\f3\fs18 1.0
\f4\fs20  every tick, so that any scaling factor set lasts for only a single tick.  This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 genomes => (object<Genome>)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The pair of 
\f3\fs18 Genome
\f4\fs20  objects associated with this individual.\cf2 \expnd0\expndtw0\kerning0
  If only one of the two genomes is desired, the 
\f3\fs18 genome1
\f4\fs20  or 
\f3\fs18 genome2
\f4\fs20  property may be used.
\f5 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 genomesNonNull => (object<Genome>)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The pair of 
\f3\fs18 Genome
\f4\fs20  objects associated with this individual, as with the 
\f3\fs18 genomes
\f4\fs20  property, if both are not null genomes.  If one or both 
\f1\i are
\f4\i0  null genomes, the null genomes are excluded from the returned vector.  This is a convenience shorthand, sometimes useful in models that involve null genomes.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
genome1 => (object<Genome>$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The first 
\f3\fs18 Genome
\f4\fs20  object associated with this individual.  This property is particularly useful when you want the first genome from each of a vector of individuals, as often arises in haploid models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 genome2 => (object<Genome>$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The second 
\f3\fs18 Genome
\f4\fs20  object associated with this individual.  This property is particularly useful when you want the second genome from each of a vector of individuals, as often arises in haploid models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 index => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The index of the individual in the 
\f3\fs18 individuals
\f4\fs20  vector of its 
\f3\fs18 Subpopulation
\f5\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 meanParentAge => (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The average age of the parents of this individual, measured in cycles.  Parentless individuals will have a 
\f3\fs18 meanParentAge
\f4\fs20  of 
\f3\fs18 0.0
\f4\fs20 .  The mean parent age is determined when a new offspring is generated, from the 
\f3\fs18 age
\f4\fs20  property of the parent or parents involved in generating the offspring.  For 
\f3\fs18 addRecombinant()
\f4\fs20  that is somewhat complex; see that method for details.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
migrant => (logical$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Set to 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 T
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 if the individual is a recent migrant, 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 F
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 otherwise.  The definition of \'93recent\'94 depends upon the model type (WF or nonWF).\
In WF models, this flag is set at the point when a new child is generated if it is a migrant (i.e., if its source subpopulation is not the same as its subpopulation), and remains valid, with the same value, for the rest of the individual\'92s lifetime.\
In nonWF models, this flag is 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 F
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 for all new individuals, is set to 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 F
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 in all individuals at the end of the reproduction tick cycle stage, and is set to 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 T
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 on all individuals moved to a new subpopulation by
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0  takeMigrants()
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 or a 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 survival()
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 callback; the 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 T
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 value set by 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 takeMigrants()
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 or 
\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 survival()
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 will remain until it is reset at the end of the next reproduction tick cycle stage.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 pedigreeID => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 pedigreeID
\f4\fs20  is a unique non-negative identifier for each individual in a simulation, never re-used throughout the duration of the simulation run.  If pedigree tracking is not enabled, this property is unavailable.\expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 pedigreeParentIDs => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 pedigreeParentIDs
\f4\fs20  contains the values of 
\f3\fs18 pedigreeID
\f4\fs20  that were possessed by the parents of an individual; it is thus a vector of two values.  If pedigree tracking is not enabled, this property is unavailable.  Parental values may be 
\f3\fs18 -1
\f4\fs20  if insufficient ticks have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).\expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 pedigreeGrandparentIDs => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 pedigreeGrandparentIDs
\f4\fs20  contains the values of 
\f3\fs18 pedigreeID
\f4\fs20  that were possessed by the grandparents of an individual; it is thus a vector of four values.  If pedigree tracking is not enabled, this property is unavailable.  Grandparental values may be 
\f3\fs18 -1
\f4\fs20  if insufficient ticks have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).\expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \kerning1\expnd0\expndtw0 reproductiveOutput => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 reproductiveOutput
\f4\fs20  contains the number of offspring for which this individual has been a parent.  If pedigree tracking is not enabled, this property is unavailable.  If an individual is a parent by cloning or selfing, or as 
\f1\i both
\f4\i0  parents for a biparental mating, this value is incremented by two.  Involvement of an individual as a parent for an 
\f3\fs18 addRecombinant()
\f4\fs20  call does not change this property\'92s value, since the reproductive contribution in that case is unclear; one must conduct separate bookkeeping for that case if necessary.\
See also the 
\f3\fs18 Subpopulation
\f4\fs20  property 
\f3\fs18 lifetimeReproductiveOutput
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 sex => (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The sex of the individual.  This will be 
\f3\fs18 "H"
\f4\fs20  if sex is not enabled in the simulation (i.e., for hermaphrodites), otherwise 
\f3\fs18 "F"
\f4\fs20  or 
\f3\fs18 "M"
\f4\fs20  as appropriate.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 spatialPosition => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The spatial position of the individual.  The length of the 
\f3\fs18 spatialPosition
\f4\fs20  property (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .  If the spatial dimensionality is zero (as it is by default), it is an error to access this property.  The elements of this property are identical to the values of the 
\f3\fs18 x
\f4\fs20 , 
\f3\fs18 y
\f4\fs20 , and 
\f3\fs18 z
\f4\fs20  properties (if those properties are encompassed by the spatial dimensionality of the simulation).  In other words, if the declared dimensionality is 
\f3\fs18 "xy"
\f5\fs20 ,
\f4  the 
\f3\fs18 individual.spatialPosition
\f4\fs20  property is equivalent to 
\f3\fs18 c(individual.x,\'a0individual.y)
\f4\fs20 ; 
\f3\fs18 individual.z
\f4\fs20  is not used since it is not encompassed by the simulation\'92s dimensionality.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 subpopulation => (object<Subpopulation>$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 Subpopulation
\f4\fs20  object to which the individual belongs.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value (as opposed to 
\f3\fs18 tagF
\f4\fs20 , which is of type 
\f3\fs18 float
\f4\fs20 ).  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to individuals.  \cf2 Note that the 
\f3\fs18 Individual
\f4\fs20  objects used by SLiM are new for every new offspring, so the 
\f3\fs18 tag
\f4\fs20  value of each new offspring generated in each tick will be initially undefined.
\f5 \cf0 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tagF <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 float
\f4\fs20  value (as opposed to 
\f3\fs18 tag
\f4\fs20 , which is of type 
\f3\fs18 integer
\f4\fs20 ).  The value of 
\f3\fs18 tagF
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tagF
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to individuals.\
Note that at present, although many classes in SLiM have an 
\f3\fs18 integer
\f4\fs20 -type 
\f3\fs18 tag
\f4\fs20  property, only 
\f3\fs18 Individual
\f4\fs20  has a 
\f3\fs18 float
\f4\fs20 -type 
\f3\fs18 tagF
\f4\fs20  property, because attaching model state to individuals seems to be particularly common and useful.  If a 
\f3\fs18 tagF
\f4\fs20  property would be helpful on another class, it would be easy to add.\
See the description of the 
\f3\fs18 tag
\f4\fs20  property above for additional comments.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 tagL0 <\'96> (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A user-defined 
\f3\fs18 logical
\f4\fs20  value (see also 
\f3\fs18 tag
\f4\fs20  and 
\f3\fs18 tagF
\f4\fs20 ).  The value of 
\f3\fs18 tagL0
\f4\fs20  is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tagL0
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual), for another way of attaching state to individuals.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 tagL1 <\'96> (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A user-defined 
\f3\fs18 logical
\f4\fs20  value (see also 
\f3\fs18 tag
\f4\fs20  and 
\f3\fs18 tagF
\f4\fs20 ).  The value of 
\f3\fs18 tagL1
\f4\fs20  is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tagL1
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual), for another way of attaching state to individuals.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 tagL2 <\'96> (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A user-defined 
\f3\fs18 logical
\f4\fs20  value (see also 
\f3\fs18 tag
\f4\fs20  and 
\f3\fs18 tagF
\f4\fs20 ).  The value of 
\f3\fs18 tagL2
\f4\fs20  is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tagL2
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual), for another way of attaching state to individuals.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 tagL3 <\'96> (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A user-defined 
\f3\fs18 logical
\f4\fs20  value (see also 
\f3\fs18 tag
\f4\fs20  and 
\f3\fs18 tagF
\f4\fs20 ).  The value of 
\f3\fs18 tagL3
\f4\fs20  is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tagL3
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual), for another way of attaching state to individuals.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 tagL4 <\'96> (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A user-defined 
\f3\fs18 logical
\f4\fs20  value (see also 
\f3\fs18 tag
\f4\fs20  and 
\f3\fs18 tagF
\f4\fs20 ).  The value of 
\f3\fs18 tagL4
\f4\fs20  is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tagL4
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual), for another way of attaching state to individuals.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 uniqueMutations => (object<Mutation>)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 All of the 
\f3\fs18 Mutation
\f4\fs20  objects present in this individual.  Mutations present in both genomes will occur only once in this property, and the mutations will be given in sorted order by 
\f3\fs18 position
\f4\fs20 , so this property is similar to 
\f3\fs18 sortBy(unique(individual.genomes.mutations), "position")
\f5\fs20 .
\f4   It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by 
\f3\fs18 sortBy()
\f5\fs20 .
\f4   This method is provided primarily for speed; it executes much faster than the Eidos equivalent above.  Indeed, it is faster than just 
\f3\fs18 individual.genomes.mutations
\f4\fs20 , and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 x <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 float
\f4\fs20  value.  The value of 
\f3\fs18 x
\f4\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  The value of 
\f3\fs18 x
\f4\fs20  is not used by SLiM unless the optional \'93continuous space\'94 facility is enabled with the 
\f3\fs18 dimensionality
\f4\fs20  parameter to 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 , in which case 
\f3\fs18 x
\f4\fs20  will be understood to represent the 
\f1\i x
\f4\i0  coordinate of the individual in space.  If continuous space is not enabled, you may use 
\f3\fs18 x
\f4\fs20  as an additional tag value of type 
\f3\fs18 float
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 y <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 float
\f4\fs20  value.  The value of 
\f3\fs18 y
\f4\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  The value of 
\f3\fs18 y
\f4\fs20  is not used by SLiM unless the optional \'93continuous space\'94 facility is enabled with the 
\f3\fs18 dimensionality
\f4\fs20  parameter to 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 , in which case 
\f3\fs18 y
\f4\fs20  will be understood to represent the 
\f1\i y
\f4\i0  coordinate of the individual in space (if the dimensionality is 
\f3\fs18 "xy"
\f4\fs20  or 
\f3\fs18 "xyz"
\f4\fs20 ).  If continuous space is not enabled, or the dimensionality is not 
\f3\fs18 "xy"
\f4\fs20  or 
\f3\fs18 "xyz"
\f4\fs20 , you may use 
\f3\fs18 y
\f4\fs20  as an additional tag value of type 
\f3\fs18 float
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 z <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 float
\f4\fs20  value.  The value of 
\f3\fs18 z
\f4\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  The value of 
\f3\fs18 z
\f4\fs20  is not used by SLiM unless the optional \'93continuous space\'94 facility is enabled with the 
\f3\fs18 dimensionality
\f4\fs20  parameter to 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 , in which case 
\f3\fs18 z
\f4\fs20  will be understood to represent the 
\f1\i z
\f4\i0  coordinate of the individual in space (if the dimensionality is 
\f3\fs18 "xyz"
\f4\fs20 ).  If continuous space is not enabled, or the dimensionality is not 
\f3\fs18 "xyz"
\f4\fs20 , you may use 
\f3\fs18 z
\f4\fs20  as an additional tag value of type 
\f3\fs18 float
\f5\fs20 .\
\pard\pardeftab397\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.7.2  
\f2\fs18 Individual
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 \'96\'a0(logical)containsMutations(object<Mutation>\'a0mutations)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns a 
\f3\fs18 logical
\f4\fs20  vector indicating whether each of the mutations in 
\f3\fs18 mutations
\f4\fs20  is present in the individual (in either of its genomes); each element in the returned vector indicates whether the corresponding mutation is present (
\f3\fs18 T
\f4\fs20 ) or absent (
\f3\fs18 F
\f4\fs20 ).  This method is provided for speed; it is much faster than the corresponding Eidos code.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (integer$)countOfMutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns the number of mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations in the individual (in both of its genomes; a mutation that is present in both genomes counts twice).  If you need a vector of the matching 
\f3\fs18 Mutation
\f4\fs20  objects, rather than just a count, use the 
\f3\fs18 Genome
\f4\fs20  method 
\f3\fs18 -mutationsOfType()
\f5\fs20 .
\f4   This method is provided for speed; it is much faster than the corresponding Eidos code.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (float)relatedness(object<Individual>
\f5 \'a0
\f3 individuals)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector containing the degrees of relatedness between the receiver and each of the individuals in 
\f3\fs18 individuals
\f4\fs20 .  The relatedness between 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20  is always 
\f3\fs18 1.0
\f4\fs20  if 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20  are actually the same individual; this facility works even if SLiM\'92s optional pedigree tracking is not enabled (in which case all other relatedness values will be 
\f3\fs18 0.0
\f4\fs20 ).  Otherwise, if pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , this method will use the pedigree information to construct a relatedness estimate.\
More specifically, this method uses all available pedigree information from the grandparental and parental pedigree records of 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20  to compute an estimate of the degree of consanguinity between 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20 .  Siblings have a relatedness of 
\f3\fs18 0.5
\f4\fs20 , as do parents to their children and vice versa; cousins have a relatedness of 
\f3\fs18 0.125
\f4\fs20 ; and so forth.  If, according to the pedigree information available, 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20  have no blood relationship, the value returned is 
\f3\fs18 0.0
\f4\fs20 .  Note that the value returned by 
\f3\fs18 relatedness()
\f4\fs20  is what is called the \'93coefficient of relationship\'94 between the two individuals (Wright, 1922; {\field{\*\fldinst{HYPERLINK "https://doi.org/10.1086/279872"}}{\fldrslt \cf3 \ul \ulc3 https://doi.org/10.1086/279872}}), and ranges from 
\f3\fs18 0.0
\f4\fs20  to 
\f3\fs18 1.0
\f4\fs20 .\
There is another commonly used metric of relatedness, called the \'93kinship coefficient\'94, that reflects the probability of identity by descent between two individuals 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20 .  In general, it is approximately equal to one-half of the coefficient of relationship; if an approximate estimate of the kinship coefficient is acceptable, especially in models in which individuals are expected to be outbred, you can simply divide 
\f3\fs18 relatedness()
\f4\fs20  by two.  However, it should be noted that Wright\'92s coefficient of relationship is 
\f1\i not
\f4\i0  a measure of the probability of identity by descent, and so it is not exactly double the kinship coefficient; they actually measure different things.  More precisely, the relationship between them is 
\f6\i r
\f5\i0 \'a0=\'a02
\f6\i \uc0\u966 
\f5\i0 /sqrt((1+
\f6\i f
\f5\i0\fs13\fsmilli6667 \sub A
\fs20 \nosupersub )(1+
\f6\i f
\f5\i0\fs13\fsmilli6667 \sub B
\fs20 \nosupersub ))
\f4 , where 
\f6\i r
\f4\i0  is Wright\'92s coefficient of relatedness, 
\f6\i \uc0\u966 
\f4\i0  is the kinship coefficient, and 
\f6\i f
\f5\i0\fs13\fsmilli6667 \sub A
\f4\fs20 \nosupersub  and 
\f6\i f
\f5\i0\fs13\fsmilli6667 \sub B
\f4\fs20 \nosupersub  are the inbreeding coefficients of 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20  respectively.\
Note that this relatedness is simply pedigree-based relatedness, and does not necessarily correspond to genetic relatedness, because of the effects of factors like assortment and recombination.  If a metric of actual genetic relatedness is desired, tree-sequence recording can be used after simulation is complete, to compute the exact genetic relatedness between individuals based upon the complete ancestry tree (a topic which is beyond the scope of this manual).  Actual genetic relatedness cannot presently be calculated during a simulation run; the information is implicitly contained in the recorded tree-sequence tables, but calculating it is too computationally expensive to be reasonable.\
This method assumes that the grandparents (or the parents, if grandparental information is not available) are themselves unrelated and that they are not inbred; this assumption is necessary because we have no information about their parentage, since SLiM\'92s pedigree tracking information only goes back two generations.  Be aware that in a model where inbreeding or selfing occurs at all (including \'93incidental selfing\'94, where a hermaphroditic individual happens to choose itself as a mate), some level of \'93background relatedness\'94 will be present and this assumption will be violated.  In such circumstances, 
\f3\fs18 relatedness()
\f4\fs20  will therefore tend to underestimate the degree of relatedness between individuals, and the greater the degree of inbreeding, the greater the underestimation will be.  If inbreeding is allowed in a model \'96 and particularly if it is common \'96 the results of 
\f3\fs18 relatedness()
\f4\fs20  should therefore not be taken as an estimate of 
\f1\i absolute
\f4\i0  relatedness, but can still be useful as an estimate of 
\f1\i relative
\f4\i0  relatedness (indicating that, say, A appears from the information available to be more closely related to B than it is to C).\
See also 
\f3\fs18 sharedParentCount()
\f4\fs20  for a different metric of relatedness.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
+\'a0(void)setSpatialPosition(float\'a0position)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Sets the spatial position of the individual (as accessed through the 
\f3\fs18 spatialPosition
\f4\fs20  property).  The length of 
\f3\fs18 position
\f4\fs20  (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .  If the spatial dimensionality is zero (as it is by default), it is an error to call this method.  The elements of 
\f3\fs18 position
\f4\fs20  are set into the values of the 
\f3\fs18 x
\f4\fs20 , 
\f3\fs18 y
\f4\fs20 , and 
\f3\fs18 z
\f4\fs20  properties (if those properties are encompassed by the spatial dimensionality of the simulation).  In other words, if the declared dimensionality is 
\f3\fs18 "xy"
\f4\fs20 , calling 
\f3\fs18 individual.setSpatialPosition(c(1.0, 0.5))
\f4\fs20  property is equivalent to 
\f3\fs18 individual.x\'a0=\'a01.0; individual.y\'a0=\'a00.5
\f4\fs20 ; 
\f3\fs18 individual.z
\f4\fs20  is not set (even if a third value is supplied in 
\f3\fs18 position
\f4\fs20 ) since it is not encompassed by the simulation\'92s dimensionality in this example.\
Note that this is an Eidos class method, somewhat unusually, which allows it to work in a special way when called on a vector of individuals.  When the target vector of individuals is non-singleton, this method can do one of two things.  If 
\f3\fs18 position
\f4\fs20  contains just a single point (i.e., is equal in length to the spatial dimensionality of the model), the spatial position of all of the target individuals will be set to the given point.  Alternatively, if 
\f3\fs18 position
\f4\fs20  contains one point per target individual (i.e., is equal in length to the number of individuals multiplied by the spatial dimensionality of the model), the spatial position of each target individual will be set to the corresponding point from 
\f3\fs18 position
\f4\fs20  (where the point data is concatenated, not interleaved, just as it would be returned by accessing the 
\f3\fs18 spatialPosition
\f4\fs20  property on the vector of target individuals).  Calling this method with a 
\f3\fs18 position
\f4\fs20  vector of any other length is an error.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \kerning1\expnd0\expndtw0 \'96\'a0(integer)sharedParentCount(object<Individual>\'a0individuals)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector containing the number of parents shared between the receiver and each of the individuals in 
\f3\fs18 individuals
\f4\fs20 .  The number of shared parents between 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20  is always 
\f3\fs18 2
\f4\fs20  if 
\f3\fs18 A
\f4\fs20  and 
\f3\fs18 B
\f4\fs20  are actually the same individual; this facility works even if SLiM\'92s optional pedigree tracking is not enabled (in which case all other relatedness values will be 
\f3\fs18 0
\f4\fs20 ).  Otherwise, if pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , this method will use the pedigree information described in section 25.7.1 to construct a relatedness estimate.\
More specifically, this method uses the parental pedigree IDs from the pedigree records of a pair of individuals to count the number of shared parents between them, such that full siblings (with all of the same parents) have a count of 
\f3\fs18 2
\f4\fs20 , and half siblings (with half of the same parents) have a count of 
\f3\fs18 1
\f4\fs20 .  If possible parents of the two individuals are 
\f3\fs18 A
\f4\fs20 , 
\f3\fs18 B
\f4\fs20 , 
\f3\fs18 C
\f4\fs20 , and 
\f3\fs18 D
\f4\fs20 , then the shared parent count is as follows, for some illustrative examples.  The first column showing the two parents of the first individual, the second column showing the two parents of the second individual; note that the two parents of an individual can be the same due to cloning or selfing:\
\pard\pardeftab720\li547\sa60\partightenfactor0
\cf2 	
\f3\fs18 AB
\f4\fs20  
\f3\fs18 CD
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 0
\f4\fs20  (no shared parents)\
	
\f3\fs18 AB
\f4\fs20  
\f3\fs18 CC
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 0
\f4\fs20  (no shared parents)\
	
\f3\fs18 AB
\f4\fs20  
\f3\fs18 AC
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 1
\f4\fs20  (half siblings)\
	
\f3\fs18 AB
\f4\fs20  
\f3\fs18 AA
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 1
\f4\fs20  (half siblings)\
	
\f3\fs18 AA
\f4\fs20  
\f3\fs18 AB
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 1
\f4\fs20  (half siblings)\
	
\f3\fs18 AB
\f4\fs20  
\f3\fs18 AB
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 2
\f4\fs20  (full siblings)\
	
\f3\fs18 AB
\f4\fs20  
\f3\fs18 BA
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 2
\f4\fs20  (full siblings)\
	
\f3\fs18 AA
\f4\fs20  
\f3\fs18 AA
\f4\fs20  
\f7 \uc0\u8594 
\f4  
\f3\fs18 2
\f4\fs20  (full siblings)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 This method does not estimate consanguinity.  For example, if one individual is itself a parent of the other individual, that is irrelevant for this method.  Similarly, in simulations of sex chromosomes, the sexes of the parents are irrelevant, even if no genetic material would have been inherited from a given parent.  See 
\f3\fs18 relatedness()
\f4\fs20  for an assessment of pedigree-based relatedness that does estimate the consanguinity of individuals.  The 
\f3\fs18 sharedParentCount()
\f4\fs20  method is preferable if your exact question is simply whether individuals are full siblings, half siblings, or non-siblings; in other cases, 
\f3\fs18 relatedness()
\f4\fs20  is probably more useful.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (float$)sumOfMutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns the sum of the selection coefficients of all mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations in the genomes of the individual.  This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, 
\f3\fs18 sumOfMutationsOfType()
\f4\fs20  will provide the sum of the additive effects of the QTLs for the given mutation type.  This method is provided for speed; it is much faster than the corresponding Eidos code.  Note that this method also exists on 
\f3\fs18 Genome
\f4\fs20 , for cases in which the sum for just one genome is desired.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (object<Mutation>)uniqueMutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns an 
\f3\fs18 object
\f4\fs20  vector of all the mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations in the individual.  Mutations present in both genomes will occur only once in the result of this method, and the mutations will be given in sorted order by 
\f3\fs18 position
\f4\fs20 , so this method is similar to 
\f3\fs18 sortBy(unique(individual.genomes.mutationsOfType(mutType)), "position")
\f5\fs20 .
\f4   It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by 
\f3\fs18 sortBy()
\f5\fs20 .
\f4   If you just need a count of the matching 
\f3\fs18 Mutation
\f4\fs20  objects, rather than a vector of the matches, use 
\f3\fs18 -countOfMutationsOfType()
\f4\fs20 .  This method is provided for speed; it is much faster than the corresponding Eidos code.  Indeed, it is faster than just 
\f3\fs18 individual.genomes.mutationsOfType(mutType)
\f4\fs20 , and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.
\f5 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.8  Class InteractionType\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.8.1  
\f2\fs18 InteractionType
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier for this interaction type; for interaction type 
\f3\fs18 i3
\f4\fs20 , for example, this is 
\f3\fs18 3
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 maxDistance <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The maximum distance over which this interaction will be evaluated.  For inter-individual distances greater than 
\f3\fs18 maxDistance
\f5\fs20 ,
\f4  the interaction strength will be zero.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 reciprocal => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The reciprocality of the interaction, as specified in 
\f3\fs18 initializeInteractionType()
\f4\fs20 .  This will be 
\f3\fs18 T
\f4\fs20  for reciprocal interactions (those for which the interaction strength of B upon A is equal to the interaction strength of A upon B), and 
\f3\fs18 F
\f4\fs20  otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 sexSegregation => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The sex-segregation of the interaction, as specified in 
\f3\fs18 initializeInteractionType()
\f4\fs20 .  For non-sexual simulations, this will be 
\f3\fs18 "**"
\f5\fs20 .
\f4   For sexual simulations, this 
\f3\fs18 string
\f4\fs20  value indicates the sex of individuals feeling the interaction, and the sex of individuals exerting the interaction; see 
\f3\fs18 initializeInteractionType()
\f4\fs20  for details.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 spatiality => (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The spatial dimensions used by the interaction, as specified in 
\f3\fs18 initializeInteractionType()
\f4\fs20 .  This will be 
\f3\fs18 ""
\f4\fs20  (the empty string) for non-spatial interactions, or 
\f3\fs18 "x"
\f4\fs20 , 
\f3\fs18 "y"
\f4\fs20 , 
\f3\fs18 "z"
\f4\fs20 , 
\f3\fs18 "xy"
\f4\fs20 , 
\f3\fs18 "xz"
\f4\fs20 , 
\f3\fs18 "yz"
\f4\fs20 , or 
\f3\fs18 "xyz"
\f4\fs20 , for interactions using those spatial dimensions respectively.  The specified dimensions are used to calculate the distances between individuals for this interaction.  The value of this property is always the same as the value given to 
\f3\fs18 initializeInteractionType()
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to interaction types.
\f5 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.8.2  
\f2\fs18 InteractionType
\f1\fs22  methods\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(float)clippedIntegral(No<Individual>\'a0receivers)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector containing the integral of the interaction function as experienced by each of the individuals in 
\f3\fs18 receivers
\f4\fs20 .  For each given individual, the interaction function is clipped to the edges of the spatial bounds of the subpopulation that individual inhabits; the individual\'92s spatial position must be within bounds or an error is raised.  A periodic boundary will, correctly, not clip the interaction function.  The interaction function is also clipped to the interaction\'92s maximum distance; that distance must be less than half of the extent of the spatial bounds in each dimension (so that, for a given dimension, the interaction function is clipped by the spatial bounds on only one side), otherwise an error is raised.  Note that for sex-specific interaction types, the sex of the receiver does not matter; an individual might not actually receive any interactions because of its sex, but it is still considered to have the same interaction function integral.  If 
\f3\fs18 receivers
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20 , the maximal integral is returned, as would be experienced by an individual farther than the maximum distance from any edge.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver subpopulation, and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
The computed value of the integral is not exact; it is calculated by an approximate numerical method designed to be fast, but the error should be fairly small (typically less than 1% from the true value).  A large amount of computation will occur the first time this method is called (perhaps taking more than a second, depending upon hardware), but subsequent calls should be very fast.  This method does not invoke 
\f3\fs18 interaction()
\f4\fs20  callbacks; the calculated integrals are only for the interaction function itself, and so will not be accurate if 
\f3\fs18 interaction()
\f4\fs20  callbacks modify the relationship between distance and interaction strength.  For this reason, the overhead of the first call will 
\f1\i not
\f4\i0  reoccur when individuals move or when the interaction is re-evaluated; for typical models, the initial overhead will be incurred only once.  The initial overhead will reoccur, however, if the interaction function itself, or the maximum interaction distance, are changed; frequent change of those parameters may render the performance of this method unacceptable.\
The integral values returned by 
\f3\fs18 clippedIntegral()
\f4\fs20  can be useful for computing interaction metrics that are scaled by the amount of \'93interaction field\'94 (to coin a term) that is present for a given individual, producing metrics of interaction 
\f1\i density
\f4\i0 .  Notably, the 
\f3\fs18 localPopulationDensity()
\f4\fs20  method automatically incorporates the mechanics of 
\f3\fs18 clippedIntegral()
\f4\fs20  into the calculations it performs; see that method\'92s documentation for further discussion of this concept.  This approach can also be useful with the 
\f3\fs18 interactingNeighborCount()
\f4\fs20  method, provided that the interaction function is of type 
\f3\fs18 "f"
\f4\fs20  (since the neighbor count does not depend upon interaction strength).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)distance(object<Individual>$\'a0receiver, [No<Individual>\'a0exerters\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector containing distances between 
\f3\fs18 receiver
\f4\fs20  and the individuals in 
\f3\fs18 exerters
\f4\fs20 .  If 
\f3\fs18 exerters
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), then a vector of the distances from 
\f3\fs18 receiver
\f4\fs20  to all individuals in its subpopulation (including itself) is returned; this case may be handled differently internally, for greater speed, so supplying 
\f3\fs18 NULL
\f4\fs20  is preferable to supplying the vector of all individuals in the subpopulation explicitly.  Otherwise, all individuals in 
\f3\fs18 exerters
\f4\fs20  must belong to a single subpopulation (but not necessarily the same subpopulation as 
\f3\fs18 receiver
\f4\fs20 ).  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
Importantly, distances are calculated according to the spatiality of the 
\f3\fs18 InteractionType
\f4\fs20  (as declared in 
\f3\fs18 initializeInteractionType()
\f4\fs20 ), not the dimensionality of the model as a whole (as declared in 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 ).  The distances returned are therefore the distances that would be used to calculate interaction strengths.  However, 
\f3\fs18 distance()
\f4\fs20  will return finite distances for all pairs of individuals, even if the individuals are non-interacting; the 
\f3\fs18 distance()
\f4\fs20  between an individual and itself will thus be 
\f3\fs18 0
\f4\fs20 .  See 
\f3\fs18 interactionDistance()
\f4\fs20  for an alternative distance definition.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)distanceFromPoint(float\'a0point, object<Individual>\'a0exerters)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector containing distances between the point given by the spatial coordinates in 
\f3\fs18 point
\f4\fs20 , which may be thought of as the \'93receiver\'94, and individuals in 
\f3\fs18 exerters
\f4\fs20 .  The 
\f3\fs18 point
\f4\fs20  vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if the interaction type\'92s spatiality is 
\f3\fs18 "xz"
\f4\fs20 , for example, then 
\f3\fs18 point[0]
\f4\fs20  is assumed to be an 
\f1\i x
\f4\i0  value, and 
\f3\fs18 point[1]
\f4\fs20  is assumed to be a 
\f1\i z
\f4\i0  value.  Be careful; this means that in general it is not safe to pass an individual\'92s 
\f3\fs18 spatialPosition
\f4\fs20  property for 
\f3\fs18 point
\f4\fs20 , for example (although it is safe if the spatiality of the interaction matches the dimensionality of the simulation).  A coordinate for a periodic spatial dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic bounds are meaningless (
\f3\fs18 pointPeriodic()
\f4\fs20  may be used to ensure this); coordinates for non-periodic spatial dimensions are not restricted.  All individuals in 
\f3\fs18 exerters
\f4\fs20  must belong to a single subpopulation; the 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for that subpopulation, and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.  The vector 
\f3\fs18 point
\f4\fs20  must be exactly as long as the spatiality of the 
\f3\fs18 InteractionType
\f4\fs20 .\
Importantly, distances are calculated according to the spatiality of the 
\f3\fs18 InteractionType
\f4\fs20  (as declared in 
\f3\fs18 initializeInteractionType()
\f4\fs20 ) not the dimensionality of the model as a whole (as declared in 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 ).  The distances are therefore interaction distances: the distances that are used to calculate interaction strengths.\
This method replaces the 
\f3\fs18 distanceToPoint()
\f4\fs20  method that existed prior to SLiM 4.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object)drawByStrength(object<Individual>\'a0receiver, [integer$\'a0count\'a0=\'a01], [No<Subpopulation>$\'a0exerterSubpop\'a0=\'a0NULL], [logical$\'a0returnDict\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns an 
\f3\fs18 object<Individual>
\f4\fs20  vector containing up to 
\f3\fs18 count
\f4\fs20  individuals drawn from 
\f3\fs18 exerterSubpop
\f4\fs20 , or if that is 
\f3\fs18 NULL
\f4\fs20  (the default), then from the subpopulation of 
\f3\fs18 receiver
\f4\fs20 , which must be singleton in the default mode of operation (but see below).  The probability of drawing particular individuals is proportional to the strength of interaction they exert upon 
\f3\fs18 receiver
\f4\fs20  (which is zero for 
\f3\fs18 receiver
\f4\fs20  itself).  All exerters must belong to a single subpopulation (but not necessarily the same subpopulation as 
\f3\fs18 receiver
\f4\fs20 ).  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\
This method may be used with either spatial or non-spatial interactions, but will be more efficient with spatial interactions that set a short maximum interaction distance.  Draws are done with replacement, so the same individual may be drawn more than once; sometimes using 
\f3\fs18 unique()
\f4\fs20  on the result of this call is therefore desirable.  If more than one draw will be needed, it is much more efficient to use a single call to 
\f3\fs18 drawByStrength()
\f4\fs20 , rather than drawing individuals one at a time.  Note that if no individuals exert a non-zero interaction strength upon 
\f3\fs18 receiver
\f4\fs20 , the vector returned will be zero-length; it is important to consider this possibility.\
Beginning in SLiM 5.0, this method has a vectorized mode of operation in which the 
\f3\fs18 receiver
\f4\fs20  parameter may be non-singleton.  To switch the method to this mode, pass 
\f3\fs18 T
\f4\fs20  for 
\f3\fs18 returnDict
\f4\fs20 , rather than the default of 
\f3\fs18 F
\f4\fs20  (the operation of which is described above).  In this mode, the return value is a 
\f3\fs18 Dictionary
\f4\fs20  object instead of a vector of 
\f3\fs18 Individual
\f4\fs20  objects.  This dictionary uses 
\f3\fs18 integer
\f4\fs20  keys that range from 
\f3\fs18 0
\f4\fs20  to 
\f3\fs18 N-1
\f4\fs20 , where 
\f3\fs18 N
\f4\fs20  is the number of individuals passed in 
\f3\fs18 receiver
\f4\fs20 ; these keys thus correspond directly to the indices of the individuals in 
\f3\fs18 receiver
\f4\fs20 , and there is one entry in the dictionary for each receiver.  The value in the dictionary, for a given 
\f3\fs18 integer
\f4\fs20  key, is an 
\f3\fs18 object<Individual>
\f4\fs20  vector with the individuals drawn for the corresponding receiver, exactly as described above for the non-vectorized case.  The results for each receiver can therefore be obtained from the returned dictionary with 
\f3\fs18 getValue()
\f4\fs20 , passing the index of the receiver.  The speed of this mode of operation will probably be similar to the speed of making 
\f3\fs18 N
\f4\fs20  separate non-vectorized calls to 
\f3\fs18 drawByStrength()
\f4\fs20 , when running single-threaded.  When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.  In this mode of operation, all receivers must belong to the same subpopulation.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)evaluate(io<Subpopulation>\'a0subpops)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Snapshots model state in preparation for the use of the interaction, for the receiver and exerter subpopulations specified by 
\f3\fs18 subpops
\f4\fs20 .  The subpopulations may be supplied either as 
\f3\fs18 integer
\f4\fs20  IDs, or as 
\f3\fs18 Subpopulation
\f4\fs20  objects.  This method will discard all previously cached data for the subpopulation(s), and will cache the current spatial positions of all individuals they contain (so that the spatial positions of those individuals may then change without disturbing the state of the interaction at the moment of evaluation).  Particular interaction distances and strengths are not computed by 
\f3\fs18 evaluate()
\f4\fs20 , and 
\f3\fs18 interaction()
\f4\fs20  callbacks will not be called in response to this method; that work is deferred until required to satisfy a query (at which point the tick and cycle counters may have advanced, so be careful with the tick ranges used in defining 
\f3\fs18 interaction()
\f4\fs20  callbacks).\
You must explicitly call 
\f3\fs18 evaluate()
\f4\fs20  at an appropriate time in the tick cycle before the interaction is used, but after any relevant changes have been made to the population.  SLiM will invalidate any existing interactions after any portion of the tick cycle in which new individuals have been born or existing individuals have died.  In a WF model, this occurs just before 
\f3\fs18 late()
\f4\fs20  events execute (see the WF tick cycle diagram), so 
\f3\fs18 late()
\f4\fs20  events are often the appropriate place to put 
\f3\fs18 evaluate()
\f4\fs20  calls, but 
\f3\fs18 first()
\f4\fs20  or 
\f3\fs18 early()
\f4\fs20  events can work too if the interaction is not needed until that point in the tick cycle anyway. In nonWF models, on the other hand, new offspring are produced just before 
\f3\fs18 early()
\f4\fs20  events and then individuals die just before 
\f3\fs18 late()
\f4\fs20  events (see the nonWF tick cycle diagram), so interactions will be invalidated twice during each tick cycle.  This means that in a nonWF model, an interaction that influences reproduction should usually be evaluated in a 
\f3\fs18 first()
\f4\fs20  event, while an interaction that influences fitness or mortality should usually be evaluated in an 
\f3\fs18 early()
\f4\fs20  event (and an interaction that affects both may need to be evaluated at both times).\
If an interaction is never evaluated for a given subpopulation, it is guaranteed that there will be essentially no memory or computational overhead associated with the interaction for that subpopulation.  Furthermore, attempting to query an interaction for a receiver or exerter in a subpopulation that has not been evaluated is guaranteed to raise an error.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(integer)interactingNeighborCount(object<Individual>\'a0receivers, [No<Subpopulation>$\'a0exerterSubpop\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the number of interacting individuals for each individual in 
\f3\fs18 receivers
\f4\fs20 , within the maximum interaction distance according to the distance metric of the 
\f3\fs18 InteractionType
\f4\fs20 , from among the exerters in 
\f3\fs18 exerterSubpop
\f4\fs20  (or, if that is 
\f3\fs18 NULL
\f4\fs20 , then from among all individuals in the receiver\'92s subpopulation).  More specifically, this method counts the number of individuals which can exert an interaction upon each receiver (which does not include the receiver itself).  All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\
This method is similar to 
\f3\fs18 nearestInteractingNeighbors()
\f4\fs20  (when passed a large count so as to guarantee that all interacting individuals are returned), but this method returns only a count of the interacting individuals, not a vector containing the individuals.  This method may also be called in a vectorized fashion, with a non-singleton vector of individuals, unlike 
\f3\fs18 nearestInteractingNeighbors()
\f4\fs20 .\
Note that this method uses interaction eligibility as a criterion; it will not count neighbors that cannot exert an interaction upon a receiver (due to sex-segregation, e.g.).  (It also does not count a receiver as a neighbor of itself.)  If a count of all neighbors is desired, rather than just interacting neighbors, use 
\f3\fs18 neighborCount()
\f4\fs20 .  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(float)interactionDistance(object<Individual>$\'a0receiver, [No<Individual>\'a0exerters\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Returns a vector containing interaction-dependent distances between 
\f3\fs18 receiver
\f4\fs20  and individuals in 
\f3\fs18 exerters
\f4\fs20 .  If 
\f3\fs18 exerters
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), then a vector of the interaction-dependent distances from 
\f3\fs18 receiver
\f4\fs20  to all individuals in its subpopulation (including 
\f3\fs18 receiver
\f4\fs20  itself) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.  Otherwise, all individuals in 
\f3\fs18 exerters
\f4\fs20  must belong to a single subpopulation (but not necessarily the same subpopulation as 
\f3\fs18 receiver
\f4\fs20 ).  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
Importantly, distances are calculated according to the spatiality of the 
\f3\fs18 InteractionType
\f4\fs20  (as declared in 
\f3\fs18 initializeInteractionType()
\f4\fs20 ), not the dimensionality of the model as a whole (as declared in 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 ).  The distances returned are therefore the distances that would be used to calculate interaction strengths.  In addition, 
\f3\fs18 interactionDistance()
\f4\fs20  will return 
\f3\fs18 INF
\f4\fs20  as the distance between 
\f3\fs18 receiver
\f4\fs20  and any individual which does not exert an interaction upon 
\f3\fs18 receiver
\f4\fs20 ; the 
\f3\fs18 interactionDistance()
\f4\fs20  between an individual and itself will thus be 
\f3\fs18 INF
\f4\fs20 , and likewise for pairs excluded from interacting by the sex segregation or max distance of the interaction type.  See 
\f3\fs18 distance()
\f4\fs20  for an alternative distance definition.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)localPopulationDensity(object<Individual>\'a0receivers, [No<Subpopulation>$\'a0exerterSubpop\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector of the local population density present at the location of each individual in 
\f3\fs18 receivers
\f4\fs20 , which does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.  However, all receivers must be in the same subpopulation.  The local population density is computed from exerters in 
\f3\fs18 exerterSubpop
\f4\fs20 , or if that is 
\f3\fs18 NULL
\f4\fs20  (the default), then from the receiver\'92s subpopulation.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\
Population density is estimated using interaction strengths, effectively doing a kernel density estimate using the interaction function as the kernel.  What is returned is computed as the total interaction strength present at a given point, divided by the integral of the interaction function around that point after clipping by the spatial bounds of the exerter subpopulation (what one might think of as the amount of \'93interaction field\'94 around the point).  This provides an estimate of local population density, in units of individuals per unit area, as a weighted average over the area covered by the interaction function, where the weight of each exerter in the average is the value of the interaction function at that exerter\'92s position.  This can also be thought of as a measure of the amount of interaction happening per unit of interaction field in the space surrounding the point.\
To calculate the clipped integral of the interaction function, this method uses the same numerical estimator used by the 
\f3\fs18 clippedIntegral()
\f4\fs20  method of 
\f3\fs18 InteractionType
\f4\fs20 , and all of the caveats described for that method apply here also; notably, all individuals must be within spatial bounds, the maximum interaction distance must be less than half the spatial extent of the subpopulation, and 
\f3\fs18 interaction()
\f4\fs20  callbacks are not used (and so, for this method, are not allowed to be active).  See the documentation for 
\f3\fs18 clippedIntegral()
\f4\fs20  for further discussion of the details of these calculations.\
To calculate the total interaction strength around the position of a receiver, this method uses the same machinery as the 
\f3\fs18 totalOfNeighborStrengths()
\f4\fs20  method of 
\f3\fs18 InteractionType
\f4\fs20 , 
\f1\i except
\f4\i0  that \'96 in contrast to other 
\f3\fs18 InteractionType
\f4\fs20  methods \'96 the interaction strength exerted by the receiver itself is included in the total (if the exerter subpopulation is the receiver\'92s own subpopulation).  This is because population density at the location of an individual includes the individual itself.  If this is not desirable, the 
\f3\fs18 totalOfNeighborStrengths()
\f4\fs20  method should probably be used.\
To see the point of this method, consider a receiver located near the edge of the spatial bounds of its subpopulation.  Some portion of the interaction function that surrounds that receiver falls outside the spatial bounds of its subpopulation, and will therefore never contain an interacting exerter.  If, for example, interaction strengths are used as a measure of competition, this receiver will therefore have an advantage, because it will never feel any competition from the portion of its range that falls outside spatial bounds.  However, that portion of its range is presumably also not available to the receiver itself, for foraging or hunting, in which case this advantage is not biologically realistic, but is instead just an undesirable \'93edge effect\'94 artifact.  Dividing by the integral of the interaction function, clipped to the spatial bounds, provides a way to compensate for this edge effect.  A nice side effect of using local population densities instead of total interaction strengths is that the maximum interaction strength passed to 
\f3\fs18 setInteractionFunction()
\f4\fs20  no longer matters; it cancels out when the total interaction strength is divided by the receiver\'92s clipped integral.  However, the 
\f1\i shape
\f4\i0  of the interaction function does still matter; it determines the relative weights used for exerters at different distances from the position of the receiver.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object)nearestInteractingNeighbors(object<Individual>\'a0receiver, [integer$\'a0count\'a0=\'a01], [No<Subpopulation>$\'a0exerterSubpop\'a0=\'a0NULL], [logical$\'a0returnDict\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns an 
\f3\fs18 object<Individual>
\f4\fs20  vector containing up to 
\f3\fs18 count
\f4\fs20  interacting individuals that are spatially closest to 
\f3\fs18 receiver
\f4\fs20 , according to the distance metric of the 
\f3\fs18 InteractionType
\f4\fs20 , from among the exerters in 
\f3\fs18 exerterSubpop
\f4\fs20  (or, if that is 
\f3\fs18 NULL
\f4\fs20 , then from among all individuals in the receiver\'92s subpopulation).  More specifically, this method returns only individuals which can exert an interaction upon 
\f3\fs18 receiver
\f4\fs20 , which must be singleton in the default mode of operation (but see below).  To obtain all of the interacting individuals within the maximum interaction distance of 
\f3\fs18 receiver
\f4\fs20 , simply pass a value for 
\f3\fs18 count
\f4\fs20  that is greater than or equal to the size of the exerter subpopulation.  Note that if fewer than 
\f3\fs18 count
\f4\fs20  interacting individuals are within the maximum interaction distance, the vector returned may be shorter than 
\f3\fs18 count
\f4\fs20 , or even zero-length; it is important to check for this possibility even when requesting a single neighbor.  If only the number of interacting individuals is needed, use 
\f3\fs18 interactingNeighborCount()
\f4\fs20  instead.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
Note that this method uses interaction eligibility as a criterion; it will not return neighbors that cannot exert an interaction upon the receiver (due to sex-segregation, e.g.).  (It will also never return the receiver as a neighbor of itself.)  To find all neighbors of the receiver, whether they can interact with it or not, use 
\f3\fs18 nearestNeighbors()
\f4\fs20 .\
Beginning in SLiM 5.0, this method has a vectorized mode of operation in which the 
\f3\fs18 receiver
\f4\fs20  parameter may be non-singleton.  To switch the method to this mode, pass 
\f3\fs18 T
\f4\fs20  for 
\f3\fs18 returnDict
\f4\fs20 , rather than the default of 
\f3\fs18 F
\f4\fs20  (the operation of which is described above).  In this mode, the return value is a 
\f3\fs18 Dictionary
\f4\fs20  object instead of a vector of 
\f3\fs18 Individual
\f4\fs20  objects.  This dictionary uses 
\f3\fs18 integer
\f4\fs20  keys that range from 
\f3\fs18 0
\f4\fs20  to 
\f3\fs18 N-1
\f4\fs20 , where 
\f3\fs18 N
\f4\fs20  is the number of individuals passed in 
\f3\fs18 receiver
\f4\fs20 ; these keys thus correspond directly to the indices of the individuals in 
\f3\fs18 receiver
\f4\fs20 , and there is one entry in the dictionary for each receiver.  The value in the dictionary, for a given 
\f3\fs18 integer
\f4\fs20  key, is an 
\f3\fs18 object<Individual>
\f4\fs20  vector with the interacting neighbors found for the corresponding receiver, exactly as described above for the non-vectorized case.  The results for each receiver can therefore be obtained from the returned dictionary with 
\f3\fs18 getValue()
\f4\fs20 , passing the index of the receiver.  The speed of this mode of operation will probably be similar to the speed of making 
\f3\fs18 N
\f4\fs20  separate non-vectorized calls to 
\f3\fs18 nearestInteractingNeighbors()
\f4\fs20 , when running single-threaded.  When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.  In this mode of operation, all receivers must belong to the same subpopulation.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object)nearestNeighbors(object<Individual>\'a0receiver, [integer$\'a0count\'a0=\'a01], [No<Subpopulation>$\'a0exerterSubpop\'a0=\'a0NULL], [logical$\'a0returnDict\'a0=\'a0F])\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns an 
\f3\fs18 object<Individual>
\f4\fs20  vector containing up to 
\f3\fs18 count
\f4\fs20  individuals that are spatially closest to 
\f3\fs18 receiver
\f4\fs20 , according to the distance metric of the 
\f3\fs18 InteractionType
\f4\fs20 , from among the exerters in 
\f3\fs18 exerterSubpop
\f4\fs20  (or, if that is 
\f3\fs18 NULL
\f4\fs20 , then from among all individuals in the receiver\'92s subpopulation).  In the default mode of operation, 
\f3\fs18 receiver
\f4\fs20  must be singleton (but see below).  To obtain all of the individuals within the maximum interaction distance of 
\f3\fs18 receiver
\f4\fs20 , simply pass a value for 
\f3\fs18 count
\f4\fs20  that is greater than or equal to the size of 
\f3\fs18 individual
\f4\fs20 \'92s subpopulation.  Note that if fewer than 
\f3\fs18 count
\f4\fs20  individuals are within the maximum interaction distance, the vector returned may be shorter than 
\f3\fs18 count
\f4\fs20 , or even zero-length; it is important to check for this possibility even when requesting a single neighbor.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
Note that this method does not use interaction eligibility as a criterion; it will return neighbors that could not interact with the receiver due to sex-segregation.  (It will never return the receiver as a neighbor of itself, however.)  To find only neighbors that are eligible to exert an interaction upon the receiver, use 
\f3\fs18 nearestInteractingNeighbors()
\f4\fs20 .\
Beginning in SLiM 5.0, this method has a vectorized mode of operation in which the 
\f3\fs18 receiver
\f4\fs20  parameter may be non-singleton.  To switch the method to this mode, pass 
\f3\fs18 T
\f4\fs20  for 
\f3\fs18 returnDict
\f4\fs20 , rather than the default of 
\f3\fs18 F
\f4\fs20  (the operation of which is described above).  In this mode, the return value is a 
\f3\fs18 Dictionary
\f4\fs20  object instead of a vector of 
\f3\fs18 Individual
\f4\fs20  objects.  This dictionary uses 
\f3\fs18 integer
\f4\fs20  keys that range from 
\f3\fs18 0
\f4\fs20  to 
\f3\fs18 N-1
\f4\fs20 , where 
\f3\fs18 N
\f4\fs20  is the number of individuals passed in 
\f3\fs18 receiver
\f4\fs20 ; these keys thus correspond directly to the indices of the individuals in 
\f3\fs18 receiver
\f4\fs20 , and there is one entry in the dictionary for each receiver.  The value in the dictionary, for a given 
\f3\fs18 integer
\f4\fs20  key, is an 
\f3\fs18 object<Individual>
\f4\fs20  vector with the neighbors found for the corresponding receiver, exactly as described above for the non-vectorized case.  The results for each receiver can therefore be obtained from the returned dictionary with 
\f3\fs18 getValue()
\f4\fs20 , passing the index of the receiver.  The speed of this mode of operation will probably be similar to the speed of making 
\f3\fs18 N
\f4\fs20  separate non-vectorized calls to 
\f3\fs18 nearestNeighbors()
\f4\fs20 , when running single-threaded.  When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.  In this mode of operation, all receivers must belong to the same subpopulation.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Individual>)nearestNeighborsOfPoint(float\'a0point, io<Subpopulation>$\'a0exerterSubpop, [integer$\'a0count\'a0=\'a01])\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns up to 
\f3\fs18 count
\f4\fs20  individuals in 
\f3\fs18 exerterSubpop
\f4\fs20  that are spatially closest to 
\f3\fs18 point
\f4\fs20 , according to the distance metric of the 
\f3\fs18 InteractionType
\f4\fs20 .  The subpopulation may be supplied either as an 
\f3\fs18 integer
\f4\fs20  ID, or as a 
\f3\fs18 Subpopulation
\f4\fs20  object.  To obtain all of the individuals within the maximum interaction distance of 
\f3\fs18 point
\f4\fs20 , simply pass a value for 
\f3\fs18 count
\f4\fs20  that is greater than or equal to the size of 
\f3\fs18 exerterSubpop
\f4\fs20 .  Note that if fewer than 
\f3\fs18 count
\f4\fs20  individuals are within the maximum interaction distance, the vector returned may be shorter than 
\f3\fs18 count
\f4\fs20 , or even zero-length; it is important to check for this possibility even when requesting a single neighbor.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for 
\f3\fs18 exerterSubpop
\f4\fs20 , and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(integer)neighborCount(object<Individual>\'a0receivers, [No<Subpopulation>$\'a0exerterSubpop\'a0=\'a0NULL])\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the number of neighbors for each individual in 
\f3\fs18 receivers
\f4\fs20 , within the maximum interaction distance according to the distance metric of the 
\f3\fs18 InteractionType
\f4\fs20 , from among the individuals in 
\f3\fs18 exerterSubpop
\f4\fs20  (or, if that is 
\f3\fs18 NULL
\f4\fs20 , then from among all individuals in the receiver\'92s subpopulation).  All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\
This method is similar to 
\f3\fs18 nearestNeighbors()
\f4\fs20  (when passed a large count so as to guarantee that all neighbors are returned), but this method returns only a count of the individuals, not a vector containing the individuals.  This method may also be called in a vectorized fashion, with a non-singleton vector of individuals, unlike 
\f3\fs18 nearestNeighbors()
\f4\fs20 .\
Note that this method does not use interaction eligibility as a criterion; it will count neighbors that cannot exert an interaction upon a receiver (due to sex-segregation, e.g.).  (It still does not count a receiver as a neighbor of itself, however.)  If a count of only interacting neighbors is desired, use 
\f3\fs18 interactingNeighborCount()
\f4\fs20 .  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(integer$)neighborCountOfPoint(float\'a0point, io<Subpopulation>$\'a0exerterSubpop)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the number of individuals in 
\f3\fs18 exerterSubpop
\f4\fs20  that are within the maximum interaction distance according to the distance metric of the 
\f3\fs18 InteractionType
\f4\fs20 .  The subpopulation may be supplied either as an 
\f3\fs18 integer
\f4\fs20  ID, or as a 
\f3\fs18 Subpopulation
\f4\fs20  object.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for 
\f3\fs18 exerterSubpop
\f4\fs20 , and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
This method is similar to 
\f3\fs18 nearestNeighborsOfPoint()
\f4\fs20  (when passed a large count so as to guarantee that all neighbors are returned), but this method returns only a count of the individuals, not a vector containing the individuals.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)setInteractionFunction(string$\'a0functionType, ...)
\f5 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Set the function used to translate spatial distances into interaction strengths for an interaction type.  The 
\f3\fs18 functionType
\f4\fs20  may be 
\f3\fs18 "f"
\f4\fs20 , in which case the ellipsis 
\f3\fs18 ...
\f4\fs20  should supply a 
\f3\fs18 numeric$
\f4\fs20  fixed interaction strength; 
\f3\fs18 "l"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  maximum strength for a linear function; 
\f3\fs18 "e"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  maximum strength and a 
\f3\fs18 numeric$
\f4\fs20  lambda (rate) parameter for a negative exponential function; 
\f3\fs18 "n"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  maximum strength and a 
\f3\fs18 numeric$
\f4\fs20  sigma (standard deviation) parameter for a Gaussian function; 
\f3\fs18 "c"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  maximum strength and a 
\f3\fs18 numeric$
\f4\fs20  scale parameter for a Cauchy distribution function; or 
\f3\fs18 "t"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  maximum strength, a 
\f3\fs18 numeric$
\f4\fs20  degrees of freedom, and a 
\f3\fs18 numeric$
\f4\fs20  scale parameter for a 
\f1\i t
\f4\i0 -distribution function.  See section 25.8 above for discussions of these interaction functions.  Non-spatial interactions must use function type 
\f3\fs18 "f"
\f4\fs20 , since no distance values are available in that case.\
The interaction function for an interaction type is normally a constant in simulations; in any case, it cannot be changed when an interaction has already been evaluated, so either it should be set prior to evaluation, or 
\f3\fs18 unevaluate()
\f4\fs20  should be called first.
\f5 \cf0 \
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)strength(object<Individual>$\'a0receiver, [No<Individual>\'a0exerters\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector containing the interaction strengths exerted upon 
\f3\fs18 receiver
\f4\fs20  by the individuals in 
\f3\fs18 exerters
\f4\fs20 .  If 
\f3\fs18 exerters
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), then a vector of the interaction strengths exerted by all individuals in the subpopulation of 
\f3\fs18 receiver
\f4\fs20  (including 
\f3\fs18 receiver
\f4\fs20  itself, with a strength of 
\f3\fs18 0.0
\f4\fs20 ) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.  Otherwise, all individuals in 
\f3\fs18 exerters
\f4\fs20  must belong to a single subpopulation (but not necessarily the same subpopulation as 
\f3\fs18 receiver
\f4\fs20 ).  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\
If the strengths of interactions exerted by a single individual upon multiple individuals are needed instead (the inverse of what this method provides), multiple calls to this method will be necessary, one per pairwise interaction queried; the interaction engine is not optimized for the inverse case, and so it will likely be quite slow to compute.  If the interaction is reciprocal and sex-symmetric, the opposite query should provide identical results in a single efficient call (because then the interactions exerted are equal to the interactions received); otherwise, the best approach might be to define a second interaction type representing the inverse interaction that you wish to be able to query efficiently.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)totalOfNeighborStrengths(object<Individual>\'a0receivers, [No<Subpopulation>$\'a0exerterSubpop\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector of the total interaction strength felt by each individual in 
\f3\fs18 receivers
\f4\fs20  by the exerters in 
\f3\fs18 exerterSubpop
\f4\fs20  (or, if that is 
\f3\fs18 NULL
\f4\fs20 , then by all individuals in the receiver\'92s subpopulation).  The 
\f3\fs18 receivers
\f4\fs20  parameter does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.  All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.  The 
\f3\fs18 evaluate()
\f4\fs20  method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.  If the 
\f3\fs18 InteractionType
\f4\fs20  is non-spatial, this method may not be called.\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf2 For one individual, this is essentially the same as calling 
\f3\fs18 nearestInteractingNeighbors()
\f4\fs20  with a large 
\f3\fs18 count
\f4\fs20  so as to obtain the complete vector of all interacting neighbors, calling 
\f3\fs18 strength()
\f4\fs20  for each of those interactions to get each interaction strength, and adding those interaction strengths together with 
\f3\fs18 sum()
\f4\fs20 .  This method is much faster than that implementation, however, since all of that work is done as a single operation.  Also, 
\f3\fs18 totalOfNeighborStrengths()
\f4\fs20  can total up interactions for more than one receiver in a single call.\
Similarly, for one individual this is essentially the same as calling 
\f3\fs18 strength()
\f4\fs20  to get the interaction strengths between a receiver and all individuals in the exerter subpopulation, and then calling 
\f3\fs18 sum()
\f4\fs20 .  Again, this method should be much faster, since this algorithm looks only at neighbors, whereas calling 
\f3\fs18 strength()
\f4\fs20  directly assesses interaction strengths with all other individuals.  This will make a particularly large difference when the subpopulation size is large and the maximum distance of the 
\f3\fs18 InteractionType
\f4\fs20  is small.\
See 
\f3\fs18 localPopulationDensity()
\f4\fs20  for a related method that calculates the total interaction strength divided by the amount of \'93interaction field\'94 present for an individual (i.e., the integral of the interaction function clipped to the spatial bounds of the subpopulation) to provide an estimate of the \'93interaction density\'94 felt by an individual.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)unevaluate(void)
\f5 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
Discards all evaluation of this interaction, for all subpopulations.  The state of the 
\f3\fs18 InteractionType
\f4\fs20  is reset to a state prior to evaluation.  This can be useful if the model state has changed in such a way that the evaluation already conducted is no longer valid.  For example, if the maximum distance or the interaction function of the 
\f3\fs18 InteractionType
\f4\fs20  need to be changed with immediate effect, or if the data used by an 
\f3\fs18 interaction()
\f4\fs20  callback has changed in such a way that previously calculated interaction strengths are no longer correct, 
\f3\fs18 unevaluate()
\f4\fs20  allows the interaction to begin again from scratch.\
In WF models, all interactions are automatically reset to an unevaluated state at the moment when the new offspring generation becomes the parental generation (at step 4 in the tick cycle).\
In nonWF models, all interactions are automatically reset to an unevaluated state twice per tick: immediately after 
\f3\fs18 reproduction()
\f4\fs20  callbacks have completed (after step 1 in the tick cycle), and immediately before viability/survival selection (before step 4 in the tick cycle).\
Given this automatic invalidation, most simulations have no reason to call 
\f3\fs18 unevaluate()
\f4\fs20 .\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 \kerning1\expnd0\expndtw0 5.9  Class LogFile\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf2 5.9.1  
\f2\fs18 LogFile
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 filePath => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The path of the log file being written to.  This may be changed with 
\f3\fs18 setFilePath()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 logInterval => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The interval for automatic logging; a new row of data will be logged every 
\f3\fs18 logInterval
\f4\fs20  ticks.  This may be changed with 
\f3\fs18 setLogInterval()
\f4\fs20 .  If automatic logging has been disabled, this property will be 
\f3\fs18 0
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 precision <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The precision of 
\f3\fs18 float
\f4\fs20  output.  To be exact, 
\f3\fs18 precision
\f4\fs20  specifies the preferred number of significant digits that will be output for 
\f3\fs18 float
\f4\fs20  values.  The default is 
\f3\fs18 6
\f4\fs20 ; values in [
\f3\fs18 1
\f4\fs20 ,
\f3\fs18 22
\f4\fs20 ] are legal, but 
\f3\fs18 17
\f4\fs20  is probably the largest value that makes sense given the limits of double-precision floating point.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.9.2  
\f2\fs18 LogFile
\f1\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(void)addCustomColumn(string$\'a0columnName, string$\'a0source, [*\'a0context\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column with its name provided by 
\f3\fs18 columnName
\f4\fs20 .  The value for the column, when a given row is generated, will be produced by the code supplied in 
\f3\fs18 source
\f4\fs20 , which is expected to return either 
\f3\fs18 NULL
\f4\fs20  (which will write out 
\f3\fs18 NA
\f4\fs20 ), or a singleton value of any non-object type.\
The 
\f3\fs18 context
\f4\fs20  parameter will be set up as a pseudo-parameter, named 
\f3\fs18 context
\f4\fs20 , when 
\f3\fs18 source
\f4\fs20  is called, allowing the same source code to be used to generate values for multiple data columns; you might, for example, provide the particular 
\f3\fs18 Subpopulation
\f4\fs20  object here that you wish 
\f3\fs18 source
\f4\fs20  to use for its calculations.  This is optional; if the default value of 
\f3\fs18 NULL
\f4\fs20  is used, then 
\f3\fs18 context
\f4\fs20  will be 
\f3\fs18 NULL
\f4\fs20  when 
\f3\fs18 source
\f4\fs20  is called.\
See 
\f3\fs18 addMeanSDColumns()
\f4\fs20  for a useful variant.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addCycle([No<Species>$\'a0species\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column that provides the cycle counter for 
\f3\fs18 species
\f4\fs20  (the same as the value of the 
\f3\fs18 cycle
\f4\fs20  property of that species).  In single-species models, 
\f3\fs18 species
\f4\fs20  may be 
\f3\fs18 NULL
\f4\fs20  to indicate that single species.  The column will simply be named 
\f3\fs18 cycle
\f4\fs20  in single-species models; an underscore and the name of the species will be appended in multispecies models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addCycleStage(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column that provides the cycle stage, named 
\f3\fs18 cycle_stage
\f4\fs20 .  The stage is provided as a 
\f3\fs18 string
\f4\fs20 , and will typically be 
\f3\fs18 "first"
\f4\fs20 , 
\f3\fs18 "early"
\f4\fs20 , 
\f3\fs18 "late"
\f4\fs20 , or 
\f3\fs18 "end"
\f4\fs20  (the latter used for the point in time at which end-of-tick automatic logging occurs).  Other possible values are discussed in the documentation for the 
\f3\fs18 cycleStage
\f4\fs20  property of 
\f3\fs18 Community
\f4\fs20 , which this column reflects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addKeysAndValuesFrom(object$\'a0source)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This 
\f3\fs18 Dictionary
\f4\fs20  method has an override in 
\f3\fs18 LogFile
\f4\fs20  to make it illegal to call, since 
\f3\fs18 LogFile
\f4\fs20  manages its 
\f3\fs18 Dictionary
\f4\fs20  entries.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addMeanSDColumns(string$\'a0columnName, string$\'a0source, [*\'a0context\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds two new data columns with names of 
\f3\fs18 columnName_mean
\f4\fs20  and 
\f3\fs18 columnName_sd
\f4\fs20 .  When a given row is generated, the code supplied in 
\f3\fs18 source
\f4\fs20  is expected to return either a zero-length vector of any type including 
\f3\fs18 NULL
\f4\fs20  (which will write out 
\f3\fs18 NA
\f4\fs20  to both columns), or a non-zero-length vector of 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  values.  In the latter case, the result vector will be summarized in the two columns by its mean and standard deviation respectively.  If the result vector has exactly one value, the standard deviation will be written as 
\f3\fs18 NA
\f4\fs20 .  The 
\f3\fs18 context
\f4\fs20  parameter is set up as a pseudo-parameter when 
\f3\fs18 source
\f4\fs20  is called, as described in 
\f3\fs18 addCustomColumn()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addPopulationSexRatio([No<Species>$\'a0species\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column that provides the population sex ratio M:(M+F) for 
\f3\fs18 species
\f4\fs20 .  In single-species models, 
\f3\fs18 species
\f4\fs20  may be 
\f3\fs18 NULL
\f4\fs20  to indicate that single species.  The column will simply be named 
\f3\fs18 sex_ratio
\f4\fs20  in single-species models; an underscore and the name of the species will be appended in multispecies models.  If the species is hermaphroditic, 
\f3\fs18 NA
\f4\fs20  will be written.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addPopulationSize([No<Species>$\'a0species\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column that provides the total population size for 
\f3\fs18 species
\f4\fs20 .  In single-species models, 
\f3\fs18 species
\f4\fs20  may be 
\f3\fs18 NULL
\f4\fs20  to indicate that single species.  The column will simply be named 
\f3\fs18 num_individuals
\f4\fs20  in single-species models; an underscore and the name of the species will be appended in multispecies models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addSubpopulationSexRatio(io<Subpopulation>$\'a0subpop)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column that provides the sex ratio M:(M+F) of the subpopulation 
\f3\fs18 subpop
\f4\fs20 , named 
\f3\fs18 pX_sex_ratio
\f4\fs20 .  If the subpopulation exists but has a size of zero, 
\f3\fs18 NA
\f4\fs20  will be written.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addSubpopulationSize(io<Subpopulation>$\'a0subpop)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column that provides the size of the subpopulation 
\f3\fs18 subpop
\f4\fs20 , named 
\f3\fs18 pX_num_individuals
\f4\fs20 .  If the subpopulation exists but has a size of zero, 
\f3\fs18 0
\f4\fs20  will be written.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addSuppliedColumn(string$\'a0columnName)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column with its name provided by 
\f3\fs18 columnName
\f4\fs20 .  The value for the column is initially undefined, and will be written as 
\f3\fs18 NA
\f4\fs20 .  A different value may (optionally) be provided by calling 
\f3\fs18 setSuppliedValue()
\f4\fs20  with a value for 
\f3\fs18 columnName
\f4\fs20 .  That value will be used for the column the next time a row is generated (whether automatically or by a call to 
\f3\fs18 logRow()
\f4\fs20 ), and the column\'92s value will subsequently be undefined again.  In other words, for any given logged row the default of 
\f3\fs18 NA
\f4\fs20  may be kept, or a different value may be supplied.  This allows the value for the column to be set at any point during the tick cycle, which can be convenient if the column\'92s value depends upon transient state that is no longer available at the time the row is logged.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addTick(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds a new data column, named 
\f3\fs18 tick
\f4\fs20 , that provides the tick number for the simulation.
\f3\fs18 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0
\cf2 \'96\'a0(void)clearKeysAndValues(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This 
\f3\fs18 Dictionary
\f4\fs20  method has an override in 
\f3\fs18 LogFile
\f4\fs20  to make it illegal to call, since 
\f3\fs18 LogFile
\f4\fs20  manages its 
\f3\fs18 Dictionary
\f4\fs20  entries.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)flush(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Flushes all buffered data to the output file, synchronously.  This will make the contents of the file on disk be up-to-date with the running simulation.  Flushing frequently may entail a small performance penalty.  More importantly, if 
\f3\fs18 .gz
\f4\fs20  compression has been requested with 
\f3\fs18 compress=T
\f4\fs20  the size of the resulting file will be larger \'96 potentially much larger \'96 if 
\f3\fs18 flush()
\f4\fs20  is called frequently.  Note that automatic periodic flushing can be requested with the 
\f3\fs18 flushInterval
\f4\fs20  parameter to 
\f3\fs18 createLogFile()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)logRow(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This logs a new row of data, by evaluating all of the generators added to the 
\f3\fs18 LogFile
\f4\fs20  with 
\f3\fs18 add...()
\f4\fs20  calls.  Note that the new row may be buffered, and thus may not be written out to disk immediately; see 
\f3\fs18 flush()
\f4\fs20 .  This method may be used instead of, or in conjunction with, automatic logging.\
You can get the 
\f3\fs18 LogFile
\f4\fs20  instance, in order to call 
\f3\fs18 logRow()
\f4\fs20  on it, from 
\f3\fs18 community.logFiles
\f4\fs20 , or you can remember it in a global constant with 
\f3\fs18 defineConstant()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)setLogInterval([Ni$\'a0logInterval\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Sets the automatic logging interval.  A 
\f3\fs18 logInterval
\f4\fs20  of 
\f3\fs18 NULL
\f4\fs20  stops automatic logging immediately.  Other values request that a new row should be logged (as if 
\f3\fs18 logRow()
\f4\fs20  were called) at the end of every 
\f3\fs18 logInterval
\f4\fs20  ticks (just before the tick count increment, in both WF and nonWF models), starting at the end of the tick in which 
\f3\fs18 setLogInterval()
\f4\fs20  was called.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)setFilePath(string$\'a0filePath, [Ns\'a0initialContents\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F], [Nl$\'a0compress\'a0=\'a0NULL], [Ns$\'a0sep\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Redirects the 
\f3\fs18 LogFile
\f4\fs20  to write new rows to a new 
\f3\fs18 filePath
\f4\fs20 .  Any rows that have been buffered but not flushed will be written to the previous file first, as if 
\f3\fs18 flush()
\f4\fs20  had been called.  With this call, new 
\f3\fs18 initialContents
\f4\fs20  may be supplied, which will either replace any existing file or will be appended to it, depending upon the value of 
\f3\fs18 append
\f4\fs20 .  New values may be supplied for 
\f3\fs18 compress
\f4\fs20  and 
\f3\fs18 sep
\f4\fs20 ; the meaning of these parameters is identical to their meaning in 
\f3\fs18 createLogFile()
\f4\fs20 , except that a value of 
\f3\fs18 NULL
\f4\fs20  for these means \'93do not change this setting from its previous value\'94.  In effect, then, this method lets you start a completely new log file at a new path, without having to create and configure a new 
\f3\fs18 LogFile
\f4\fs20  object.  The new file will be created (or appended) synchronously, with the specified initial contents.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)setSuppliedValue(string$\'a0columnName, +$\'a0value)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Registers a value, passed in 
\f3\fs18 value
\f4\fs20 , to be used for the supplied column named 
\f3\fs18 columnName
\f4\fs20  when a row is next logged.  This column must have been added with 
\f3\fs18 addSuppliedColumn()
\f4\fs20 .  A value of 
\f3\fs18 NULL
\f4\fs20  may be passed to log 
\f3\fs18 NA
\f4\fs20 , but logging 
\f3\fs18 NA
\f4\fs20  is the default behavior for supplied columns in any case.  Otherwise, the value must be a singleton, and its type should match the values previously supplied for the column (otherwise the log file may be difficult to parse, since the values within the column will not be of one consistent type).  See 
\f3\fs18 addSuppliedColumn()
\f4\fs20  for further details.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)setValue(is$\'a0key, *\'a0value)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This 
\f3\fs18 Dictionary
\f4\fs20  method has an override in 
\f3\fs18 LogFile
\f4\fs20  to make it illegal to call, since 
\f3\fs18 LogFile
\f4\fs20  manages its 
\f3\fs18 Dictionary
\f4\fs20  entries.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(logical$)willAutolog(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns 
\f3\fs18 T
\f4\fs20  if the log file is configured to log a new row automatically at the end of the current tick; otherwise, returns 
\f3\fs18 F
\f4\fs20 .  This is useful for calculating a value that will be logged only in ticks when the value is needed.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.10  Class Mutation\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.10.1  
\f2\fs18 Mutation
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier for this mutation.  Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run.  These identifiers are not re-used during a run, except that if a population file is loaded from disk, the loaded mutations will receive their original identifier values as saved in the population file.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 isFixed => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 T
\f4\fs20  if the mutation has fixed (in the SLiM sense of having been converted to a 
\f3\fs18 Substitution
\f4\fs20  object), 
\f3\fs18 F
\f4\fs20  otherwise.  Since fixed/substituted mutations are removed from the simulation, you will only see this flag be 
\f3\fs18 T
\f4\fs20  if you have held onto a mutation beyond its usual lifetime.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 isSegregating => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 T
\f4\fs20  if the mutation is segregating (in the SLiM sense of not having been either lost or converted to a 
\f3\fs18 Substitution
\f4\fs20  object), 
\f3\fs18 F
\f4\fs20  otherwise.  Since both lost and fixed/substituted mutations are removed from the simulation, you will only see this flag be 
\f3\fs18 F
\f4\fs20  if you have held onto a mutation beyond its usual lifetime.  Note that if 
\f3\fs18 isSegregating
\f4\fs20  is 
\f3\fs18 F
\f4\fs20 , 
\f3\fs18 isFixed
\f4\fs20  will let you determine whether the mutation is no longer segregating because it was lost, or because it fixed.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutationType => (object<MutationType>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 MutationType
\f4\fs20  from which this mutation was drawn.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
nucleotide <\'96> (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A 
\f3\fs18 string
\f4\fs20  representing the nucleotide associated with this mutation; this will be 
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "C"
\f4\fs20 , 
\f3\fs18 "G"
\f4\fs20 , or 
\f3\fs18 "T"
\f4\fs20 .  If the mutation is not nucleotide-based, this property is unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 nucleotideValue <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 An 
\f3\fs18 integer
\f4\fs20  representing the nucleotide associated with this mutation; this will be 
\f3\fs18 0
\f4\fs20  (A), 
\f3\fs18 1
\f4\fs20  (C), 
\f3\fs18 2
\f4\fs20  (G), or 
\f3\fs18 3
\f4\fs20  (T).  If the mutation is not nucleotide-based, this property is unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 originTick => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The tick in which this mutation arose.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 position => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The position in the chromosome of this mutation.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 selectionCoeff => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The selection coefficient of the mutation, drawn from the distribution of fitness effects of its 
\f3\fs18 MutationType
\f5\fs20 .
\f4 \cf2 \expnd0\expndtw0\kerning0
  If a mutation has a 
\f3\fs18 selectionCoeff
\f4\fs20  of 
\f1\i s
\f4\i0 , the multiplicative fitness effect of the mutation in a homozygote is 1+
\f1\i s
\f4\i0 ; in a heterozygote it is 1+
\f1\i hs
\f4\i0 , where 
\f1\i h
\f4\i0  is the dominance coefficient kept by the mutation type.
\f5 \cf0 \kerning1\expnd0\expndtw0 \

\f4 Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.  This means that if you set a mutation 
\f3\fs18 mut
\f4\fs20 \'92s selection coefficient to some number 
\f3\fs18 x
\f4\fs20 , 
\f3\fs18 mut.selectionCoeff==x
\f4\fs20  may be 
\f3\fs18 F
\f4\fs20  due to floating-point rounding error.  Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.  Instead, it is recommended to use the 
\f3\fs18 id
\f4\fs20  or 
\f3\fs18 tag
\f4\fs20  properties to identify particular mutations.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 subpopID <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier of the subpopulation in which this mutation arose.  This property can be used to track the ancestry of mutations through their subpopulation of origin.\
If you don\'92t care which subpopulation a mutation originated in, the 
\f3\fs18 subpopID
\f4\fs20  may be used as an arbitrary 
\f3\fs18 integer
\f4\fs20  \'93tag\'94 value for any purpose you wish; SLiM does not do anything with the value of 
\f3\fs18 subpopID
\f4\fs20  except propagate it to 
\f3\fs18 Substitution
\f4\fs20  objects and report it in output.  (It must still be 
\f3\fs18 >= 0
\f4\fs20 , however, since SLiM object identifiers are limited to nonnegative integers).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.10.2  
\f2\fs18 Mutation
\f1\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 \'96\'a0(void)setMutationType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the mutation type of the mutation to 
\f3\fs18 mutType
\f4\fs20  (which may be specified as either an 
\f3\fs18 integer
\f4\fs20  identifier or a 
\f3\fs18 MutationType
\f4\fs20  object).  This implicitly changes the dominance coefficient of the mutation to that of the new mutation type, since the dominance coefficient is a property of the mutation type.  On the other hand, the selection coefficient of the mutation is not changed, since it is a property of the mutation object itself; it can be changed explicitly using the 
\f3\fs18 setSelectionCoeff()
\f4\fs20  method if so desired.\
The mutation type of a mutation is normally a constant in simulations, so be sure you know what you are doing.  Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In nucleotide-based models, a restriction applies: nucleotide-based mutations may not be changed to a non-nucleotide-based mutation type, and non-nucleotide-based mutations may not be changed to a nucleotide-based mutation type.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)setSelectionCoeff(float$\'a0selectionCoeff)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the selection coefficient of the mutation to 
\f3\fs18 selectionCoeff
\f4\fs20 .  The selection coefficient will be changed for all individuals that possess the mutation, since they all share a single 
\f3\fs18 Mutation
\f4\fs20  object (note that the dominance coefficient will remain unchanged, as it is determined by the mutation type).\
This is normally a constant in simulations, so be sure you know what you are doing; often setting up a 
\f3\fs18 mutationEffect()
\f4\fs20  callback is preferable, in order to modify the selection coefficient in a more limited and controlled fashion.  Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.11  Class MutationType\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.11.1  
\f2\fs18 MutationType
\f1\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 color <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The color used to display mutations of this type in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f3\fs18 "#RRGGBB"
\f4\fs20 .  If 
\f3\fs18 color
\f4\fs20  is the empty string, 
\f3\fs18 ""
\f4\fs20 , SLiMgui\'92s default (selection-coefficient\'96based) color scheme is used; this is the default for new 
\f3\fs18 MutationType
\f4\fs20  objects.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 colorSubstitution <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The color used to display substitutions of this type in SLiMgui (see the discussion for the 
\f3\fs18 colorSubstitution
\f4\fs20  property of the 
\f3\fs18 Chromosome
\f4\fs20  class for details).  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f3\fs18 "#RRGGBB"
\f4\fs20 .  If 
\f3\fs18 colorSubstitution
\f4\fs20  is the empty string, 
\f3\fs18 ""
\f4\fs20 , SLiMgui\'92s default (selection-coefficient\'96based) color scheme is used; this is the default for new 
\f3\fs18 MutationType
\f4\fs20  objects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 convertToSubstitution <\'96> (logical$)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
This property governs whether mutations of this mutation type will be converted to 
\f3\fs18 Substitution
\f4\fs20  objects when they reach fixation.\
In WF models this property is 
\f3\fs18 T
\f4\fs20  by default, since conversion to 
\f3\fs18 Substitution
\f4\fs20  objects provides large speed benefits; it should be set to 
\f3\fs18 F
\f4\fs20  only if necessary, and only on the mutation types for which it is necessary.  This might be needed, for example, if you are using a 
\f3\fs18 mutationEffect()
\f4\fs20  callback to implement an epistatic relationship between mutations; a mutation epistatically influencing the fitness of other mutations through a 
\f3\fs18 mutationEffect()
\f4\fs20  callback would need to continue having that influence even after reaching fixation, but if the simulation were to replace the fixed mutation with a 
\f3\fs18 Substitution
\f4\fs20  object the mutation would no longer be considered in fitness calculations (unless the callback explicitly consulted the list of 
\f3\fs18 Substitution
\f4\fs20  objects kept by the simulation).  Other script-defined behaviors in 
\f3\fs18 mutationEffect()
\f4\fs20 , 
\f3\fs18 interaction()
\f4\fs20 , 
\f3\fs18 mateChoice()
\f4\fs20 , 
\f3\fs18 modifyChild()
\f4\fs20 , and 
\f3\fs18 recombination()
\f4\fs20  callbacks might also necessitate the disabling of substitution for a given mutation type; this is an important consideration to keep in mind.\
In contrast, for nonWF models this property is 
\f3\fs18 F
\f4\fs20  by default, because even mutations with no epistatis or other indirect fitness effects will continue to influence the survival probabilities of individuals.  For nonWF models, only neutral mutation types with no epistasis or other side effects can safely be converted to substitutions upon fixation.  When such a pure-neutral mutation type is defined in a nonWF model, this property should be set to 
\f3\fs18 T
\f4\fs20  to tell SLiM that substitution is allowed; this may have very large positive effects on performance, so it is important to remember when modeling background neutral mutations.\
SLiM consults this flag at the end of each tick when deciding whether to substitute each fixed mutation.  If this flag is 
\f3\fs18 T
\f4\fs20 , all eligible fixed mutations will be converted at the end of the current tick, even if they were previously left unconverted because of the previous value of the flag.  Setting this flag to 
\f3\fs18 F
\f4\fs20  will prevent future substitutions, but will not cause any existing 
\f3\fs18 Substitution
\f4\fs20  objects to be converted back into 
\f3\fs18 Mutation
\f4\fs20  objects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 distributionParams => (fs)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The parameters that configure the chosen distribution of fitness effects.  This will be of type 
\f3\fs18 string
\f4\fs20  for DFE type 
\f3\fs18 "s"
\f4\fs20 , and type 
\f3\fs18 float
\f4\fs20  for all other DFE types.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 distributionType => (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The type of distribution of fitness effects; one of 
\f3\fs18 "f"
\f4\fs20 , 
\f3\fs18 "g"
\f5\fs20 ,
\f4  
\f3\fs18 "e"
\f5\fs20 ,
\f4  
\f3\fs18 "n"
\f5\fs20 ,
\f4  
\f3\fs18 "w"
\f5\fs20 ,
\f4  or 
\f3\fs18 "s"
\f5\fs20 :\

\f3\fs18 "f"
\f4\fs22  \'96 A 
\f0\b f
\f4\b0 ixed fitness effect.  This DFE type has a single parameter, the selection coefficient 
\f1\i s
\f4\i0  to be used by all mutations of the mutation type.\

\f3\fs18 "g"
\f4\fs22  \'96 A 
\f0\b g
\f4\b0 amma-distributed fitness effect.  This DFE type is specified by two parameters, a shape parameter and a mean value.  The gamma distribution from which mutations are drawn is given by the probability density function 
\f6\i P
\f5\i0 (
\f6\i s
\f5\i0 \'a0|\'a0
\f8\i \uc0\u945 
\f5\i0 ,
\f8\i \uc0\u946 
\f5\i0 )\'a0
\f9 = [\uc0\u915 (
\f8\i \uc0\u945 
\f5\i0 )
\f8\i \uc0\u946 \u945 
\f5\i0 ]\super \uc0\u8722 1\nosupersub exp(\uc0\u8722 
\f6\i s
\f5\i0 /
\f8\i \uc0\u946 
\f5\i0 )
\f4 , where 
\f8\i \uc0\u945 
\f4\i0  is the shape parameter, and the specified mean for the distribution is equal to 
\f8\i \uc0\u945 \u946 
\f4\i0 .  Note that this parameterization is the same as for the Eidos function 
\f3\fs18 rgamma()
\f4\fs22 .  A gamma distribution is often used to model deleterious mutations at functional sites.\

\f3\fs18 "e"
\f4\fs22  \'96 An 
\f0\b e
\f4\b0 xponentially-distributed fitness effect.  This DFE type is specified by a single parameter, the mean of the distribution.  The exponential distribution from which mutations are drawn is given by the probability density function 
\f6\i P
\f5\i0 (
\f6\i s
\f5\i0 \'a0|\'a0
\f8\i \uc0\u946 
\f5\i0 )\'a0= 
\f8\i \uc0\u946 
\f5\i0 \super \uc0\u8722 1\nosupersub exp(\uc0\u8722 
\f6\i s
\f5\i0 /
\f8\i \uc0\u946 
\f5\i0 )
\f4 , where 
\f8\i \uc0\u946 
\f4\i0  is the specified mean for the distribution.  This parameterization is the same as for the Eidos function 
\f3\fs18 rexp()
\f4\fs22 .  An exponential distribution is often used to model beneficial mutations.\

\f3\fs18 "n"
\f4\fs22  \'96 A 
\f0\b n
\f4\b0 ormally-distributed fitness effect.  This DFE type is specified by two parameters, a mean and a standard deviation.  The normal distribution from which mutations are drawn is given by the probability density function 
\f6\i P
\f5\i0 (
\f6\i s
\f5\i0 \'a0|\'a0
\f8\i \uc0\u956 
\f5\i0 ,
\f8\i \uc0\u963 
\f5\i0 )\'a0= (2
\f9 \uc0\u960 
\f8\i \uc0\u963 
\f5\i0 \super 2\nosupersub )\super \uc0\u8722 1/2\nosupersub exp(\uc0\u8722 (
\f6\i s
\f5\i0 \uc0\u8722 
\f8\i \uc0\u956 
\f5\i0 )\super 2\nosupersub /2
\f8\i \uc0\u963 
\f5\i0 \super 2\nosupersub )
\f4 , where 
\f8\i \uc0\u956 
\f4\i0  is the mean and 
\f8\i \uc0\u963 
\f4\i0  is the standard deviation.  This parameterization is the same as for the Eidos function 
\f3\fs18 rnorm()
\f4\fs22 .  A normal distribution is often used to model mutations that can be either beneficial or deleterious, since both tails of the distribution are unbounded.\

\f3\fs18 "w"
\f4\fs22  \'96 A 
\f0\b W
\f4\b0 eibull-distributed fitness effect.  This DFE type is specified by a scale parameter and a shape parameter.  The Weibull distribution from which mutations are drawn is given by the probability density function 
\f6\i P
\f5\i0 (
\f6\i s
\f5\i0 \'a0|\'a0
\f8\i \uc0\u955 
\f5\i0 ,
\f6\i k
\f5\i0 )\'a0= (
\f6\i k
\f5\i0 /
\f8\i \uc0\u955 
\f6 \super k
\f5\i0 \nosupersub )
\f6\i s\super k
\f5\i0 \uc0\u8722 1\nosupersub exp(\uc0\u8722 (
\f6\i s
\f5\i0 /
\f8\i \uc0\u955 
\f5\i0 )
\f6\i \super k
\f5\i0 \nosupersub )
\f4 , where 
\f8\i \uc0\u955 
\f4\i0  is the scale parameter and 
\f6\i k
\f4\i0  is the shape parameter.  This parameterization is the same as for the Eidos function 
\f3\fs18 rweibull()
\f4\fs22 .  A Weibull distribution is often used to model mutations following extreme-value theory.\

\f3\fs18 "s"
\f4\fs22  \'96 A 
\f0\b s
\f4\b0 cript-based fitness effect.  This DFE type is specified by a script parameter of type 
\f3\fs18 string
\f4\fs22 , specifying an Eidos script to be executed to produce each new selection coefficient.  For example, the script 
\f3\fs18 "return rbinom(1);"
\f4\fs22  could be used to generate selection coefficients drawn from a binomial distribution, using the Eidos function 
\f3\fs18 rbinom()
\f4\fs22 , even though that mutational distribution is not supported by SLiM directly.  The script must return a singleton float or integer.\
Note that these distributions can in principle produce selection coefficients smaller than 
\f3\fs18 -1.0. 
\f4\fs22 In that case
\f5 ,
\f4  the mutations will be evaluated as \'93lethal\'94 by SLiM, and the relative fitness of the individual will be set to 
\f3\fs18 0.0
\f5\fs22 .
\fs20 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 dominanceCoeff <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The dominance coefficient used for mutations of this type when heterozygous.  Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
Note that the dominance coefficient is not bounded.  A dominance coefficient greater than 
\f3\fs18 1.0
\f4\fs20  may be used to achieve an overdominance effect.  By making the selection coefficient very small and the dominance coefficient very large, an overdominance scenario in which both homozygotes have the same fitness may be approximated, to a nearly arbitrary degree of precision.\
Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.  This means that if you set a mutation type 
\f3\fs18 muttype
\f4\fs20 \'92s dominance coefficient to some number 
\f3\fs18 x
\f4\fs20 , 
\f3\fs18 muttype.dominanceCoeff==x
\f4\fs20  may be 
\f3\fs18 F
\f4\fs20  due to floating-point rounding error.  Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.  Instead, it is recommended to use the 
\f3\fs18 id
\f4\fs20  or 
\f3\fs18 tag
\f4\fs20  properties to identify particular mutation types.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 haploidDominanceCoeff\cf0  <\cf2 \'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The dominance coefficient used for mutations of this type when they occur opposite a null genome (as in sex-chromosome models and models involving haploids).  This defaults to 
\f3\fs18 1.0
\f4\fs20 , and is used only in models where null genomes are present; the 
\f3\fs18 dominanceCoeff
\f4\fs20  property is the dominance coefficient used in most circumstances.  Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the 
\f3\fs18 Species
\f4\fs20  method 
\f3\fs18 recalculateFitness()
\f4\fs20  \'96 but see the documentation of that method for caveats.\
As with the 
\f3\fs18 dominanceCoeff
\f4\fs20  property, this is stored internally using a single-precision float; see the documentation for 
\f3\fs18 dominanceCoeff
\f4\fs20  for discussion.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier for this mutation type; for mutation type 
\f3\fs18 m3
\f4\fs20 , for example, this is 
\f3\fs18 3
\f5\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutationStackGroup <\'96> (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The group into which this mutation type belongs for purposes of mutation stacking policy.  This is equal to the mutation type\'92s 
\f3\fs18 id
\f4\fs20  by default.  See 
\f3\fs18 mutationStackPolicy
\f4\fs20 , below, for discussion.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In nucleotide-based models, the stacking group for nucleotide-based mutation types is always 
\f3\fs18 -1
\f4\fs20 , and cannot be changed.  Non-nucleotide-based mutation types may also be set to share the 
\f3\fs18 -1
\f4\fs20  stacking group, if they should participate in the same stacking policy as nucleotide-based mutations, but that would be quite unusual.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationStackPolicy <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 This property and the 
\f3\fs18 mutationStackGroup
\f4\fs20  property together govern whether mutations of this mutation type\'92s stacking group can \'93stack\'94 \'96 can occupy the same position in a single individual.  A set of mutation types with the same value for 
\f3\fs18 mutationStackGroup
\f4\fs20  is called a \'93stacking group\'94, and all mutation types in a given stacking group must have the same 
\f3\fs18 mutationStackPolicy
\f4\fs20  value, which defines the stacking behavior of all mutations of the mutation types in the stacking group.  In other words, one stacking group might allow its mutations to stack, while another stacking group might not, but the policy within each stacking group must be unambiguous.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
This property is 
\f3\fs18 "s"
\f4\fs20  by default, indicating that mutations in this stacking group should be allowed to stack without restriction.  If the policy is set to 
\f3\fs18 "f"
\f4\fs20 , the 
\f1\i first
\f4\i0  mutation of stacking group at a given site is retained; further mutations of this stacking group at the same site are discarded with no effect.  This can be useful for modeling one-way changes; once a gene is disabled by a premature stop codon, for example, you might wish to assume, for simplicity, that further mutations cannot alter that fact.  If the policy is set to 
\f3\fs18 "l"
\f4\fs20 , the 
\f1\i last
\f4\i0  mutation of this stacking group at a given site is retained; earlier mutation of this stacking group at the same site are discarded.  This can be useful for modeling an \'93infinite-alleles\'94 scenario in which every new mutation at a site generates a completely new allele, rather than retaining the previous mutations at the site.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 The mutation stacking policy applies only within the given mutation type\'92s stacking group; mutations of different stacking groups are always allowed to stack in SLiM.  The policy applies to all mutations added to the model after the policy is set, whether those mutations are introduced by calls such as 
\f3\fs18 addMutation()
\f4\fs20 , 
\f3\fs18 addNewMutation()
\f4\fs20 , or 
\f3\fs18 addNewDrawnMutation()
\f4\fs20 , or are added by SLiM\'92s own mutation-generation machinery.  However, no attempt is made to enforce the policy for mutations already existing at the time the policy is set; typically, therefore, the policy is set in an 
\f3\fs18 initialize()
\f4\fs20  callback so that it applies throughout the simulation.  The policy is also not enforced upon the mutations loaded from a file with 
\f3\fs18 readFromPopulationFile()
\f4\fs20 ; such mutations were governed by whatever stacking policy was in effect when the population file was generated.
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 \expnd0\expndtw0\kerning0
In nucleotide-based models, the stacking policy for nucleotide-based mutation types is always 
\f3\fs18 "l"
\f4\fs20 , and cannot be changed.  This ensures that new nucleotide mutations always replace the previous nucleotide at a site, and that more than one nucleotide mutation is never present at the same position in a single genome.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 nucleotideBased => (logical$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If the mutation type was created with 
\f3\fs18 initializeMutationType()
\f4\fs20 , it is not nucleotide-based, and this property is 
\f3\fs18 F
\f4\fs20 .  If it was created with 
\f3\fs18 initializeMutationTypeNuc()
\f4\fs20 , it is nucleotide-based, and this property is 
\f3\fs18 T
\f4\fs20 .  See those methods for further discussion.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 species => (object<Species>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The species to which the target object belongs.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to mutation types.
\f5 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.11.2  
\f2\fs18 MutationType
\f1\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(float)drawSelectionCoefficient([integer$\'a0n\'a0=\'a01])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Draws and returns a vector of 
\f3\fs18 n
\f4\fs20  selection coefficients using the currently defined distribution of fitness effects (DFE) for the target mutation type.  If the DFE is type 
\f3\fs18 "s"
\f4\fs20 , this method will result in synchronous execution of the DFE\'92s script.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)setDistribution(string$\'a0distributionType, ...)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the distribution of fitness effects for a mutation type.  The 
\f3\fs18 distributionType
\f4\fs20  may be 
\f3\fs18 "f"
\f4\fs20 , in which case the ellipsis 
\f3\fs18 ...
\f4\fs20  should supply a 
\f3\fs18 numeric$
\f4\fs20  fixed selection coefficient; 
\f3\fs18 "e"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  mean selection coefficient for the exponential distribution; 
\f3\fs18 "g"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  mean selection coefficient and a 
\f3\fs18 numeric$
\f4\fs20  alpha shape parameter for a gamma distribution; 
\f3\fs18 "n"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  mean selection coefficient and a 
\f3\fs18 numeric$
\f4\fs20  sigma (standard deviation) parameter for a normal distribution
\fs22 ; 
\f3\fs18 "w"
\f4\fs22 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs22  
\f9 \uc0\u955 
\f4  scale parameter and a 
\f3\fs18 numeric$
\f4\fs22  k shape parameter for a Weibull distribution; or 
\f3\fs18 "s"
\f4\fs22 , in which case the ellipsis should supply a 
\f3\fs18 string$
\f4\fs22  Eidos script parameter.
\fs20   The DFE for a mutation type is normally a constant in simulations, so be sure you know what you are doing.
\f5 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.12  Class SLiMEidosBlock\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.12.1  
\f2\fs18 SLiMEidosBlock
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 active <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If this evaluates to 
\f3\fs18 logical
\f4\fs20  
\f3\fs18 F
\f4\fs20  (i.e., is equal to 
\f3\fs18 0
\f4\fs20 ), the script block is inactive and will not be called.  The value of 
\f3\fs18 active
\f4\fs20  for all registered script blocks is reset to 
\f3\fs18 -1
\f4\fs20  at the beginning of each tick, prior to script events being called, thus activating all blocks (except callbacks associated with a species that is not active in that tick, which are deactivated as part of the deactivation of the species).  Any 
\f3\fs18 integer
\f4\fs20  value other than 
\f3\fs18 -1
\f4\fs20  may be used instead of 
\f3\fs18 -1
\f4\fs20  to represent that a block is active; for example, 
\f3\fs18 active
\f4\fs20  may be used as a counter to make a block execute a fixed number of times in each tick.  This value is not cached by SLiM; if it is changed, the new value takes effect immediately.  For example, a callback might be activated and inactivated repeatedly during a single tick.\cf0 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 end => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The last tick in which the script block is active.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier for this script block; for script 
\f3\fs18 s3
\f4\fs20 , for example, this is 
\f3\fs18 3
\f4\fs20 .  A script block for which no 
\f3\fs18 id
\f4\fs20  was given will have an 
\f3\fs18 id
\f4\fs20  of 
\f3\fs18 -1
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 source => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The source code string of the script block.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 speciesSpec => (object<Species>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The 
\f3\fs18 species
\f4\fs20  specifier for the script block.  The species specifier for a callback block indicates the callback\'92s associated species; the callback is called to modify the default behavior for that species.  If the script block has no 
\f3\fs18 species
\f4\fs20  specifier, this property\'92s value is a zero-length 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Species
\f4\fs20 .  This property is read-only; normally it is set by preceding the definition of a callback with a 
\f3\fs18 species
\f4\fs20  specifier, of the form 
\f3\fs18 species <species-name>
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 start => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The first tick in which the script block is active.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 ticksSpec => (object<Species>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The 
\f3\fs18 ticks
\f4\fs20  specifier for the script block.  The 
\f3\fs18 ticks
\f4\fs20  specifier for an event block indicates the event\'92s associated species; the event executes only in ticks when that species is active.  If the script block has no 
\f3\fs18 ticks
\f4\fs20  specifier, this property\'92s value is a zero-length 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Species
\f4\fs20 .  This property is read-only; normally it is set by preceding the definition of an event with a 
\f3\fs18 ticks
\f4\fs20  specifier, of the form 
\f3\fs18 ticks <species-name>
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 type => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The type of the script block; this will be 
\f3\fs18 "first"
\f4\fs20 , 
\f3\fs18 "early"
\f4\fs20 , or 
\f3\fs18 "late"
\f4\fs20  for the three types of Eidos events, or 
\f3\fs18 "initialize"
\f4\fs20 , 
\f3\fs18 "fitnessEffect"
\f4\fs20 , 
\f3\fs18 "interaction"
\f4\fs20 , 
\f3\fs18 "mateChoice"
\f4\fs20 , 
\f3\fs18 "modifyChild"
\f4\fs20 , 
\f3\fs18 "mutation"
\f4\fs20 , 
\f3\fs18 "mutationEffect"
\f4\fs20 , 
\f3\fs18 "recombination"
\f4\fs20 , 
\f3\fs18 "reproduction"
\f4\fs20 , or 
\f3\fs18 "survival"
\f4\fs20  for the respective types of Eidos callbacks.
\f3\fs18 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.12.2  
\f2\fs18 SLiMEidosBlock
\f1\fs22  methods\
\pard\pardeftab397\fi274\ri720\sb40\sa40\partightenfactor0

\f5\i0 \cf0 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b \cf0 5.13  Class SLiMgui\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.13.1  
\f2\fs18 SLiMgui
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \expnd0\expndtw0\kerning0
pid => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The Un*x process identifier (commonly called the \'93pid\'94) of the running SLiMgui application.  This can be useful for scripts that wish to use system calls to influence the SLiMgui application.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 \kerning1\expnd0\expndtw0 5.13.2  
\f2\fs18 SLiMgui
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(void)openDocument(string$\'a0filePath)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Open the document at 
\f3\fs18 filePath
\f4\fs20  in SLiMgui, if possible.  Supported document types include SLiM model files (typically with a 
\f3\fs18 .slim
\f4\fs20  path extension), text files (typically with a 
\f3\fs18 .txt
\f4\fs20  path extension, and opened as untitled model files), and PNG, JPG/JPEG, BMP, and GIF image file formats (typically 
\f3\fs18 .png
\f4\fs20  / 
\f3\fs18 .jpg
\f4\fs20  / 
\f3\fs18 .jpeg
\f4\fs20  / 
\f3\fs18 .bmp
\f4\fs20  / 
\f3\fs18 .gif
\f4\fs20 , respectively).  (Note that in SLiMguiLegacy, PDF files (
\f3\fs18 .pdf
\f4\fs20 ) are supported but these other image file formats are not.)  This method can be particularly useful for opening images created by the simulation itself, often by sublaunching a plotting process in R or another environment.\expnd0\expndtw0\kerning0
\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)pauseExecution(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Pauses a model that is playing in SLiMgui.  This is essentially equivalent to clicking the \'93Play\'94 button to stop the execution of the model.  Execution can be resumed by the user, by clicking the \'93Play\'94 button again; unlike calling 
\f3\fs18 stop()
\f4\fs20  or 
\f3\fs18 simulationFinished()
\f4\fs20 , the simulation is not terminated.  This method can be useful for debugging or exploratory purposes, to pause the model at a point of interest.  Execution is paused at the end of the currently executing tick, not mid-tick.\
If the model is being profiled, or is executing forward to a tick number entered in the tick field, 
\f3\fs18 pauseExecution()
\f4\fs20  will do nothing; by design, 
\f3\fs18 pauseExecution()
\f4\fs20  only pauses execution when SLiMgui is doing a simple \'93Play\'94 of the model.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf2 \kerning1\expnd0\expndtw0 5.14  Class SpatialMap
\f4\b0 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 (object<SpatialMap>$)SpatialMap(string$\'a0name, object<SpatialMap>$\'a0map)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Creates a new 
\f3\fs18 SpatialMap
\f4\fs20  object that is a copy of 
\f3\fs18 map
\f4\fs20 , named 
\f3\fs18 name
\f4\fs20 .\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.14.1  
\f2\fs18 SpatialMap
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 gridDimensions => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The dimensions of the spatial map\'92s grid of values, in the order of the components of the map\'92s spatiality.  For example, a map with spatiality 
\f3\fs18 "xz"
\f4\fs20  and a grid of values that is 
\f3\fs18 500
\f4\fs20  in the 
\f3\fs18 "x"
\f4\fs20  dimension by 
\f3\fs18 300
\f4\fs20  in the 
\f3\fs18 "z"
\f4\fs20  dimension would return 
\f3\fs18 c(500, 300)
\f4\fs20  for this property.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 interpolate <\'96> (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Whether interpolation between grid values is enabled (
\f3\fs18 T
\f4\fs20 ) or disabled (
\f3\fs18 F
\f4\fs20 ).  The initial value of this property is set by 
\f3\fs18 defineSpatialMap()
\f4\fs20 , but it can be changed.  The interpolation performed is linear; for cubic interpolation, use the 
\f3\fs18 interpolate()
\f4\fs20  method.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 name => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The name of the spatial map, usually as provided to 
\f3\fs18 defineSpatialMap()
\f4\fs20 .  The names of spatial maps must be unique within any given subpopulation, but the same name may be reused for different spatial maps in different subpopulations.  The name is used to identify a map for methods such as 
\f3\fs18 spatialMapValue()
\f4\fs20 , and is also used for display in SLiMgui.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 spatialBounds => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The spatial bounds to which the spatial map is aligned.  These bounds come from the subpopulation that originally created the map, with the 
\f3\fs18 defineSpatialMap()
\f4\fs20  method, and cannot be subsequently changed.  All subpopulations that use a given spatial map must match that map\'92s spatial bounds, so that the map does not stretch or shrink relative to its initial configuration.  The components of the spatial bounds of a map correspond to the components of the map\'92s spatiality; for example, a map with spatiality 
\f3\fs18 "xz"
\f4\fs20  will have bounds (
\f3\fs18 x0
\f4\fs20 , 
\f3\fs18 z0
\f4\fs20 , 
\f3\fs18 x1
\f4\fs20 , 
\f3\fs18 z1
\f4\fs20 ); bounds for 
\f3\fs18 "y"
\f4\fs20  are not included, since that dimension is not used by the spatial map.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 spatiality => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The spatiality of the map: the subset of the model\'92s dimensions that are used by the spatial map.  The spatiality of a map is configured by 
\f3\fs18 defineSpatialMap()
\f4\fs20  and cannot subsequently be changed.  For example, a 3D model (with dimensionality 
\f3\fs18 "xyz"
\f4\fs20 ) might define a 2D spatial map with spatiality 
\f3\fs18 "xz"
\f4\fs20 , providing spatial values that do not depend upon the 
\f3\fs18 "y"
\f4\fs20  dimension.  Often, however, the spatiality of a map will match the dimensionality of the model.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual), for another way of attaching state to spatial maps.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf2 5.14.2  
\f2\fs18 SpatialMap
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \'96\'a0(object<SpatialMap>$)add(ifo<SpatialMap>\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds 
\f3\fs18 x
\f4\fs20  to the spatial map.  One possibility is that 
\f3\fs18 x
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  value; in this case, 
\f3\fs18 x
\f4\fs20  is added to each grid value of the target spatial map.  Another possibility is that 
\f3\fs18 x
\f4\fs20  is an 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  vector/matrix/array of the same dimensions as the target spatial map\'92s grid; in this case, each value of 
\f3\fs18 x
\f4\fs20  is added to the corresponding grid value of the target spatial map.  The third possibility is that 
\f3\fs18 x
\f4\fs20  is itself a (singleton) spatial map; in this case, each grid value of 
\f3\fs18 x
\f4\fs20  is added to the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)blend(ifo<SpatialMap>\'a0x, float$\'a0xFraction)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Blends 
\f3\fs18 x
\f4\fs20  into the spatial map, giving 
\f3\fs18 x
\f4\fs20  a weight of 
\f3\fs18 xFraction
\f4\fs20  and the existing values in the target spatial map a weight of 
\f3\fs18 1 - xFraction
\f4\fs20 , such that the resulting values in the target spatial map are then given by 
\f3\fs18 x\'a0*\'a0xFraction + target\'a0*\'a0(1\'a0-\'a0xFraction)
\f4\fs20 .  The value of 
\f3\fs18 xFraction
\f4\fs20  must be in [0.0, 1.0].\
One possibility is that 
\f3\fs18 x
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  value; in this case, 
\f3\fs18 x
\f4\fs20  is blended with each grid value of the target spatial map.  Another possibility is that 
\f3\fs18 x
\f4\fs20  is an 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  vector/matrix/array of the same dimensions as the target spatial map\'92s grid; in this case, each value of 
\f3\fs18 x
\f4\fs20  is blended with the corresponding grid value of the target spatial map.  The third possibility is that 
\f3\fs18 x
\f4\fs20  is itself a (singleton) spatial map; in this case, each grid value of 
\f3\fs18 x
\f4\fs20  is blended with the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)changeColors([Nif\'a0valueRange\'a0=\'a0NULL], [Ns\'a0colors\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Changes the color scheme for the target spatial map.  The meaning of 
\f3\fs18 valueRange
\f4\fs20  and 
\f3\fs18 colors
\f4\fs20  are identical to their meaning in 
\f3\fs18 defineSpatialMap()
\f4\fs20 , but are also described here.\
The 
\f3\fs18 valueRange
\f4\fs20  and 
\f3\fs18 colors
\f4\fs20  parameters travel together; either both are 
\f3\fs18 NULL
\f4\fs20 , or both are specified.  They control how map values will be transformed into colors, by SLiMgui and by the 
\f3\fs18 mapColor()
\f4\fs20  method.  The 
\f3\fs18 valueRange
\f4\fs20  parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.  The 
\f3\fs18 colors
\f4\fs20  parameter then establishes the corresponding colors for values within the interval defined by 
\f3\fs18 valueRange
\f4\fs20 : values less than or equal to 
\f3\fs18 valueRange[0]
\f4\fs20  will map to 
\f3\fs18 colors[0]
\f4\fs20 , values greater than or equal to 
\f3\fs18 valueRange[1]
\f4\fs20  will map to the last 
\f3\fs18 colors
\f4\fs20  value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.  This is much simpler than it sounds in this description; see the recipes in chapter 15 for an illustration of its use.\
If 
\f3\fs18 valueRange
\f4\fs20  and 
\f3\fs18 colors
\f4\fs20  are both 
\f3\fs18 NULL
\f4\fs20 , a default grayscale color scheme will be used in SLiMgui, but an error will result if 
\f3\fs18 mapColor()
\f4\fs20  is called.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)changeValues(ifo<SpatialMap>\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Changes the grid values used for the target spatial map.  The parameter 
\f3\fs18 x
\f4\fs20  should be either a 
\f3\fs18 SpatialMap
\f4\fs20  object from which values are taken directly, or a vector, matrix, or array of numeric values as described in the documentation for 
\f3\fs18 defineSpatialMap()
\f4\fs20 .  Other characteristics of the spatial map, such as its color mapping (if defined), its spatial bounds, and its spatiality, will remain unchanged.  The grid resolution of the spatial map is allowed to change with this method.  This method is useful for changing the values of a spatial map over time, such as to implement changes to the landscape\'92s characteristics due to seasonality, climate change, processes such as fire or urbanization, and so forth.  As with the original map values provided to 
\f3\fs18 defineSpatialMap()
\f4\fs20 , it is often useful to read map values from a PNG image file using the Eidos class 
\f3\fs18 Image
\f4\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)divide(ifo<SpatialMap>\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Divides the spatial map by 
\f3\fs18 x
\f4\fs20 .  One possibility is that 
\f3\fs18 x
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  value; in this case, each grid value of the target spatial map is divided by 
\f3\fs18 x
\f4\fs20 .  Another possibility is that 
\f3\fs18 x
\f4\fs20  is an 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  vector/matrix/array of the same dimensions as the target spatial map\'92s grid; in this case, each grid value of the target spatial map is divided by the corresponding value of 
\f3\fs18 x
\f4\fs20 .  The third possibility is that 
\f3\fs18 x
\f4\fs20  is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is divided by the corresponding grid value of 
\f3\fs18 x
\f4\fs20  (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)exp(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Exponentiates the values of the spatial map.  More precisely, each grid value 
\f1\i x
\f4\i0  of the target spatial map is exponentiated \'96 replaced by the value 
\f1\i e
\fs13\fsmilli6667 \super x
\f4\i0\fs20 \nosupersub .  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)gridValues(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the values for the spatial map\'92s grid as a vector (for a 1D map), a matrix (for a 2D map), or an array (for a 3D map).  The form and orientation of the returned values is such that it could be used to create a new spatial map, with 
\f3\fs18 defineSpatialMap()
\f4\fs20 , which would be identical to the original.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)interpolate(integer$\'a0factor, [string$\'a0method\'a0=\'a0"linear"])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Increases the resolution of the spatial map by 
\f3\fs18 factor
\f4\fs20 , changing the dimensions of the spatial map\'92s grid of values (while leaving its spatial bounds unchanged), by interpolating new values between the existing values.  The parameter 
\f3\fs18 factor
\f4\fs20  must be an integer in [
\f3\fs18 2
\f4\fs20 , 
\f3\fs18 10001
\f4\fs20 ], somewhat arbitrarily.  The target spatial map is returned, to allow easy chaining of operations.\
For a 1D spatial map, 
\f3\fs18 factor-1
\f4\fs20  new values will be inserted between every pair of values in the original value grid.  A 
\f3\fs18 factor
\f4\fs20  of 
\f3\fs18 2
\f4\fs20  would therefore insert one new value between each pair of existing values, thereby increasing the map\'92s resolution by a factor of two.  Note that if the spatial map\'92s original grid dimension was 
\f1\i N
\f4\i0 , the new grid dimension with a 
\f3\fs18 factor
\f4\fs20  of 
\f1\i k
\f4\i0  would be 
\f1\i k
\f4\i0 (
\f1\i N
\f4\i0 \uc0\u8722 1)+1, not 
\f1\i kN
\f4\i0 , because new values are inserted only 
\f1\i between
\f4\i0  existing values.  For 2D and 3D spatial maps, essentially the same process is conducted along each axis of the map\'92s spatiality, increasing the resolution of the map by 
\f3\fs18 factor
\f4\fs20  in every dimension.\
If 
\f3\fs18 method
\f4\fs20  is 
\f3\fs18 "linear"
\f4\fs20  (the default), linear (or bilinear or trilinear, for 2D/3D maps) interpolation will be used to interpolate the values for the new grid points.  Alternatively, if 
\f3\fs18 method
\f4\fs20  is 
\f3\fs18 "nearest"
\f4\fs20 , the nearest value in the old grid will be used for new grid points; with this method, it is recommended that 
\f3\fs18 factor
\f4\fs20  be odd, not even, to avoid artifacts due to rounding of coordinates midway between the original grid positions.  If method is 
\f3\fs18 "cubic"
\f4\fs20 , cubic (or bicubic, for 2D maps) will be used; this generally produces smoother interpolation with fewer artifacts than 
\f3\fs18 "linear"
\f4\fs20 , but it is not supported for 3D maps.  The choice of interpolation method used here is independent of the map\'92s 
\f3\fs18 interpolate
\f4\fs20  property.  Note that while the 
\f3\fs18 "nearest"
\f4\fs20  and 
\f3\fs18 "linear"
\f4\fs20  interpolation methods will leave the range of values in the map unchanged, 
\f3\fs18 "cubic"
\f4\fs20  interpolation may produce interpolated values that are outside the original range of values (by design).  Periodic boundaries are currently supported only for 
\f3\fs18 "nearest"
\f4\fs20 , 
\f3\fs18 "linear"
\f4\fs20 , and 1D 
\f3\fs18 "cubic"
\f4\fs20  interpolation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(string)mapColor(numeric\'a0value)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Uses the spatial map\'92s color-translation machinery (as defined by the 
\f3\fs18 valueRange
\f4\fs20  and 
\f3\fs18 colors
\f4\fs20  parameters to 
\f3\fs18 defineSpatialMap()
\f4\fs20 ) to translate each element of 
\f3\fs18 value
\f4\fs20  into a corresponding color string.  If the spatial map does not have color-translation capabilities, an error will result.  See the documentation for 
\f3\fs18 defineSpatialMap()
\f4\fs20  for information regarding the details of color translation.  See the Eidos manual for further information on color strings.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Image>$)mapImage([Ni$\'a0width\'a0=\'a0NULL], [Ni$\'a0height\'a0=\'a0NULL], [logical$\'a0centers\'a0=\'a0F], [logical$\'a0color\'a0=\'a0T])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns an 
\f3\fs18 Image
\f4\fs20  object sampled from the spatial map.  The image will be 
\f3\fs18 width
\f4\fs20  pixels wide and 
\f3\fs18 height
\f4\fs20  pixels tall; the intrinsic size of the spatial map itself will be used if one of these parameters is 
\f3\fs18 NULL
\f4\fs20 .  The image will be oriented in the same way as it is displayed in SLiMgui (which conceptually entails a transformation from matrix coordinates, which store values by column, to standard image coordinates, which store values by row; see the Eidos manual\'92s documentation of 
\f3\fs18 Image
\f4\fs20  for details).  This method may only be called for 2D spatial maps at present.\
The sampling of the spatial map can be done in one of two ways, as controlled by the 
\f3\fs18 centers
\f4\fs20  parameter.  If 
\f3\fs18 centers
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , a (
\f3\fs18 width+1
\f4\fs20 ) \'d7 (
\f3\fs18 height+1
\f4\fs20 ) grid of lines that delineates 
\f3\fs18 width
\f4\fs20  \'d7 
\f3\fs18 height
\f4\fs20  rectangular pixels will be overlaid on top of the spatial map, and values will be sampled from the spatial map at the 
\f1\i center
\f4\i0  of each of these pixels.  If 
\f3\fs18 centers
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), a 
\f3\fs18 width
\f4\fs20  \'d7 
\f3\fs18 height
\f4\fs20  grid of lines will be overlaid on top of the spatial map, and values will be sampled from the spatial map at the 
\f1\i vertices
\f4\i0  of the grid.  If interpolation is not enabled for the spatial map, these two options will both recover the original matrix of values used to define the spatial map (assuming, here and below, that 
\f3\fs18 width
\f4\fs20  and 
\f3\fs18 height
\f4\fs20  are 
\f3\fs18 NULL
\f4\fs20 ).  If interpolation is enabled for the spatial map, however, 
\f3\fs18 centers == F
\f4\fs20  will recover the original values, but will not capture the \'93typical\'94 value of each pixel in the image; 
\f3\fs18 centers == T
\f4\fs20 , on the other hand, will not recover the original values, but will capture the \'93typical\'94 value of each pixel in the image (i.e., the value at the center of each pixel, as produced by interpolation).  The figures in section 15.11 may be helpful for visualizing the difference between these options; the overlaid grids span the full extent of the spatial map, just as shown in that section.\
If 
\f3\fs18 color
\f4\fs20  is 
\f3\fs18 T
\f4\fs20  (the default), the 
\f3\fs18 valueRange
\f4\fs20  and 
\f3\fs18 colors
\f4\fs20  parameters supplied to 
\f3\fs18 defineSpatialMap()
\f4\fs20  will be used to translate map values to RGB color values as described in the documentation of that method, providing the same appearance as in SLiMgui; of course those parameters must have been supplied, otherwise an error will result.  If 
\f3\fs18 color
\f4\fs20  is 
\f3\fs18 F
\f4\fs20 , on the other hand, a grayscale image will be produced that directly reflects the map values without color translation.  In this case, this method needs to translate map values, which can have any 
\f3\fs18 float
\f4\fs20  value, into grayscale pixel values that are integers in [
\f3\fs18 0
\f4\fs20 , 
\f3\fs18 255
\f4\fs20 ].  To do so, the map values are multiplied by 
\f3\fs18 255.0
\f4\fs20 , clamped to [
\f3\fs18 0.0
\f4\fs20 , 
\f3\fs18 255.0
\f4\fs20 ], and then rounded to the nearest integer.  This translation scheme essentially assumes that map values are in [0, 1]; for spatial maps that were defined using the 
\f3\fs18 floatK
\f4\fs20  channel of a grayscale PNG image, this should recover the original image\'92s pixel values.  (If a different translation scheme is desired, 
\f3\fs18 color=T
\f4\fs20  with the desired 
\f3\fs18 valueRange
\f4\fs20  and 
\f3\fs18 colors
\f4\fs20  should be used.)\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)mapValue(float\'a0point)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Uses the spatial map\'92s mapping machinery (as defined by the 
\f3\fs18 gridSize
\f4\fs20 , 
\f3\fs18 values
\f4\fs20 , and 
\f3\fs18 interpolate
\f4\fs20  parameters to 
\f3\fs18 defineSpatialMap()
\f4\fs20 ) to translate the coordinates of 
\f3\fs18 point
\f4\fs20  into a corresponding map value.  The length of 
\f3\fs18 point
\f4\fs20  must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality 
\f3\fs18 "xz"
\f4\fs20 , 
\f3\fs18 point
\f4\fs20  must be of length 
\f3\fs18 2
\f4\fs20 , specifying the 
\f1\i x
\f4\i0  and 
\f1\i z
\f4\i0  coordinates of the point to be evaluated.  Interpolation will automatically be used if it was enabled for the spatial map.  Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use 
\f3\fs18 pointPeriodic()
\f4\fs20  to wrap the point coordinates first if desired.  See the documentation for 
\f3\fs18 defineSpatialMap()
\f4\fs20  for information regarding the details of value mapping.\
Beginning in SLiM 3.3, 
\f3\fs18 point
\f4\fs20  may contain more than one point to be looked up.  In this case, the length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of the spatiality of the spatial map; for a spatial map with spatiality 
\f3\fs18 "xz"
\f4\fs20 , for example, the length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of 
\f3\fs18 2
\f4\fs20 , and successive pairs of elements from point (elements 
\f3\fs18 0
\f4\fs20  and 
\f3\fs18 1
\f4\fs20 , then elements 
\f3\fs18 2
\f4\fs20  and 
\f3\fs18 3
\f4\fs20 , etc.) will be taken as the 
\f1\i x
\f4\i0  and 
\f1\i z
\f4\i0  coordinates of the points to be evaluated.  This allows 
\f3\fs18 spatialMapValue()
\f4\fs20  to be used in a vectorized fashion.\
The 
\f3\fs18 spatialMapValue()
\f4\fs20  method of 
\f3\fs18 Subpopulation
\f4\fs20  provides the same functionality as this method; it may be more convenient to use, for some usage cases, and it checks that the spatial map is actually added to the subpopulation in question, providing an additional consistency check.  However, either method may be used.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)multiply(ifo<SpatialMap>\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Multiplies the spatial map by 
\f3\fs18 x
\f4\fs20 .  One possibility is that 
\f3\fs18 x
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  value; in this case, each grid value of the target spatial map is multiplied by 
\f3\fs18 x
\f4\fs20 .  Another possibility is that 
\f3\fs18 x
\f4\fs20  is an 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  vector/matrix/array of the same dimensions as the target spatial map\'92s grid; in this case, each grid value of the target spatial map is multiplied by the corresponding value of 
\f3\fs18 x
\f4\fs20 .  The third possibility is that 
\f3\fs18 x
\f4\fs20  is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is multiplied by the corresponding grid value of 
\f3\fs18 x
\f4\fs20  (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)power(ifo<SpatialMap>\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Raises the spatial map to the power 
\f3\fs18 x
\f4\fs20 .  One possibility is that 
\f3\fs18 x
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  value; in this case, each grid value of the target spatial map is raised to the power 
\f3\fs18 x
\f4\fs20 .  Another possibility is that 
\f3\fs18 x
\f4\fs20  is an 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  vector/matrix/array of the same dimensions as the target spatial map\'92s grid; in this case, each grid value of the target spatial map is raised to the power of the corresponding value of 
\f3\fs18 x
\f4\fs20 .  The third possibility is that 
\f3\fs18 x
\f4\fs20  is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is raised to power of the corresponding grid value of 
\f3\fs18 x
\f4\fs20  (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)range(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the range of values contained in the spatial map.  The result is a 
\f3\fs18 float
\f4\fs20  vector of length 
\f3\fs18 2
\f4\fs20 ; the first element is the minimum map value, and the second element is the maximum map value.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)rescale([numeric$\'a0min\'a0=\'a00.0], [numeric$\'a0max\'a0=\'a01.0])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Rescales the values of the spatial map to the range [
\f3\fs18 min
\f4\fs20 , 
\f3\fs18 max
\f4\fs20 ].  By default, the rescaling is to the range [
\f3\fs18 0.0
\f4\fs20 , 
\f3\fs18 1.0
\f4\fs20 ].  It is required that 
\f3\fs18 min
\f4\fs20  be less than 
\f3\fs18 max
\f4\fs20 , and that both be finite.  Note that the final range may not be exactly [
\f3\fs18 min
\f4\fs20 , 
\f3\fs18 max
\f4\fs20 ] due to numerical error.  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)sampleImprovedNearbyPoint(float\'a0point, float$\'a0maxDistance, string$\'a0functionType, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This variant of 
\f3\fs18 sampleNearbyPoint()
\f4\fs20  samples a Metropolis\'96Hastings move on the spatial map.  See 
\f3\fs18 sampleNearbyPoint()
\f4\fs20  for discussion of the basic idea.  This method proposes a nearby point drawn from the given kernel.  If the drawn point has a larger map value than the original point, the new point is returned.  If the drawn point has a smaller map value than the original point, it is returned with a probability equal to the ratio between its map value and the original map value, otherwise the original point is returned.  The distribution of individuals that move (or not) to new locations governed by this method will converge upon the map itself, in a similar manner to how MCMC converges upon the posterior distribution (assuming no other forces, such as birth or death, influence the distribution of individuals).  Movement governed by this method is \'93improved\'94 in the sense that individuals will tend to remain where they are unless the new sampled point is an improvement for them \'96 a higher map value.\
Note that unlike 
\f3\fs18 sampleNearbyPoint()
\f4\fs20 , this method requires that all map values are non-negative.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)sampleNearbyPoint(float\'a0point, float$\'a0maxDistance, string$\'a0functionType, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 For a spatial point supplied in 
\f3\fs18 point
\f4\fs20 , returns a nearby point sampled from a kernel weighted by the spatial map\'92s values.  Only points within the maximum distance of the kernel, 
\f3\fs18 maxDistance
\f4\fs20 , will be chosen, and the probability that a given point is chosen will be proportional to the density of the kernel at that point multiplied by the value of the map at that point (interpolated, if interpolation is enabled for the map).  Negative values of the map will be treated as zero.  The point returned will be within spatial bounds, respecting periodic boundaries if in effect (so there is no need to call 
\f3\fs18 pointPeriodic()
\f4\fs20  on the result).\
The kernel is specified with a kernel shape, 
\f3\fs18 functionType
\f4\fs20 , followed by zero or more ellipsis arguments; see 
\f3\fs18 smooth()
\f4\fs20  for further information.  For this method, at present only kernel types 
\f3\fs18 "f"
\f4\fs20 , 
\f3\fs18 "l"
\f4\fs20 , 
\f3\fs18 "e"
\f4\fs20 , 
\f3\fs18 "n"
\f4\fs20 , and 
\f3\fs18 "t"
\f4\fs20  are supported, and type 
\f3\fs18 "t"
\f4\fs20  is not presently supported for 3D kernels.\
This method can be used to find points in the vicinity of individuals that are favorable \'96 possessing more resources, or better environmental conditions, etc.  It can also be used to guide the dispersal or foraging behavior of individuals.  See 
\f3\fs18 sampleImprovedNearbyPoint()
\f4\fs20  for a variant that may be useful for directed movement across a landscape.  Note that the algorithm for 
\f3\fs18 sampleNearbyPoint()
\f4\fs20  works by rejection sampling, and so will be very inefficient if the maximum value of the map (anywhere, across the entire map) is much larger than the typical value of the map where individuals are.  The algorithm for 
\f3\fs18 sampleImprovedNearbyPoint()
\f4\fs20  is different, and does not exhibit this performance issue.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)smooth(float$\'a0maxDistance, string$\'a0functionType, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Smooths (or blurs, one could say) the values of the spatial map by convolution with a kernel.  The kernel is specified with a maximum distance 
\f3\fs18 maxDistance
\f4\fs20  (beyond which the kernel cuts off to a value of zero), a kernel type 
\f3\fs18 functionType
\f4\fs20  that should be 
\f3\fs18 "f"
\f4\fs20 , 
\f3\fs18 "l"
\f4\fs20 , 
\f3\fs18 "e"
\f4\fs20 , 
\f3\fs18 "n"
\f4\fs20 , 
\f3\fs18 "c"
\f4\fs20 , or 
\f3\fs18 "t"
\f4\fs20 , and additional parameters in the ellipsis 
\f3\fs18 ...
\f4\fs20  that depend upon the kernel type and further specify its shape.  The target spatial map is returned, to allow easy chaining of operations.\
The kernel specification is similar to that for the 
\f3\fs18 setInteractionType()
\f4\fs20  method of 
\f3\fs18 InteractionType
\f4\fs20 , but omits the maximum value of the kernel.  Specifically, 
\f3\fs18 functionType
\f4\fs20  may be 
\f3\fs18 "f"
\f4\fs20 , in which case no ellipsis arguments should be supplied; 
\f3\fs18 "l"
\f4\fs20 , similarly with no ellipsis arguments; 
\f3\fs18 "e"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  lambda (rate) parameter for a negative exponential function; 
\f3\fs18 "n"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  sigma (standard deviation) parameter for a Gaussian function; 
\f3\fs18 "c"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  scale parameter for a Cauchy distribution function; or 
\f3\fs18 "t"
\f4\fs20 , in which case the ellipsis should supply a 
\f3\fs18 numeric$
\f4\fs20  degrees of freedom and a 
\f3\fs18 numeric$
\f4\fs20  scale parameter for a 
\f1\i t
\f4\i0 -distribution function.  See the 
\f3\fs18 InteractionType
\f4\fs20  class documentation for discussions of these kernel types.\
Distance metrics specified to this method, such as 
\f3\fs18 maxDistance
\f4\fs20  and the additional kernel shape parameters, are measured in the distance scale of the spatial map \'96 the same distance scale in which the spatial bounds of the map are specified.  The operation is performed upon the grid values of the spatial map; distances are internally translated into the scale of the value grid.  For non-periodic boundaries, clipping at the edge of the spatial map is done; in a 2D map with no periodic boundaries, for example, the weights of edge and corner grid values are adjusted for their partial (one-half and one-quarter) coverage.  For periodic boundaries, the smoothing operation will automatically wrap around based upon the assumption that the grid values at the two connected edges of the periodic boundary have identical values (which they should, since by definition they represent the same position in space).\
The density scale of the kernel has no effect and will be normalized; this is the reason that 
\f3\fs18 smooth()
\f4\fs20 , unlike 
\f3\fs18 InteractionType
\f4\fs20 , does not require specification of the maximum value of the kernel.  This normalization prevents the kernel from increasing or decreasing the average spatial map value (apart from possible edge effects).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<SpatialMap>$)subtract(ifo<SpatialMap>\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Subtracts 
\f3\fs18 x
\f4\fs20  from the spatial map.  One possibility is that 
\f3\fs18 x
\f4\fs20  is a singleton 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  value; in this case, 
\f3\fs18 x
\f4\fs20  is subtracted from each grid value of the target spatial map.  Another possibility is that 
\f3\fs18 x
\f4\fs20  is an 
\f3\fs18 integer
\f4\fs20  or 
\f3\fs18 float
\f4\fs20  vector/matrix/array of the same dimensions as the target spatial map\'92s grid; in this case, each value of 
\f3\fs18 x
\f4\fs20  is subtracted from the corresponding grid value of the target spatial map.  The third possibility is that 
\f3\fs18 x
\f4\fs20  is itself a (singleton) spatial map; in this case, each grid value of 
\f3\fs18 x
\f4\fs20  is subtracted from the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).  The target spatial map is returned, to allow easy chaining of operations.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.15  Class Species\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.15.1  
\f2\fs18 Species
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 avatar => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The avatar string used to represent this species in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Avatars are typically one-character strings, often using an emoji that symbolizes the species.  This property is read-only; its value should be set with the 
\f3\fs18 avatar
\f4\fs20  parameter of 
\f3\fs18 initializeSpecies()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 chromosome => (object<Chromosome>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 Chromosome
\f4\fs20  
\f3\fs18 object
\f4\fs20  used by the species.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 chromosomeType => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The type of chromosome being simulated by this species; this will be one of 
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "X"
\f4\fs20 , or 
\f3\fs18 "Y"
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 color => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The color used to display information about this species in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f3\fs18 "#RRGGBB"
\f4\fs20  (see the Eidos manual).  This property is read-only; its value should be set with the 
\f3\fs18 color
\f4\fs20  parameter of 
\f3\fs18 initializeSpecies()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 cycle <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The current cycle count for this species.  This counter begins at 1, and increments at the end of every tick in which the species is active.  In models with non-overlapping generations, particularly WF models, this can be thought of as a generation counter.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 description <\'96> (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A human-readable 
\f3\fs18 string
\f4\fs20  description for the species.  By default, this is the empty string, 
\f3\fs18 ""
\f4\fs20 ; however, it may be set to whatever you wish.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 dimensionality => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The spatial dimensionality of the simulation for this species, as specified in 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .  This will be 
\f3\fs18 ""
\f4\fs20  (the empty string) for non-spatial simulations (the default), or 
\f3\fs18 "x"
\f4\fs20 , 
\f3\fs18 "xy"
\f4\fs20 , or 
\f3\fs18 "xyz"
\f4\fs20 , for simulations using those spatial dimensions respectively.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 genomicElementTypes => (object<GenomicElementType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 GenomicElementType
\f4\fs20  objects being used in the species.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The identifier for this species.  Species identifiers are determined by their declaration order in the script; the first declared species is given an 
\f3\fs18 id
\f4\fs20  of 
\f3\fs18 0
\f4\fs20 , the second is given an 
\f3\fs18 id
\f4\fs20  of 
\f3\fs18 1
\f4\fs20 , and so forth.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutationTypes => (object<MutationType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 MutationType
\f4\fs20  objects being used in the species.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutations => (object<Mutation>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 Mutation
\f4\fs20  objects that are currently active in the species.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 name => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A human-readable 
\f3\fs18 string
\f4\fs20  name for the subpopulation.  This is always the declared name of the species, as given in the explicit species declaration in script, and cannot be changed.  The 
\f3\fs18 name
\f4\fs20  of a species may appear as a label in SLiMgui, and it can be useful in generating output, debugging, and other purposes.  See also the description property, which can be changed by the user and used for any purpose.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
nucleotideBased => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If 
\f3\fs18 T
\f4\fs20 , the model for this species is nucleotide-based; if 
\f3\fs18 F
\f4\fs20 , it is not.  See the discussion of the 
\f3\fs18 nucleotideBased
\f4\fs20  parameter to 
\f3\fs18 initializeSLiMOptions()
\f4\fs20  for discussion.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 periodicity => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The spatial periodicity of the simulation for this species, as specified in 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .  This will be 
\f3\fs18 ""
\f4\fs20  (the empty string) for non-spatial simulations and simulations with no periodic spatial dimensions (the default).  Otherwise, it will be a string representing the subset of spatial dimensions that have been declared to be periodic, as specified to 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 scriptBlocks => (object<SLiMEidosBlock>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects in the simulation that have been declared with this species as their 
\f3\fs18 species
\f4\fs20  specifier (
\f1\i not
\f4\i0  
\f3\fs18 ticks
\f4\fs20  specifier).  These will always be callback blocks; callbacks are species-specific, while other types of blocks are not.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 sexEnabled => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 If 
\f3\fs18 T
\f4\fs20 , sex is enabled for this species; if 
\f3\fs18 F
\f4\fs20 , individuals are hermaphroditic.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 subpopulations => (object<Subpopulation>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 Subpopulation
\f4\fs20  instances currently defined in the species.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 substitutions => (object<Substitution>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A vector of 
\f3\fs18 Substitution
\f4\fs20  objects, representing all mutations that have been fixed in this species.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to the simulation.
\f5 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.15.2  
\f2\fs18 Species
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 \'96\'a0(object<Subpopulation>$)addSubpop(is$\'a0subpopID, integer$\'a0size, [float$\'a0sexRatio\'a0=\'a00.5]\cf2 , [logical$\'a0haploid\'a0=\'a0F]\cf0 )
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Add a new subpopulation with id 
\f3\fs18 subpopID
\f4\fs20  and 
\f3\fs18 size
\f4\fs20  individuals (see the SLiM manual for further details).  The 
\f3\fs18 subpopID
\f4\fs20  parameter may be either an 
\f3\fs18 integer
\f4\fs20  giving the ID of the new subpopulation, or a 
\f3\fs18 string
\f4\fs20  giving the name of the new subpopulation (such as 
\f3\fs18 "p5"
\f4\fs20  to specify an ID of 5).  Only if sex is enabled for the species, the initial sex ratio may optionally be specified as 
\f3\fs18 sexRatio
\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
 (as the male fraction, M:M+F)\cf0 \kerning1\expnd0\expndtw0 ; if it is not specified, a default of 
\f3\fs18 0.5
\f4\fs20  is used.  The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.  Subpopulations added by this method will initially consist of individuals with empty genomes. In order to model subpopulations that split from an already existing subpopulation, use 
\f3\fs18 addSubpopSplit()
\f5\fs20 .\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 Only in nonWF models, the 
\f3\fs18 haploid
\f4\fs20  parameter may be 
\f3\fs18 T
\f4\fs20 ; in this case, the second genome of each new individual will be a null genome, rather than an empty genome.  For even greater control in nonWF models, you can call 
\f3\fs18 addSubpop()
\f4\fs20  with an initial size of 
\f3\fs18 0
\f4\fs20  and then stock the population with new individuals created however you wish in the next tick\'92s 
\f3\fs18 reproduction()
\f4\fs20  callback.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<Subpopulation>$)addSubpopSplit(is$\'a0subpopID, integer$\'a0size, io<Subpopulation>$\'a0sourceSubpop, [float$\'a0sexRatio\'a0=\'a00.5])
\f5 \
\pard\pardeftab529\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Split off a new subpopulation with id 
\f3\fs18 subpopID
\f4\fs20  and 
\f3\fs18 size
\f4\fs20  individuals derived from subpopulation 
\f3\fs18 sourceSubpop
\f4\fs20 .  The 
\f3\fs18 subpopID
\f4\fs20  parameter may be either an 
\f3\fs18 integer
\f4\fs20  giving the ID of the new subpopulation, or a 
\f3\fs18 string
\f4\fs20  giving the name of the new subpopulation (such as 
\f3\fs18 "p5"
\f4\fs20  to specify an ID of 5).  The 
\f3\fs18 sourceSubpop
\f4\fs20  parameter may specify the source subpopulation either as a 
\f3\fs18 Subpopulation
\f4\fs20  object or by 
\f3\fs18 integer
\f4\fs20  identifier.  Only if sex is enabled for the species, the initial sex ratio may optionally be specified as 
\f3\fs18 sexRatio
\f4\fs20  (as the male fraction, M:M+F); if it is not specified, a default of 
\f3\fs18 0.5
\f4\fs20  is used.  The new subpopulation will be defined as a global variable immediately by this method (see section 24.15), and will also be returned by this method.\
Subpopulations added by this method will consist of individuals that are clonal copies of individuals from the source subpopulation, randomly chosen with probabilities proportional to fitness.  The fitness of all of these initial individuals is considered to be 1.0, to avoid a doubled round of selection in the initial tick, given that fitness values were already used to choose the individuals to clone.  Once this initial set of individuals has mated to produce offspring, the model is effectively of parental individuals in the source subpopulation mating randomly according to fitness, as usual in SLiM, with juveniles migrating to the newly added subpopulation.  Effectively, then, then new subpopulation is created empty, and is filled by migrating juveniles from the source subpopulation, in accordance with SLiM\'92s usual model of juvenile migration.\
\pard\pardeftab529\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0\cf0 (integer$)countOfMutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab529\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns the number of mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations that are currently active in the species.  If you need a vector of the matching 
\f3\fs18 Mutation
\f4\fs20  objects, rather than just a count, use 
\f3\fs18 -mutationsOfType()
\f5\fs20 .
\f4   This method is often used to determine whether an introduced mutation is still active (as opposed to being either lost or fixed).  This method is provided for speed; it is much faster than the corresponding Eidos code.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Individual>)individualsWithPedigreeIDs(integer\'a0pedigreeIDs, [Nio<Subpopulation>\'a0subpops\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Looks up individuals by pedigree ID, optionally within specific subpopulations.  Pedigree tracking must be turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20  to use this method, otherwise an error will result.  This method is vectorized; more than one pedigree id may be passed in 
\f3\fs18 pedigreeID
\f4\fs20 , in which case the returned vector will contain all of the individuals for which a match was found (in the same order in which they were supplied).  If a given id is not found, the returned vector will contain no entry for that id (so the length of the returned vector may not match the length of 
\f3\fs18 pedigreeIDs
\f4\fs20 ).  If none of the given ids were found, the returned vector will be 
\f3\fs18 object<Individual>(0)
\f4\fs20 , an empty 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Individual
\f4\fs20 .  If you have more than one pedigree ID to look up, calling this method just once, in vectorized fashion, may be much faster than calling it once for each ID, due to internal optimizations.\
To find individuals within all subpopulations, pass the default of 
\f3\fs18 NULL
\f4\fs20  for 
\f3\fs18 subpops
\f4\fs20 .  If you are interested only in matches within a specific subpopulation, pass that subpopulation for 
\f3\fs18 subpops
\f4\fs20 ; that will make the search faster.  Similarly, if you know that a particular subpopulation is the most likely to contain matches, you should supply that subpopulation first in the 
\f3\fs18 subpops
\f4\fs20  vector so that it will be searched first; the supplied subpopulations are searched in order.  Subpopulations may be supplied either as 
\f3\fs18 integer
\f4\fs20  IDs, or as 
\f3\fs18 Subpopulation
\f4\fs20  objects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)killIndividuals(object<Individual>\'a0individuals)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Immediately kills the individuals in 
\f3\fs18 individuals
\f4\fs20 .  This removes them from their subpopulation and gives them an 
\f3\fs18 index
\f4\fs20  value of 
\f3\fs18 -1
\f4\fs20 .  The 
\f3\fs18 Individual
\f4\fs20  objects are not freed immediately, since references to them could still exist in local Eidos variables; instead, the individuals are kept in a temporary \'93graveyard\'94 until they can be freed safely.  It therefore continues to be safe to use them and their genomes, except that accessing their 
\f3\fs18 subpopulation
\f4\fs20  property will raise an error since they no longer have a subpopulation.\
Note that the indices and order of individuals and genomes in all source subpopulations will change unpredictably as a side effect of this method.  All evaluated interactions are invalidated as a side effect of calling this method.\
Note that this method is only for use in nonWF models, in which mortality is managed manually by the model script.  In WF models, mortality is managed automatically by the SLiM core when the new offspring generation becomes the parental generation and the previous parental generation dies; mortality does not otherwise occur in WF models.  In nonWF models, mortality normally occurs during the survival stage of the tick cycle, based upon the fitness values calculated by SLiM, and 
\f3\fs18 survival()
\f4\fs20  callbacks can influence the outcome of that survival stage.  Calls to 
\f3\fs18 killIndividuals()
\f4\fs20 , on the other hand, can be made at any time during 
\f3\fs18 first()
\f4\fs20 , 
\f3\fs18 early()
\f4\fs20 , or 
\f3\fs18 late()
\f4\fs20  events, and the result cannot be modified by 
\f3\fs18 survival()
\f4\fs20  callbacks; the given individuals are simply immediately killed.  This method therefore provides an alternative, and relatively rarely used, mortality mechanism that is disconnected from fitness.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(integer)mutationCounts(Nio<Subpopulation>\'a0subpops, [No<Mutation>\'a0mutations\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Return an 
\f3\fs18 integer
\f4\fs20  vector with the frequency counts of all of the 
\f3\fs18 Mutation
\f4\fs20  objects passed in 
\f3\fs18 mutations
\f4\fs20 , within the 
\f3\fs18 Subpopulation
\f4\fs20  objects in 
\f3\fs18 subpops
\f4\fs20 .  The 
\f3\fs18 subpops
\f4\fs20  argument is required, but you may pass 
\f3\fs18 NULL
\f4\fs20  to get population-wide frequency counts.\cf2   Subpopulations may be supplied either as 
\f3\fs18 integer
\f4\fs20  IDs, or as 
\f3\fs18 Subpopulation
\f4\fs20  objects.\cf0   If the optional 
\f3\fs18 mutations
\f4\fs20  argument is 
\f3\fs18 NULL
\f4\fs20  (the default), frequency counts will be returned for all of the active 
\f3\fs18 Mutation
\f4\fs20  objects in the species \'96 the same 
\f3\fs18 Mutation
\f4\fs20  objects, and in the same order, as would be returned by the 
\f3\fs18 mutations
\f4\fs20  property of 
\f3\fs18 sim
\f4\fs20 , in other words.\
See the 
\f3\fs18 -mutationFrequencies()
\f4\fs20  method to obtain 
\f3\fs18 float
\f4\fs20  frequencies instead of 
\f3\fs18 integer
\f4\fs20  counts.\cf2   See also the 
\f3\fs18 Genome
\f4\fs20  methods 
\f3\fs18 mutationCountsInGenomes()
\f4\fs20  and 
\f3\fs18 mutationFrequenciesInGenomes()
\f4\fs20 .
\f5 \cf0 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(float)mutationFrequencies(Nio<Subpopulation>\'a0subpops, [No<Mutation>\'a0mutations\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Return a 
\f3\fs18 float
\f4\fs20  vector with the frequencies of all of the 
\f3\fs18 Mutation
\f4\fs20  objects passed in 
\f3\fs18 mutations
\f4\fs20 , within the 
\f3\fs18 Subpopulation
\f4\fs20  objects in 
\f3\fs18 subpops
\f4\fs20 .  The 
\f3\fs18 subpops
\f4\fs20  argument is required, but you may pass 
\f3\fs18 NULL
\f4\fs20  to get population-wide frequencies.\cf2   Subpopulations may be supplied either as 
\f3\fs18 integer
\f4\fs20  IDs, or as 
\f3\fs18 Subpopulation
\f4\fs20  objects.\cf0   If the optional 
\f3\fs18 mutations
\f4\fs20  argument is 
\f3\fs18 NULL
\f4\fs20  (the default), frequencies will be returned for all of the active 
\f3\fs18 Mutation
\f4\fs20  objects in the species \'96 the same 
\f3\fs18 Mutation
\f4\fs20  objects, and in the same order, as would be returned by the 
\f3\fs18 mutations
\f4\fs20  property of 
\f3\fs18 sim
\f4\fs20 , in other words.
\f5 \

\f4 See the 
\f3\fs18 -mutationCounts()
\f4\fs20  method to obtain 
\f3\fs18 integer
\f4\fs20  counts instead of 
\f3\fs18 float
\f4\fs20  frequencies.\cf2   See also the 
\f3\fs18 Genome
\f4\fs20  methods 
\f3\fs18 mutationCountsInGenomes()
\f4\fs20  and 
\f3\fs18 mutationFrequenciesInGenomes()
\f4\fs20 .
\f5 \cf0 \
\pard\pardeftab529\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (object<Mutation>)mutationsOfType(io<MutationType>$\'a0mutType)
\f5 \
\pard\pardeftab529\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Returns an 
\f3\fs18 object
\f4\fs20  vector of all the mutations that are of the type specified by 
\f3\fs18 mutType
\f4\fs20 , out of all of the mutations that are currently active in the species.  If you just need a count of the matching 
\f3\fs18 Mutation
\f4\fs20  objects, rather than a vector of the matches, use 
\f3\fs18 -countOfMutationsOfType()
\f5\fs20 .
\f4   This method is often used to look up an introduced mutation at a later point in the simulation, since there is no way to keep persistent references to objects in SLiM.  This method is provided for speed; it is much faster than the corresponding Eidos code.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)outputFixedMutations([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output all fixed mutations \'96 all 
\f3\fs18 Substitution
\f4\fs20  objects, in other words \'96 in a SLiM native format.  If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .
\f4   Mutations which have fixed but have not been turned into 
\f3\fs18 Substitution
\f4\fs20  objects \'96 typically because 
\f3\fs18 convertToSubstitution
\f4\fs20  has been set to 
\f3\fs18 F
\f4\fs20  for their mutation type \'96 are not output; they are still considered to be segregating mutations by SLiM.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)outputFull([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0binary\'a0=\'a0F], [logical$\'a0append\'a0=\'a0F], [logical$\'a0spatialPositions\'a0=\'a0T]\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0ages\'a0=\'a0T], [logical$\'a0ancestralNucleotides\'a0=\'a0T]\kerning1\expnd0\expndtw0 , [logical$\'a0pedigreeIDs\'a0=\'a0F]\cf0 )
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output the state of the entire population.  If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .
\f4   When writing to a file, a 
\f3\fs18 logical
\f4\fs20  flag, 
\f3\fs18 binary
\f4\fs20 , may be supplied as well.  If 
\f3\fs18 binary
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , the population state will be written as a binary file instead of a text file (binary data cannot be written to the standard output stream).  The binary file is usually smaller, and in any case will be read much faster than the corresponding text file would be read.  Binary files are not guaranteed to be portable between platforms; in other words, a binary file written on one machine may not be readable on a different machine (but in practice it usually will be, unless the platforms being used are fairly unusual).  If 
\f3\fs18 binary
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), a text file will be written.\
Beginning with SLiM 2.3, the 
\f3\fs18 spatialPositions
\f4\fs20  parameter may be used to control the output of the spatial positions of individuals in species for which continuous space has been enabled using the 
\f3\fs18 dimensionality
\f4\fs20  option of 
\f3\fs18 initializeSLiMOptions()
\f5\fs20 .
\f4   If 
\f3\fs18 spatialPositions
\f4\fs20  is 
\f3\fs18 F
\f4\fs20 , the output will not contain spatial positions, and will be identical to the output generated by SLiM 2.1 and later.  If 
\f3\fs18 spatialPositions
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , spatial position information will be output if it is available.  If the species does not have continuous space enabled, the 
\f3\fs18 spatialPositions
\f4\fs20  parameter will be ignored.  Positional information may be output for all output destinations \'96 the Eidos output stream, a text file, or a binary file.
\f5 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 \expnd0\expndtw0\kerning0
Beginning with SLiM 3.0, the 
\f3\fs18 ages
\f4\fs20  parameter may be used to control the output of the ages of individuals in nonWF simulations.  If 
\f3\fs18 ages
\f4\fs20  is 
\f3\fs18 F
\f4\fs20 , the output will not contain ages, preserving backward compatibility with the output format of SLiM 2.1 and later.  If 
\f3\fs18 ages
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , ages will be output for nonWF models.  In WF simulations, the 
\f3\fs18 ages
\f4\fs20  parameter will be ignored.\
Beginning with SLiM 3.3, the 
\f3\fs18 ancestralNucleotides
\f4\fs20  parameter may be used to control the output of the ancestral nucleotide sequence in nucleotide-based models.  If 
\f3\fs18 ancestralNucleotides
\f4\fs20  is 
\f3\fs18 F
\f4\fs20 , the output will not contain ancestral nucleotide information, and so the ancestral sequence will not be restored correctly if the saved file is loaded with 
\f3\fs18 readPopulationFile()
\f4\fs20 .  This option is provided because the ancestral sequence may be quite large, for models with a long chromosome (e.g., 1 GB if the chromosome is 10
\fs13\fsmilli6667 \super 9
\fs20 \nosupersub  bases long, when saved in text format, or 0.25 GB when saved in binary format).  If the model is not nucleotide-based (as enabled with the 
\f3\fs18 nucleotideBased
\f4\fs20  parameter to 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 ), the 
\f3\fs18 ancestralNucleotides
\f4\fs20  parameter will be ignored.  Note that in nucleotide-based models the output format will 
\f1\i always
\f4\i0  include the nucleotides associated with any nucleotide-based mutations; the 
\f3\fs18 ancestralNucleotides
\f4\fs20  flag governs only the ancestral sequence.\
\kerning1\expnd0\expndtw0 Beginning with SLiM 3.5, the 
\f3\fs18 pedigreeIDs
\f4\fs20  parameter may be used to request that pedigree IDs be written out (and read in by 
\f3\fs18 readFromPopulationFile()
\f4\fs20 , subsequently).  This option is turned off (
\f3\fs18 F
\f4\fs20 ) by default, to preserve backward compatibility; if it is turned on (
\f3\fs18 T
\f4\fs20 ), different file version values will be used, and backward compatibility with previous versions of SLiM will be lost.  This option may only be used if SLiM\'92s optional pedigree tracking has been enabled with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 .\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf0 Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)outputMutations(object<Mutation>\'a0mutations, [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output all of the given mutations.  This can be used to output all mutations of a given mutation type, for example.  \cf2 \expnd0\expndtw0\kerning0
If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 .
\f5 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 \expnd0\expndtw0\kerning0
In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(integer$)readFromPopulationFile(string$\'a0filePath\cf2 , [No$\'a0subpopMap\'a0=\'a0NULL]\cf0 )\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Read from a population initialization file, whether in text or binary format as previously specified to 
\f3\fs18 outputFull()
\f4\fs20 , and return the tick counter value represented by the file\'92s contents (i.e., the tick at which the file was generated).  Although this is most commonly used to set up initial populations (often in an Eidos event set to run in tick 1, immediately after simulation initialization), it may be called in any 
\f3\fs18 early()
\f4\fs20  or 
\f3\fs18 late()
\f4\fs20  Eidos event; the current state of all populations in the target species will be wiped and replaced by the state in the file at 
\f3\fs18 filePath
\f4\fs20 .  All Eidos variables that are of type 
\f3\fs18 object
\f4\fs20  and have element type 
\f3\fs18 Subpopulation
\f4\fs20 , 
\f3\fs18 Genome
\f4\fs20 , 
\f3\fs18 Mutation
\f4\fs20 , 
\f3\fs18 Individual
\f4\fs20 , or 
\f3\fs18 Substitution
\f4\fs20  will be removed as a side effect of this method if they contain any element that belongs to the target species, because those objects will no longer exist in the SLiM simulation; if you want to preserve any of that state, you should output it or save it to a file prior to this call.  New symbols will be defined to refer to the new 
\f3\fs18 Subpopulation
\f4\fs20  objects loaded from the file.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 If the file being read was written by a version of SLiM prior to 2.3, then for backward compatibility fitness values will be calculated immediately for any new subpopulations created by this call, which will trigger the calling of any activated and applicable 
\f3\fs18 mutationEffect()
\f4\fs20  and 
\f3\fs18 fitnessEffect()
\f4\fs20  callbacks.  When reading files written by SLiM 2.3 or later, fitness values are not calculated as a side effect of this call (because the simulation will often need to evaluate interactions or modify other state prior to doing so).\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In SLiM 2.3 and later when using the WF model, calling 
\f3\fs18 readFromPopulationFile()
\f4\fs20  from any context other than a 
\f3\fs18 late()
\f4\fs20  event causes a warning; calling from a 
\f3\fs18 late()
\f4\fs20  event is almost always correct in WF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the tick cycle without the need to force their recalculation (see comments on 
\f3\fs18 recalculateFitness()
\f4\fs20 ).\
In SLiM 3.0 when using the nonWF model, calling 
\f3\fs18 readFromPopulationFile()
\f4\fs20  from any context other than an 
\f3\fs18 early()
\f4\fs20  event causes a warning; calling from an 
\f3\fs18 early()
\f4\fs20  event is almost always correct in nonWF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the tick cycle without the need to force their recalculation (see comments on 
\f3\fs18 recalculateFitness()
\f4\fs20 ).\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 As of SLiM 2.1, this method changes the tick and cycle counters to the tick and cycle read from the file.  If you do not want these counters to be changed, you can change them back after reading, by setting 
\f3\fs18 community.tick
\f4\fs20  and 
\f3\fs18 sim.cycle
\f4\fs20  to whatever values you wish.  Note that restoring a saved past state and running forward again will not yield the same simulation results, because the random number generator\'92s state will not be the same; to ensure reproducibility from a given time point, 
\f3\fs18 setSeed()
\f4\fs20  can be used to establish a new seed value.  Any changes made to structure of the species (mutation types, genomic element types, etc.) will not be wiped and re-established by 
\f3\fs18 readFromPopulationFile()
\f4\fs20 ; this method loads only the population\'92s state, not the species configuration, so care should be taken to ensure that the species structure meshes coherently with the loaded data.  Indeed, state such as the selfing and cloning rates of subpopulations, values set into 
\f3\fs18 tag
\f4\fs20  properties, and values set onto objects with 
\f3\fs18 setValue()
\f4\fs20  will also be lost, since it is not saved out by 
\f3\fs18 outputFull()
\f4\fs20 .  Only information saved by 
\f3\fs18 outputFull()
\f4\fs20  will be restored; all other state associated with the species \'96 subpopulations, individuals, genomes, mutations, and substitutions \'96 will be lost, and should be re-established by the model if it is still needed.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 As of SLiM 2.3, this method will read and restore the spatial positions of individuals if that information is present in the output file and the species has enabled continuous space (see 
\f3\fs18 outputFull()
\f4\fs20  for details).  If spatial positions are present in the output file but the species has not enabled continuous space (or the number of spatial dimensions does not match), an error will result.  If the species has enabled continuous space but spatial positions are not present in the output file, the spatial positions of the individuals read will be undefined, but an error is not raised.\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
As of SLiM 3.0, this method will read and restore the ages of individuals if that information is present in the output file and the simulation is based upon the nonWF model.  If ages are present but the simulation uses a WF model, an error will result; the WF model does not use age information.  If ages are not present but the simulation uses a nonWF model, an error will also result; the nonWF model requires age information.\
As of SLiM 3.3, this method will restore the nucleotides of nucleotide-based mutations, and will restore the ancestral nucleotide sequence, if that information is present in the output file.  Loading an output file that contains nucleotide information in a non-nucleotide-based model, and 
\f1\i vice versa
\f4\i0 , will produce an error.\
\kerning1\expnd0\expndtw0 As of SLiM 3.5, this method will read and restore the pedigree IDs of individuals and genomes if that information is present in the output file (as requested with 
\f3\fs18 outputFull(pedigreeIDs=T)
\f4\fs20 ) 
\f1\i and
\f4\i0  if SLiM\'92s optional pedigree tracking has been enabled with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 .\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 This method can also be used to read tree-sequence (
\f3\fs18 .trees
\f4\fs20 ) files saved by 
\f3\fs18 treeSeqOutput()
\f4\fs20  or generated by the Python 
\f3\fs18 pyslim
\f4\fs20  package.  Note that the user metadata for a tree-sequence file can be read separately with the 
\f3\fs18 treeSeqMetadata()
\f4\fs20  function.  Beginning with SLiM 4, the 
\f3\fs18 subpopMap
\f4\fs20  parameter may be supplied to re-order the populations of the input tree sequence when it is loaded in to SLiM.  This parameter must have a value that is a 
\f3\fs18 Dictionary
\f4\fs20 ; the keys of this dictionary should be SLiM population identifiers as 
\f3\fs18 string
\f4\fs20  values (e.g., 
\f3\fs18 "p2"
\f4\fs20 ), and the values should be indexes of populations in the input tree sequence; a key/value pair of 
\f3\fs18 "p2", 4
\f4\fs20  would mean that the fifth population in the input (the one at zero-based index 
\f3\fs18 4
\f4\fs20 ) should become 
\f3\fs18 p2
\f4\fs20  on loading into SLiM.  If 
\f3\fs18 subpopMap
\f4\fs20  is non-
\f3\fs18 NULL
\f4\fs20 , 
\f1\i all
\f4\i0  populations in the tree sequence must be explicitly mapped, even if their index will not change and even if they will not be used by SLiM; the only exception is for unused slots in the population table, which can be explicitly remapped but do not have to be.  For instance, suppose we have a tree sequence in which population 
\f3\fs18 0
\f4\fs20  is unused, population 
\f3\fs18 1
\f4\fs20  is not a SLiM population (for example, an ancestral population produced by 
\f3\fs18 msprime
\f4\fs20 ), and population 2 is a SLiM population, and we want to load this in with population 2 as 
\f3\fs18 p0
\f4\fs20  in SLiM.  To do this, we could supply a value of 
\f3\fs18 Dictionary("p0", 2, "p1", 1, "p2", 0)
\f4\fs20  for 
\f3\fs18 subpopMap
\f4\fs20 , or we could leave out slot 
\f3\fs18 0
\f4\fs20  since it is unused, with 
\f3\fs18 Dictionary("p0", 2, "p1", 1)
\f4\fs20 .  Although this facility cannot be used to remove populations in the tree sequence, note that it may 
\f1\i add
\f4\i0  populations that will be visible when 
\f3\fs18 treeSeqOutput()
\f4\fs20  is called (although these will not be SLiM populations); if, in this example, we had used 
\f3\fs18 Dictionary("p0", 0, "p1", 1, "p5", 2)
\f4\fs20  and then we wrote the result out with 
\f3\fs18 treeSeqOutput()
\f4\fs20 , the resulting tree sequence would have six populations, although three of them would be empty and would not be used by SLiM.  The use of 
\f3\fs18 subpopMap
\f4\fs20  makes it easier to load simulation data that was generated in Python, since that typically uses an id of 
\f3\fs18 0
\f4\fs20 .  The 
\f3\fs18 subpopMap
\f4\fs20  parameter may not be used with file formats other than tree-sequence files, at the present time; setting up the correct subpopulation ids is typically easier when working with those other formats.  Note the 
\f3\fs18 tskit
\f4\fs20  command-line interface can be used, like 
\f3\fs18 python3 -m tskit populations file.trees
\f4\fs20 , to find out the number of subpopulations in a tree-sequence file and their IDs.\
When loading a tree sequence, a crosscheck of the loaded data will be performed to ensure that the tree sequence was well-formed and was loaded correctly.  When running a Release build of SLiM, however, this crosscheck will only occur the first time that 
\f3\fs18 readFromPopulationFile()
\f4\fs20  is called to load a tree sequence; subsequent calls will not perform this crosscheck, for greater speed when running models that load saved population state many times (such as models that are conditional on fixation).  If you suspect that a tree sequence file might be corrupted or read incorrectly, running a Debug build of SLiM enables crosschecks after every load.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)recalculateFitness([Ni$\'a0tick\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Force an immediate recalculation of fitness values for all individuals in all subpopulations.  Normally fitness values are calculated at a fixed point in each tick, and those values are cached and used until the next recalculation.  If simulation parameters are changed in script in a way that affects fitness calculations, and if you wish those changes to take effect immediately rather than taking effect at the next automatic recalculation, you may call 
\f3\fs18 recalculateFitness()
\f4\fs20  to force an immediate recalculation and recache.\
The optional parameter 
\f3\fs18 tick
\f4\fs20  provides the tick for which 
\f3\fs18 mutationEffect()
\f4\fs20  and 
\f3\fs18 fitnessEffect()
\f4\fs20  callbacks should be selected; if it is 
\f3\fs18 NULL
\f4\fs20  (the default), the current tick value for the simulation, 
\f3\fs18 community.tick
\f4\fs20 , is used.  If you call 
\f3\fs18 recalculateFitness()
\f4\fs20  in an 
\f3\fs18 early()
\f4\fs20  event in a WF model, you may wish this to be 
\f3\fs18 community.tick - 1
\f4\fs20  in order to utilize the 
\f3\fs18 mutationEffect()
\f4\fs20  and 
\f3\fs18 fitnessEffect()
\f4\fs20  callbacks for the previous tick, as if the changes that you have made to fitness-influencing parameters were already in effect at the end of the previous tick when the new generation was first created and evaluated (usually it is simpler to just make such changes in a 
\f3\fs18 late()
\f4\fs20  event instead, however, in which case calling 
\f3\fs18 recalculateFitness()
\f4\fs20  is probably not necessary at all since fitness values will be recalculated immediately afterwards).  Regardless of the value supplied for 
\f3\fs18 tick
\f4\fs20  here, 
\f3\fs18 community.tick
\f4\fs20  inside callbacks will report the true tick number, so if your callbacks consult that parameter in order to create tick-specific fitness effects you will need to handle the discrepancy somehow.  (Similar considerations apply for nonWF models that call 
\f3\fs18 recalculateFitness()
\f4\fs20  in a 
\f3\fs18 late()
\f4\fs20  event, which is also not advisable in general.)\
After this call, the fitness values used for all purposes in SLiM will be the newly calculated values.  Calling this method will trigger the calling of any enabled and applicable 
\f3\fs18 mutationEffect()
\f4\fs20  and 
\f3\fs18 fitnessEffect()
\f4\fs20  callbacks, so this is quite a heavyweight operation; you should think carefully about what side effects might result (which is why fitness recalculation does not just occur automatically after changes that might affect fitness values).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerFitnessEffectCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f5 \'a0
\f3 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 fitnessEffect()
\f4\fs20  callback in the current simulation (specific to the target species), with an optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations), and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerMateChoiceCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 mateChoice()
\f4\fs20  callback in the current simulation\cf2  (specific to the target species)\cf0 , with optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations) and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerModifyChildCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f5 \'a0
\f3 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 modifyChild()
\f4\fs20  callback in the current simulation\cf2  (specific to the target species)\cf0 , with optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations) and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(object<SLiMEidosBlock>$)registerMutationCallback(Nis$\'a0id, string$\'a0source, [Nio<MutationType>$\'a0mutType\'a0=\'a0NULL], [Nio<Subpopulation>$\'a0subpop\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 mutation()
\f4\fs20  callback in the current simulation\kerning1\expnd0\expndtw0  (specific to the target species)\expnd0\expndtw0\kerning0
, with an optional mutation type 
\f3\fs18 mutType
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  mutation type identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all mutation types), optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may also be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations), and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \kerning1\expnd0\expndtw0 \'96\'a0(object<SLiMEidosBlock>$)registerMutationEffectCallback(Nis$\'a0id, string$\'a0source, io<MutationType>$\'a0mutType, [Nio<Subpopulation>$\'a0subpop\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 mutationEffect()
\f4\fs20  callback in the current simulation (specific to the target species), with a required mutation type 
\f3\fs18 mutType
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  mutation type identifier), optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may also be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations), and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerRecombinationCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f5 \'a0
\f3 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 recombination()
\f4\fs20  callback in the current simulation\cf2  (specific to the target species)\cf0 , with optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations) and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerReproductionCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f5 \'a0
\f3 =\'a0NULL], \cf2 \expnd0\expndtw0\kerning0
[Ns$\'a0sex\'a0=\'a0NULL], \cf0 \kerning1\expnd0\expndtw0 [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 reproduction()
\f4\fs20  callback in the current simulation\kerning1\expnd0\expndtw0  (specific to the target species)\expnd0\expndtw0\kerning0
, with optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations), optional sex-specificity 
\f3\fs18 sex
\f4\fs20  (which may be 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  in sexual species to make the callback specific to males or females respectively, or 
\f3\fs18 NULL
\f4\fs20  for no sex-specificity), and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(object<SLiMEidosBlock>$)registerSurvivalCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f5 \'a0
\f3 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f3\fs18 string
\f4\fs20  singleton 
\f3\fs18 source
\f4\fs20 , as an Eidos 
\f3\fs18 survival()
\f4\fs20  callback in the current simulation\cf2  (specific to the target species)\cf0 , with optional subpopulation 
\f3\fs18 subpop
\f4\fs20  (which may be an 
\f3\fs18 integer
\f4\fs20  identifier, or 
\f3\fs18 NULL
\f4\fs20 , the default, to indicate all subpopulations) and optional 
\f3\fs18 start
\f4\fs20  and 
\f3\fs18 end
\f4\fs20  ticks all limiting its applicability.  The script block will be given identifier 
\f3\fs18 id
\f4\fs20  (specified as an 
\f3\fs18 integer
\f4\fs20 , or as a 
\f3\fs18 string
\f4\fs20  symbolic name such as 
\f3\fs18 "s5"
\f4\fs20 ); this may be 
\f3\fs18 NULL
\f4\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f3\fs18 SLiMEidosBlock
\f4\fs20  objects, and is active immediately; it 
\f1\i may
\f4\i0  be eligible to execute in the current tick.  The new 
\f3\fs18 SLiMEidosBlock
\f4\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)simulationFinished(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Declare the current simulation finished.  This method is equivalent to the 
\f3\fs18 Community
\f4\fs20  method 
\f3\fs18 simulationFinished()
\f4\fs20 , except that this method is only legal to call in single-species models (to provide backward compatibility).  It is recommended that new code should call the 
\f3\fs18 Community
\f4\fs20  method; this method may be deprecated in the future.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)skipTick(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Deactivate the target species for the current tick.  This sets the 
\f3\fs18 active
\f4\fs20  property of the species to 
\f3\fs18 F
\f4\fs20 ; it also set the 
\f3\fs18 active
\f4\fs20  property of all callbacks that belong to the species (with the species as their 
\f3\fs18 species
\f4\fs20  specifier) to 
\f3\fs18 F
\f4\fs20 , and sets the active property of all events that are synchronized with the species (with the species as their 
\f3\fs18 ticks
\f4\fs20  specifier) to 
\f3\fs18 F
\f4\fs20 .  The cycle counter for the species will not be incremented at the end of the tick.  This method may only be called in 
\f3\fs18 first()
\f4\fs20  events, to ensure that species are either active or inactive throughout a given tick.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Mutation>)subsetMutations([No<Mutation>$\'a0exclude\'a0=\'a0NULL], [Nio<MutationType>$\'a0mutType\'a0=\'a0NULL], [Ni$\'a0position\'a0=\'a0NULL], [Nis$\'a0nucleotide\'a0=\'a0NULL], [Ni$\'a0tag\'a0=\'a0NULL], [Ni$\'a0id\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector of mutations subset from the list of all active mutations in the species (as would be provided by the 
\f3\fs18 mutations
\f4\fs20  property).  The parameters specify constraints upon the subset of mutations that will be returned.  Parameter 
\f3\fs18 exclude
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a specific mutation that should not be included (typically the focal mutation in some operation).  Parameter 
\f3\fs18 mutType
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a mutation type for the mutations to be returned (as either a 
\f3\fs18 MutationType
\f4\fs20  object or an 
\f3\fs18 integer
\f4\fs20  identifier).  Parameter 
\f3\fs18 position
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a base position for the mutations to be returned.  Parameter 
\f3\fs18 nucleotide
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a nucleotide for the mutations to be returned (either as a string, 
\f3\fs18 "A"
\f4\fs20  / 
\f3\fs18 "C"
\f4\fs20  / 
\f3\fs18 "G"
\f4\fs20  / 
\f3\fs18 "T"
\f4\fs20 , or as an integer, 
\f3\fs18 0
\f4\fs20  / 
\f3\fs18 1
\f4\fs20  / 
\f3\fs18 2
\f4\fs20  / 
\f3\fs18 3
\f4\fs20  respectively).  Parameter 
\f3\fs18 tag
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a tag value for the mutations to be returned.  Parameter 
\f3\fs18 id
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a required value for the 
\f3\fs18 id
\f4\fs20  property of the mutations to be returned.\
This method is shorthand for getting the 
\f3\fs18 mutations
\f4\fs20  property of the subpopulation, and then using operator 
\f3\fs18 []
\f4\fs20  to select only mutations with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.  Note that if you only need to select on mutation type, the 
\f3\fs18 mutationsOfType()
\f4\fs20  method will be even faster.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(logical$)treeSeqCoalesced(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns the coalescence state for the recorded tree sequence at the last simplification.  The returned value is a logical singleton flag, 
\f3\fs18 T
\f4\fs20  to indicate that full coalescence was observed at the last tree-sequence simplification (meaning that there is a single ancestral individual that roots all ancestry trees at all sites along the chromosome \'96 although not necessarily the 
\f1\i same
\f4\i0  ancestor at all sites), or 
\f3\fs18 F
\f4\fs20  if full coalescence was not observed.  For simple models, reaching coalescence may indicate that the model has reached an equilibrium state, but this may not be true in models that modify the dynamics of the model during execution by changing migration rates, introducing new mutations programmatically, dictating non-random mating, etc., so be careful not to attach more meaning to coalescence than it is due; some models may require burn-in beyond coalescence to reach equilibrium, or may not have an equilibrium state at all.  Also note that some actions by a model, such as adding a new subpopulation, may cause the coalescence state to revert from 
\f3\fs18 T
\f4\fs20  back to 
\f3\fs18 F
\f4\fs20  (at the next simplification), so a return value of 
\f3\fs18 T
\f4\fs20  may not necessarily mean that the model is coalesced at the present moment \'96 only that it 
\f1\i was
\f4\i0  coalesced at the last simplification.\
This method may only be called if tree sequence recording has been turned on with 
\f3\fs18 initializeTreeSeq()
\f4\fs20 ; in addition, 
\f3\fs18 checkCoalescence=T
\f4\fs20  must have been supplied to 
\f3\fs18 initializeTreeSeq()
\f4\fs20 , so that the necessary work is done during each tree-sequence simplification.  Since this method does not perform coalescence checking itself, but instead simply returns the coalescence state observed at the last simplification, it may be desirable to call 
\f3\fs18 treeSeqSimplify()
\f4\fs20  immediately before 
\f3\fs18 treeSeqCoalesced()
\f4\fs20  to obtain up-to-date information.  However, the speed penalty of doing this in every tick would be large, and most models do not need this level of precision; usually it is sufficient to know that the model has coalesced, without knowing whether that happened in the current tick or in a recent preceding tick.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)treeSeqOutput(string$\'a0path, [logical$\'a0simplify\'a0=\'a0T], [logical$\'a0includeModel\'a0=\'a0T], \kerning1\expnd0\expndtw0 [No$\'a0metadata\'a0=\'a0NULL]\expnd0\expndtw0\kerning0
)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Outputs the current tree sequence recording tables to the path specified by path.  This method may only be called if tree sequence recording has been turned on with 
\f3\fs18 initializeTreeSeq()
\f4\fs20 .  If 
\f3\fs18 simplify
\f4\fs20  is 
\f3\fs18 T
\f4\fs20  (the default), simplification will be done immediately prior to output; this is almost always desirable, unless a model wishes to avoid simplification entirely.  (Note that if simplification is not done, then all genomes since the last simplification will be marked as samples in the resulting tree sequence.)  A binary tree sequence file will be written to the specified path; a filename extension of 
\f3\fs18 .trees
\f4\fs20  is suggested for this type of file.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
Normally, the full SLiM script used to generate the tree sequence is written out to the provenance entry of the tree sequence file, to the 
\f3\fs18 model
\f4\fs20  subkey of the 
\f3\fs18 parameters
\f4\fs20  top-level key.  Supplying 
\f3\fs18 F
\f4\fs20  for 
\f3\fs18 includeModel
\f4\fs20  suppresses output of the full script.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 A 
\f3\fs18 Dictionary
\f4\fs20  object containing user-generated metadata may be supplied with the 
\f3\fs18 metadata
\f4\fs20  parameter.  If present, this dictionary will be serialized as JSON and attached to the saved tree sequence under a key named 
\f3\fs18 user_metadata
\f4\fs20 , within the 
\f3\fs18 SLiM
\f4\fs20  key.  If 
\f3\fs18 tskit
\f4\fs20  is used to read the tree sequence in Python, this metadata will automatically be deserialized and made available at 
\f3\fs18 ts.metadata["SLiM"]["user_metadata"]
\f4\fs20 .  This metadata dictionary is not used by SLiM, or by 
\f3\fs18 pyslim
\f4\fs20 , 
\f3\fs18 tskit
\f4\fs20 , or 
\f3\fs18 msprime
\f4\fs20 ; you may use it for any purpose you wish.  Note that 
\f3\fs18 metadata
\f4\fs20  may actually be any subclass of 
\f3\fs18 Dictionary
\f4\fs20 , such as a 
\f3\fs18 DataFrame
\f4\fs20 .  It can even be a 
\f3\fs18 Species
\f4\fs20  object such as 
\f3\fs18 sim
\f4\fs20 , or a 
\f3\fs18 LogFile
\f4\fs20  instance; however, only the keys and values contained by the object\'92s 
\f3\fs18 Dictionary
\f4\fs20  superclass state will be serialized into the metadata (properties of the subclass will be ignored).  This metadata dictionary can be recovered from the saved file using the 
\f3\fs18 treeSeqMetadata()
\f4\fs20  function.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(void)treeSeqRememberIndividuals(object<Individual>\'a0individuals\kerning1\expnd0\expndtw0 , [logical$\'a0permanent\'a0=\'a0T]\expnd0\expndtw0\kerning0
)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Mark the individuals specified by 
\f3\fs18 individuals
\f4\fs20  to be kept across tree sequence table simplification.  This method may only be called if tree sequence recording has been turned on with 
\f3\fs18 initializeTreeSeq()
\f4\fs20 .  All currently living individuals are always kept across simplification; this method does not need to be called, and indeed should not be called, for that purpose.  Instead, 
\f3\fs18 treeSeqRememberIndividuals()
\f4\fs20  allows any individual, including dead individuals, to be kept in the final tree sequence.  Typically this would be used, for example, to keep particular individuals that you wanted to be able to trace ancestry back to in later analysis.  However, this is not the typical usage pattern for tree sequence recording; most models will not need to call this method.\
There are two ways to keep individuals across simplification.  If 
\f3\fs18 permanent
\f4\fs20  is 
\f3\fs18 T
\f4\fs20  (the default), then the specified individuals will be permanently remembered: their genomes will be added to the current sample, and they will always be present in the tree sequence.  Permanently remembering a large number of individuals will, of course, markedly increase memory usage and runtime.\
Supplying 
\f3\fs18 F
\f4\fs20  for 
\f3\fs18 permanent
\f4\fs20  will instead mark the individuals only for (temporary) retention: their genomes will not be added to the sample, and they will appear in the final tree sequence only if one of their genomes is retained across simplification.  In other words, the rule of thumb for retained individuals is simple: if a genome is kept by simplification, the genome\'92s corresponding individual is kept also, 
\f1\i if
\f4\i0  it is retained.  Note that permanent remembering takes priority; calling this function with 
\f3\fs18 permanent=F
\f4\fs20  on an individual that has previously been permanently remembered will not remove it from the sample.\
The behavior of simplification for individuals retained with 
\f3\fs18 permanent=F
\f4\fs20  depends upon the value of the 
\f3\fs18 retainCoalescentOnly
\f4\fs20  flag passed to 
\f3\fs18 initializeTreeSeq()
\f4\fs20 ; here we will discuss the behavior of that flag in detail.  First of all, genomes are 
\f1\i always
\f4\i0  removed by simplification unless they are (a) part of the final generation (i.e., in a living individual when simplification occurs), (b) ancestral to the final generation, (c) a genome of a permanently remembered individual, or (d) ancestral to a permanently remembered individual.  If 
\f3\fs18 retainCoalescentOnly
\f4\fs20  is 
\f3\fs18 T
\f4\fs20  (the default), they are 
\f1\i also
\f4\i0  always removed if they are not a branch point (i.e., a coalescent node or most recent common ancestor) in the tree sequence.  In some cases it may be useful to retain a genome and its associated individual when it is simply an intermediate node in the ancestry (i.e., in the middle of a branch).  This can be enabled by setting 
\f3\fs18 retainCoalescentOnly
\f4\fs20  to 
\f3\fs18 F
\f4\fs20  in your call to 
\f3\fs18 initializeTreeSeq()
\f4\fs20 .  In this case, ancestral genomes that are intermediate (\'93unary nodes\'94, in 
\f3\fs18 tskit
\f4\fs20  parlance) and are within an individual that has been retained using the 
\f3\fs18 permanent=F
\f4\fs20  flag here are kept, along with the retained individual itself.  Since setting 
\f3\fs18 retainCoalescentOnly
\f4\fs20  to 
\f3\fs18 F
\f4\fs20  will prevent the unary nodes for retained individuals from being pruned, simplification may often be unable to prune very much at all from the tree sequence, and memory usage and runtime may increase rapidly.  If you are retaining many individuals, this setting should therefore be used only with caution; it is not necessary if you are purely interested in the most recent common ancestors.  See the 
\f3\fs18 pyslim
\f4\fs20  documentation for further discussion of retaining and remembering individuals and the effects of the 
\f3\fs18 retainCoalescentOnly
\f4\fs20  flag.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
The metadata (age, location, etc) that are stored in the resulting tree sequence are those values present at either (a) the final generation, \kerning1\expnd0\expndtw0 if the individual is alive when the tree sequence is output\expnd0\expndtw0\kerning0
, or (b) the last time that the individual was remembered, if not.  Calling 
\f3\fs18 treeSeqRememberIndividuals()
\f4\fs20  on an individual that is already remembered will cause the archived information about the remembered individual to be updated to reflect the individual\'92s current state.  A case where this is particularly important is for the spatial location of individuals in continuous-space models.  SLiM automatically remembers the individuals that comprise the first generation of any new subpopulation created with 
\f3\fs18 addSubpop()
\f4\fs20 , for easy recapitation and other analysis.  However, since these first-generation individuals are remembered at the moment they are created, their spatial locations have not yet been set up, and will contain garbage \'96 and those garbage values will be archived in their remembered state.  If you need correct spatial locations of first-generation individuals for your post-simulation analysis, you should call 
\f3\fs18 treeSeqRememberIndividuals()
\f4\fs20  explicitly on the first generation, after setting spatial locations, to update the archived information with the correct spatial positions.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)treeSeqSimplify(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Triggers an immediate simplification of the tree sequence recording tables.  This method may only be called if tree sequence recording has been turned on with 
\f3\fs18 initializeTreeSeq()
\f4\fs20 .  A call to this method will free up memory being used by entries that are no longer in the ancestral path of any individual within the current sample (currently living individuals, in other words, plus those explicitly added to the sample with 
\f3\fs18 treeSeqRememberIndividuals()
\f4\fs20 ), but it can also take a significant amount of time.  Typically calling this method is not necessary; the automatic simplification performed occasionally by SLiM should be sufficient for most models.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 \kerning1\expnd0\expndtw0 5.16  Class Subpopulation\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.16.1  
\f2\fs18 Subpopulation
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 cloningRate => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The fraction of children in the next generation that will be produced by cloning (as opposed to biparental mating).  In non-sexual (i.e. hermaphroditic) simulations, this property is a singleton 
\f3\fs18 float
\f4\fs20  representing the overall subpopulation cloning rate.  In sexual simulations, this property is a 
\f3\fs18 float
\f4\fs20  vector with two values: the cloning rate for females (at index 
\f3\fs18 0
\f4\fs20 ) and for males (at index 
\f3\fs18 1
\f4\fs20 ).
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 description <\'96> (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A human-readable 
\f3\fs18 string
\f4\fs20  description for the subpopulation.  By default, this is the empty string, 
\f3\fs18 ""
\f4\fs20 ; however, it may be set to whatever you wish.  When tree-sequence recording is enabled, 
\f3\fs18 description
\f4\fs20  is persisted in the subpopulation\'92s metadata in tree-sequence output.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 firstMaleIndex => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The index of the first male individual in the subpopulation.  The 
\f3\fs18 genomes
\f4\fs20  vector is sorted into females first and males second; 
\f3\fs18 firstMaleIndex
\f4\fs20  gives the position of the boundary between those sections.  Note, however, that there are two genomes per diploid individual, and the 
\f3\fs18 firstMaleIndex
\f4\fs20  is 
\f1\i not
\f4\i0  premultiplied by 
\f3\fs18 2
\f4\fs20 ; you must multiply it by 
\f3\fs18 2
\f4\fs20  before using it to decide whether a given index into 
\f3\fs18 genomes
\f4\fs20  is a genome for a male or a female.  The 
\f3\fs18 firstMaleIndex
\f4\fs20  property is also the number of females in the subpopulation, given this design.  For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
fitnessScaling <\'96> (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A 
\f3\fs18 float
\f4\fs20  scaling factor applied to the fitness of all individuals in this subpopulation (i.e., the fitness value computed for each individual will be multiplied by this value).  This is primarily of use in nonWF models, where fitness is absolute, rather than in WF models, where fitness is relative (and thus a constant factor multiplied into the fitness of every individual will make no difference); however, it may be used in either type of model.  This provides a simple, fast way to modify the fitness of all individuals in a subpopulation; conceptually it is similar to returning the same fitness effect for all individuals in the subpopulation from a 
\f3\fs18 fitnessEffect()
\f4\fs20  callback, but without the complexity and performance overhead of implementing such a callback.  To scale the fitness of individuals by different (individual-specific) factors, see the 
\f3\fs18 fitnessScaling
\f4\fs20  property of 
\f3\fs18 Individual
\f4\fs20 .\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 The value of 
\f3\fs18 fitnessScaling
\f4\fs20  is reset to 
\f3\fs18 1.0
\f4\fs20  every tick, so that any scaling factor set lasts for only a single tick.  This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 genomes => (object<Genome>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 All of the genomes contained by the subpopulation; there are two genomes per diploid individual.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 genomesNonNull => (object<Genome>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 All of the genomes contained by the subpopulation, as with the 
\f3\fs18 genomes
\f4\fs20  property, if all of them are not null genomes; any null genomes present are excluded from the returned vector.  This is a convenience shorthand, sometimes useful in models that involve null genomes.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier for this subpopulation; for subpopulation 
\f3\fs18 p3
\f4\fs20 , for example, this is 
\f3\fs18 3
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 immigrantSubpopFractions => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The expected value of the fraction of children in the next generation that are immigrants arriving from particular subpopulations.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 immigrantSubpopIDs => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifiers of the particular subpopulations from which immigrants will arrive in the next generation.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 individualCount => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The number of individuals in the subpopulation; one-half of the number of genomes.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 individuals => (object<Individual>)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 All of the individuals contained by the subpopulation.  Each individual is diploid and thus contains two 
\f3\fs18 Genome
\f4\fs20  objects.\cf2 \expnd0\expndtw0\kerning0
  See the 
\f3\fs18 sampleIndividuals()
\f4\fs20  and 
\f3\fs18 subsetIndividuals()
\f4\fs20  for fast ways to get a subset of the individuals in a subpopulation.
\f5 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 lifetimeReproductiveOutput => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 lifetimeReproductiveOutput
\f4\fs20  contains the value of the 
\f3\fs18 Individual
\f4\fs20  property 
\f3\fs18 reproductiveOutput
\f4\fs20  for all individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).  This allows access to the lifetime reproductive output of individuals in the subpopulation at the end of their lives.  If pedigree tracking is not on, this property is unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 lifetimeReproductiveOutputF => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 lifetimeReproductiveOutputF
\f4\fs20  contains the value of the 
\f3\fs18 Individual
\f4\fs20  property 
\f3\fs18 reproductiveOutput
\f4\fs20  for all female individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).  This property is undefined if separate sexes have not been enabled, or if pedigree tracking is not on.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 lifetimeReproductiveOutputM => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 If pedigree tracking is turned on with 
\f3\fs18 initializeSLiMOptions(keepPedigrees=T)
\f4\fs20 , 
\f3\fs18 lifetimeReproductiveOutputM
\f4\fs20  contains the value of the 
\f3\fs18 Individual
\f4\fs20  property 
\f3\fs18 reproductiveOutput
\f4\fs20  for all male individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).  This property is undefined if separate sexes have not been enabled, or if pedigree tracking is not on.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 name <\'96> (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A human-readable 
\f3\fs18 string
\f4\fs20  name for the subpopulation.  By default, this is the subpopulation\'92s symbol as a 
\f3\fs18 string
\f4\fs20 ; for subpopulation 
\f3\fs18 p3
\f4\fs20 , for example, 
\f3\fs18 name
\f4\fs20  defaults to 
\f3\fs18 "p3"
\f4\fs20 .  However, it may be set to whatever you wish except that subpopulation names must be unique across time (two different subpopulations may not both have the name 
\f3\fs18 "foo"
\f4\fs20 , even if they never exist at the same time).  A subpopulation\'92s 
\f3\fs18 name
\f4\fs20  may appear as a label in SLiMgui, and it can be useful in generating output, debugging, and other purposes.  When tree-sequence recording is enabled, 
\f3\fs18 name
\f4\fs20  is persisted in the subpopulation\'92s metadata in tree-sequence output, and can then be used in Python to identify the subpopulation; if you plan to take advantage of that feature, 
\f3\fs18 name
\f4\fs20  should follow the syntax of Python identifiers: starting with a letter or underscore 
\f3\fs18 [a-zA-Z_]
\f4\fs20 , followed by letters, digits, or underscores 
\f3\fs18 [a-zA-Z0-9_]
\f4\fs20 , without spaces, hyphens, or other characters.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 selfingRate => (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The expected value of the fraction of children in the next generation that will be produced by selfing (as opposed to biparental mating).  Selfing is only possible in non-sexual (i.e. hermaphroditic) simulations; for sexual simulations this property always has a value of 
\f3\fs18 0.0
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 sexRatio => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 For sexual simulations, the sex ratio for the subpopulation.  This is defined, in SLiM, as the fraction of the subpopulation that is male; in other words, it is actually the M:(M+F) ratio.  For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 spatialMaps => (object<SpatialMap>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The spatial maps that are currently added to the subpopulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 spatialBounds => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The spatial boundaries of the subpopulation.  The length of the 
\f3\fs18 spatialBounds
\f4\fs20  property depends upon the spatial dimensionality declared with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .  If the spatial dimensionality is zero (as it is by default), the value of this property is 
\f3\fs18 float(0)
\f4\fs20  (a zero-length 
\f3\fs18 float
\f4\fs20  vector).  Otherwise, minimums are supplied for each coordinate used by the dimensionality of the simulation, followed by maximums for each.  In other words, if the declared dimensionality is 
\f3\fs18 "xy"
\f4\fs20 , the 
\f3\fs18 spatialBounds
\f4\fs20  property will contain values 
\f3\fs18 (x0,\'a0y0,\'a0x1,\'a0y1)
\f4\fs20 ; bounds for the 
\f1\i z
\f4\i0  coordinate will not be included in that case, since that coordinate is not used in the simulation\'92s dimensionality.  This property cannot be set, but the 
\f3\fs18 setSpatialBounds()
\f4\fs20  method may be used to achieve the same thing.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 species => (object<Species>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
The species to which the target object belongs.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is initially undefined\cf2 \expnd0\expndtw0\kerning0
, and it is an error to try to read it\cf0 \kerning1\expnd0\expndtw0 ; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f3\fs18 getValue()
\f4\fs20  and 
\f3\fs18 setValue()
\f4\fs20  methods\cf2  (provided by the 
\f3\fs18 Dictionary
\f4\fs20  class; see the Eidos manual)\cf0 , for another way of attaching state to subpopulations.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.16.2  
\f2\fs18 Subpopulation
\f1\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(object<Individual>)addCloned(object<Individual>$\'a0parent, [integer$\'a0count\'a0=\'a01], [logical$\'a0defer\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Generates a new offspring individual from the given parent by clonal reproduction, queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.  The subpopulation of 
\f3\fs18 parent
\f4\fs20  will be used to locate applicable 
\f3\fs18 mutation()
\f4\fs20  and 
\f3\fs18 modifyChild()
\f4\fs20  callbacks governing the generation of the offspring individual.\
Beginning in SLiM 5.0, the 
\f3\fs18 count
\f4\fs20  parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).  Each offspring is generated independently, based upon the given parameters.  The returned vector contains all generated offspring, except those that were rejected by a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  If all offspring are rejected, 
\f3\fs18 object<Individual>(0)
\f4\fs20  is returned, which is a zero-length 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Individual
\f4\fs20 ; note that this is a change in behavior from earlier versions, which would return 
\f3\fs18 NULL
\f4\fs20 .\
Beginning in SLiM 5.0, passing 
\f3\fs18 T
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.  Genome generation can only be deferred if there are no active 
\f3\fs18 mutation()
\f4\fs20  callbacks; otherwise, an error will result.  Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a 
\f3\fs18 modifyChild()
\f4\fs20  callback or otherwise).  There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of 
\f3\fs18 F
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  is generally preferable since it has fewer restrictions.  When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists).\
Also beginning in SLiM 5.0, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from 
\f3\fs18 parent
\f4\fs20 ; more specifically, the 
\f3\fs18 x
\f4\fs20  property will be inherited in all spatial models (1D/2D/3D), the 
\f3\fs18 y
\f4\fs20  property in 2D/3D models, and the 
\f3\fs18 z
\f4\fs20  property in 3D models.  Properties not inherited will be left uninitialized, as they were prior to SLiM 5.  The parent\'92s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to 
\f3\fs18 pointDeviated()
\f4\fs20 .\
Note that this method is only for use in nonWF models.  See 
\f3\fs18 addCrossed()
\f4\fs20  for further general notes on the addition of new offspring individuals.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(object<Individual>)addCrossed(object<Individual>$\'a0parent1, object<Individual>$\'a0parent2, [Nfs$\'a0sex\'a0=\'a0NULL], [integer$\'a0count\'a0=\'a01], [logical$\'a0defer\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Generates a new offspring individual from the given parents by biparental sexual reproduction, queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.  Attempting to use a newly generated offspring individual as a mate, or to reference it as a member of the target subpopulation in any other way, will result in an error.  In most models the returned individual is not used, but it is provided for maximal generality and flexibility.\
The new offspring individual is generated from 
\f3\fs18 parent1
\f4\fs20  and 
\f3\fs18 parent2
\f4\fs20  by crossing them.  In sexual models 
\f3\fs18 parent1
\f4\fs20  must be female and 
\f3\fs18 parent2
\f4\fs20  must be male; in hermaphroditic models, 
\f3\fs18 parent1
\f4\fs20  and 
\f3\fs18 parent2
\f4\fs20  are unrestricted.  If 
\f3\fs18 parent1
\f4\fs20  and 
\f3\fs18 parent2
\f4\fs20  are the same individual in a hermaphroditic model, that parent self-fertilizes, or \'93selfs\'94, to generate the offspring sexually (note this is not the same as clonal reproduction).  Such selfing is considered \'93incidental\'94 by 
\f3\fs18 addCrossed()
\f4\fs20 , however; if the 
\f3\fs18 preventIncidentalSelfing
\f4\fs20  flag of 
\f3\fs18 initializeSLiMOptions()
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , supplying the same individual for 
\f3\fs18 parent1
\f4\fs20  and 
\f3\fs18 parent2
\f4\fs20  is an error (you must check for and prevent incidental selfing if you set that flag in a nonWF model).  If non-incidental selfing is desired, 
\f3\fs18 addSelfed()
\f4\fs20  should be used instead.\
The 
\f3\fs18 sex
\f4\fs20  parameter specifies the sex of the offspring.  A value of 
\f3\fs18 NULL
\f4\fs20  means \'93make the default choice\'94; in non-sexual models it is the only legal value for 
\f3\fs18 sex
\f4\fs20 , and does nothing, whereas in sexual models it causes male or female to be chosen with equal probability.  A value of 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  for 
\f3\fs18 sex
\f4\fs20  specifies that the offspring should be male or female, respectively.  Finally, a 
\f3\fs18 float
\f4\fs20  value from 
\f3\fs18 0.0
\f4\fs20  to 
\f3\fs18 1.0
\f4\fs20  for 
\f3\fs18 sex
\f4\fs20  provides the probability that the offspring will be male; a value of 
\f3\fs18 0.0
\f4\fs20  will produce a female, a value of 
\f3\fs18 1.0
\f4\fs20  will produce a male, and for intermediate values SLiM will draw the sex of the offspring randomly according to the specified probability.  Unless you wish the bias the sex ratio of offspring, the default value of 
\f3\fs18 NULL
\f4\fs20  should generally be used.\
Note that any defined, active, and applicable 
\f3\fs18 recombination()
\f4\fs20 , 
\f3\fs18 mutation()
\f4\fs20 , and 
\f3\fs18 modifyChild()
\f4\fs20  callbacks will be called as a side effect of calling this method, before this method even returns.  For 
\f3\fs18 recombination()
\f4\fs20  and 
\f3\fs18 mutation()
\f4\fs20  callbacks, the subpopulation of the parent that is generating a given gamete is used; for 
\f3\fs18 modifyChild()
\f4\fs20  callbacks the situation is more complex.  In most biparental mating events, 
\f3\fs18 parent1
\f4\fs20  and 
\f3\fs18 parent2
\f4\fs20  will belong to the same subpopulation, and 
\f3\fs18 modifyChild()
\f4\fs20  callbacks for that subpopulation will be used, just as in WF models.  In certain models (such as models of pollen flow and broadcast spawning), however, biparental mating may occur between parents that are not from the same subpopulation; that is legal in nonWF models, and in that case, 
\f3\fs18 modifyChild()
\f4\fs20  callbacks for the subpopulation of 
\f3\fs18 parent1
\f4\fs20  are used (since that is the maternal parent).\
If the 
\f3\fs18 modifyChild()
\f4\fs20  callback process results in rejection of the proposed child (see section 26.5), a new offspring individual is not be generated.  To force the generation of an offspring individual from a given pair of parents, you could loop until 
\f3\fs18 addCrossed()
\f4\fs20  succeeds, but note that if your 
\f3\fs18 modifyChild()
\f4\fs20  callback rejects all proposed children from those particular parents, your model will then hang, so care must be taken with this approach.  Usually, nonWF models do not force generation of offspring in this manner; rejection of a proposed offspring by a 
\f3\fs18 modifyChild()
\f4\fs20  callback typically represents a phenomenon such as post-mating reproductive isolation or lethal genetic incompatibilities that would reduce the expected litter size, so the default behavior is typically desirable.\
Beginning in SLiM 5.0, the 
\f3\fs18 count
\f4\fs20  parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).  Each offspring is generated independently, based upon the given parameters.  The returned vector contains all generated offspring, except those that were rejected by a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  If all offspring are rejected, 
\f3\fs18 object<Individual>(0)
\f4\fs20  is returned, which is a zero-length 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Individual
\f4\fs20 ; note that this is a change in behavior from earlier versions, which would return 
\f3\fs18 NULL
\f4\fs20 .\
Beginning in SLiM 5.0, passing 
\f3\fs18 T
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.  Genome generation can only be deferred if there are no active 
\f3\fs18 mutation()
\f4\fs20  or 
\f3\fs18 recombination()
\f4\fs20  callbacks; otherwise, an error will result.  Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a 
\f3\fs18 modifyChild()
\f4\fs20  callback or otherwise).  There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of 
\f3\fs18 F
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  is generally preferable since it has fewer restrictions.  When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists).\
Also beginning in SLiM 5.0, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from 
\f3\fs18 parent1
\f4\fs20 ; more specifically, the 
\f3\fs18 x
\f4\fs20  property will be inherited in all spatial models (1D/2D/3D), the 
\f3\fs18 y
\f4\fs20  property in 2D/3D models, and the 
\f3\fs18 z
\f4\fs20  property in 3D models.  Properties not inherited will be left uninitialized, as they were prior to SLiM 5.  The parent\'92s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to 
\f3\fs18 pointDeviated()
\f4\fs20 .\
Note that this method is only for use in nonWF models, in which offspring generation is managed manually by the model script; in such models, 
\f3\fs18 addCrossed()
\f4\fs20  must be called only from 
\f3\fs18 reproduction()
\f4\fs20  callbacks, and may not be called at any other time.  In WF models, offspring generation is managed automatically by the SLiM core.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(object<Individual>)addEmpty([Nfs$\'a0sex\'a0=\'a0NULL], [Nl$\'a0genome1Null\'a0=\'a0NULL], [Nl$\'a0genome2Null\'a0=\'a0NULL], [integer$\'a0count\'a0=\'a01])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Generates a new offspring individual with empty genomes (i.e., containing no mutations), queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.  No 
\f3\fs18 recombination()
\f4\fs20  or 
\f3\fs18 mutation()
\f4\fs20  callbacks will be called.  The target subpopulation will be used to locate applicable 
\f3\fs18 modifyChild()
\f4\fs20  callbacks governing the generation of the offspring individual (unlike the other 
\f3\fs18 addX()
\f4\fs20  methods, because there is no parental individual to reference).  The offspring is considered to have no parents for the purposes of pedigree tracking.  The 
\f3\fs18 sex
\f4\fs20  parameter is treated as in 
\f3\fs18 addCrossed()
\f4\fs20 .\
By default \'96 when 
\f3\fs18 genome1Null
\f4\fs20  and 
\f3\fs18 genome2Null
\f4\fs20  are both 
\f3\fs18 NULL
\f4\fs20  \'96 null genomes will be generated instead of empty genomes only in sex-chromosome simulations, where the sex chromosome that is not being simulated is represented by a null genome; otherwise, empty genomes rather than null genomes will be created.  This default behavior can be changed by passing 
\f3\fs18 T
\f4\fs20  or 
\f3\fs18 F
\f4\fs20  for 
\f3\fs18 genome1Null
\f4\fs20  or 
\f3\fs18 genome2Null
\f4\fs20 , which will force the corresponding offspring genome to be null (
\f3\fs18 T
\f4\fs20 ) or non-null (
\f3\fs18 F
\f4\fs20 ).  The behavior in sex-chromosome simulations cannot be changed, since the presence of null genomes there is dictated by sex, but 
\f3\fs18 T
\f4\fs20  or 
\f3\fs18 F
\f4\fs20  may be passed as long as it matches what SLiM would do anyway.  In all other simulations there is little point in passing 
\f3\fs18 F
\f4\fs20  (since that would be the default behavior anyway), but passing 
\f3\fs18 T
\f4\fs20  can be used to make one or both genomes be null genomes, which can be useful for, e.g., modeling haploids (for which, by convention, the 
\f1\i second
\f4\i0  genome is usually a null genome in SLiM).\
Beginning in SLiM 5.0, the 
\f3\fs18 count
\f4\fs20  parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).  Each offspring is generated independently, based upon the given parameters.  The returned vector contains all generated offspring, except those that were rejected by a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  If all offspring are rejected, 
\f3\fs18 object<Individual>(0)
\f4\fs20  is returned, which is a zero-length 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Individual
\f4\fs20 ; note that this is a change in behavior from earlier versions, which would return 
\f3\fs18 NULL
\f4\fs20 .\
Note that this method is only for use in nonWF models.  See 
\f3\fs18 addCrossed()
\f4\fs20  for further general notes on the addition of new offspring individuals.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(object<Individual>)addRecombinant(No<Genome>$\'a0strand1, No<Genome>$\'a0strand2, Ni\'a0breaks1, No<Genome>$\'a0strand3, No<Genome>$\'a0strand4, Ni\'a0breaks2, [Nfs$\'a0sex\'a0=\'a0NULL], [No<Individual>$\'a0parent1\'a0=\'a0NULL], [No<Individual>$\'a0parent2\'a0=\'a0NULL], [integer$\'a0count\'a0=\'a01], [logical$\'a0defer\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Generates a new offspring individual from the given parental genomes with the specified crossover breakpoints, queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.  The target subpopulation will be used to locate applicable 
\f3\fs18 mutation()
\f4\fs20  and 
\f3\fs18 modifyChild()
\f4\fs20  callbacks governing the generation of the offspring individual (unlike the other 
\f3\fs18 addX()
\f4\fs20  methods, because there are potentially up to four parental individuals to reference); 
\f3\fs18 recombination()
\f4\fs20  callbacks will not be called by this method.  This method is an advanced feature; most models will use 
\f3\fs18 addCrossed()
\f4\fs20 , 
\f3\fs18 addSelfed()
\f4\fs20 , or 
\f3\fs18 addCloned()
\f4\fs20  instead.\
This method supports several possible configurations for 
\f3\fs18 strand1
\f4\fs20 , 
\f3\fs18 strand2
\f4\fs20 , and 
\f3\fs18 breaks1
\f4\fs20  (and the same applies for 
\f3\fs18 strand3
\f4\fs20 , 
\f3\fs18 strand4
\f4\fs20 , and 
\f3\fs18 breaks2
\f4\fs20 ).  If 
\f3\fs18 strand1
\f4\fs20  and 
\f3\fs18 strand2
\f4\fs20  are both 
\f3\fs18 NULL
\f4\fs20 , the corresponding genome in the generated offspring will be empty, as from 
\f3\fs18 addEmpty()
\f4\fs20 , with no parental genomes and no added mutations; in this case, 
\f3\fs18 breaks1
\f4\fs20  must be 
\f3\fs18 NULL
\f4\fs20  or zero-length.  If 
\f3\fs18 strand1
\f4\fs20  is non-
\f3\fs18 NULL
\f4\fs20  but 
\f3\fs18 strand2
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20 , the corresponding genome in the generated offspring will be a clonal copy of 
\f3\fs18 strand1
\f4\fs20  with mutations added, as from 
\f3\fs18 addCloned()
\f4\fs20 ; in this case, 
\f3\fs18 breaks1
\f4\fs20  must similarly be 
\f3\fs18 NULL
\f4\fs20  or zero-length.  If 
\f3\fs18 strand1
\f4\fs20  and 
\f3\fs18 strand2
\f4\fs20  are both non-
\f3\fs18 NULL
\f4\fs20 , the corresponding genome in the generated offspring will result from recombination between 
\f3\fs18 strand1
\f4\fs20  and 
\f3\fs18 strand2
\f4\fs20  with mutations added, as from 
\f3\fs18 addCrossed()
\f4\fs20 , with 
\f3\fs18 strand1
\f4\fs20  being the initial copy strand; copying will switch between strands at each breakpoint in 
\f3\fs18 breaks1
\f4\fs20 , which must be non-
\f3\fs18 NULL
\f4\fs20  but need not be sorted or uniqued (SLiM will sort and unique the supplied breakpoints internally).  (It is not currently legal for 
\f3\fs18 strand1
\f4\fs20  to be 
\f3\fs18 NULL
\f4\fs20  and 
\f3\fs18 strand2
\f4\fs20  non-
\f3\fs18 NULL
\f4\fs20 ; that variant may be assigned some meaning in future.)  Again, this discussion applies equally to 
\f3\fs18 strand3
\f4\fs20 , 
\f3\fs18 strand4
\f4\fs20 , and 
\f3\fs18 breaks2
\f4\fs20 , 
\f1\i mutatis mutandis
\f4\i0 .  Note that when new mutations are generated by 
\f3\fs18 addRecombinant()
\f4\fs20 , their 
\f3\fs18 subpopID
\f4\fs20  property will be the 
\f3\fs18 id
\f4\fs20  of the offspring\'92s subpopulation, since the parental subpopulation is ambiguous; this behavior differs from the other 
\f3\fs18 add...()
\f4\fs20  methods.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 The 
\f3\fs18 sex
\f4\fs20  parameter is interpreted exactly as in 
\f3\fs18 addCrossed()
\f4\fs20 ; see that method for discussion.  If the offspring sex is specified in any way (i.e., if 
\f3\fs18 sex
\f4\fs20  is non-
\f3\fs18 NULL
\f4\fs20 ), the strands provided must be compatible with the sex chosen.  If the offspring sex is not specified (i.e., if 
\f3\fs18 sex
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20 ), the sex will be inferred from the strands provided where possible (when modeling an X or Y chromosome), or will be chosen randomly otherwise (when modeling autosomes); it will 
\f1\i not
\f4\i0  be inferred from the sex of the individuals possessing the parental strands, even when the reproductive mode is essentially clonal from a single parent, since such inference would be ambiguous in the general case.  When modeling the X or Y, 
\f3\fs18 strand1
\f4\fs20  and 
\f3\fs18 strand2
\f4\fs20  must be X genomes (or 
\f3\fs18 NULL
\f4\fs20 ), and 
\f3\fs18 strand3
\f4\fs20  and 
\f3\fs18 strand4
\f4\fs20  must both be X genomes or both be Y genomes (or 
\f3\fs18 NULL
\f4\fs20 ).\
By default, the offspring is considered to have no parents for the purposes of pedigree tracking, since there may be more than two \'93parents\'94 in the general case.  If pedigree tracking of parentage is desired, 
\f3\fs18 parent1
\f4\fs20  and/or 
\f3\fs18 parent2
\f4\fs20  may be passed to explicitly establish particular individuals as the parents of the offspring for purposes of pedigree tracking.  In this case, if only one of 
\f3\fs18 parent1
\f4\fs20  and 
\f3\fs18 parent2
\f4\fs20  is non-
\f3\fs18 NULL
\f4\fs20 , that individual will be set as 
\f1\i both
\f4\i0  of the parents of the offspring, mirroring the way that parentage is tracked for other cases such as 
\f3\fs18 addCloned()
\f4\fs20  and 
\f3\fs18 addSelfed()
\f4\fs20 .  It is not required for 
\f3\fs18 parent1
\f4\fs20  or 
\f3\fs18 parent2
\f4\fs20  to actually be a genetic parent of the offspring at all, although typically they would be.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
These semantics allow several uses for 
\f3\fs18 addRecombinant()
\f4\fs20 .  When all strands are non-
\f3\fs18 NULL
\f4\fs20 , it is similar to 
\f3\fs18 addCrossed()
\f4\fs20  except that the recombination breakpoints are specified explicitly, allowing very precise offspring generation without having to override SLiM\'92s breakpoint generation with a 
\f3\fs18 recombination()
\f4\fs20  callback.  When only 
\f3\fs18 strand1
\f4\fs20  and 
\f3\fs18 strand3
\f4\fs20  are supplied, it is very similar to 
\f3\fs18 addCloned()
\f4\fs20 , creating a clonal offspring, except that the two parental genomes need not belong to the same individual (whatever that might mean biologically).  Supplying only 
\f3\fs18 strand1
\f4\fs20  is useful for modeling clonally reproducing haploids; the second genome of every offspring will be kept empty and will not receive new mutations.  For a model of clonally reproducing haploids that undergo horizontal gene transfer (HGT), supplying only 
\f3\fs18 strand1
\f4\fs20  and 
\f3\fs18 strand2
\f4\fs20  will allow HGT from 
\f3\fs18 strand2
\f4\fs20  to replace segments of an otherwise clonal copy of 
\f3\fs18 strand1
\f4\fs20 , while the second genome of the generated offspring will again be kept empty; this could be useful for modeling bacterial conjugation, for example.  Other variations are also possible.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 The value of the 
\f3\fs18 meanParentAge
\f4\fs20  property of the generated offspring is calculated from the mean parent age of each of its two genomes (whether they turn out to be null genomes or not); that may be an average of two values (if both offspring genomes have at least one parent), a single value (if one offspring genome has no parent), or no values (if both offspring genomes have no parent, in which case 
\f3\fs18 0.0
\f4\fs20  results).  The mean parent age of a given offspring genome is the mean of the ages of the parents of the two strands used to generate that offspring genome; if one strand is 
\f3\fs18 NULL
\f4\fs20  then the mean parent age for that offspring genome is the age of the parent of the non-
\f3\fs18 NULL
\f4\fs20  strand, while if both strands are 
\f3\fs18 NULL
\f4\fs20  then that offspring genome is parentless and is not used in the final calculation.  In other words, if one offspring genome has two parents with ages A and B, and the other offspring genome has one parent with age C, the 
\f3\fs18 meanParentAge
\f4\fs20  of the offspring will be (A+B+C+C)\'a0/\'a04, not (A+B+C)\'a0/\'a03.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
Note that gene conversion tracts are not explicitly supported by this method; the 
\f3\fs18 breaks
\f4\fs20  vectors provide crossover breakpoints, which may be used to implement crossovers or simple gene conversion tracts.  There is no way to specify complex gene conversion tracts with heteroduplex mismatch repair.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 Beginning in SLiM 5.0, the 
\f3\fs18 count
\f4\fs20  parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).  Each offspring is generated independently, based upon the given parameters.  The returned vector contains all generated offspring, except those that were rejected by a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  If all offspring are rejected, 
\f3\fs18 object<Individual>(0)
\f4\fs20  is returned, which is a zero-length 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Individual
\f4\fs20 ; note that this is a change in behavior from earlier versions, which would return 
\f3\fs18 NULL
\f4\fs20 .\
Beginning in SLiM 5.0, passing 
\f3\fs18 T
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.  Genome generation can only be deferred if there are no active 
\f3\fs18 mutation()
\f4\fs20  callbacks; otherwise, an error will result.  Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a 
\f3\fs18 modifyChild()
\f4\fs20  callback or otherwise).  There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of 
\f3\fs18 F
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  is generally preferable since it has fewer restrictions.  When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists).\
Also beginning in SLiM 5.0, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from 
\f3\fs18 parent1
\f4\fs20 ; more specifically, the 
\f3\fs18 x
\f4\fs20  property will be inherited in all spatial models (1D/2D/3D), the 
\f3\fs18 y
\f4\fs20  property in 2D/3D models, and the 
\f3\fs18 z
\f4\fs20  property in 3D models.  Properties not inherited will be left uninitialized, as they were prior to SLiM 5.  The parent\'92s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to 
\f3\fs18 pointDeviated()
\f4\fs20 .  If 
\f3\fs18 parent1
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), 
\f3\fs18 parent2
\f4\fs20  will be used; if it is also 
\f3\fs18 NULL
\f4\fs20 , no spatial position will be inherited.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
Note that this method is only for use in nonWF models.  See 
\f3\fs18 addCrossed()
\f4\fs20  for further general notes on the addition of new offspring individuals.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Individual>)addSelfed(object<Individual>$\'a0parent, [integer$\'a0count\'a0=\'a01], [logical$\'a0defer\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \kerning1\expnd0\expndtw0 Generates a new offspring individual from the given parent by selfing, queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.  The subpopulation of 
\f3\fs18 parent
\f4\fs20  will be used to locate applicable 
\f3\fs18 mutation()
\f4\fs20 , 
\f3\fs18 recombination()
\f4\fs20 , and 
\f3\fs18 modifyChild()
\f4\fs20  callbacks governing the generation of the offspring individual.\
Since selfing requires that 
\f3\fs18 parent
\f4\fs20  act as a source of both a male and a female gamete, this method may be called only in hermaphroditic models; calling it in sexual models will result in an error.  This method represents a non-incidental selfing event, so the 
\f3\fs18 preventIncidentalSelfing
\f4\fs20  flag of 
\f3\fs18 initializeSLiMOptions()
\f4\fs20  has no effect on this method (in contrast to the behavior of 
\f3\fs18 addCrossed()
\f4\fs20 , where selfing is assumed to be incidental).\
Beginning in SLiM 5.0, the 
\f3\fs18 count
\f4\fs20  parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).  Each offspring is generated independently, based upon the given parameters.  The returned vector contains all generated offspring, except those that were rejected by a 
\f3\fs18 modifyChild()
\f4\fs20  callback.  If all offspring are rejected, 
\f3\fs18 object<Individual>(0)
\f4\fs20  is returned, which is a zero-length 
\f3\fs18 object
\f4\fs20  vector of class 
\f3\fs18 Individual
\f4\fs20 ; note that this is a change in behavior from earlier versions, which would return 
\f3\fs18 NULL
\f4\fs20 .\
Beginning in SLiM 5.0, passing 
\f3\fs18 T
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.  Genome generation can only be deferred if there are no active 
\f3\fs18 mutation()
\f4\fs20  or 
\f3\fs18 recombination()
\f4\fs20  callbacks; otherwise, an error will result.  Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a 
\f3\fs18 modifyChild()
\f4\fs20  callback or otherwise).  There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of 
\f3\fs18 F
\f4\fs20  for 
\f3\fs18 defer
\f4\fs20  is generally preferable since it has fewer restrictions.  When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists).\
Also beginning in SLiM 5.0, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from 
\f3\fs18 parent
\f4\fs20 ; more specifically, the 
\f3\fs18 x
\f4\fs20  property will be inherited in all spatial models (1D/2D/3D), the 
\f3\fs18 y
\f4\fs20  property in 2D/3D models, and the 
\f3\fs18 z
\f4\fs20  property in 3D models.  Properties not inherited will be left uninitialized, as they were prior to SLiM 5.  The parent\'92s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to 
\f3\fs18 pointDeviated()
\f4\fs20 .\
Note that this method is only for use in nonWF models.  See 
\f3\fs18 addCrossed()
\f4\fs20  for further general notes on the addition of new offspring individuals.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)addSpatialMap(object<SpatialMap>$\'a0map)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Adds the given 
\f3\fs18 SpatialMap
\f4\fs20  object, 
\f3\fs18 map
\f4\fs20 , to the subpopulation.  (The spatial map would have been previously created with a call to 
\f3\fs18 defineSpatialMap()
\f4\fs20  on a different subpopulation; 
\f3\fs18 addSpatialMap()
\f4\fs20  can then be used to add that existing spatial map with other subpopulations, sharing the map between subpopulations.)  If the map is already added to the target subpopulation, this method does nothing; if a different map with the same name is already added to the subpopulation, an error results (because map names must be unique within each subpopulation).  The map being added must be compatible with the target subpopulation; in particular, the spatial bounds utilized by the map must exactly match the corresponding spatial bounds for the subpopulation, and the dimensionality of the subpopulation must encompass the spatiality of the map.  For example, if the map has a spatiality of 
\f3\fs18 "xz"
\f4\fs20  then the subpopulation must have a dimensionality of 
\f3\fs18 "xyz"
\f4\fs20  so that it encompasses both 
\f3\fs18 "x"
\f4\fs20  and 
\f3\fs18 "z"
\f4\fs20 , and the subpopulation\'92s spatial bounds for 
\f3\fs18 "x"
\f4\fs20  and 
\f3\fs18 "z"
\f4\fs20  must match those for the map (but the spatial bounds for 
\f3\fs18 "y"
\f4\fs20  are unimportant, since the map does not use that dimension).\
Adding a map to a subpopulation is not strictly necessary, at present; one may query a 
\f3\fs18 SpatialMap
\f4\fs20  object directly using 
\f3\fs18 mapValue()
\f4\fs20 , regarding points in a subpopulation, without the map actually having been added to that subpopulation.  However, it is a good idea to use 
\f3\fs18 addSpatialMap()
\f4\fs20 , both for its compatibility check that prevents unnoticed scripting errors, and because it ensures correct display of the model in SLiMgui.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(float)cachedFitness(Ni\'a0indices)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 The fitness values calculated for the individuals at the indices given are returned.  If 
\f3\fs18 NULL
\f4\fs20  is passed, fitness values for all individuals in the subpopulation are returned.  The fitness values returned are cached values; 
\f3\fs18 mutationEffect()
\f4\fs20  and 
\f3\fs18 fitnessEffect()
\f4\fs20  callbacks are therefore not called as a side effect of this method.  It is always an error to call 
\f3\fs18 cachedFitness()
\f4\fs20  from inside a 
\f3\fs18 mutationEffect()
\f4\fs20  or 
\f3\fs18 fitnessEffect()
\f4\fs20  callback, since fitness values are in the middle of being set up.  In WF models, it is also an error to call 
\f3\fs18 cachedFitness()
\f4\fs20  from a 
\f3\fs18 late()
\f4\fs20  event, because fitness values for the new offspring generation have not yet been calculated and are undefined.  In nonWF models, the population may be a mixture of new and old individuals, so instead, 
\f3\fs18 NAN
\f4\fs20  will be returned as the fitness of any new individuals whose fitness has not yet been calculated.  When new subpopulations are first created with 
\f3\fs18 addSubpop()
\f4\fs20  or 
\f3\fs18 addSubpopSplit()
\f4\fs20 , the fitness of all of the newly created individuals is considered to be 
\f3\fs18 1.0
\f4\fs20  until fitness values are recalculated.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(void)configureDisplay([Nf\'a0center\'a0=\'a0NULL], [Nf$\'a0scale\'a0=\'a0NULL], [Ns$\'a0color\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 This method customizes the display of the subpopulation in SLiMgui\'92s Population Visualization graph.  When this method is called by a model running outside SLiMgui, it will do nothing except type-checking and bounds-checking its arguments.  When called by a model running in SLiMgui, the position, size, and color of the subpopulation\'92s displayed circle can be controlled as specified below.\
The 
\f3\fs18 center
\f4\fs20  parameter sets the coordinates of the center of the subpopulation\'92s displayed circle; it must be a 
\f3\fs18 float
\f4\fs20  vector of length two, such that 
\f3\fs18 center[0]
\f4\fs20  provides the 
\f1\i x
\f4\i0 -coordinate and 
\f3\fs18 center[1]
\f4\fs20  provides the 
\f1\i y
\f4\i0 -coordinate.  The square central area of the Population Visualization occupies scaled coordinates in [0,1] for both 
\f1\i x
\f4\i0  and 
\f1\i y
\f4\i0 , so the values in 
\f3\fs18 center
\f4\fs20  must be within those bounds.  If a value of 
\f3\fs18 NULL
\f4\fs20  is provided, SLiMgui\'92s default center will be used (which currently arranges subpopulations in a circle).\
The 
\f3\fs18 scale
\f4\fs20  parameter sets a scaling factor to be applied to the radius of the subpopulation\'92s displayed circle.  The default radius used by SLiMgui is a function of the subpopulation\'92s number of individuals; this default radius is then multiplied by 
\f3\fs18 scale
\f4\fs20 .  If a value of 
\f3\fs18 NULL
\f4\fs20  is provided, the default radius will be used; this is equivalent to supplying a 
\f3\fs18 scale
\f4\fs20  of 
\f3\fs18 1.0
\f4\fs20 .  Typically the same 
\f3\fs18 scale
\f4\fs20  value should be used by all subpopulations, to scale all of their circles up or down uniformly, but that is not required.\
The 
\f3\fs18 color
\f4\fs20  parameter sets the color to be used for the displayed subpopulation\'92s circle.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f3\fs18 "#RRGGBB"
\f4\fs20  (see the Eidos manual).  If 
\f3\fs18 color
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  or the empty string, 
\f3\fs18 ""
\f4\fs20 , SLiMgui\'92s default (fitness-based) color will be used.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \kerning1\expnd0\expndtw0 \'96\'a0(object<SpatialMap>$)defineSpatialMap(string$\'a0name, string$\'a0spatiality, numeric\'a0values, [logical$\'a0interpolate\'a0=\'a0F], [Nif\'a0valueRange\'a0=\'a0NULL], [Ns\'a0colors\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Defines a spatial map for the subpopulation; see the 
\f3\fs18 SpatialMap
\f4\fs20  documentation regarding this class.  The new map is automatically added to the subpopulation; 
\f3\fs18 addSpatialMap()
\f4\fs20  does not need to be called.  (That method is for sharing the map with additional subpopulations, beyond the one for which the map was originally defined.)  The new 
\f3\fs18 SpatialMap
\f4\fs20  object is returned, and may be retained permanently using 
\f3\fs18 defineConstant()
\f4\fs20  or 
\f3\fs18 defineGlobal()
\f4\fs20  for convenience.\
The name of the map is given by 
\f3\fs18 name
\f4\fs20 , and can be used to identify it.  The map uses the spatial dimensions referenced by 
\f3\fs18 spatiality
\f4\fs20 , which must be a subset of the dimensions defined for the simulation in 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .  Spatiality 
\f3\fs18 "x"
\f4\fs20  is permitted for dimensionality 
\f3\fs18 "x"
\f4\fs20 ; spatiality 
\f3\fs18 "x"
\f4\fs20 , 
\f3\fs18 "y"
\f4\fs20 , or 
\f3\fs18 "xy"
\f4\fs20  for dimensionality 
\f3\fs18 "xy"
\f4\fs20 ; and spatiality 
\f3\fs18 "x"
\f4\fs20 , 
\f3\fs18 "y"
\f4\fs20 , 
\f3\fs18 "z"
\f4\fs20 , 
\f3\fs18 "xy"
\f4\fs20 , 
\f3\fs18 "yz"
\f4\fs20 , 
\f3\fs18 "xz"
\f4\fs20 , or 
\f3\fs18 "xyz"
\f4\fs20  for dimensionality 
\f3\fs18 "xyz"
\f4\fs20 .  The spatial map is defined by a grid of values supplied in parameter 
\f3\fs18 values
\f4\fs20 .  That grid of values is aligned with the spatial bounds of the subpopulation, as described in more detail below; the spatial map is therefore coupled to those spatial bounds, and can only be used in subpopulations that match those particular spatial bounds (to avoid stretching or shrinking the map).  The remaining optional parameters are described below.\
Note that the semantics of this method changed in SLiM 3.5; in particular, the 
\f3\fs18 gridSize
\f4\fs20  parameter was removed, and the interpretation of the 
\f3\fs18 values
\f4\fs20  parameter changed as described below.  Existing code written prior to SLiM 3.5 will produce an error, due to the removed 
\f3\fs18 gridSize
\f4\fs20  parameter, and must be revised carefully to obtain the same result, even if 
\f3\fs18 NULL
\f4\fs20  had been passed for 
\f3\fs18 gridSize
\f4\fs20  previously.\
Beginning in SLiM 3.5, the 
\f3\fs18 values
\f4\fs20  parameter must be a vector/matrix/array with the number of dimensions appropriate for the declared spatiality of the map; for example, a map with spatiality 
\f3\fs18 "x"
\f4\fs20  would require a (one-dimensional) vector, spatiality 
\f3\fs18 "xy"
\f4\fs20  would require a (two-dimensional) matrix, and a map with spatiality of 
\f3\fs18 "xyz"
\f4\fs20  would require a three-dimensional array.  (See the Eidos manual for discussion of vectors, matrices, and arrays.)  The data in 
\f3\fs18 values
\f4\fs20  is interpreted in such a way that a two-dimensional matrix of values, with (0, 0) at upper left and values by column, is transformed into the format expected by SLiM, with (0, 0) at lower left and values by row; in other words, the two-dimensional matrix as it prints in the Eidos console will match the appearance of the two-dimensional spatial map as seen in SLiMgui.  
\f1\i This is a change in behavior from versions prior to SLiM 3.5
\f4\i0 ; it ensures that images loaded from disk with the Eidos class 
\f3\fs18 Image
\f4\fs20  can be used directly as spatial maps, achieving the expected orientation, with no need for transposition or flipping.  If the spatial map is a three-dimensional array, it is read as successive 
\f1\i z
\f4\i0 -axis \'93planes\'94, each of which is a two-dimensional matrix that is treated as described above.\
Moving on to the other parameters of 
\f3\fs18 defineSpatialMap()
\f4\fs20 : if 
\f3\fs18 interpolate
\f4\fs20  is 
\f3\fs18 F
\f4\fs20 , values across the spatial map are not interpolated; the value at a given point is equal to the nearest value defined by the grid of values specified.  If 
\f3\fs18 interpolate
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 , values across the spatial map will be interpolated (using linear, bilinear, or trilinear interpolation as appropriate) to produce spatially continuous variation in values.  In either case, the corners of the value grid are exactly aligned with the corners of the spatial boundaries of the subpopulation as specified by 
\f3\fs18 setSpatialBounds()
\f4\fs20 , and the value grid is then stretched across the spatial extent of the subpopulation in such a manner as to produce equal spacing between the values along each dimension.  The setting of 
\f3\fs18 interpolation
\f4\fs20  only affects how values between these grid points are calculated: by nearest-neighbor, or by linear interpolation.  Interpolation of spatial maps with periodic boundaries is not handled specially; to ensure that the edges of a periodic spatial map join smoothly, simply ensure that the grid values at the edges of the map are identical, since they will be coincident after periodic wrapping.  Note that cubic/bicubic interpolation is generally smoother than linear/bilinear interpolation, with fewer artifacts, but it is substantially slower to calculate; use the 
\f3\fs18 interpolate()
\f4\fs20  method of 
\f3\fs18 SpatialMap
\f4\fs20  to precalculate an interpolated map using cubic/bucubic interpolation.\
The 
\f3\fs18 valueRange
\f4\fs20  and 
\f3\fs18 colors
\f4\fs20  parameters travel together; either both are unspecified, or both are specified.  They control how map values will be transformed into colors, by SLiMgui and by the 
\f3\fs18 mapColor()
\f4\fs20  method.  The 
\f3\fs18 valueRange
\f4\fs20  parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.  The 
\f3\fs18 colors
\f4\fs20  parameter then establishes the corresponding colors for values within the interval defined by 
\f3\fs18 valueRange
\f4\fs20 : values less than or equal to 
\f3\fs18 valueRange[0]
\f4\fs20  will map to 
\f3\fs18 colors[0]
\f4\fs20 , values greater than or equal to 
\f3\fs18 valueRange[1]
\f4\fs20  will map to the last 
\f3\fs18 colors
\f4\fs20  value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.  This is much simpler than it sounds in this description; see the recipes in chapter 15 for an illustration of its use.\
Note that at present, SLiMgui will only display spatial maps of spatiality 
\f3\fs18 "x"
\f4\fs20 , 
\f3\fs18 "y"
\f4\fs20 , or 
\f3\fs18 "xy"
\f4\fs20 ; the color-mapping parameters will simply be ignored by SLiMgui for other spatiality values (even if the spatiality is a superset of these values; SLiMgui will not attempt to display an 
\f3\fs18 "xyz"
\f4\fs20  spatial map, for example, since it has no way to choose which 2D slice through the 
\f1\i xyz
\f4\i0  space it ought to display).  The 
\f3\fs18 mapColor()
\f4\fs20  method will return translated color strings for any spatial map, however, even if SLiMgui is unable to display the spatial map.  If there are multiple spatial maps that SLiMgui is capable of displaying, it choose one for display by default, but other maps may be selected from the action menu on the individuals view (by clicking on the button with the gear icon).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)outputMSSample(integer$\'a0sampleSize, [logical$\'a0replace\'a0=\'a0T], [string$\'a0requestedSex\'a0=\'a0"*"], [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F]\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0filterMonomorphic\'a0=\'a0F]\cf0 \kerning1\expnd0\expndtw0 )
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output a random sample from the subpopulation in MS format.  Positions in the output will span the interval [0,1].  A sample of genomes (not entire individuals, note) of size 
\f3\fs18 sampleSize
\f4\fs20  from the subpopulation will be output.  The sample may be done either with or without replacement, as specified by 
\f3\fs18 replace
\f4\fs20 ; the default is to sample with replacement.  A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  for 
\f3\fs18 requestedSex
\f4\fs20 ; passing 
\f3\fs18 "*"
\f4\fs20 , the default, indicates that genomes from individuals should be selected randomly, without respect to sex.  If the sampling options provided by this method are not adequate, see the 
\f3\fs18 outputMS()
\f4\fs20  method of 
\f3\fs18 Genome
\f4\fs20  for a more flexible low-level option.\
If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 \expnd0\expndtw0\kerning0
If 
\f3\fs18 filterMonomorphic
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), all mutations that are present in the sample will be included in the output.  This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in 
\f1\i every
\f4\i0  sampled genome, and are thus apparently fixed).  These may be filtered out with 
\f3\fs18 filterMonomorphic = T
\f4\fs20  if desired; note that this option means that some mutations that do exist in the sampled genomes might not be included in the output, simply because they exist in every sampled genome.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 See 
\f3\fs18 outputSample()
\f4\fs20  and 
\f3\fs18 outputVCFSample()
\f4\fs20  for other output formats.  Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)outputSample(integer$\'a0sampleSize, [logical$\'a0replace\'a0=\'a0T], [string$\'a0requestedSex\'a0=\'a0"*"], [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output a random sample from the subpopulation in SLiM\'92s native format.  A sample of genomes (not entire individuals, note) of size 
\f3\fs18 sampleSize
\f4\fs20  from the subpopulation will be output.  The sample may be done either with or without replacement, as specified by 
\f3\fs18 replace
\f4\fs20 ; the default is to sample with replacement.  A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  for 
\f3\fs18 requestedSex
\f4\fs20 ; passing 
\f3\fs18 "*"
\f4\fs20 , the default, indicates that genomes from individuals should be selected randomly, without respect to sex.  If the sampling options provided by this method are not adequate, see the 
\f3\fs18 output()
\f4\fs20  method of 
\f3\fs18 Genome
\f4\fs20  for a more flexible low-level option.\
If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .\

\f4 See 
\f3\fs18 outputMSSample()
\f4\fs20  and 
\f3\fs18 outputVCFSample()
\f4\fs20  for other output formats.  Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)outputVCFSample(integer$\'a0sampleSize, [logical$\'a0replace\'a0=\'a0T], [string$\'a0requestedSex\'a0=\'a0"*"], [logical$\'a0outputMultiallelics\'a0=\'a0T], [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F]\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0simplifyNucleotides\'a0=\'a0F], [logical$\'a0outputNonnucleotides\'a0=\'a0T]\cf0 \kerning1\expnd0\expndtw0 )
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Output a random sample from the subpopulation in VCF format.  A sample of individuals (not genomes, note \'96 unlike the 
\f3\fs18 outputSample()
\f4\fs20  and 
\f3\fs18 outputMSSample()
\f4\fs20  methods) of size 
\f3\fs18 sampleSize
\f4\fs20  from the subpopulation will be output.  The sample may be done either with or without replacement, as specified by 
\f3\fs18 replace
\f4\fs20 ; the default is to sample with replacement.  A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing 
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20  for 
\f3\fs18 requestedSex
\f4\fs20 ; passing 
\f3\fs18 "*"
\f4\fs20 , the default, indicates that genomes from individuals should be selected randomly, without respect to sex.  If the sampling options provided by this method are not adequate, see the 
\f3\fs18 outputVCF()
\f4\fs20  method of 
\f3\fs18 Genome
\f4\fs20  for a more flexible low-level option.\
If the optional parameter 
\f3\fs18 filePath
\f4\fs20  is 
\f3\fs18 NULL
\f4\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f3\fs18 filePath
\f4\fs20 , overwriting that file if 
\f3\fs18 append
\f4\fs20  if 
\f3\fs18 F
\f4\fs20 , or appending to the end of it if 
\f3\fs18 append
\f4\fs20  is 
\f3\fs18 T
\f5\fs20 .\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4 \cf2 \expnd0\expndtw0\kerning0
The parameters 
\f3\fs18 outputMultiallelics
\f4\fs20 , 
\f3\fs18 simplifyNucleotides
\f4\fs20 , and 
\f3\fs18 outputNonnucleotides
\f4\fs20  affect the format of the output produced; see the reference documentation for further discussion.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 See 
\f3\fs18 outputMSSample()
\f4\fs20  and 
\f3\fs18 outputSample()
\f4\fs20  for other output formats.  Output is generally done in a 
\f3\fs18 late()
\f4\fs20  event, so that the output reflects the state of the simulation at the end of a tick.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)pointDeviated(integer$\'a0n, float\'a0point, string$\'a0boundary, numeric$\'a0maxDistance, string$\'a0functionType, ...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a vector containing 
\f3\fs18 n
\f4\fs20  points that are derived from 
\f3\fs18 point
\f4\fs20  by adding a deviation drawn from a dispersal kernel (specified by 
\f3\fs18 maxDistance
\f4\fs20 , 
\f3\fs18 functionType
\f4\fs20 , and the ellipsis parameters 
\f3\fs18 ...
\f4\fs20 ) and then applying a boundary condition specified by 
\f3\fs18 boundary
\f4\fs20 .  This method therefore performs the steps of a simple dispersal algorithm in a single vectorized call.\
The parameter 
\f3\fs18 point
\f4\fs20  may contain a single point which is deviated and bounded 
\f3\fs18 n
\f4\fs20  times, or may contain 
\f3\fs18 n
\f4\fs20  points each of which is deviated and bounded.  In any case, each point in 
\f3\fs18 point
\f4\fs20  should match the dimensionality of the model \'96 one element in a 1D model, two elements in a 2D model, or three elements in a 3D model.  This method should not be called in a non-spatial model.\
The dispersal kernel is specified similarly to other kernel-based methods, such as 
\f3\fs18 setInteractionFunction()
\f4\fs20  and 
\f3\fs18 smooth()
\f4\fs20 ; see the 
\f3\fs18 InteractionType
\f4\fs20  class documentation for detailed discussion of the available spatial kernel types and their parameters (supplied in the ellipsis, 
\f3\fs18 ...
\f4\fs20 ).  For 
\f3\fs18 pointDeviated()
\f4\fs20 , the Cauchy (
\f3\fs18 "c"
\f4\fs20 ) kernel is not allowed since it is not well-behaved for this purpose, and the Student\'92s 
\f1\i t
\f4\i0  (
\f3\fs18 "t"
\f4\fs20 ) kernel is not allowed in 3D models at present simply because it hasn\'92t been implemented.  The random points returned from this method are drawn from the probability distribution that is radially symmetric and has density proportional to the interaction strength \'96 in other words, at distance 
\f1\i r
\f4\i0  the density is proportional to the functional form referred to by 
\f3\fs18 functionType
\f4\fs20 .  For instance, the density of the probability distribution for type 
\f3\fs18 "e"
\f4\fs20  with rate 
\f1\i a
\f4\i0  at distance 
\f1\i r
\f4\i0  is proportional to exp(\uc0\u8722 
\f1\i ra
\f4\i0 ); and so the distribution of the distance in 1D is exponential, while in 2D it is proportional to 
\f1\i r
\f4\i0  exp(\uc0\u8722 
\f1\i ra
\f4\i0 ) (i.e., Gamma with shape parameter 1).\
The boundary condition must be one of 
\f3\fs18 "none"
\f4\fs20 , 
\f3\fs18 "periodic"
\f4\fs20 , 
\f3\fs18 "reflecting"
\f4\fs20 , 
\f3\fs18 "stopping"
\f4\fs20 , or 
\f3\fs18 "reprising"
\f4\fs20 .  For 
\f3\fs18 "none"
\f4\fs20 , no boundary condition is enforced; the deviated points are simply returned as is.  For 
\f3\fs18 "periodic"
\f4\fs20 , 
\f3\fs18 "reflecting"
\f4\fs20 , and 
\f3\fs18 "stopping"
\f4\fs20 , the boundary condition is enforced just as it is by the 
\f3\fs18 pointPeriodic()
\f4\fs20 , 
\f3\fs18 pointReflected()
\f4\fs20 , and 
\f3\fs18 pointStopped()
\f4\fs20  methods; see their documentation for further details.  For 
\f3\fs18 "reprising"
\f4\fs20 , if the deviated point is out of bounds a new deviated point will be chosen, based upon the same original point, until a point inside bounds is obtained.  Note that absorbing boundaries (for which being out-of-bounds is lethal) would be implemented in script; this method cannot enforce them.\
In the typical usage case, 
\f3\fs18 point
\f4\fs20  comes from the 
\f3\fs18 spatialPosition
\f4\fs20  property for a vector of individuals, and the result is then set back onto the same vector of individuals using the 
\f3\fs18 setSpatialPosition()
\f4\fs20  method; however, this method might be useful in other situations too.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(logical)pointInBounds(float\'a0point)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns 
\f3\fs18 T
\f4\fs20  if 
\f3\fs18 point
\f4\fs20  is inside the spatial boundaries of the subpopulation, 
\f3\fs18 F
\f4\fs20  otherwise.  For example, for a simulation with 
\f3\fs18 "xy"
\f4\fs20  dimensionality, if 
\f3\fs18 point
\f4\fs20  contains exactly two values constituting an (
\f1\i x
\f4\i0 ,
\f1\i y
\f4\i0 ) point, the result will be 
\f3\fs18 T
\f4\fs20  if and only if 
\f3\fs18 ((point[0]>=x0) & (point[0]<=x1) & (point[1]>=y0) & (point[1]<=y1))
\f4\fs20  given spatial bounds 
\f3\fs18 (x0, y0, x1, y1)
\f4\fs20 .  This method is useful for implementing absorbing or reprising boundary conditions.  This may only be called in simulations for which continuous space has been enabled with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .\
The length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f3\fs18 point
\f4\fs20  may contain values comprising more than one point.  In this case, a 
\f3\fs18 logical
\f4\fs20  vector will be returned in which each element is 
\f3\fs18 T
\f4\fs20  if the corresponding point in 
\f3\fs18 point
\f4\fs20  is inside the spatial boundaries of the subpopulation, 
\f3\fs18 F
\f4\fs20  otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)pointPeriodic(float\'a0point)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a revised version of 
\f3\fs18 point
\f4\fs20  that has been brought inside the periodic spatial boundaries of the subpopulation (as specified by the 
\f3\fs18 periodicity
\f4\fs20  parameter of 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 ) by wrapping around periodic spatial boundaries.  In brief, if a coordinate of 
\f3\fs18 point
\f4\fs20  lies beyond a periodic spatial boundary, that coordinate is wrapped around the boundary, so that it lies inside the spatial extent by the same magnitude that it previously lay outside, but on the opposite side of the space; in effect, the two edges of the periodic spatial boundary are seamlessly joined.  This is done iteratively until all coordinates lie inside the subpopulation\'92s periodic boundaries.  Note that non-periodic spatial boundaries are not enforced by this method; they should be enforced using 
\f3\fs18 pointReflected()
\f4\fs20 , 
\f3\fs18 pointStopped()
\f4\fs20 , or some other means of enforcing boundary constraints (which can be used after 
\f3\fs18 pointPeriodic()
\f4\fs20  to bring the remaining coordinates into bounds; coordinates already brought into bounds by 
\f3\fs18 pointPeriodic()
\f4\fs20  will be unaffected by those calls).  This method is useful for implementing periodic boundary conditions.  This may only be called in simulations for which continuous space  and at least one periodic spatial dimension have been enabled with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .\
The length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f3\fs18 point
\f4\fs20  may contain values comprising more than one point.  In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)pointReflected(float\'a0point)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a revised version of 
\f3\fs18 point
\f4\fs20  that has been brought inside the spatial boundaries of the subpopulation by reflection.  In brief, if a coordinate of 
\f3\fs18 point
\f4\fs20  lies beyond a spatial boundary, that coordinate is reflected across the boundary, so that it lies inside the boundary by the same magnitude that it previously lay outside the boundary.  This is done iteratively until all coordinates lie inside the subpopulation\'92s boundaries.  This method is useful for implementing reflecting boundary conditions.  This may only be called in simulations for which continuous space has been enabled with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .\
The length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f3\fs18 point
\f4\fs20  may contain values comprising more than one point.  In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)pointStopped(float\'a0point)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a revised version of 
\f3\fs18 point
\f4\fs20  that has been brought inside the spatial boundaries of the subpopulation by clamping.  In brief, if a coordinate of 
\f3\fs18 point
\f4\fs20  lies beyond a spatial boundary, that coordinate is set to exactly the position of the boundary, so that it lies on the edge of the spatial boundary.  This method is useful for implementing stopping boundary conditions.  This may only be called in simulations for which continuous space has been enabled with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .\
The length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f3\fs18 point
\f4\fs20  may contain values comprising more than one point.  In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(float)pointUniform([integer$\'a0n\'a0=\'a01])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Returns a new point (or points, for 
\f3\fs18 n
\f4\fs20  > 1) generated from uniform draws for each coordinate, within the spatial boundaries of the subpopulation.  The returned vector will contain 
\f3\fs18 n
\f4\fs20  points, each comprised of a number of coordinates equal to the dimensionality of the simulation, so it will be of total length 
\f3\fs18 n
\f4\fs20 *dimensionality.  This may only be called in simulations for which continuous space has been enabled with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \kerning1\expnd0\expndtw0 \'96\'a0(void)removeSpatialMap(so<SpatialMap>$\'a0map)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Removes the 
\f3\fs18 SpatialMap
\f4\fs20  object specified by 
\f3\fs18 map
\f4\fs20  from the subpopulation.  The parameter 
\f3\fs18 map
\f4\fs20  may be either a 
\f3\fs18 SpatialMap
\f4\fs20  object, or a 
\f3\fs18 string
\f4\fs20  name for spatial map.  The map must have been added to the subpopulation with 
\f3\fs18 addSpatialMap()
\f4\fs20 ; if it has not been, an error results.  Removing spatial maps that are no longer in use is optional in most cases.  It is generally a good idea because it might decrease SLiM\'92s memory footprint; also, it avoids an error if the subpopulation\'92s spatial bounds are changed (see 
\f3\fs18 setSpatialBounds()
\f4\fs20 ).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)removeSubpopulation(void)
\f5 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
Removes this subpopulation from the model.  The subpopulation is immediately removed from the list of active subpopulations, and the symbol representing the subpopulation is undefined.  The subpopulation object itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.\
Note that this method is only for use in nonWF models, in which there is a distinction between a subpopulation being empty and a subpopulation being removed from the simulation; an empty subpopulation may be re-colonized by migrants, whereas as a removed subpopulation no longer exists at all.  WF models do not make this distinction; when a subpopulation is empty it is automatically removed.  WF models should therefore call 
\f3\fs18 setSubpopulationSize(0)
\f4\fs20  instead of this method; 
\f3\fs18 setSubpopulationSize()
\f4\fs20  is the standard way for WF models to change the subpopulation size, including to a size of 
\f3\fs18 0
\f4\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0\cf2 \expnd0\expndtw0\kerning0
(object<Individual>)sampleIndividuals(integer$\'a0size, [logical$\'a0replace\'a0=\'a0F], [No<Individual>$\'a0exclude\'a0=\'a0NULL], [Ns$\'a0sex\'a0=\'a0NULL], [Ni$\'a0tag\'a0=\'a0NULL], [Ni$\'a0minAge\'a0=\'a0NULL], [Ni$\'a0maxAge\'a0=\'a0NULL], [Nl$\'a0migrant\'a0=\'a0NULL])
\f5 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns a vector of individuals, of size less than or equal to parameter 
\f3\fs18 size
\f4\fs20 , sampled from the individuals in the target subpopulation.  Sampling is done without replacement if 
\f3\fs18 replace
\f4\fs20  is 
\f3\fs18 F
\f4\fs20  (the default), or with replacement if 
\f3\fs18 replace
\f4\fs20  is 
\f3\fs18 T
\f4\fs20 .  The remaining parameters specify constraints upon the pool of individuals that will be considered candidates for the sampling.  Parameter 
\f3\fs18 exclude
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a specific individual that should not be considered a candidate (typically the focal individual in some operation).  Parameter 
\f3\fs18 sex
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a sex (
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20 ) for the individuals to be drawn, in sexual models.  Parameter 
\f3\fs18 tag
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a tag value for the individuals to be drawn.  Parameters 
\f3\fs18 minAge
\f4\fs20  and 
\f3\fs18 maxAge
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a minimum or maximum age for the individuals to be drawn, in nonWF models.  Parameter 
\f3\fs18 migrant
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a required value for the 
\f3\fs18 migrant
\f4\fs20  property of the individuals to be drawn (so 
\f3\fs18 T
\f4\fs20  will require that individuals be migrants, 
\f3\fs18 F
\f4\fs20  will require that they not be).  If the candidate pool is smaller than the requested sample size, all eligible candidates will be returned (in randomized order); the result will be a zero-length vector if no eligible candidates exist (unlike 
\f3\fs18 sample()
\f4\fs20 ).\
This method is similar to getting the 
\f3\fs18 individuals
\f4\fs20  property of the subpopulation, using operator 
\f3\fs18 []
\f4\fs20  to select only individuals with the desired properties, and then using 
\f3\fs18 sample()
\f4\fs20  to sample from that candidate pool.  However, besides being much simpler than the equivalent Eidos code, it is also much faster, and it does not fail if less than the full sample size is available.  See 
\f3\fs18 subsetIndividuals()
\f4\fs20  for a similar method that returns a full subset, rather than a sample.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)setCloningRate(numeric\'a0rate)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the cloning rate of this subpopulation.  The rate is changed to 
\f3\fs18 rate
\f4\fs20 , which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).  Clonal reproduction can be enabled in both non-sexual (i.e. hermaphroditic) and sexual simulations.  In non-sexual simulations, 
\f3\fs18 rate
\f4\fs20  must be a singleton value representing the overall clonal reproduction rate for the subpopulation.  In sexual simulations, 
\f3\fs18 rate
\f4\fs20  may be either a singleton (specifying the clonal reproduction rate for both sexes) or a vector containing two numeric values (the female and male cloning rates specified separately, at indices 
\f3\fs18 0
\f4\fs20  and 
\f3\fs18 1
\f4\fs20  respectively).  During mating and offspring generation, the probability that any given offspring individual will be generated by cloning \'96 by asexual reproduction without gametes or meiosis \'96 will be equal to the cloning rate (for its sex, in sexual simulations) set in the parental (not the offspring!) subpopulation.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)setMigrationRates(io<Subpopulation>\'a0sourceSubpops, numeric\'a0rates)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the migration rates to this subpopulation from the subpopulations in 
\f3\fs18 sourceSubpops
\f4\fs20  to the corresponding rates specified in 
\f3\fs18 rates
\f4\fs20 ; in other words, 
\f3\fs18 rates
\f4\fs20  gives the expected fractions of the children in this subpopulation that will subsequently be generated from parents in the subpopulations 
\f3\fs18 sourceSubpops
\f4\fs20  (see the SLiM manual for further details).  This method will only set the migration fractions from the subpopulations given; migration rates from other subpopulations will be left unchanged (explicitly set a zero rate to turn off migration from a given subpopulation).  The type of 
\f3\fs18 sourceSubpops
\f4\fs20  may be either 
\f3\fs18 integer
\f4\fs20 , specifying subpopulations by identifier, or 
\f3\fs18 object
\f4\fs20 , specifying subpopulations directly.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)setSelfingRate(numeric$\'a0rate)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the selfing rate of this subpopulation.  The rate is changed to 
\f3\fs18 rate
\f4\fs20 , which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).  Selfing can only be enabled in non-sexual (i.e. hermaphroditic) simulations.  During mating and offspring generation, the probability that any given offspring individual will be generated by selfing \'96 by self-fertilization via gametes produced by meiosis by a single parent \'96 will be equal to the selfing rate set in the parental (not the offspring!) subpopulation.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)setSexRatio(float$\'a0sexRatio)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the sex ratio of this subpopulation to 
\f3\fs18 sexRatio
\f4\fs20 .  As defined in SLiM, this is actually the fraction of the subpopulation that is male; in other words, the M:(M+F) ratio.  This will take effect when children are next generated; it does not change the current subpopulation state.  Unlike the selfing rate, the cloning rate, and migration rates, the sex ratio is deterministic: SLiM will generate offspring that exactly satisfy the requested sex ratio (within integer roundoff limits).
\f5 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)setSpatialBounds(numeric\'a0bounds)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
Set the spatial boundaries of the subpopulation to 
\f3\fs18 bounds
\f4\fs20 .  This method may be called only for simulations in which continuous space has been enabled with 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 .  The length of 
\f3\fs18 bounds
\f4\fs20  must be double the spatial dimensionality, so that it supplies both minimum and maximum values for each coordinate.  More specifically, for a dimensionality of 
\f3\fs18 "x"
\f4\fs20 , 
\f3\fs18 bounds
\f4\fs20  should supply 
\f3\fs18 (x0,\'a0x1)
\f4\fs20  values; for dimensionality 
\f3\fs18 "xy"
\f4\fs20  it should supply 
\f3\fs18 (x0,\'a0y0,\'a0x1,\'a0y1)
\f4\fs20  values; and for dimensionality 
\f3\fs18 "xyz"
\f4\fs20  it should supply 
\f3\fs18 (x0,\'a0y0,\'a0z0,\'a0x1,\'a0y1,\'a0z1)
\f4\fs20  (in that order).  These boundaries will be used by SLiMgui to calibrate the display of the subpopulation, and will be used by methods such as 
\f3\fs18 pointInBounds()
\f4\fs20 , 
\f3\fs18 pointReflected()
\f4\fs20 , 
\f3\fs18 pointStopped()
\f4\fs20 , and 
\f3\fs18 pointUniform()
\f4\fs20 .  The default spatial boundaries for all subpopulations span the interval 
\f3\fs18 [0,1]
\f4\fs20  in each dimension.  Spatial dimensions that are periodic (as established with the 
\f3\fs18 periodicity
\f4\fs20  parameter to 
\f3\fs18 initializeSLiMOptions()
\f4\fs20 ) must have a minimum coordinate value of 
\f3\fs18 0.0
\f4\fs20  (a restriction that allows the handling of periodicity to be somewhat more efficient).  The current spatial bounds for the subpopulation may be obtained through the 
\f3\fs18 spatialBounds
\f4\fs20  property.\cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 The spatial bounds of a subpopulation are shared with any 
\f3\fs18 SpatialMap
\f4\fs20  objects added to the subpopulation.  For this reason, once a spatial map has been added to a subpopulation, the spatial bounds of the subpopulation can no longer be changed (because it would stretch or shrink the associated spatial map, which does not seem to make physical sense).  The bounds for a subpopulation should therefore be configured before any spatial maps are added to it.  If those bounds do need to change subsequently, any associated spatial maps must first be removed with 
\f3\fs18 removeSpatialMap()
\f4\fs20 , to ensure model consistency.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0(void)setSubpopulationSize(integer$\'a0size)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 Set the size of this subpopulation to 
\f3\fs18 size
\f4\fs20  individuals (see the SLiM manual for further details).  This will take effect when children are next generated; it does not change the current subpopulation state.  Setting a subpopulation to a size of 0 does have some immediate effects that serve to disconnect it from the simulation: the subpopulation is removed from the list of active subpopulations, the subpopulation is removed as a source of migration for all other subpopulations, and the symbol representing the subpopulation is undefined.  In this case, the subpopulation itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (string)spatialMapColor(string$\'a0name, numeric\'a0value)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 This method has been deprecated, and may be removed in a future release of SLiM.
\f4\b0   In SLiM 5.0 and later, use the 
\f3\fs18 SpatialMap
\f4\fs20  method 
\f3\fs18 mapColor()
\f4\fs20  instead, and see that method\'92s documentation.  (This method differs only in taking a 
\f3\fs18 name
\f4\fs20  parameter, which is used to look up the spatial map from those that have been added to the subpopulation.)\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(object<Image>$)spatialMapImage(string$\'a0name, [Ni$\'a0width\'a0=\'a0NULL], [Ni$\'a0height\'a0=\'a0NULL], [logical$\'a0centers\'a0=\'a0F], [logical$\'a0color\'a0=\'a0T])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 This method has been deprecated, and may be removed in a future release of SLiM.
\f4\b0   In SLiM 5.0 and later, use the 
\f3\fs18 SpatialMap
\f4\fs20  method 
\f3\fs18 mapImage()
\f4\fs20  instead, and see that method\'92s documentation.  (This method differs only in taking a 
\f3\fs18 name
\f4\fs20  parameter, which is used to look up the spatial map from those that have been added to the subpopulation.)\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96
\f5 \'a0
\f3 (float)spatialMapValue(so<SpatialMap>$\'a0map, float\'a0point)
\f5 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Looks up the spatial map specified by 
\f3\fs18 map
\f4\fs20 , and uses its mapping machinery (as defined by the 
\f3\fs18 gridSize
\f4\fs20 , 
\f3\fs18 values
\f4\fs20 , and 
\f3\fs18 interpolate
\f4\fs20  parameters to 
\f3\fs18 defineSpatialMap()
\f4\fs20 ) to translate the coordinates of 
\f3\fs18 point
\f4\fs20  into a corresponding map value.  The parameter 
\f3\fs18 map
\f4\fs20  may specify the map either as a 
\f3\fs18 SpatialMap
\f4\fs20  object, or by its 
\f3\fs18 string
\f4\fs20  name; in either case, the map must have been added to the subpopulation.  The length of 
\f3\fs18 point
\f4\fs20  must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality 
\f3\fs18 "xz"
\f4\fs20 , 
\f3\fs18 point
\f4\fs20  must be of length 
\f3\fs18 2
\f4\fs20 , specifying the 
\f1\i x
\f4\i0  and 
\f1\i z
\f4\i0  coordinates of the point to be evaluated.  Interpolation will automatically be used if it was enabled for the spatial map.  Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use 
\f3\fs18 pointPeriodic()
\f4\fs20  to wrap the point coordinates first if desired.  See the documentation for 
\f3\fs18 defineSpatialMap()
\f4\fs20  for information regarding the details of value mapping.\
Beginning in SLiM 3.3, 
\f3\fs18 point
\f4\fs20  may contain more than one point to be looked up.  In this case, the length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of the spatiality of the spatial map; for a spatial map with spatiality 
\f3\fs18 "xz"
\f4\fs20 , for example, the length of 
\f3\fs18 point
\f4\fs20  must be an exact multiple of 
\f3\fs18 2
\f4\fs20 , and successive pairs of elements from point (elements 
\f3\fs18 0
\f4\fs20  and 
\f3\fs18 1
\f4\fs20 , then elements 
\f3\fs18 2
\f4\fs20  and 
\f3\fs18 3
\f4\fs20 , etc.) will be taken as the 
\f1\i x
\f4\i0  and 
\f1\i z
\f4\i0  coordinates of the points to be evaluated.  This allows 
\f3\fs18 spatialMapValue()
\f4\fs20  to be used in a vectorized fashion.\
The 
\f3\fs18 mapValue()
\f4\fs20  method of 
\f3\fs18 SpatialMap
\f4\fs20  provides the same functionality directly on the 
\f3\fs18 SpatialMap
\f4\fs20  class; 
\f3\fs18 spatialMapValue()
\f4\fs20  is provided on 
\f3\fs18 Subpopulation
\f4\fs20  partly for backward compatibility, but also for convenience for the most common usage case of spatial maps.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \'96\'a0\cf2 \expnd0\expndtw0\kerning0
(object<Individual>)subsetIndividuals([No<Individual>$\'a0exclude\'a0=\'a0NULL], [Ns$\'a0sex\'a0=\'a0NULL], [Ni$\'a0tag\'a0=\'a0NULL], [Ni$\'a0minAge\'a0=\'a0NULL], [Ni$\'a0maxAge\'a0=\'a0NULL], [Nl$\'a0migrant\'a0=\'a0NULL])
\f5 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns a vector of individuals subset from the individuals in the target subpopulation.  The parameters specify constraints upon the subset of individuals that will be returned.  Parameter 
\f3\fs18 exclude
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a specific individual that should not be included (typically the focal individual in some operation).  Parameter 
\f3\fs18 sex
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a sex (
\f3\fs18 "M"
\f4\fs20  or 
\f3\fs18 "F"
\f4\fs20 ) for the individuals to be returned, in sexual models.  Parameter 
\f3\fs18 tag
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a tag value for the individuals to be returned.  Parameters 
\f3\fs18 minAge
\f4\fs20  and 
\f3\fs18 maxAge
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a minimum or maximum age for the individuals to be returned, in nonWF models.  Parameter 
\f3\fs18 migrant
\f4\fs20 , if non-
\f3\fs18 NULL
\f4\fs20 , may specify a required value for the 
\f3\fs18 migrant
\f4\fs20  property of the individuals to be returned (so 
\f3\fs18 T
\f4\fs20  will require that individuals be migrants, 
\f3\fs18 F
\f4\fs20  will require that they not be).\
This method is shorthand for getting the 
\f3\fs18 individuals
\f4\fs20  property of the subpopulation, and then using operator 
\f3\fs18 []
\f4\fs20  to select only individuals with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.  See 
\f3\fs18 sampleIndividuals()
\f4\fs20  for a similar method that returns a sample taken from a chosen subset of individuals.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \'96\'a0(void)takeMigrants(object<Individual>\'a0migrants)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 Immediately moves the individuals in 
\f3\fs18 migrants
\f4\fs20  to the target subpopulation (removing them from their previous subpopulation).  Individuals in 
\f3\fs18 migrants
\f4\fs20  that are already in the target subpopulation are unaffected.  Note that the indices and order of individuals and genomes in both the target and source subpopulations will change unpredictably as a side effect of this method.\
Note that this method is only for use in nonWF models, in which migration is managed manually by the model script.  In WF models, migration is managed automatically by the SLiM core based upon the migration rates set for each subpopulation with 
\f3\fs18 setMigrationRates()
\f4\fs20 .
\f5 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.17  Class Substitution\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\b0 \cf0 5.17.1  
\f2\fs18 Substitution
\f1\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\i0\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier for this mutation.  Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run, and that identifier is carried over to the 
\f3\fs18 Substitution
\f4\fs20  object when the mutation fixes.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 fixationTick => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The tick in which this mutation fixed.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 mutationType => (object<MutationType>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The 
\f3\fs18 MutationType
\f4\fs20  from which this mutation was drawn.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 \expnd0\expndtw0\kerning0
nucleotide <\'96> (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 A 
\f3\fs18 string
\f4\fs20  representing the nucleotide associated with this mutation; this will be 
\f3\fs18 "A"
\f4\fs20 , 
\f3\fs18 "C"
\f4\fs20 , 
\f3\fs18 "G"
\f4\fs20 , or 
\f3\fs18 "T"
\f4\fs20 .  If the mutation is not nucleotide-based, this property is unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf2 nucleotideValue <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf2 An 
\f3\fs18 integer
\f4\fs20  representing the nucleotide associated with this mutation; this will be 
\f3\fs18 0
\f4\fs20  (A), 
\f3\fs18 1
\f4\fs20  (C), 
\f3\fs18 2
\f4\fs20  (G), or 
\f3\fs18 3
\f4\fs20  (T).  If the mutation is not nucleotide-based, this property is unavailable.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 \kerning1\expnd0\expndtw0 originTick => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The tick in which this mutation arose.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 position => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The position in the chromosome of this mutation.
\f5 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 selectionCoeff => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The selection coefficient of the mutation, drawn from the distribution of fitness effects of its 
\f3\fs18 MutationType
\f5\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 subpopID <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 The identifier of the subpopulation in which this mutation arose.  This value is carried over from the 
\f3\fs18 Mutation
\f4\fs20  object directly; if a \'93tag\'94 value was used in the 
\f3\fs18 Mutation
\f4\fs20  object, that value will carry over to the corresponding 
\f3\fs18 Substitution
\f4\fs20  object.  The 
\f3\fs18 subpopID
\f4\fs20  in 
\f3\fs18 Substitution
\f4\fs20  is a read-write property to allow it to be used as a \'93tag\'94 in the same way, if the origin subpopulation identifier is not needed.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f3\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f4\fs20 \cf0 A user-defined 
\f3\fs18 integer
\f4\fs20  value.  The value of 
\f3\fs18 tag
\f4\fs20  is carried over automatically from the original 
\f3\fs18 Mutation
\f4\fs20  object.  Apart from that, the value of 
\f3\fs18 tag
\f4\fs20  is not used by SLiM; it is free for you to use.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f1\i\fs22 \cf0 5.17.2  
\f2\fs18 Substitution
\f1\fs22  methods\
\pard\pardeftab397\fi274\ri720\sb40\sa40\partightenfactor0

\f5\i0 \cf0 \
}