{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Optima-Bold;\f1\fnil\fcharset0 Menlo-Regular;\f2\fswiss\fcharset0 Optima-Regular;
\f3\fswiss\fcharset0 Optima-Italic;\f4\froman\fcharset0 TimesNewRomanPSMT;\f5\fnil\fcharset0 Menlo-Bold;
\f6\fnil\fcharset0 AppleColorEmoji;\f7\froman\fcharset0 TimesNewRomanPS-ItalicMT;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red150\green150\blue150;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c65500\c65500\c65500;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab397
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.1.  Initialization functions\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (integer$)initializeAncestralNucleotides(is\'a0sequence)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 \expnd0\expndtw0\kerning0
This function, which may be called only in nucleotide-based models, supplies an ancestral nucleotide sequence for the model.  The 
\f1\fs18 sequence
\f2\fs20  parameter may be an 
\f1\fs18 integer
\f2\fs20  vector providing nucleotide values (A=0, C=1, G=2, T=3), or a 
\f1\fs18 string
\f2\fs20  vector providing single-character nucleotides (
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "C"
\f2\fs20 , 
\f1\fs18 "G"
\f2\fs20 , 
\f1\fs18 "T"
\f2\fs20 ), or a singleton 
\f1\fs18 string
\f2\fs20  providing the sequence as one string (
\f1\fs18 "ACGT..."
\f2\fs20 ), or a singleton 
\f1\fs18 string
\f2\fs20  providing the filesystem path of a FASTA file which will be read in to provide the sequence (if the file contains than one sequence, the first sequence will be used).  Only A/C/G/T nucleotide values may be provided; other symbols, such as those for amino acids, gaps, or nucleotides of uncertain identity, are not allowed.  The two semantic meanings of 
\f1\fs18 sequence
\f2\fs20  that involve a singleton 
\f1\fs18 string
\f2\fs20  value are distinguished heuristically; a singleton 
\f1\fs18 string
\f2\fs20  that contains only the letters ACGT will be assumed to be a nucleotide sequence rather than a filename.  The length of the ancestral sequence is returned.\
A utility function, 
\f1\fs18 randomNucleotides()
\f2\fs20 , is provided by SLiM to assist in generating simple random nucleotide sequences.
\f3\i \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\i0\fs18 \cf2 \kerning1\expnd0\expndtw0 (object<Chromosome>$)initializeChromosome(integer$\'a0id, [Ni$\'a0length\'a0=\'a0NULL], [string$\'a0type\'a0=\'a0"A"], [Ns$\'a0symbol\'a0=\'a0NULL], [Ns$\'a0name\'a0=\'a0NULL], [integer$\'a0mutationRuns\'a0=\'a00])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calling this function, added in SLiM\'a05, initiates the configuration of a chromosome in the species being initialized.  The new 
\f1\fs18 Chromosome
\f2\fs20  object is returned, but it is still under construction and will error if used; see below for details.  That chromosome is then the \'93focal chromosome\'94 for subsequent genetic initialization functions \'96 specifically, for 
\f1\fs18 initializeAncestralNucleotides()
\f2\fs20 , 
\f1\fs18 initializeGeneConversion()
\f2\fs20 , 
\f1\fs18 initializeGenomicElement()
\f2\fs20 , 
\f1\fs18 initializeHotspotMap()
\f2\fs20 , 
\f1\fs18 initializeMutationRate()
\f2\fs20 , and 
\f1\fs18 initializeRecombinationRate()
\f2\fs20 .  If you wish to call 
\f1\fs18 initializeChromosome()
\f2\fs20  at all (which is not required), you must call it 
\f3\i before
\f2\i0  calling any of those genetic initialization functions, so that the focal chromosome is created 
\f3\i before
\f2\i0  being configured further; otherwise, SLiM will assume that you want a default single-chromosome model, and when 
\f1\fs18 initializeChromosome()
\f2\fs20  is called later (contradicting that assumption), an error will result.\
Furthermore, there are some other initialization functions must be called before 
\f1\fs18 initializeChromosome()
\f2\fs20  if they are called at all \'96 specifically, 
\f1\fs18 initializeSex()
\f2\fs20 , 
\f1\fs18 initializeTreeSeq()
\f2\fs20 , 
\f1\fs18 initializeSpecies()
\f2\fs20 , and 
\f1\fs18 initializeSLiMOptions()
\f2\fs20 .  This is so that 
\f1\fs18 initializeChromosome()
\f2\fs20  knows the context within which the new chromosome is to be created; if these methods have not been called when 
\f1\fs18 initializeChromosome()
\f2\fs20  is called, the default context is assumed (non-sexual, no tree-sequence recording, single-species, non-nucleotide-based), and an error will result downstream if one of those functions is later called (indicating that those assumptions might be incorrect).\
The parameters to 
\f1\fs18 initializeChromosome()
\f2\fs20  configure the chromosome created.  They will be discussed out of order here, because that order of presentation will, I hope, be clearer.\
There are three parameters that in some way identify the chromosome.  First, the required 
\f1\fs18 id
\f2\fs20  parameter provides an 
\f1\fs18 integer
\f2\fs20  identifier for the chromosome, which can be used to look up the chromosome later in the simulation; it can be any non-negative 
\f1\fs18 integer
\f2\fs20  value, but must be unique within the species (two chromosomes in the same species cannot have the same 
\f1\fs18 id
\f2\fs20 ).  Often it is an empirical chromosome number, for convenience and clarity; if modeling human chromosome 7, for example, you might provide 
\f1\fs18 7
\f2\fs20 .  Second, the 
\f1\fs18 symbol
\f2\fs20  parameter provides a 
\f1\fs18 string
\f2\fs20  identifier for the chromosome, which can also be used to look up the chromosome later in the simulation.  If 
\f1\fs18 NULL
\f2\fs20  (the default) is passed for 
\f1\fs18 symbol
\f2\fs20 , the chromosome\'92s default 
\f1\fs18 symbol
\f2\fs20  value will be the 
\f1\fs18 string
\f2\fs20  version of its 
\f1\fs18 id
\f2\fs20  (
\f1\fs18 "7"
\f2\fs20  for an 
\f1\fs18 id
\f2\fs20  of 
\f1\fs18 7
\f2\fs20 , for example).  The chromosome\'92s 
\f1\fs18 symbol
\f2\fs20  value will be used to identify the chromosome in output \'96 in VCF output, for example, and in SLiMgui.  It must be non-empty (not 
\f1\fs18 ""
\f2\fs20 ), no more than five characters long, and unique within the species.  Third, the 
\f1\fs18 name
\f2\fs20  parameter can be any 
\f1\fs18 string
\f2\fs20  value; if 
\f1\fs18 NULL
\f2\fs20  (the default) is passed, the 
\f1\fs18 name
\f2\fs20  value will be 
\f1\fs18 ""
\f2\fs20 .  The 
\f1\fs18 name
\f2\fs20  is not used by SLiM, and can be used in any way you wish.\
The 
\f1\fs18 length
\f2\fs20  parameter sets the length, in base positions, of the chromosome, and must either be 
\f1\fs18 NULL
\f2\fs20 , or an 
\f1\fs18 integer
\f2\fs20  greater than or equal to 
\f1\fs18 1
\f2\fs20 .  If 
\f1\fs18 length
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20 , the length of the chromosome will be calculated after all 
\f1\fs18 initialize()
\f2\fs20  callbacks have been called, as the maximum position referenced by the chromosome\'92s genomic elements, recombination map, mutation rate map, and (in nucleotide-based models) hotspot map; in other words, the chromosome will be sized to encompass all of the things it contains (which is also the behavior of the implicitly defined chromosome if 
\f1\fs18 initializeChromosome()
\f2\fs20  is not called).  Otherwise \'96 if 
\f1\fs18 length
\f2\fs20  is specified with an 
\f1\fs18 integer
\f2\fs20  value \'96 the chromosome\'92s length will be fixed at that value, and the last valid base position in the chromosome will be 
\f1\fs18 length-1
\f2\fs20 .  Attempting to add a genomic element or a mutation after the last position will raise an error.  Similarly, the last position of the chromosome must match the last position specified for recombination, mutation, and hotspot maps for that chromosome, but not all positions on a chromosome have to actually be used in the model (i.e., not all positions must be covered by a genomic element).\
The 
\f1\fs18 type
\f2\fs20  parameter specifies the type of chromosome to be created.  There are numerous options, and they are somewhat complex.  They are discussed in more detail in the documentation for class 
\f1\fs18 Chromosome
\f2\fs20 , particularly their specific patterns of inheritance; but they are briefly summarized here for quick reference.  Note that \'93\'96\'93 below indicates a null haplosome.  First of all, in hermaphroditic models 
\f1\fs18 type
\f2\fs20  will generally be one of:\
\pard\pardeftab720\li907\ri360\sa60\partightenfactor0

\f1\fs18 \cf2 "A"
\f2\fs20  (autosome), the default, specifying a diploid autosomal chromosome.\

\f1\fs18 "H"
\f2\fs20  (haploid), specifying a haploid autosomal chromosome that recombines in biparental crosses.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 Some sex-chromosome types are supported only in sexual models:\
\pard\pardeftab720\li907\ri360\sa60\partightenfactor0

\f1\fs18 \cf2 "X"
\f2\fs20  (X), specifying an X chromosome that is diploid (XX) in females, haploid (X\'96) in males.\

\f1\fs18 "Y"
\f2\fs20  (Y), specifying a Y chromosome that is haploid (Y) in males, absent (\'96) in females.\

\f1\fs18 "Z"
\f2\fs20  (Z), specifying a Z chromosome that is diploid (ZZ) in males, haploid (\'96Z) in females.\

\f1\fs18 "W"
\f2\fs20  (W), specifying a W chromosome that is haploid (W) in females, absent (\'96) in males.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 And there are some haploid chromosome types that are also supported only in sexual models:\
\pard\pardeftab720\li907\ri360\sa60\partightenfactor0

\f1\fs18 \cf2 "HF"
\f2\fs20  (haploid female-inherited), specifying a haploid autosomal chromosome that is inherited by both sexes from the first (female) parent in biparental crosses.\

\f1\fs18 "FL"
\f2\fs20  (female line), specifying a haploid autosomal chromosome that is inherited only by females, from the female parent, and is represented by a null haplosome in males.\

\f1\fs18 "HM"
\f2\fs20  (haploid male-inherited), specifying a haploid autosomal chromosome that is inherited by both sexes from the second (male) parent in biparental crosses.\

\f1\fs18 "ML"
\f2\fs20  (male line), specifying a haploid autosomal chromosome that is inherited only by males, from the male parent, and is represented by a null haplosome in females.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 Finally, two additional values of 
\f1\fs18 type
\f2\fs20 , 
\f1\fs18 "H-"
\f2\fs20  and 
\f1\fs18 "-Y"
\f2\fs20 , are supported for backward compatibility (not intended for use in new models).  They are discussed in the 
\f1\fs18 Chromosome
\f2\fs20  documentation.\
The 
\f1\fs18 mutationRuns
\f2\fs20  parameter specifies how many mutation runs the chromosome should use.  Internally, SLiM divides haplosomes into a sequence of consecutive mutation runs, allowing more efficient internal computations.  The optimal mutation run length is short enough that each mutation run is relatively unlikely to be modified by mutation/recombination events when inherited, but long enough that each mutation run is likely to contain a relatively large number of mutations; these priorities are in tension, so an intermediate balance between them is generally optimal.  The optimal number of mutation runs will depend on the model\'92s details, and may also depend upon the machine and even the compiler used to build SLiM.  If the 
\f1\fs18 mutationRuns
\f2\fs20  parameter is not 
\f1\fs18 0
\f2\fs20 , SLiM will use the value given as the number of mutation runs inside 
\f1\fs18 Haplosome
\f2\fs20  objects for the chromosome.  If 
\f1\fs18 mutationRuns
\f2\fs20  is 
\f1\fs18 0
\f2\fs20  (the default), then the behavior depends upon a parameter to the 
\f1\fs18 initializeSLiMOptions()
\f2\fs20  function, 
\f1\fs18 doMutationRunExperiments
\f2\fs20 .  If that flag is 
\f1\fs18 F
\f2\fs20 , the behavior here is as if 
\f1\fs18 mutationRuns=1
\f2\fs20  had been passed: one mutation run will be used, and mutation run experiments will not be conducted.  If that flag is 
\f1\fs18 T
\f2\fs20  (the default), then for 
\f1\fs18 mutationRuns=0
\f2\fs20  SLiM will conduct experiments at runtime, using different mutation run counts, to try to determine the number of mutation runs that produces the best performance.  The value that SLiM\'92s experiments determine may not be optimal, however, and in any case there is some overhead associated with conducting these experiments; for maximal performance it can thus be beneficial to determine the true optimal value for the simulation yourself, and set it explicitly using this parameter. Specifying the number of mutation runs is an advanced technique, but in some cases it can improve performance significantly.\
The order in which 
\f1\fs18 initializeChromosome()
\f2\fs20  calls are made is generally unimportant, since the chromosomes assort independently of each other anyway, but SLiM will preserve the order in which they were defined for you (for the 
\f1\fs18 chromosomes
\f2\fs20  property of Species, for display in SLiMgui, for writing out to VCF, and so forth).  All of the above types of chromosomes can be defined any number of times; you can have any number of autosomal chromosomes, for example.  In a sexual model you could even have multiple defined sex chromosomes \'96 not in the sense of a female being XX, but in the sense of a female being X
\fs13\fsmilli6667 \sub 1
\fs20 \nosupersub X
\fs13\fsmilli6667 \sub 1
\fs20 \nosupersub X
\fs13\fsmilli6667 \sub 2
\fs20 \nosupersub X
\fs13\fsmilli6667 \sub 2
\fs20 \nosupersub , where X
\fs13\fsmilli6667 \sub 1
\fs20 \nosupersub  and X
\fs13\fsmilli6667 \sub 2
\fs20 \nosupersub  are two different kinds of X chromosome.  Similarly, you could define both an X and a Z for a species, if you wish; each would segregate correctly according to the sex of the offspring.  In sexual models in SLiM the sex of an offspring is determined randomly or given by the user in script; it is not a function of the sex chromosomes present in the individual, although the sex chromosomes present in the individual will correlate with sex.  In other words, SLiM does not know and does not care what sex-determination system the species is using; the chromosomes follow the sex, rather than the sex following the chromosomes.  This should allow any sex-determination system to be modeled, even if it is unusual, non-genetic, etc.\
As stated above, the new 
\f1\fs18 Chromosome
\f2\fs20  object is returned by this call, but it is still under construction so most of its methods and properties will error.  It will remain in this state until 
\f1\fs18 initialize()
\f2\fs20  callbacks have completed, and will then become active and usable.  Until that point, there are only a handful of uses that are guaranteed to be allowed: storing it in a variable; remembering it with 
\f1\fs18 defineConstant()
\f2\fs20 ; using the methods and properties of its superclasses, notably 
\f1\fs18 Dictionary
\f2\fs20 ; setting SLiMgui display-related properties such as 
\f1\fs18 colorSubstitution
\f2\fs20 ; getting and setting its 
\f1\fs18 tag
\f2\fs20  property; and accessing those of its properties that were passed to the 
\f1\fs18 initializeChromosome()
\f2\fs20  call, specifically 
\f1\fs18 id
\f2\fs20 , 
\f1\fs18 symbol
\f2\fs20 , 
\f1\fs18 name
\f2\fs20 , 
\f1\fs18 type
\f2\fs20 , 
\f1\fs18 length
\f2\fs20 , and 
\f1\fs18 lastPosition
\f2\fs20 .  Its other properties, and all 
\f1\fs18 Chromosome
\f2\fs20  methods, will raise an error while in this state.  This safeguard protects the new 
\f1\fs18 Chromosome
\f2\fs20  object from being used while still in an inconsistent state.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(void)initializeGeneConversion(numeric$\'a0nonCrossoverFraction, numeric$\'a0meanLength, numeric$\'a0simpleConversionFraction, [numeric$\'a0bias\'a0=\'a00], [logical$\'a0redrawLengthsOnFailure\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calling this function switches the recombination model from a \'93simple crossover\'94 model to a \'93double-stranded break (DSB)\'94 model, and configures the details of the gene conversion tracts that will therefore be modeled.  The fraction of DSBs that will be modeled as non-crossover events is given by 
\f1\fs18 nonCrossoverFraction
\f2\fs20 .  The mean length of gene conversion tracts (whether associated with crossover or non-crossover events) is given by 
\f1\fs18 meanLength
\f2\fs20 ; the actual extent of a gene conversion tract will be the sum of two independent draws from a geometric distribution with mean 
\f1\fs18 meanLength/2
\f2\fs20 .  The fraction of gene conversion tracts that are modeled as \'93simple\'94 is given by 
\f1\fs18 simpleConversionFraction
\f2\fs20 ; the remainder will be modeled as \'93complex\'94, involving repair of heteroduplex mismatches.  Finally, the 
\f1\fs18 GC
\f2\fs20  bias during heteroduplex mismatch repair is given by 
\f1\fs18 bias
\f2\fs20 , with the default of 
\f1\fs18 0.0
\f2\fs20  indicating no bias, 
\f1\fs18 1.0
\f2\fs20  indicating an absolute preference for 
\f1\fs18 G
\f2\fs20 /
\f1\fs18 C
\f2\fs20  mutations over 
\f1\fs18 A
\f2\fs20 /
\f1\fs18 T
\f2\fs20  mutations, and 
\f1\fs18 -1.0
\f2\fs20  indicating an absolute preference for 
\f1\fs18 A
\f2\fs20 /
\f1\fs18 T
\f2\fs20  mutations over 
\f1\fs18 G
\f2\fs20 /
\f1\fs18 C
\f2\fs20  mutations.  A non-zero bias may only be set in nucleotide-based models.  This function, and the way that gene conversion is modeled, fundamentally changed in SLiM 3.3.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 Beginning in SLiM 4.1, the 
\f1\fs18 redrawLengthsOnFailure
\f2\fs20  parameter can be used to modify the internal mechanics of layout of gene conversion tracts.  If it is 
\f1\fs18 F
\f2\fs20  (the default, and the only behavior supported before SLiM 4.1), then if an attempt to lay out gene conversion tracts fails (because the tracts overlap each other, or overlap the start or end of the chromosome), SLiM will try again by drawing new positions for the tracts \'96 essentially shuffling the tracts around to try to find positions for them that don\'92t overlap.  If 
\f1\fs18 redrawLengthsOnFailure
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 , then if an attempt to lay out gene conversion tracts fails, SLiM will try again by drawing new lengths for the tracts, as well as new positions.  This makes it more likely that layout will succeed, but risks biasing the realized mean tract length downward from the requested mean length (since layout of long tracts is more likely fail due to overlap).  In either case, if SLiM attempts to lay out gene conversion tracts 100 times without success, an error will result.  That error indicates that the specified constraints for gene conversion are difficult to satisfy \'96 tracts may commonly be so long that it is difficult or impossible to find an acceptable layout for them within the specified chromosome length.  Setting 
\f1\fs18 redrawLengthsOnFailure
\f2\fs20  to 
\f1\fs18 T
\f2\fs20  may mitigate this problem, at the price of biasing the mean tract length downward as discussed.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (object<GenomicElement>)initializeGenomicElement(io<GenomicElementType>\'a0genomicElementType, [Ni\'a0start\'a0=\'a0NULL], [Ni\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 \expnd0\expndtw0\kerning0
Add a genomic element to the chromosome at initialization time.  The 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  parameters give the first and last base positions to be spanned by the new genomic element.  The new element will be based upon the genomic element type identified by 
\f1\fs18 genomicElementType
\f2\fs20 , which can be either an 
\f1\fs18 integer
\f2\fs20 , representing the ID of the desired element type, or an 
\f1\fs18 object
\f2\fs20  of type 
\f1\fs18 GenomicElementType
\f2\fs20  specified directly.\
Beginning in SLiM 3.3, this function is vectorized: the 
\f1\fs18 genomicElementType
\f2\fs20 , 
\f1\fs18 start
\f2\fs20 , and 
\f1\fs18 end
\f2\fs20  parameters do not have to be singletons.  In particular, 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  may be of any length, but must be equal in length; each 
\f1\fs18 start
\f2\fs20 /
\f1\fs18 end
\f2\fs20  element pair will generate one new genomic element spanning the given base positions.  In this case, 
\f1\fs18 genomicElementType
\f2\fs20  may still be a singleton, providing the genomic element type to be used for all of the new genomic elements, or it may be equal in length to 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20 , providing an independent genomic element type for each new element.  When adding a large number of genomic elements, it will be much faster to add them in order of ascending position with a vectorized call.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 Beginning in SLiM 5, passing 
\f1\fs18 NULL
\f2\fs20  for 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  is allowed by 
\f1\fs18 initializeGenomicElement()
\f2\fs20 , but only in one specific case: if the focal chromosome being configured was explicitly defined with 
\f1\fs18 initializeChromosome()
\f2\fs20 , and that focal chromosome was given an explicit length (rather than a length of 
\f1\fs18 NULL
\f2\fs20 ).  In that case, 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  may be 
\f1\fs18 NULL
\f2\fs20  (
\f3\i both
\f2\i0  of them, not just one of them), indicating that the genomic element created should span the entire length of the focal chromosome.  Since 
\f1\fs18 NULL
\f2\fs20  is now the default value for 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20 , this makes this common configuration very simple to set up.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
The return value provides the genomic element(s) created by the call, in the order in which they were specified in the parameters to 
\f1\fs18 initializeGenomicElement()
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (object<GenomicElementType>$)initializeGenomicElementType(is$\'a0id, io<MutationType>\'a0mutationTypes, numeric\'a0proportions\cf2 \expnd0\expndtw0\kerning0
, [Nf\'a0mutationMatrix\'a0=\'a0NULL]\cf0 \kerning1\expnd0\expndtw0 )
\f4 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf0 Add a genomic element type at initialization time.  The 
\f1\fs18 id
\f2\fs20  must not already be used for any genomic element type in the simulation.  The 
\f1\fs18 mutationTypes
\f2\fs20  vector identifies the mutation types used by the genomic element, and the 
\f1\fs18 proportions
\f2\fs20  vector should be of equal length, specifying the relative proportion of mutations that will be drawn from the corresponding mutation type (proportions do not need to add up to one; they are interpreted relatively).  The 
\f1\fs18 id
\f2\fs20  parameter may be either an 
\f1\fs18 integer
\f2\fs20  giving the ID of the new genomic element type, or a 
\f1\fs18 string
\f2\fs20  giving the name of the new genomic element type (such as 
\f1\fs18 "g5"
\f2\fs20  to specify an ID of 5).  The 
\f1\fs18 mutationTypes
\f2\fs20  parameter may be either an 
\f1\fs18 integer
\f2\fs20  vector representing the IDs of the desired mutation types, or an 
\f1\fs18 object
\f2\fs20  vector of 
\f1\fs18 MutationType
\f2\fs20  elements specified directly.  The global symbol for the new genomic element type is immediately available; the return value also provides the new object.
\f4 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2 \cf2 \expnd0\expndtw0\kerning0
The 
\f1\fs18 mutationMatrix
\f2\fs20  parameter is 
\f1\fs18 NULL
\f2\fs20  by default, and in non-nucleotide-based models it must be 
\f1\fs18 NULL
\f2\fs20 .  In nucleotide-based models, on the other hand, it must be non-
\f1\fs18 NULL
\f2\fs20 , and therefore must be supplied.  In that case, 
\f1\fs18 mutationMatrix
\f2\fs20  should take one of two standard forms.  For sequence-based mutation rates that depend upon only the single nucleotide at a mutation site, 
\f1\fs18 mutationMatrix
\f2\fs20  should be a 4\'d74 
\f1\fs18 float
\f2\fs20  matrix, specifying mutation rates for an existing nucleotide state (rows from 
\f1\fs18 0
\f2\fs20 \'96
\f1\fs18 3
\f2\fs20  representing A/C/G/T) to each of the four possible derived nucleotide states (columns, with the same meaning).  The mutation rates in this matrix are absolute rates, per nucleotide per gamete; they will be used by SLiM directly unless they are multiplied by a factor from the hotspot map (see 
\f1\fs18 initializeHotspotMap()
\f2\fs20 ).  Rates in 
\f1\fs18 mutationMatrix
\f2\fs20  that involve the mutation of a nucleotide to itself (
\f1\fs18 A
\f2\fs20  to 
\f1\fs18 A
\f2\fs20 , 
\f1\fs18 C
\f2\fs20  to 
\f1\fs18 C
\f2\fs20 , etc.) are not used by SLiM and must be 
\f1\fs18 0.0
\f2\fs20  by convention.\
It is important to note that the order of the rows and columns used in SLiM, A/C/G/T, is not a universal convention; other sources will present substitution-rate/transition-rate matrices using different conventions, and so care must be taken when importing such matrices into SLiM.\
For sequence-based mutation rates that depend upon the trinucleotide sequence centered upon a mutation site (the adjacent bases to the left and right, in other words, as well as the mutating nucleotide itself), 
\f1\fs18 mutationMatrix
\f2\fs20  should be a 64\'d74 
\f1\fs18 float
\f2\fs20  matrix, specifying mutation rates for the central nucleotide of an existing trinucleotide sequence (rows from 
\f1\fs18 0
\f2\fs20 \'96
\f1\fs18 63
\f2\fs20 , representing codons as described in the documentation for the 
\f1\fs18 ancestralNucleotides()
\f2\fs20  method of 
\f1\fs18 Chromosome
\f2\fs20 ) to each of the four possible derived nucleotide states (columns from 
\f1\fs18 0
\f2\fs20 \'96
\f1\fs18 3
\f2\fs20  for A/C/G/T as before).  Note that in every case it is the central nucleotide of the trinucleotide sequence that is mutating, but rates can be specified independently based upon the nucleotides in the first and third positions as well, with this type of mutation matrix.\
Several helper functions are defined to construct common types of mutation matrices, such as 
\f1\fs18 mmJukesCantor()
\f2\fs20  to create a mutation matrix for a Jukes\'96Cantor model.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (void)initializeHotspotMap(numeric\'a0multipliers, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 In nucleotide-based models, set the mutation rate 
\f3\i multiplier
\f2\i0  along the chromosome.  Nucleotide-based models define sequence-based mutation rates that are set up with the 
\f1\fs18 mutationMatrix
\f2\fs20  parameter to 
\f1\fs18 initializeGenomicElementType()
\f2\fs20 .  If no hotspot map is specified by calling 
\f1\fs18 initializeHotspotMap()
\f2\fs20 , a hotspot map with a multiplier of 
\f1\fs18 1.0
\f2\fs20  across the whole chromosome is assumed (and so the sequence-based rates are the absolute mutation rates used by SLiM).  A hotspot map modifies the sequence-based rates by scaling them up in some regions, with multipliers greater than 
\f1\fs18 1.0
\f2\fs20  (representing mutational hot spots), and/or scaling them down in some regions, with multipliers less than 
\f1\fs18 1.0
\f2\fs20  (representing mutational cold spots).\
There are two ways to call this function.  If the optional 
\f1\fs18 ends
\f2\fs20  parameter is 
\f1\fs18 NULL
\f2\fs20  (the default), then 
\f1\fs18 multipliers
\f2\fs20  must be a singleton value that specifies a single multiplier to be used along the entire chromosome (typically 
\f1\fs18 1.0
\f2\fs20 , but not required to be).  If, on the other hand, 
\f1\fs18 ends
\f2\fs20  is supplied, then 
\f1\fs18 multipliers
\f2\fs20  and 
\f1\fs18 ends
\f2\fs20  must be the same length, and the values in 
\f1\fs18 ends
\f2\fs20  must be specified in ascending order.  In that case, 
\f1\fs18 multipliers
\f2\fs20  and 
\f1\fs18 ends
\f2\fs20  taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f1\fs18 ends
\f2\fs20  should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).\
For example, if the following call is made:\
\pard\pardeftab720\ri720\partightenfactor0
\cf2 	
\f1\fs18 initializeHotspotMap(c(1.0, 1.2), c(5000, 9999));\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 then the result is that the mutation rate multiplier for bases 
\f1\fs18 0
\f2\fs20 ...
\f1\fs18 5000
\f2\fs20  (inclusive) will be 
\f1\fs18 1.0
\f2\fs20  (and so the specified sequence-based mutation rates will be used verbatim), and the multiplier for bases 
\f1\fs18 5001
\f2\fs20 ...
\f1\fs18 9999
\f2\fs20  (inclusive) will be 
\f1\fs18 1.2
\f2\fs20  (and so the sequence-based mutation rates will be multiplied by 1.2 within the region).\
Note that mutations are generated by SLiM only within genomic elements, regardless of the hotspot map.  In effect, the hotspot map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a multiplier of zero.  There is no harm in supplying a hotspot map that specifies multipliers for areas outside of the genomic elements defined; the excess information is simply not used.\
If the optional 
\f1\fs18 sex
\f2\fs20  parameter is 
\f1\fs18 "*"
\f2\fs20  (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f1\fs18 sex
\f2\fs20  may be 
\f1\fs18 "M"
\f2\fs20  or 
\f1\fs18 "F"
\f2\fs20  instead, in which case the supplied hotspot map is used only for that sex (i.e., when generating a gamete from a parent of that sex).  In this case, two calls must be made to 
\f1\fs18 initializeHotspotMap()
\f2\fs20 , one for each sex, even if a multiplier of 
\f1\fs18 1.0
\f2\fs20  is desired for the other sex; no default hotspot map is supplied.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (object<InteractionType>$)initializeInteractionType(is$\'a0id, string$\'a0spatiality, [logical$\'a0reciprocal\'a0=\'a0F], [numeric$\'a0maxDistance\'a0=\'a0INF], [string$\'a0sexSegregation\'a0=\'a0"**"])
\f4 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Add an interaction type at initialization time.  The 
\f1\fs18 id
\f2\fs20  must not already be used for any interaction type in the simulation.  The 
\f1\fs18 id
\f2\fs20  parameter may be either an 
\f1\fs18 integer
\f2\fs20  giving the ID of the new interaction type, or a 
\f1\fs18 string
\f2\fs20  giving the name of the new interaction type (such as 
\f1\fs18 "i5"
\f2\fs20  to specify an ID of 5).\
The 
\f1\fs18 spatiality
\f2\fs20  may be 
\f1\fs18 ""
\f2\fs20 , for non-spatial interactions (i.e., interactions that do not depend upon the distance between individuals); 
\f1\fs18 "x"
\f2\fs20 , 
\f1\fs18 "y"
\f2\fs20 , or 
\f1\fs18 "z"
\f2\fs20  for one-dimensional interactions; 
\f1\fs18 "xy"
\f2\fs20 , 
\f1\fs18 "xz"
\f2\fs20 , or 
\f1\fs18 "yz"
\f2\fs20  for two-dimensional interactions; or 
\f1\fs18 "xyz"
\f2\fs20  for three-dimensional interactions.  The dimensions referenced by spatiality must be defined as spatial dimensions with 
\f1\fs18 initializeSLiMOptions()
\f2\fs20 ; if the simulation has dimensionality 
\f1\fs18 "xy"
\f2\fs20 , for example, then interactions in the simulation may have spatiality 
\f1\fs18 ""
\f2\fs20 , 
\f1\fs18 "x"
\f2\fs20 , 
\f1\fs18 "y"
\f2\fs20 , or 
\f1\fs18 "xy"
\f2\fs20 , but may not reference spatial dimension 
\f3\i z
\f2\i0  and thus may not have spatiality 
\f1\fs18 "xz"
\f2\fs20 , 
\f1\fs18 "yz"
\f2\fs20 , or 
\f1\fs18 "xyz"
\f2\fs20 .  If no spatial dimensions have been configured, only non-spatial interactions may be defined.\
The 
\f1\fs18 reciprocal
\f2\fs20  flag may be 
\f1\fs18 T
\f2\fs20 , in which case the interaction is guaranteed by the user to be 
\f3\i reciprocal
\f2\i0 : whatever the interaction strength is for exerter B upon receiver A, it will be equal (in magnitude and sign) for exerter A upon receiver B.  In principle, this allows the 
\f1\fs18 InteractionType
\f2\fs20  to reduce the amount of computation necessary by up to a factor of two (although it may or may not be used).  If 
\f1\fs18 reciprocal
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 , the interaction is not guaranteed to be reciprocal and each interaction will be computed independently.  The built-in interaction formulas are all reciprocal, but if you implement an 
\f1\fs18 interaction()
\f2\fs20  callback, you must consider whether the callback you have implemented preserves reciprocality or not.  For this reason, the default is 
\f1\fs18 reciprocal=F
\f2\fs20 , so that bugs are not inadvertently introduced by an invalid assumption of reciprocality.  See below for a note regarding reciprocality in sexual simulations when using the 
\f1\fs18 sexSegregation
\f2\fs20  flag.\
The 
\f1\fs18 maxDistance
\f2\fs20  parameter supplies the maximum distance over which interactions of this type will be evaluated; at greater distances, the interaction strength is considered to be zero (for efficiency).  The default value of 
\f1\fs18 maxDistance
\f2\fs20 , 
\f1\fs18 INF
\f2\fs20  (positive infinity), indicates that there is no maximum interaction distance; note that this can make some interaction queries much less efficient, and is therefore not recommended.  In SLiM 3.1 and later, a warning will be issued if a spatial interaction type is defined with no maximum distance to encourage a maximum distance to be defined.\
The 
\f1\fs18 sexSegregation
\f2\fs20  parameter governs the applicability of the interaction to each sex, in sexual simulations.  It does not affect distance calculations in any way; it only modifies the way in which interaction strengths are calculated.  The default, 
\f1\fs18 "**"
\f2\fs20 , implies that the interaction is felt by both sexes (the first character of the 
\f1\fs18 string
\f2\fs20  value) and is exerted by both sexes (the second character of the 
\f1\fs18 string
\f2\fs20  value).  Either or both characters may be 
\f1\fs18 M
\f2\fs20  or 
\f1\fs18 F
\f2\fs20  instead; for example, 
\f1\fs18 "MM"
\f2\fs20  would indicate a male-male interaction, such as male-male competition, whereas 
\f1\fs18 "FM"
\f2\fs20  would indicate an interaction influencing only female receivers that is influenced only by male exerters, such as male mating displays that influence female attraction.  This parameter may be set only to 
\f1\fs18 "**"
\f2\fs20  unless sex has been enabled with 
\f1\fs18 initializeSex()
\f2\fs20 .  Note that a value of 
\f1\fs18 sexSegregation
\f2\fs20  other than 
\f1\fs18 "**"
\f2\fs20  may imply some degree of non-reciprocality, but it is not necessary to specify 
\f1\fs18 reciprocal
\f2\fs20  to be 
\f1\fs18 F
\f2\fs20  for this reason; SLiM will take the sex-segregation of the interaction into account for you.  The value of 
\f1\fs18 reciprocal
\f2\fs20  may therefore be interpreted as meaning: in those cases, if any, in which A interacts with B and B interacts with A, is the interaction strength guaranteed to be the same in both directions?  The 
\f1\fs18 sexSegregation
\f2\fs20  parameter is shorthand for setting sex constraints on the interaction type using the 
\f1\fs18 setConstraints()
\f2\fs20  method; see that method for a more extensive set of constraints that may be used.\
By default, the interaction strength is 
\f1\fs18 1.0
\f2\fs20  for all interactions within 
\f1\fs18 maxDistance
\f2\fs20 .  Often it is desirable to change the interaction function using 
\f1\fs18 setInteractionFunction()
\f2\fs20 ; modifying interaction strengths can also be achieved with 
\f1\fs18 interaction()
\f2\fs20  callbacks if necessary.  In any case, interactions beyond 
\f1\fs18 maxDistance
\f2\fs20  always have a strength of 
\f1\fs18 0.0
\f2\fs20 , and the interaction strength of an individual with itself is always 
\f1\fs18 0.0
\f2\fs20 , regardless of the interaction function or callbacks.\
The global symbol for the new interaction type is immediately available; the return value also provides the new object.  Note that in multispecies models, 
\f1\fs18 initializeInteractionType()
\f2\fs20  must be called from a non-species-specific 
\f1\fs18 interaction()
\f2\fs20  callback (declared as 
\f1\fs18 species all initialize()
\f2\fs20 ), since interactions are managed at the community level.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)initializeMutationRate(numeric\'a0rates, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])
\f4 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Set the mutation rate per base position per gamete.  To be precise, this mutation rate is the expected mean number of mutations that will occur per base position per gamete; note that this is different from how the recombination rate is defined (see 
\f1\fs18 initializeRecombinationRate()
\f2\fs20 ).  The number of mutations that actually occurs at a given base position when generating an offspring haplosome is, in effect, drawn from a Poisson distribution with that expected mean (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).  It is possible for this Poisson draw to indicate that two or more new mutations have arisen at the same base position, particularly when the mutation rate is very high; in this case, the new mutations will be added to the site one at a time, and as always the mutation stacking policy will be followed.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
There are two ways to call this function.  If the optional 
\f1\fs18 ends
\f2\fs20  parameter is 
\f1\fs18 NULL
\f2\fs20  (the default), then 
\f1\fs18 rates
\f2\fs20  must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.  If, on the other hand, 
\f1\fs18 ends
\f2\fs20  is supplied, then 
\f1\fs18 rates
\f2\fs20  and 
\f1\fs18 ends
\f2\fs20  must be the same length, and the values in 
\f1\fs18 ends
\f2\fs20  must be specified in ascending order.  In that case, 
\f1\fs18 rates
\f2\fs20  and 
\f1\fs18 ends
\f2\fs20  taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f1\fs18 ends
\f2\fs20  should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).\
For example, if the following call is made:\
\pard\pardeftab720\ri720\partightenfactor0

\f4 \cf0 \kerning1\expnd0\expndtw0 	
\f1\fs18 initializeMutationRate(c(1e-7, 2.5e-8), c(5000, 9999));\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 \expnd0\expndtw0\kerning0
then the result is that the mutation rate for bases 
\f1\fs18 0
\f2\fs20 ...
\f1\fs18 5000
\f2\fs20  (inclusive) will be 
\f1\fs18 1e-7
\f2\fs20 , and the rate for bases 
\f1\fs18 5001
\f2\fs20 ...
\f1\fs18 9999
\f2\fs20  (inclusive) will be 
\f1\fs18 2.5e-8
\f2\fs20 .\
Note that mutations are generated by SLiM only within genomic elements, regardless of the mutation rate map.  In effect, the mutation rate map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a mutation rate of zero.  There is no harm in supplying a mutation rate map that specifies rates for areas outside of the genomic elements defined; that rate information is simply not used.  The 
\f1\fs18 overallMutationRate
\f2\fs20  family of properties on 
\f1\fs18 Chromosome
\f2\fs20  provide the overall mutation rate after genomic element coverage has been taken into account, so it will reflect the rate at which new mutations will actually be generated in the simulation as configured.\
If the optional 
\f1\fs18 sex
\f2\fs20  parameter is 
\f1\fs18 "*"
\f2\fs20  (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f1\fs18 sex
\f2\fs20  may be 
\f1\fs18 "M"
\f2\fs20  or 
\f1\fs18 "F"
\f2\fs20  instead, in which case the supplied mutation rate map is used only for that sex (i.e., when generating a gamete from a parent of that sex).  In this case, two calls must be made to 
\f1\fs18 initializeMutationRate()
\f2\fs20 , one for each sex, even if a rate of zero is desired for the other sex; no default mutation rate map is supplied.
\f3\i \

\f2\i0 In nucleotide-based models, 
\f1\fs18 initializeMutationRate()
\f2\fs20  may not be called.  Instead, the desired sequence-based mutation rate(s) should be expressed in the 
\f1\fs18 mutationMatrix
\f2\fs20  parameter to 
\f1\fs18 initializeGenomicElementType()
\f2\fs20 .  If variation in the mutation rate along the chromosome is desired, 
\f1\fs18 initializeHotspotMap()
\f2\fs20  should be used.
\f3\i \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\i0 \cf2 \kerning1\expnd0\expndtw0 The 
\f1\fs18 initializeMutationRateFromFile()
\f2\fs20  function is a useful convenience function if you wish to read the mutation rate map from a file.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (void)initializeMutationRateFromFile(string$\'a0path, integer$\'a0lastPosition, [float$\'a0scale\'a0=\'a01.0e-08], [string$\'a0sep\'a0=\'a0"\\t"], [string$\'a0dec\'a0=\'a0"."])\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Set a mutation rate map from data read from the file at 
\f1\fs18 path
\f2\fs20 .  This function is essentially a wrapper for 
\f1\fs18 initializeMutationRate()
\f2\fs20  that uses 
\f1\fs18 readCSV()
\f2\fs20  and passes the data through.  The file is expected to contain two columns of data.  The first column must be 
\f1\fs18 integer
\f2\fs20  start positions for rate map regions; the first region should start at position 
\f1\fs18 0
\f2\fs20  if the map\'92s positions are 
\f1\fs18 0
\f2\fs20 -based, or at position 
\f1\fs18 1
\f2\fs20  if the map\'92s positions are 
\f1\fs18 1
\f2\fs20 -based; in the latter case, 
\f1\fs18 1
\f2\fs20  will be subtracted from every position since SLiM uses 
\f1\fs18 0
\f2\fs20 -based positions.  The second column must be 
\f1\fs18 float
\f2\fs20  rates, relative to the scaling factor specified in 
\f1\fs18 scale
\f2\fs20 ; for example, if a given rate is 
\f1\fs18 1.2
\f2\fs20  and 
\f1\fs18 scale
\f2\fs20  is 
\f1\fs18 1e-8
\f2\fs20  (the default), the rate used will be 
\f1\fs18 1.2e-8
\f2\fs20 .  No column header line should be present; the file should start immediately with numerical data.  The expected separator between columns is a tab character by default, but may be passed in 
\f1\fs18 sep
\f2\fs20 ; the expected decimal separator is a period by default, but may be passed in 
\f1\fs18 dec
\f2\fs20 .  Once read, the map is converted into a rate map specified with end positions, rather than start positions, and the position given by 
\f1\fs18 lastPosition
\f2\fs20  is used as the end of the last rate region; it should be the last position of the chromosome.\
See 
\f1\fs18 readCSV()
\f2\fs20  for further details on 
\f1\fs18 sep
\f2\fs20  and 
\f1\fs18 dec
\f2\fs20 , which are passed through to it; and see 
\f1\fs18 initializeMutationRate()
\f2\fs20  for details on how the rate map is validated and used.\
This function is written in Eidos, and its source code can be viewed with 
\f1\fs18 functionSource()
\f2\fs20 , so you can copy and modify its code if you need to modify its functionality.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (object<MutationType>$)initializeMutationType(is$\'a0id, numeric$\'a0dominanceCoeff, string$\'a0distributionType, ...)
\f4 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Add a mutation type at initialization time.  The 
\f1\fs18 id
\f2\fs20  must not already be used for any mutation type in the simulation.  The 
\f1\fs18 id
\f2\fs20  parameter may be either an 
\f1\fs18 integer
\f2\fs20  giving the ID of the new mutation type, or a 
\f1\fs18 string
\f2\fs20  giving the name of the new mutation type (such as 
\f1\fs18 "m5"
\f2\fs20  to specify an ID of 5).  The dominanceCoeff parameter supplies the dominance coefficient for the mutation type; 
\f1\fs18 0.0
\f2\fs20  produces no dominance, 
\f1\fs18 1.0
\f2\fs20  complete dominance, and values greater than 
\f1\fs18 1.0
\f2\fs20 , overdominance.  The 
\f1\fs18 distributionType
\f2\fs20  may be 
\f1\fs18 "f"
\f2\fs20 , in which case the ellipsis 
\f1\fs18 ...
\f2\fs20  should supply a 
\f1\fs18 numeric$
\f2\fs20  fixed selection coefficient; 
\f1\fs18 "e"
\f2\fs20 , in which case the ellipsis should supply a 
\f1\fs18 numeric$
\f2\fs20  mean selection coefficient for an exponential distribution; 
\f1\fs18 "g"
\f2\fs20 , in which case the ellipsis should supply a 
\f1\fs18 numeric$
\f2\fs20  mean selection coefficient and a 
\f1\fs18 numeric$
\f2\fs20  alpha shape parameter for a gamma distribution; 
\f1\fs18 "n"
\f2\fs20 , in which case the ellipsis should supply a 
\f1\fs18 numeric$
\f2\fs20  mean selection coefficient and a 
\f1\fs18 numeric$
\f2\fs20  sigma (standard deviation) parameter for a normal distribution; 
\f1\fs18 "p"
\f2\fs20 , in which case the ellipsis should supply a 
\f1\fs18 numeric$
\f2\fs20  mean selection coefficient and a 
\f1\fs18 numeric$
\f2\fs20  scale parameter for a Laplace distribution; 
\f1\fs18 "w"
\f2\fs20 , in which case the ellipsis should supply a 
\f1\fs18 numeric$
\f2\fs20  
\f4 \uc0\u955 
\f2  scale parameter and a 
\f1\fs18 numeric$
\f2\fs20  k shape parameter for a Weibull distribution; or 
\f1\fs18 "s"
\f2\fs20 , in which case the ellipsis should supply a 
\f1\fs18 string$
\f2\fs20  Eidos script parameter.  The global symbol for the new mutation type is immediately available; the return value also provides the new object.\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
Note that by default in WF models, all mutations of a given mutation type will be converted into 
\f1\fs18 Substitution
\f2\fs20  objects when they reach fixation, for efficiency reasons.  If you need to disable this conversion, to keep mutations of a given type active in the simulation even after they have fixed, you can do so by setting the 
\f1\fs18 convertToSubstitution
\f2\fs20  property of 
\f1\fs18 MutationType
\f2\fs20  to 
\f1\fs18 F
\f2\fs20 .  In contrast, by default in nonWF models mutations will not be converted into 
\f1\fs18 Substitution
\f2\fs20  objects when they reach fixation; 
\f1\fs18 convertToSubstitution
\f2\fs20  is 
\f1\fs18 F
\f2\fs20  by default in nonWF models.  To enable conversion in nonWF models for neutral mutation types with no indirect fitness effects, you should therefore set 
\f1\fs18 convertToSubstitution
\f2\fs20  to 
\f1\fs18 T
\f2\fs20 .\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (object<MutationType>$)initializeMutationTypeNuc(is$\'a0id, numeric$\'a0dominanceCoeff, string$\'a0distributionType, ...)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Add a nucleotide-based mutation type at initialization time.  This function is identical to 
\f1\fs18 initializeMutationType()
\f2\fs20  except that the new mutation type will be nucleotide-based \'96 in other words, mutations belonging to the new mutation type will have an associated nucleotide.  This function may be called only in nucleotide-based models (as enabled by the 
\f1\fs18 nucleotideBased
\f2\fs20  parameter to 
\f1\fs18 initializeSLiMOptions()
\f2\fs20 ).\
Nucleotide-based mutations always use a 
\f1\fs18 mutationStackGroup
\f2\fs20  of 
\f1\fs18 -1
\f2\fs20  and a 
\f1\fs18 mutationStackPolicy
\f2\fs20  of 
\f1\fs18 "l"
\f2\fs20 .  This ensures that a new nucleotide mutation always replaces any previously existing nucleotide mutation at a given position, regardless of the mutation types of the nucleotide mutations.  These values are set automatically by 
\f1\fs18 initializeMutationTypeNuc()
\f2\fs20 , and may not be changed.\
See the documentation for 
\f1\fs18 initializeMutationType()
\f2\fs20  for all other discussion.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (void)initializeRecombinationRate(numeric\'a0rates, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])
\f4 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Set the recombination rate per base position per gamete.  To be precise, this recombination rate is the probability that a breakpoint will occur between one base and the next base; note that this is different from how the mutation rate is defined (see 
\f1\fs18 initializeMutationRate()
\f2\fs20 ).  A recombination rate of 1 centimorgan/Mbp corresponds to a recombination rate of 
\f1\fs18 1e-8
\f2\fs20  in the units used by SLiM.  All rates must be in the interval [
\f1\fs18 0.0
\f2\fs20 , 
\f1\fs18 0.5
\f2\fs20 ].  A rate of 
\f1\fs18 0.5
\f2\fs20  implies complete independence between the adjacent bases, which might be used to implement unlinked loci.  Whether a breakpoint occurs between two bases is then, in effect, determined by a binomial draw with a single trial and the given rate as probability (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).  The recombinational process in SLiM will never generate more then one crossover between one base and the next (in one generation/haplosome), and a supplied rate of 
\f1\fs18 0.5
\f2\fs20  will therefore result in an actual probability of 
\f1\fs18 0.5
\f2\fs20  for a crossover at the relevant position.  (Note that this was not true in SLiM 2.x and earlier, however; their implementation of recombination resulted in a crossover probability of about 39.3% for a rate of 
\f1\fs18 0.5
\f2\fs20 , due to the use of an inaccurate approximation method.  Recombination rates lower than about 
\f1\fs18 0.01
\f2\fs20  would have been essentially exact, since the approximation error became large only as the rate approached 
\f1\fs18 0.5
\f2\fs20 .)\
There are two ways to call this function.  If the optional 
\f1\fs18 ends
\f2\fs20  parameter is 
\f1\fs18 NULL
\f2\fs20  (the default), then 
\f1\fs18 rates
\f2\fs20  must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.  If, on the other hand, 
\f1\fs18 ends
\f2\fs20  is supplied, then 
\f1\fs18 rates
\f2\fs20  and 
\f1\fs18 ends
\f2\fs20  must be the same length, and the values in 
\f1\fs18 ends
\f2\fs20  must be specified in ascending order.  In that case, 
\f1\fs18 rates
\f2\fs20  and 
\f1\fs18 ends
\f2\fs20  taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f1\fs18 ends
\f2\fs20  should extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).\
If the optional 
\f1\fs18 sex
\f2\fs20  parameter is 
\f1\fs18 "*"
\f2\fs20  (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f1\fs18 sex
\f2\fs20  may be 
\f1\fs18 "M"
\f2\fs20  or 
\f1\fs18 "F"
\f2\fs20  instead, in which case the supplied recombination map is used only for that sex.  In this case, two calls must be made to 
\f1\fs18 initializeRecombinationRate()
\f2\fs20 , one for each sex, even if a rate of zero is desired for the other sex; no default recombination map is supplied.\
The 
\f1\fs18 initializeRecombinationRateFromFile()
\f2\fs20  function is a useful convenience function if you wish to read the recombination rate map from a file.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (void)initializeRecombinationRateFromFile(string$\'a0path, integer$\'a0lastPosition, [float$\'a0scale\'a0=\'a01.0e-08], [string$\'a0sep\'a0=\'a0"\\t"], [string$\'a0dec\'a0=\'a0"."], [string$\'a0sex\'a0=\'a0"*"])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Set a recombination rate map from data read from the file at 
\f1\fs18 path
\f2\fs20 .  This function is essentially a wrapper for 
\f1\fs18 initializeRecombinationRate()
\f2\fs20  that uses 
\f1\fs18 readCSV()
\f2\fs20  and passes the data through.  The file is expected to contain two columns of data.  The first column must be 
\f1\fs18 integer
\f2\fs20  start positions for rate map regions; the first region should start at position 
\f1\fs18 0
\f2\fs20  if the map\'92s positions are 
\f1\fs18 0
\f2\fs20 -based, or at position 
\f1\fs18 1
\f2\fs20  if the map\'92s positions are 
\f1\fs18 1
\f2\fs20 -based; in the latter case, 
\f1\fs18 1
\f2\fs20  will be subtracted from every position since SLiM uses 
\f1\fs18 0
\f2\fs20 -based positions.  The second column must be 
\f1\fs18 float
\f2\fs20  rates, relative to the scaling factor specified in 
\f1\fs18 scale
\f2\fs20 ; for example, if a given rate is 
\f1\fs18 1.2
\f2\fs20  and 
\f1\fs18 scale
\f2\fs20  is 
\f1\fs18 1e-8
\f2\fs20  (the default), the rate used will be 
\f1\fs18 1.2e-8
\f2\fs20 .  No column header line should be present; the file should start immediately with numerical data.  The expected separator between columns is a tab character by default, but may be passed in 
\f1\fs18 sep
\f2\fs20 ; the expected decimal separator is a period by default, but may be passed in 
\f1\fs18 dec
\f2\fs20 .  Once read, the map is converted into a rate map specified with end positions, rather than start positions, and the position given by 
\f1\fs18 lastPosition
\f2\fs20  is used as the end of the last rate region; it should be the last position of the chromosome.\
See 
\f1\fs18 readCSV()
\f2\fs20  for further details on 
\f1\fs18 sep
\f2\fs20  and 
\f1\fs18 dec
\f2\fs20 , which are passed through to it; and see 
\f1\fs18 initializeRecombinationRate()
\f2\fs20  for details on how the rate map is validated and used, and how the 
\f1\fs18 sex
\f2\fs20  parameter is used.\
This function is written in Eidos, and its source code can be viewed with 
\f1\fs18 functionSource()
\f2\fs20 , so you can copy and modify its code if you need to modify its functionality.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (void)initializeSex([Ns$\'a0chromosomeType\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Enable sex in the simulation.  Beginning in SLiM 5, this method should generally be passed 
\f1\fs18 NULL
\f2\fs20 , simply indicating that sex should be enabled: individuals will then be male and female (rather than hermaphroditic), biparental crosses will be required to be between a female first parent and a male second parent, and selfing will not be allowed.  In this new configuration style, if a sexual simulation involving sex chromosomes is desired, the new 
\f1\fs18 initializeChromosome()
\f2\fs20  call should be used to configure the chromosome setup for the simulation.\
For backward compatibility, the old style of configuring a sexual simulation is still supported, however.  This implicitly defines a single chromosome, without a call to 
\f1\fs18 initializeChromosome()
\f2\fs20 .  With this old configuration approach, the 
\f1\fs18 chromosomeType
\f2\fs20  parameter to 
\f1\fs18 initializeSex()
\f2\fs20  gives the type of chromosome that should be simulated; this should be 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "X"
\f2\fs20 , or 
\f1\fs18 "Y"
\f2\fs20 , and this 
\f1\fs18 chromosomeType
\f2\fs20  value will be used as the symbol (
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "X"
\f2\fs20 , or 
\f1\fs18 "Y"
\f2\fs20 ) for the implicit chromosome.  These legacy chromosome types correspond to the new chromosome types 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "X"
\f2\fs20 , and 
\f1\fs18 "-Y"
\f2\fs20  respectively (note that it is 
\f3\i not
\f2\i0  
\f1\fs18 "Y"
\f2\fs20 ), when using 
\f1\fs18 initializeChromosome()
\f2\fs20 .  The implicit chromosome\'92s 
\f1\fs18 id
\f2\fs20  property is always 
\f1\fs18 1
\f2\fs20 .  This old style of chromosome configuration is much less flexible, however, allowing only these three chromosome types, and only allowing a single chromosome to be set up.  This backward compatibility mode may be removed for SLiM in the future, and should be considered deprecated; new models should call 
\f1\fs18 initializeChromosome()
\f2\fs20  explicitly instead.\
There is no way to disable sex once it has been enabled; if you don\'92t want to have sex, don\'92t call this function.  If you require more flexibility with mating types and reproductive strategies than SLiM\'92s built-in support for sex provides, do not call 
\f1\fs18 initializeSex()
\f2\fs20 ; instead, track the sex or mating type of individuals yourself in script (with the 
\f1\fs18 tag
\f2\fs20  property of 
\f1\fs18 Individual
\f2\fs20 , for example), and manage the consequences of that in your script yourself, in terms of which individuals can mate with which, and exactly how the offspring is produced.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b \cf2 The 
\f5\fs18 xDominanceCoeff
\f0\fs20  parameter has been deprecated and removed.
\f2\b0   In SLiM 5 and later, use the 
\f1\fs18 hemizygousDominanceCoeff
\f2\fs20  property of 
\f1\fs18 MutationType
\f2\fs20  instead.  \cf3 If the 
\f1\fs18 chromosomeType
\f2\fs20  is 
\f1\fs18 "X"
\f2\fs20 , the optional 
\f1\fs18 xDominanceCoeff
\f2\fs20  parameter can supply the dominance coefficient used when a mutation is present in an XY male, and is thus \'93heterozygous\'94 (but in a different sense than the heterozygosity of an XX female with one copy of the mutation).\cf2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)initializeSLiMModelType(string$\'a0modelType)
\f4 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 \expnd0\expndtw0\kerning0
Configure the type of SLiM model used for the simulation.  At present, one of two model types may be selected.  If 
\f1\fs18 modelType
\f2\fs20  is 
\f1\fs18 "WF"
\f2\fs20 , SLiM will use a Wright-Fisher (WF) model; this is the model type that has always been supported by SLiM, and is the model type used if 
\f1\fs18 initializeSLiMModelType()
\f2\fs20  is not called.  If 
\f1\fs18 modelType
\f2\fs20  is 
\f1\fs18 "nonWF"
\f2\fs20 , SLiM will use a non-Wright-Fisher (nonWF) model instead; this is a new model type supported by SLiM 3.0 and above.\
If 
\f1\fs18 initializeSLiMModelType()
\f2\fs20  is called at all then it must be called before any other initialization function, so that SLiM knows from the outset which features are enabled and which are not.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (void)initializeSLiMOptions([logical$\'a0keepPedigrees\'a0=\'a0F], [string$\'a0dimensionality\'a0=\'a0""], [string$\'a0periodicity\'a0=\'a0""], [logical$\'a0doMutationRunExperiments\'a0=\'a0T], [logical$\'a0preventIncidentalSelfing\'a0=\'a0F]\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0nucleotideBased\'a0=\'a0F], [logical$\'a0randomizeCallbacks\'a0=\'a0T]\cf0 \kerning1\expnd0\expndtw0 )
\f4 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 \expnd0\expndtw0\kerning0
Configure options for the simulation.  If 
\f1\fs18 initializeSLiMOptions()
\f2\fs20  is called at all then it must be called before any other initialization function (except 
\f1\fs18 initializeSLiMModelType()
\f2\fs20 ), so that SLiM knows from the outset which optional features are enabled and which are not.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 If 
\f1\fs18 keepPedigrees
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 , SLiM will keep pedigree information for every individual in the simulation, tracking the identity of its parents and grandparents.  This allows individuals to assess their degree of pedigree-based relatedness to other individuals (see 
\f1\fs18 Individual
\f2\fs20 \'92s 
\f1\fs18 relatedness()
\f2\fs20  and 
\f1\fs18 sharedParentCount()
\f2\fs20  methods), as well as allowing a model to find \'93trios\'94 (two parents and an offspring they generated) using the pedigree properties of 
\f1\fs18 Individual
\f2\fs20 .  As a side effect of 
\f1\fs18 keepPedigrees
\f2\fs20  being 
\f1\fs18 T
\f2\fs20 , the 
\f1\fs18 pedigreeID
\f2\fs20 , 
\f1\fs18 pedigreeParentIDs
\f2\fs20 , and 
\f1\fs18 pedigreeGrandparentIDs
\f2\fs20  properties of 
\f1\fs18 Individual
\f2\fs20  will have defined values, as will the 
\f1\fs18 haplosomePedigreeID
\f2\fs20  property of 
\f1\fs18 Haplosome
\f2\fs20 .  Note that pedigree-based relatedness doesn\'92t necessarily correspond to genetic relatedness, due to effects such as assortment and recombination.  Beginning in SLiM 3.5, 
\f1\fs18 keepPedigrees=T
\f2\fs20  also enables tracking of individual reproductive output, available through the 
\f1\fs18 reproductiveOutput
\f2\fs20  property of 
\f1\fs18 Individual
\f2\fs20  and the 
\f1\fs18 lifetimeReproductiveOutput
\f2\fs20  property of 
\f1\fs18 Subpopulation
\f2\fs20 .\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 If 
\f1\fs18 dimensionality
\f2\fs20  is not 
\f1\fs18 ""
\f2\fs20 , SLiM will enable its optional \'93continuous space\'94 facility.  Three values for 
\f1\fs18 dimensionality
\f2\fs20  are presently supported: 
\f1\fs18 "x"
\f2\fs20 , 
\f1\fs18 "xy"
\f2\fs20 , and 
\f1\fs18 "xyz"
\f2\fs20 , specifying that continuous space should be enabled for one, two, or three dimensions, respectively, using (
\f3\i x
\f2\i0 ), (
\f3\i x
\f2\i0 , 
\f3\i y
\f2\i0 ), and (
\f3\i x
\f2\i0 , 
\f3\i y
\f2\i0 , 
\f3\i z
\f2\i0 ) coordinates respectively.  This has a number of side effects.  First of all, it means that the specified properties of 
\f1\fs18 Individual
\f2\fs20  (
\f1\fs18 x
\f2\fs20 , 
\f1\fs18 y
\f2\fs20 , and/or 
\f1\fs18 z
\f2\fs20 ) will be interpreted by SLiM as spatial positions; in particular, SLiMgui will use those properties to display subpopulations spatially.  Second, it allows spatial interactions to be defined, evaluated, and queried using 
\f1\fs18 initializeInteractionType()
\f2\fs20  and 
\f1\fs18 interaction()
\f2\fs20  callbacks.  And third, it enables the use of any other properties and methods related to continuous space, such as setting the spatial boundaries of subpopulations, which would otherwise raise an error.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
If 
\f1\fs18 periodicity
\f2\fs20  is not 
\f1\fs18 ""
\f2\fs20 , SLiM will designate the specified spatial dimensions as being periodic \'96 wrapping around at the edges of the spatial boundaries of that dimension.  This option may only be used if the 
\f1\fs18 dimensionality
\f2\fs20  parameter to 
\f1\fs18 initializeSLiMOptions()
\f2\fs20  has been used to enable spatiality in the model, and only spatial dimensions that were specified in the dimensionality of the model may be declared to be periodic (but if desired, it is permissible to make just a subset of those dimensions periodic; it is not an all-or-none proposition).  For example, if the specified dimensionality is 
\f1\fs18 "xy"
\f2\fs20 , the model\'92s periodicity may be 
\f1\fs18 "x"
\f2\fs20 , 
\f1\fs18 "y"
\f2\fs20 , or 
\f1\fs18 "xy"
\f2\fs20  (or 
\f1\fs18 ""
\f2\fs20 , the default, to specify that there are no periodic dimensions).  A one-dimensional periodic model would model a space like the perimeter of a circle.  A two-dimensional model periodic in one of those dimensions would model a space like a cylinder without its end caps; if periodic in both dimensions, the modeled space is a torus.  The shapes of three-dimensional periodic models are harder to visualize, but are essentially higher-dimensional analogues of these concepts.  Periodic boundary conditions are commonly used to model spatial scenarios without \'93edge effects\'94, since there are no edges in the periodic spatial dimensions.  The 
\f1\fs18 pointPeriodic()
\f2\fs20  method of 
\f1\fs18 Subpopulation
\f2\fs20  is typically used in conjunction with this option, to actually implement the periodic boundary condition for the specified dimensions.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 The 
\f1\fs18 doMutationRunExperiments
\f2\fs20  parameter specifies whether SLiM should attempt to conduct experiments at runtime to determine the optimal number of mutation runs used in the model.  This is a performance optimization.  If 
\f1\fs18 doMutationRunExperiments
\f2\fs20  is 
\f1\fs18 T
\f2\fs20  (the default), this optimization is enabled for all chromosomes that do not have an explicitly specified mutation run count; this is generally desirable and may significantly improve performance.  If 
\f1\fs18 doMutationRunExperiments
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 , this optimization is disabled and chromosomes that do not have an explicitly specified mutation run count will simply use a single mutation run.  See the documentation for 
\f1\fs18 initializeChromosome()
\f2\fs20  for further discussion.  Note that this parameter used to be 
\f1\fs18 [integer$\'a0mutationRuns\'a0=\'a00]
\f2\fs20 , specifying the mutation run count directly.  That parameter has been moved to 
\f1\fs18 initializeChromosome()
\f2\fs20 , allowing a different mutation run count to be specified for each chromosome in multi-chromosome models.\expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 If 
\f1\fs18 preventIncidentalSelfing
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 , incidental selfing in hermaphroditic models will be prevented by SLiM.  By default (i.e., if 
\f1\fs18 preventIncidentalSelfing
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 ), SLiM chooses the first and second parents in a biparental mating event independently.  It is therefore possible for the same individual to be chosen as both the first and second parent, resulting in selfing events even when the selfing rate is zero.  In many models this is unimportant, since it happens fairly infrequently and does not have large consequences.  This behavior is SLiM\'92s default because it is the simplest option, and produces results that most closely align with simple analytical population genetics models.  However, in some models this selfing can be undesirable and problematic.  In particular, models that involve very high variance in fitness or very small effective population sizes may see elevated rates of selfing that substantially influence model results.  If 
\f1\fs18 preventIncidentalSelfing
\f2\fs20  is set to 
\f1\fs18 T
\f2\fs20 , all such incidental selfing will be prevented (by choosing a new second parent if the first parent was chosen again).  Non-incidental selfing, as requested by the selfing rate, will still be permitted.  Note that if incidental selfing is prevented, SLiM will hang if it is unable to find a different second parent; there must always be at least two individuals in the population with non-zero fitness, and 
\f1\fs18 mateChoice()
\f2\fs20  and 
\f1\fs18 modifyChild()
\f2\fs20  callbacks must not absolutely prevent those two individuals from producing viable offspring.  Enforcement of the prohibition on incidental selfing will occur after 
\f1\fs18 mateChoice()
\f2\fs20  callbacks have been called (and thus the default mating weights provided to 
\f1\fs18 mateChoice()
\f2\fs20  callbacks will 
\f3\i not
\f2\i0  exclude the first parent!), but will occur before 
\f1\fs18 modifyChild()
\f2\fs20  callbacks are called (so those callbacks may assume that the first and second parents are distinct).\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
If 
\f1\fs18 nucleotideBased
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 , the model will be nucleotide-based.  In this case, auto-generated mutations (i.e., mutation types used by genomic element types) must be nucleotide-based, and an ancestral nucleotide sequence must be supplied with 
\f1\fs18 initializeAncestralNucleotides()
\f2\fs20 .  Non-nucleotide-based mutations may still be used, but may not be referenced by genomic element types.  A mutation rate (or rate map) may not be supplied with 
\f1\fs18 initializeMutationRate()
\f2\fs20 ; instead, a hotspot map may (optionally) be supplied with 
\f1\fs18 initializeHotspotMap()
\f2\fs20 .  This choice has many consequences across SLiM. \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 If 
\f1\fs18 randomizeCallbacks
\f2\fs20  is 
\f1\fs18 T
\f2\fs20  (the default), the order in which individuals are processed in callbacks will be randomized to make it easier to avoid order-dependency bugs.  This flag exists because the order of individuals in each subpopulation is non-random; most notably, females always come before males in the individuals vector, but non-random ordering may also occur with respect to things like migrant versus non-migrant status, origin by selfing versus cloning versus biparental mating, and other factors.  When this option is 
\f1\fs18 F
\f2\fs20 , individuals in a subpopulation are processed in the order of the individuals vector in each tick cycle stage, which may lead to order-dependency issues if there is an enabled callback whose behavior is not fully independent between calls.  Setting this option to 
\f1\fs18 T
\f2\fs20  will cause individuals within each subpopulation to be processed in a randomized order in each tick cycle stage; specifically, this randomizes the order of calls to 
\f1\fs18 mutationEffect()
\f2\fs20  callbacks in both WF and nonWF models, and calls to 
\f1\fs18 reproduction()
\f2\fs20  and 
\f1\fs18 survival()
\f2\fs20  callbacks in nonWF models.  Each subpopulation is still processed separately, in sequential order, so order-dependency issues between subpopulations are still possible if callbacks have effects that are not fully independent.  This feature was added in SLiM 4, breaking backward compatibility; to recover the behavior of previous versions of SLiM, pass 
\f1\fs18 F
\f2\fs20  for this option (but then be very careful about order-dependency issues in your script).  The default of 
\f1\fs18 T
\f2\fs20  is the safe option, but a small speed penalty is incurred by the randomization of the processing order \'96 for most models the difference will be less than 1%, but in the worst case it may approach 10%.  Models that do not have any order-dependency issue may therefore run somewhat faster if this is set to 
\f1\fs18 F
\f2\fs20 .  Note that anywhere that your script uses the 
\f1\fs18 individuals
\f2\fs20  property of 
\f1\fs18 Subpopulation
\f2\fs20 , the order of individuals returned will be non-random (regardless of the setting of this option); you should use 
\f1\fs18 sample()
\f2\fs20  to shuffle the order of the individuals vector if necessary to avoid order-dependency issues in your script.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 This function will likely be extended with further options in the future, added on to the end of the argument list.  Using named arguments with this call is recommended for readability.  Note that turning on optional features may increase the runtime and memory footprint of SLiM.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (void)initializeSpecies([integer$\'a0tickModulo\'a0=\'a01], [integer$\'a0tickPhase\'a0=\'a01], [string$\'a0avatar\'a0=\'a0""], [string$\'a0color\'a0=\'a0""])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Configure options for the species being initialized.  This initialization function may only be called in multispecies models (i.e., models with explicit species declarations); in single-species models, the default values are assumed and cannot be changed.\
The 
\f1\fs18 tickModulo
\f2\fs20  and 
\f1\fs18 tickPhase
\f2\fs20  parameters determine the activation schedule for the species.  The 
\f1\fs18 active
\f2\fs20  property of the species will be set to 
\f1\fs18 T
\f2\fs20  (thus activating the species) every 
\f1\fs18 tickModulo
\f2\fs20  ticks, beginning in tick 
\f1\fs18 tickPhase
\f2\fs20 .  (However, when the species is activated in a given tick, the 
\f1\fs18 skipTick()
\f2\fs20  method may still be called in a 
\f1\fs18 first()
\f2\fs20  event to deactivate it.)  See the 
\f1\fs18 active
\f2\fs20  property of 
\f1\fs18 Species
\f2\fs20  for more details.\
The 
\f1\fs18 avatar
\f2\fs20  parameter, if not 
\f1\fs18 ""
\f2\fs20 , sets a 
\f1\fs18 string
\f2\fs20  value used to represent the species graphically, particularly in SLiMgui but perhaps in other contexts also.  The 
\f1\fs18 avatar
\f2\fs20  should generally be a single character \'96 usually an emoji corresponding to the species, such as 
\f1\fs18 "
\f6\fs14 \uc0\u55358 \u56714 
\f1\fs18 "
\f2\fs20  for foxes or 
\f1\fs18 "
\f6\fs14 \uc0\u55357 \u56365 
\f1\fs18 "
\f2\fs20  for mice.  If 
\f1\fs18 avatar
\f2\fs20  is the empty string, 
\f1\fs18 ""
\f2\fs20 , SLiMgui will choose a default avatar.\
The 
\f1\fs18 color
\f2\fs20  parameter, if not 
\f1\fs18 ""
\f2\fs20 , sets a 
\f1\fs18 string
\f2\fs20  color value used to represent the species in SLiMgui.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f1\fs18 "#RRGGBB"
\f2\fs20  (see the Eidos manual for details).  If 
\f1\fs18 color
\f2\fs20  is the empty string, 
\f1\fs18 ""
\f2\fs20 , SLiMgui will choose a default color.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (object<Trait>$)initializeTrait(string$\'a0name, string$\'a0type, [Nf$\'a0baselineOffset\'a0=\'a0NULL], [Nf$\'a0individualOffsetMean\'a0=\'a0NULL], [Nf$\'a0individualOffsetSD\'a0=\'a0NULL], [logical$\'a0directFitnessEffect\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calling this function, added in SLiM 5.1, configures a phenotypic trait in the species being initialized.  The new 
\f1\fs18 Trait
\f2\fs20  object is returned.  For more details on the way that traits work in SLiM, beyond what is given below, see the 
\f1\fs18 Trait
\f2\fs20  class documentation.\
The 
\f1\fs18 name
\f2\fs20  parameter gives the name of the new trait.  This may be any (non-empty) string, except that it must not conflict with any other trait in any species in the model, it must not conflict with any global variable or constant, and it must not conflict with the name of any existing property on the 
\f1\fs18 Individual
\f2\fs20  class.  The second requirement is because, after the new trait is created, a new global constant is defined that represents the trait\'92s index within the species, for quick reference to the trait in various contexts.  The third requirement is because, after the new trait is created, a new property is added to individuals of the species, with the same name as the new trait, that allows the trait values of individuals to be accessed directly as properties.  For example, if the new trait is named 
\f1\fs18 myTrait
\f2\fs20 , a new global constant 
\f1\fs18 myTrait
\f2\fs20  would be defined as 
\f1\fs18 myTrait
\f2\fs20 \'92s index in the species, and access to an individual\'92s trait value would be possible through the property 
\f1\fs18 individual.myTrait
\f2\fs20 .\
The 
\f1\fs18 type
\f2\fs20  parameter gives the type of trait to be created, as a 
\f1\fs18 string
\f2\fs20  value.  This should be either 
\f1\fs18 "multiplicative"
\f2\fs20 , if the trait value should be the result of multiplying effects together (as in a typical population-genetics model), or 
\f1\fs18 "additive"
\f2\fs20 , if the trait value should be the result of adding effects together (as in a typical quantitative-genetics model).\
The 
\f1\fs18 baselineOffset
\f2\fs20  parameter sets the baseline offset for the trait, incorporated (multiplicatively or additively) to the trait value of every individual.  If 
\f1\fs18 NULL
\f2\fs20  is passed, the default baseline offset is 
\f1\fs18 1.0
\f2\fs20  for multiplicative traits, 
\f1\fs18 0.0
\f2\fs20  for additive traits, such that the baseline offset has no effect upon the trait value.\
The 
\f1\fs18 individualOffsetMean
\f2\fs20  and 
\f1\fs18 individualOffsetSD
\f2\fs20  parameters together define a normal distribution from which individual offsets are drawn to provide what is often called \'93environmental variance\'94 or \'93developmental noise\'94.  As for the baseline offset, the individual offset mean defaults (if 
\f1\fs18 NULL
\f2\fs20  is passed) to 
\f1\fs18 1.0
\f2\fs20  for multiplicative traits, 
\f1\fs18 0.0
\f2\fs20  for additive traits, to produce no effect.  The default standard deviation for the individual offset, if 
\f1\fs18 NULL
\f2\fs20  is passed, is 
\f1\fs18 0.0
\f2\fs20 .  If 
\f1\fs18 NULL
\f2\fs20  is passed for one of these parameters, it must be passed for both; either the default distribution is used, or it is not.\
Finally, the 
\f1\fs18 directFitnessEffect
\f2\fs20  parameter specifies whether the final calculated trait value for an individual should be used directly as a fitness effect for that individual.  This will typically be 
\f1\fs18 T
\f2\fs20  (the default) in population-genetics models where the product of all mutation effects (
\f1\fs18 1+s
\f2\fs20  or 
\f1\fs18 1+hs
\f2\fs20  for each mutation) is used as the fitness of the individual, but will typically be 
\f1\fs18 F
\f2\fs20  in quantitative-genetics models where the sum of all mutation effects is a trait value that is then translated into a fitness effect through a fitness function.  It would also be 
\f1\fs18 F
\f2\fs20  for any trait that affects an aspect of the individual other than fitness \'96 dispersal distance, for example, or aggression.\
The use of the 
\f1\fs18 initializeTrait()
\f2\fs20  function is optional.  If it is not called, a new 
\f1\fs18 Trait
\f2\fs20  object will be created automatically, with a name generated from the species name plus a 
\f1\fs18 "T"
\f2\fs20 ; typically, then, the name is 
\f1\fs18 simT
\f2\fs20 , except in multispecies models.  This default trait is configured to be multiplicative, with default values for the other parameters except 
\f1\fs18 directFitnessEffect
\f2\fs20 , which is 
\f1\fs18 T
\f2\fs20  for the default trait.  This provides the behavior of SLiM prior to the introduction of multiple traits in SLiM 5.1.  The creation of the default trait occurs as a side effect of the first call to 
\f1\fs18 initializeMutationType()
\f2\fs20 , if 
\f1\fs18 initializeTrait()
\f2\fs20  has not already been called.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(void)initializeTreeSeq([logical$\'a0recordMutations\'a0=\'a0T], [Nif$\'a0simplificationRatio\'a0=\'a0NULL], [Ni$\'a0simplificationInterval\'a0=\'a0NULL], [logical$\'a0checkCoalescence\'a0=\'a0F], [logical$\'a0runCrosschecks\'a0=\'a0F], [logical$\'a0\kerning1\expnd0\expndtw0 retainCoalescentOnly\expnd0\expndtw0\kerning0
\'a0=\'a0T]\kerning1\expnd0\expndtw0 , [Ns$\'a0timeUnit\'a0=\'a0NULL]\expnd0\expndtw0\kerning0
)
\f4 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Configure options for tree sequence recording.  Calling this function turns on tree sequence recording, as a side effect, for later reconstruction of the simulation\'92s evolutionary dynamics; if you do not want tree sequence recording to be enabled, do not call this function.  Note that tree-sequence recording internally uses SLiM\'92s \'93pedigree tracking\'94 feature to uniquely identify individuals and haplosomes; however, if you want to use pedigree tracking in your script you must still enable it yourself with 
\f1\fs18 initializeSLiMOptions(keepPedigrees=T)
\f2\fs20 .  A separate tree sequence will be recorded for each chromosome in the simulation, as configured with 
\f1\fs18 initializeChromosome()
\f2\fs20 .\
The 
\f1\fs18 recordMutations
\f2\fs20  flag controls whether information about individual mutations is recorded or not.  Such recording takes time and memory, and so can be turned off if only the tree sequence itself is needed, but it is turned on by default since mutation recording is generally useful.\
The 
\f1\fs18 simplificationRatio
\f2\fs20  and 
\f1\fs18 simplificationInterval
\f2\fs20  parameters control how often automatic simplification of the recorded tree sequence occurs.  This is a speed\'96memory tradeoff: more frequent simplification (lower 
\f1\fs18 simplificationRatio
\f2\fs20  or smaller 
\f1\fs18 simplificationInterval
\f2\fs20 ) means the stored tree sequences will use less memory, but at a cost of somewhat longer run times.  Conversely, a larger 
\f1\fs18 simplificationRatio
\f2\fs20  or 
\f1\fs18 simplificationInterval
\f2\fs20  means that SLiM will wait longer between simplifications.  There are three ways these parameters can be used.  With the first option, with a non-
\f1\fs18 NULL
\f2\fs20  
\f1\fs18 simplificationRatio
\f2\fs20  and a 
\f1\fs18 NULL
\f2\fs20  value for 
\f1\fs18 simplificationInterval
\f2\fs20 , SLiM will try to find an optimal tick interval for simplification such that the ratio of the memory used by the tree sequence tables, (before:after) simplification, is close to the requested ratio. The default of 
\f1\fs18 10
\f2\fs20  (used if both 
\f1\fs18 simplificationRatio
\f2\fs20  and 
\f1\fs18 simplificationInterval
\f2\fs20  are 
\f1\fs18 NULL
\f2\fs20 ) thus requests that SLiM try to find a tick interval such that the maximum size of the stored tree sequences is ten times the size after simplification. 
\f1\fs18 INF
\f2\fs20  may be supplied to indicate that automatic simplification should never occur; 
\f1\fs18 0
\f2\fs20  may be supplied to indicate that automatic simplification should be performed at the end of every tick.  Alternatively \'96 the second option \'96 
\f1\fs18 simplificationRatio
\f2\fs20  may be 
\f1\fs18 NULL
\f2\fs20  and 
\f1\fs18 simplificationInterval
\f2\fs20  may be set to the interval, in ticks, between simplifications.  This may provide more reliable performance, but the interval must be chosen carefully to avoid exceeding the available memory.  The 
\f1\fs18 simplificationInterval
\f2\fs20  value may be a very large number to specify that simplification should never occur (not 
\f1\fs18 INF
\f2\fs20 , though, since it is an 
\f1\fs18 integer
\f2\fs20  value), or 
\f1\fs18 1
\f2\fs20  to simplify every tick.  Finally \'96 the third option \'96 both parameters may be non-
\f1\fs18 NULL
\f2\fs20 , in which case 
\f1\fs18 simplificationRatio
\f2\fs20  is used as described above, while 
\f1\fs18 simplificationInterval
\f2\fs20  provides the 
\f3\i initial
\f2\i0  interval first used by SLiM (and then subsequently increased or decreased to try to match the requested simplification ratio).  The default initial interval, used when 
\f1\fs18 simplificationInterval
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20 , is usually 
\f1\fs18 20
\f2\fs20 ; this is chosen to be relatively frequent, and thus unlikely to lead to a memory overflow, but it can result in rather slow spool-up for models where the equilibrium simplification interval, as determined by the simplification ratio, is much longer.  It can therefore be helpful to set a larger initial interval so that the early part of the model run is not excessively bogged down in simplification.\
The 
\f1\fs18 checkCoalescence
\f2\fs20  parameter controls whether a check for full coalescence is conducted after each simplification.  If a model will call 
\f1\fs18 treeSeqCoalesced()
\f2\fs20  to check for coalescence during its execution, 
\f1\fs18 checkCoalescence
\f2\fs20  should be set to 
\f1\fs18 T
\f2\fs20 .  Since the coalescence checks entail a performance penalty, the default of 
\f1\fs18 F
\f2\fs20  is preferable otherwise.  See the documentation for 
\f1\fs18 treeSeqCoalesced()
\f2\fs20  for further discussion.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 The 
\f1\fs18 runCrosschecks
\f2\fs20  parameter controls whether cross-checks between SLiM\'92s internal data structures and the tree-sequence recording data structures will be conducted.  These two sets of data structures record much the same thing (mutations in haplosomes), but using completely different representations, so such cross-checks can be useful to confirm that the two data structures do indeed represent the same conceptual state.  This slows down the model considerably, however, and would normally be turned on only for debugging purposes, so it is turned off by default.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 The 
\f1\fs18 retainCoalescentOnly
\f2\fs20  parameter controls how, exactly, simplification of the tree-sequence data is performed in SLiM (both for auto-simplification and for calls to 
\f1\fs18 treeSeqSimplify()
\f2\fs20 ).  More specifically, this parameter controls the behavior of simplification for individuals and haplosomes that have been \'93retained\'94 by calling 
\f1\fs18 treeSeqRememberIndividuals()
\f2\fs20  with the parameter 
\f1\fs18 permanent=F
\f2\fs20 .  The default of 
\f1\fs18 retainCoalescentOnly=T
\f2\fs20  helps to keep the number of retained individuals relatively small, which is helpful if your simulation regularly flags many individuals for retaining.  In this case, changing 
\f1\fs18 retainCoalescentOnly
\f2\fs20  to 
\f1\fs18 F
\f2\fs20  may dramatically increase memory usage and runtime, in a similar way to permanently remembering all the individuals.  See the documentation of 
\f1\fs18 treeSeqRememberIndividuals()
\f2\fs20  for further discussion.\
The 
\f1\fs18 timeUnit
\f2\fs20  parameter controls the time unit stated in the tree sequence when it is saved (which can be accessed through 
\f1\fs18 tskit
\f2\fs20  APIs); it has no effect on the running simulation whatsoever.  The default value, 
\f1\fs18 NULL
\f2\fs20 , means that a time unit of 
\f1\fs18 "ticks"
\f2\fs20  will be used for all model types.  (In SLiM 3.7 / 3.7.1, 
\f1\fs18 NULL
\f2\fs20  implied a time unit of 
\f1\fs18 "generations"
\f2\fs20  for WF models, but 
\f1\fs18 "ticks"
\f2\fs20  for nonWF models; given the new multispecies timescale parameters in SLiM 4, a default of 
\f1\fs18 "ticks"
\f2\fs20  makes sense in all cases since now even in WF models one tick might not equal one biological generation.)  It may be helpful to set 
\f1\fs18 timeUnit
\f2\fs20  to 
\f1\fs18 "generations"
\f2\fs20  explicitly when modeling non-overlapping generations in which one tick equals one generation, to tell 
\f1\fs18 tskit
\f2\fs20  that the time unit does in fact represent biological generations; doing so may avoid warnings from 
\f1\fs18 tskit
\f2\fs20  or 
\f1\fs18 msprime
\f2\fs20  regarding the time unit, in cases such as recapitation where the simulation timescale is important.\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.2.  Nucleotide utilities\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf2 \expnd0\expndtw0\kerning0
(is)codonsToAminoAcids(integer\'a0codons, [li$\'a0long\'a0=\'a0F], [logical$\'a0paste\'a0=\'a0T])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 \kerning1\expnd0\expndtw0 Returns the amino acid sequence corresponding to the codon sequence in 
\f1\fs18 codons
\f2\fs20 .  Codons should be represented with values in [
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 63
\f2\fs20 ] where AAA is 
\f1\fs18 0
\f2\fs20 , AAC is 
\f1\fs18 1
\f2\fs20 , AAG is 
\f1\fs18 2
\f2\fs20 , and TTT is 
\f1\fs18 63
\f2\fs20 ; see 
\f1\fs18 ancestralNucleotides()
\f2\fs20  for discussion of this encoding.  If 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 F
\f2\fs20  (the default), the standard single-letter codes for amino acids will be used (where Serine is 
\f1\fs18 "S"
\f2\fs20 , etc.); if 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 , the standard three-letter codes will be used instead (where Serine is 
\f1\fs18 "Ser"
\f2\fs20 , etc.).  Beginning in SLiM 3.5, if 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 integer
\f2\fs20  codes will be used as follows (and 
\f1\fs18 paste
\f2\fs20  will be ignored):\
\pard\tx3780\pardeftab720\li1080\sa60\partightenfactor0
\cf2 stop (TAA, TAG, TGA)	
\f1\fs18 0
\f2\fs20 \uc0\u8232 Alanine	
\f1\fs18 1
\f2\fs20 \uc0\u8232 Arginine	
\f1\fs18 2
\f2\fs20 \uc0\u8232 Asparagine	
\f1\fs18 3
\f2\fs20 \uc0\u8232 Aspartic acid (Aspartate)	
\f1\fs18 4
\f2\fs20 \uc0\u8232 Cysteine	
\f1\fs18 5
\f2\fs20 \uc0\u8232 Glutamine	
\f1\fs18 6
\f2\fs20 \uc0\u8232 Glutamic acid (Glutamate)	
\f1\fs18 7
\f2\fs20 \uc0\u8232 Glycine	
\f1\fs18 8
\f2\fs20 \uc0\u8232 Histidine	
\f1\fs18 9
\f2\fs20 \uc0\u8232 Isoleucine	
\f1\fs18 10
\f2\fs20 \uc0\u8232 Leucine	
\f1\fs18 11
\f2\fs20 \uc0\u8232 Lysine	
\f1\fs18 12
\f2\fs20 \uc0\u8232 Methionine	
\f1\fs18 13
\f2\fs20 \uc0\u8232 Phenylalanine	
\f1\fs18 14
\f2\fs20 \uc0\u8232 Proline	
\f1\fs18 15
\f2\fs20 \uc0\u8232 Serine	
\f1\fs18 16
\f2\fs20 \uc0\u8232 Threonine	
\f1\fs18 17
\f2\fs20 \uc0\u8232 Tryptophan	
\f1\fs18 18
\f2\fs20 \uc0\u8232 Tyrosine	
\f1\fs18 19
\f2\fs20 \uc0\u8232 Valine	
\f1\fs18 20
\f2\fs20 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf2 There does not seem to be a widely used standard for integer coding of amino acids, so SLiM just numbers them alphabetically, making stop codons 
\f1\fs18 0
\f2\fs20 .  If you want a different coding, you can make your own 64-element vector and use it to convert codons to whatever integer codes you need.  Other 
\f1\fs18 integer
\f2\fs20  values of 
\f1\fs18 long
\f2\fs20  are reserved for future use (to support other codings), and will currently produce an error.\
When 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 T
\f2\fs20  or 
\f1\fs18 F
\f2\fs20  and 
\f1\fs18 paste
\f2\fs20  is 
\f1\fs18 T
\f2\fs20  (the default), the amino acid sequence returned will be a singleton 
\f1\fs18 string
\f2\fs20 , such as 
\f1\fs18 "LYATI"
\f2\fs20  (when 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 ) or 
\f1\fs18 "Leu-Tyr-Ala-Thr-Ile"
\f2\fs20  (when 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 ).  When 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 T
\f2\fs20  or 
\f1\fs18 F
\f2\fs20  and 
\f1\fs18 paste
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 , the amino acid sequence will instead be returned as a 
\f1\fs18 string
\f2\fs20  vector, with one element per amino acid, such as 
\f1\fs18 "L" "Y" "A" "T" "I"
\f2\fs20  (when 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 ) or 
\f1\fs18 "Leu" "Tyr" "Ala" "Thr" "Ile"
\f2\fs20  (when 
\f1\fs18 long
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 ).  Using the 
\f1\fs18 paste=T
\f2\fs20  option is considerably faster than using 
\f1\fs18 paste()
\f2\fs20  in script.\expnd0\expndtw0\kerning0
\
This function interprets the supplied codon sequence as the 
\f3\i sense
\f2\i0  strand (i.e., the strand that is 
\f3\i not
\f2\i0  transcribed, and which mirrors the mRNA\'92s sequence).  This uses the standard DNA codon table directly.  For example, if the nucleotide sequence is CAA TTC, that will correspond to a codon vector of 
\f1\fs18 16 61
\f2\fs20 , and will result in the amino acid sequence Gln-Phe (
\f1\fs18 "QF"
\f2\fs20 ).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (is)codonsToNucleotides(integer\'a0codons, [string$\'a0format\'a0=\'a0"string"])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Returns the nucleotide sequence corresponding to the codon sequence supplied in 
\f1\fs18 codons
\f2\fs20 .  Codons should be represented with values in [
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 63
\f2\fs20 ] where AAA is 
\f1\fs18 0
\f2\fs20 , AAC is 
\f1\fs18 1
\f2\fs20 , AAG is 
\f1\fs18 2
\f2\fs20 , and TTT is 
\f1\fs18 63
\f2\fs20 ; see 
\f1\fs18 ancestralNucleotides()
\f2\fs20  for discussion of this encoding.\
The 
\f1\fs18 format
\f2\fs20  parameter controls the format of the returned sequence.  It may be 
\f1\fs18 "string"
\f2\fs20  to obtain the sequence as a singleton 
\f1\fs18 string
\f2\fs20  (e.g., 
\f1\fs18 "TATACG"
\f2\fs20 ), 
\f1\fs18 "char"
\f2\fs20  to obtain it as a 
\f1\fs18 string
\f2\fs20  vector of single characters (e.g., 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "C"
\f2\fs20 , 
\f1\fs18 "G"
\f2\fs20 ), or 
\f1\fs18 "integer"
\f2\fs20  to obtain it as an 
\f1\fs18 integer
\f2\fs20  vector (e.g., 
\f1\fs18 3
\f2\fs20 , 
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 3
\f2\fs20 , 
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 1
\f2\fs20 , 
\f1\fs18 2
\f2\fs20 ), using SLiM\'92s standard code of A=
\f1\fs18 0
\f2\fs20 , C=
\f1\fs18 1
\f2\fs20 , G=
\f1\fs18 2
\f2\fs20 , T=
\f1\fs18 3
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float)mm16To256(float\'a0mutationMatrix16)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Returns a 64\'d74 mutation matrix that is functionally identical to the supplied 4\'d74 mutation matrix in 
\f1\fs18 mutationMatrix16
\f2\fs20 .  The mutation rate for each of the 64 trinucleotides will depend only upon the central nucleotide of the trinucleotide, and will be taken from the corresponding entry for the same nucleotide in 
\f1\fs18 mutationMatrix16
\f2\fs20 .  This function can be used to easily construct a simple trinucleotide-based mutation matrix which can then be modified so that specific trinucleotides sustain a mutation rate that does not depend only upon their central nucleotide.\
See the documentation for 
\f1\fs18 initializeGenomicElementType()
\f2\fs20  for further discussion of how these 64\'d74 mutation matrices are interpreted and used.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float)mmJukesCantor(float$\'a0alpha)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Returns a mutation matrix representing a Jukes\'96Cantor (1969) model with mutation rate 
\f1\fs18 alpha
\f2\fs20  to each possible alternative nucleotide at a site.  This 2\'d72 matrix is suitable for use with 
\f1\fs18 initializeGenomicElementType()
\f2\fs20 .  Note that the actual mutation rate produced by this matrix is 
\f1\fs18 3*alpha
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float)mmKimura(float$\'a0alpha, float$\'a0beta)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Returns a mutation matrix representing a Kimura (1980) model with transition rate 
\f1\fs18 alpha
\f2\fs20  and transversion rate 
\f1\fs18 beta
\f2\fs20 .  This 2\'d72 matrix is suitable for use with 
\f1\fs18 initializeGenomicElementType()
\f2\fs20 .  Note that the actual mutation rate produced by this model is 
\f1\fs18 alpha+2*beta
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (integer)nucleotideCounts(is\'a0sequence)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 A convenience function that returns an 
\f1\fs18 integer
\f2\fs20  vector of length four, providing the number of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.  The parameter sequence may be a singleton 
\f1\fs18 string
\f2\fs20  (e.g., 
\f1\fs18 "TATA"
\f2\fs20 ), a 
\f1\fs18 string
\f2\fs20  vector of single characters (e.g., 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 ), or an 
\f1\fs18 integer
\f2\fs20  vector (e.g., 3, 
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 3
\f2\fs20 , 
\f1\fs18 0
\f2\fs20 ), using SLiM\'92s standard code of A=
\f1\fs18 0
\f2\fs20 , C=
\f1\fs18 1
\f2\fs20 , G=
\f1\fs18 2
\f2\fs20 , T=
\f1\fs18 3
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float)nucleotideFrequencies(is\'a0sequence)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 A convenience function that returns a 
\f1\fs18 float
\f2\fs20  vector of length four, providing the frequencies of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.  The parameter sequence may be a singleton 
\f1\fs18 string
\f2\fs20  (e.g., 
\f1\fs18 "TATA"
\f2\fs20 ), a 
\f1\fs18 string
\f2\fs20  vector of single characters (e.g., 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 ), or an 
\f1\fs18 integer
\f2\fs20  vector (e.g., 3, 
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 3
\f2\fs20 , 
\f1\fs18 0
\f2\fs20 ), using SLiM\'92s standard code of A=
\f1\fs18 0
\f2\fs20 , C=
\f1\fs18 1
\f2\fs20 , G=
\f1\fs18 2
\f2\fs20 , T=
\f1\fs18 3
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (integer)nucleotidesToCodons(is\'a0sequence)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Returns the codon sequence corresponding to the nucleotide sequence in 
\f1\fs18 sequence
\f2\fs20 .  The codon sequence is an 
\f1\fs18 integer
\f2\fs20  vector with values from 
\f1\fs18 0
\f2\fs20  to 
\f1\fs18 63
\f2\fs20 , based upon successive nucleotide triplets in the nucleotide sequence.  The codon value for a given nucleotide triplet XYZ is 16X\'a0+\'a04Y\'a0+\'a0Z, where X, Y, and Z have the usual values A=
\f1\fs18 0
\f2\fs20 , C=
\f1\fs18 1
\f2\fs20 , G=
\f1\fs18 2
\f2\fs20 , T=
\f1\fs18 3
\f2\fs20 .  For example, the triplet AAA has a codon value of 
\f1\fs18 0
\f2\fs20 , AAC is 
\f1\fs18 1
\f2\fs20 , AAG is 
\f1\fs18 2
\f2\fs20 , AAT is 
\f1\fs18 3
\f2\fs20 , ACA is 
\f1\fs18 4
\f2\fs20 , and on upward to TTT which is 
\f1\fs18 63
\f2\fs20 .  If the nucleotide sequence AACACATTT is passed in, the codon vector 
\f1\fs18 1 4 63
\f2\fs20  will therefore be returned.  These codon values can be useful in themselves; they can also be passed to 
\f1\fs18 codonsToAminoAcids()
\f2\fs20  to translate them into the corresponding amino acid sequence if desired.\
The nucleotide sequence in 
\f1\fs18 sequence
\f2\fs20  may be supplied in any of three formats: a 
\f1\fs18 string
\f2\fs20  vector with single-letter nucleotides (e.g., 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 ), a singleton 
\f1\fs18 string
\f2\fs20  of nucleotide letters (e.g., 
\f1\fs18 "TATA"
\f2\fs20 ), or an 
\f1\fs18 integer
\f2\fs20  vector of nucleotide values (e.g., 
\f1\fs18 3
\f2\fs20 , 
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 3
\f2\fs20 , 
\f1\fs18 0
\f2\fs20 ) using SLiM\'92s standard code of A=
\f1\fs18 0
\f2\fs20 , C=
\f1\fs18 1
\f2\fs20 , G=
\f1\fs18 2
\f2\fs20 , T=
\f1\fs18 3
\f2\fs20 .  If the choice of format is not driven by other considerations, such as ease of manipulation, then the singleton 
\f1\fs18 string
\f2\fs20  format will certainly be the most memory-efficient for long sequences, and will probably also be the fastest.  The nucleotide sequence provided must be a multiple of three in length, so that it translates to an integral number of codons.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (is)randomNucleotides(integer$\'a0length, [Nif\'a0basis\'a0=\'a0NULL], [string$\'a0format\'a0=\'a0"string"])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 \expnd0\expndtw0\kerning0
Generates a new random nucleotide sequence with 
\f1\fs18 length
\f2\fs20  bases.  The four nucleotides ACGT are equally probable if 
\f1\fs18 basis
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20  (the default); otherwise, 
\f1\fs18 basis
\f2\fs20  may be a 4-element 
\f1\fs18 integer
\f2\fs20  or 
\f1\fs18 float
\f2\fs20  vector providing relative fractions for A, C, G, and T respectively (these need not sum to 
\f1\fs18 1.0
\f2\fs20 , as they will be normalized).  More complex generative models such as Markov processes are not supported intrinsically in SLiM at this time, but arbitrary generated sequences may always be loaded from files on disk.\
The 
\f1\fs18 format
\f2\fs20  parameter controls the format of the returned sequence.  It may be 
\f1\fs18 "string"
\f2\fs20  to obtain the generated sequence as a singleton 
\f1\fs18 string
\f2\fs20  (e.g., 
\f1\fs18 "TATA"
\f2\fs20 ), 
\f1\fs18 "char"
\f2\fs20  to obtain it as a 
\f1\fs18 string
\f2\fs20  vector of single characters (e.g., 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 , 
\f1\fs18 "T"
\f2\fs20 , 
\f1\fs18 "A"
\f2\fs20 ), or 
\f1\fs18 "integer"
\f2\fs20  to obtain it as an 
\f1\fs18 integer
\f2\fs20  vector (e.g., 
\f1\fs18 3
\f2\fs20 , 
\f1\fs18 0
\f2\fs20 , 
\f1\fs18 3, 0
\f2\fs20 ), using SLiM\'92s standard code of A=
\f1\fs18 0
\f2\fs20 , C=
\f1\fs18 1
\f2\fs20 , G=
\f1\fs18 2
\f2\fs20 , T=
\f1\fs18 3
\f2\fs20 .  For passing directly to 
\f1\fs18 initializeAncestralNucleotides()
\f2\fs20 , format 
\f1\fs18 "string"
\f2\fs20  (a singleton string) will certainly be the most memory-efficient, and probably also the fastest.  Memory efficiency can be a significant consideration; the nucleotide sequence for a chromosome of length 10
\fs13\fsmilli6667 \super 9
\fs20 \nosupersub  will occupy approximately 1 GB of memory when stored as a singleton string (with one byte per nucleotide), and much more if stored in the other formats.  However, the other formats can be easier to work with in Eidos, and so may be preferable for relatively short chromosomes if you are manipulating the generated sequence.\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 \kerning1\expnd0\expndtw0 3.3.  Population genetics utilities
\f2\b0\fs20 \cf2 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \kerning1\expnd0\expndtw0 (float$)calcFST(object<Haplosome>\'a0haplosomes1, object<Haplosome>\'a0haplosomes2, [No<Mutation>\'a0muts\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates the 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \nosupersub  between two 
\f1\fs18 Haplosome
\f2\fs20  vectors \'96 typically, but not necessarily, the haplosomes that constitute two different subpopulations (which we will assume for the purposes of this discussion).  In general, higher 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \nosupersub  indicates greater genetic divergence between subpopulations.\
The calculation is done using only the mutations in 
\f1\fs18 muts
\f2\fs20 ; if 
\f1\fs18 muts
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20 , all mutations are used.  The 
\f1\fs18 muts
\f2\fs20  parameter can therefore be used to calculate the 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \nosupersub  only for a particular mutation type (by passing only mutations of that type).\
The calculation can be narrowed to apply to only a window \'96 a subrange of the full chromosome \'96 by passing the interval bounds [
\f1\fs18 start
\f2\fs20 , 
\f1\fs18 end
\f2\fs20 ] for the desired window.  In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.  The default behavior, with 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  of 
\f1\fs18 NULL
\f2\fs20 , provides the haplosome-wide 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \nosupersub , which is often used to assess the overall level of genetic divergence between sister species or allopatric subpopulations.\
The code for 
\f1\fs18 calcFST()
\f2\fs20  is, roughly, an Eidos implementation of Wright\'92s definition of 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \nosupersub  (but see below for further discussion and clarification):\

\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \expnd0\expndtw0\kerning0
\nosupersub  = 1 - 
\f3\i H
\f2\i0\fs13\fsmilli6667 \kerning1\expnd0\expndtw0 \sub S
\fs20 \expnd0\expndtw0\kerning0
\nosupersub  / 
\f3\i H
\f2\i0\fs13\fsmilli6667 \kerning1\expnd0\expndtw0 \sub T
\fs20 \expnd0\expndtw0\kerning0
\nosupersub \
\kerning1\expnd0\expndtw0 where 
\f3\i H
\fs13\fsmilli6667 \sub S
\f2\i0\fs20 \nosupersub  is the average heterozygosity in the two subpopulations, and 
\f3\i H
\fs13\fsmilli6667 \sub T 
\f2\i0\fs20 \nosupersub is the total heterozygosity when both subpopulations are combined.  In this implementation, the two haplosome vectors are weighted equally, not weighted by their size.  In SLiM 3, the implementation followed Wright\'92s definition closely, and returned the 
\f3\i average of ratios
\f2\i0 : 
\f1\fs18 mean(1.0 - H_s/H_t)
\f2\fs20 , in the Eidos code.  In SLiM 4, it returns the 
\f3\i ratio of averages
\f2\i0  instead: 
\f1\fs18 1.0 - mean(H_s)/mean(H_t)
\f2\fs20 .  In other words, the 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \nosupersub  value reported by SLiM 4 is an average across the specified mutations in the two sets of haplosomes, where 
\f1\fs18 H_s
\f2\fs20  and 
\f1\fs18 H_t
\f2\fs20  are first averaged across all specified mutations prior to taking the ratio of the two.  This ratio of averages is less biased than the average of ratios, and and is generally considered to be best practice (see, e.g., Bhatia et al., 2013).  This means that the behavior of 
\f1\fs18 calcFST()
\f2\fs20  differs between SLiM 3 and SLiM 4.\
As can be seen from its equation, the 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub ST
\fs20 \nosupersub  is undefined if 
\f3\i H
\fs13\fsmilli6667 \sub T
\f2\i0\fs20 \nosupersub  is zero, which occurs if no mutations are present in the haplosomes provided (given the optionally specified window and set of mutations).  In that case, 
\f1\fs18 calcFST()
\f2\fs20  will return 
\f1\fs18 NAN
\f2\fs20 .  It is up to the caller to detect this with 
\f1\fs18 isNAN()
\f2\fs20  and handle it as necessary.\
The implementation of 
\f1\fs18 calcFST()
\f2\fs20 , viewable with 
\f1\fs18 functionSource()
\f2\fs20 , treats every mutation in 
\f1\fs18 muts
\f2\fs20  as independent in the heterozygosity calculations; in other words, if mutations are stacked, the heterozygosity calculated is 
\f3\i by mutation
\f2\i0 , not 
\f3\i by site
\f2\i0 .  Similarly, if multiple 
\f1\fs18 Mutation
\f2\fs20  objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each 
\f1\fs18 Mutation
\f2\fs20  object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.  One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.  In most biologically realistic models, such genetic states will be quite rare, and so the impact of these choices will be negligible; however, in some models these distinctions may be important.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcHeterozygosity(object<Haplosome>\'a0haplosomes, [No<Mutation>\'a0muts\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates the heterozygosity for a vector of haplosomes (containing at least one element), based upon the frequencies of mutations in the haplosomes.  The result is the 
\f3\i expected
\f2\i0  heterozygosity, for the individuals to which the haplosomes belong, assuming that they are under Hardy-Weinberg equilibrium; this can be compared to the 
\f3\i observed
\f2\i0  heterozygosity of an individual, as calculated by 
\f1\fs18 calcPairHeterozygosity()
\f2\fs20 .  Often 
\f1\fs18 haplosomes
\f2\fs20  will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.  By default, with 
\f1\fs18 muts=NULL
\f2\fs20 , the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for 
\f1\fs18 muts
\f2\fs20 .\
In multi-chromosome models, all of the haplosomes and mutations passed in 
\f1\fs18 haplosomes
\f2\fs20  and 
\f1\fs18 muts
\f2\fs20  must all be associated with the same single chromosome.  If you wish to calculate heterozygosity across multiple chromosomes, you can simply write a 
\f1\fs18 for
\f2\fs20  loop that calculates it for each chromosome and combines the results; but it is not entirely clear how to weight the chromosomes to produce a single number, especially when sex chromosomes and other chromosomes of variable ploidy might be represented in 
\f1\fs18 haplosomes
\f2\fs20 , so it is not done automatically by this function.\
The calculation can be narrowed to apply to only a window \'96 a subrange of the full chromosome \'96 by passing the interval bounds [
\f1\fs18 start
\f2\fs20 , 
\f1\fs18 end
\f2\fs20 ] for the desired window.  In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.  The default behavior, with 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  of 
\f1\fs18 NULL
\f2\fs20 , provides the haplosome-wide heterozygosity.\
The implementation of 
\f1\fs18 calcHeterozygosity()
\f2\fs20 , viewable with 
\f1\fs18 functionSource()
\f2\fs20 , treats every mutation as independent in the heterozygosity calculations.  One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations.  In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.  See 
\f1\fs18 calcPairHeterozygosity()
\f2\fs20  for further discussion.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcInbreedingLoad(object<Haplosome>\'a0haplosomes, [Nio<MutationType>$\'a0mutType\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates inbreeding load (the haploid number of lethal equivalents, or 
\f3\i B
\f2\i0 ) for a vector of haplosomes (containing at least one element) passed in 
\f1\fs18 haplosomes
\f2\fs20 .  The calculation can be limited to a focal mutation type passed in 
\f1\fs18 mutType
\f2\fs20  (which may be either an 
\f1\fs18 integer
\f2\fs20  representing the ID of the desired mutation type, or a 
\f1\fs18 MutationType
\f2\fs20  object specified directly); if 
\f1\fs18 mutType
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20  (the default), all of the mutations for the focal species will be considered.  In any case, only deleterious mutations (those with a negative selection coefficient) will be included in the final calculation.\
The inbreeding load is a measure of the quantity of recessive deleterious variation that is heterozygous in a population and can contribute to fitness declines under inbreeding.  This function implements the following equation from Morton et al. (1956), which assumes no epistasis and random mating:\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f3\i\fs22 \cf2 B
\f2\i0  = sum(
\f3\i qs
\f2\i0 ) \uc0\u8722  sum(
\f3\i q
\f2\i0\fs14\fsmilli7333 \super 2
\f3\i\fs22 \nosupersub s
\f2\i0 ) \uc0\u8722  2sum(
\f3\i q
\f2\i0 (1\uc0\u8722 
\f3\i q
\f2\i0 )
\f3\i sh
\f2\i0 )\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\fs20 \cf2 where 
\f3\i q
\f2\i0  is the frequency of a given deleterious allele, 
\f3\i s
\f2\i0  is the absolute value of the selection coefficient, and 
\f3\i h
\f2\i0  is its dominance coefficient.  Note that the implementation, viewable with 
\f1\fs18 functionSource()
\f2\fs20 , sets a maximum |
\f3\i s
\f2\i0 | of 
\f1\fs18 1.0
\f2\fs20  (i.e., a lethal allele); |
\f3\i s
\f2\i0 | can sometimes be greater than 
\f1\fs18 1.0
\f2\fs20  when 
\f3\i s
\f2\i0  is drawn from a distribution, but in practice an allele with 
\f3\i s
\f2\i0 \'a0<\'a0
\f1\fs18 -1.0
\f2\fs20  has the same lethal effect as when 
\f3\i s
\f2\i0 \'a0=\'a0
\f1\fs18 -1.0
\f2\fs20 .  Also note that this implementation will not work when the model changes the dominance coefficients of mutations using 
\f1\fs18 mutationEffect()
\f2\fs20  callbacks, since it relies on the 
\f1\fs18 dominanceCoeff
\f2\fs20  property of 
\f1\fs18 MutationType
\f2\fs20 . Finally, note that, to estimate the diploid number of lethal equivalents (2
\f3\i B
\f2\i0 ), the result from this function can simply be multiplied by two.\
This function was contributed by Chris Kyriazis; thanks, Chris!\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcMeanFroh(object<Individual>\'a0individuals, [integer$\'a0minimumLength\'a0=\'a01000000], [Niso<Chromosome>$\'a0chromosome\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates the mean value of the 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  statistic across the individuals passed in 
\f1\fs18 individuals
\f2\fs20 .  This statistic is a measure of individual autozygosity, likely resulting from inbreeding, and is calculated based upon \'93runs of homozygosity\'94, or ROH, in the genome of an individual.  Broadly speaking, 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  is the proportion of an individual\'92s genome that is spanned by ROH longer than a given threshold length.  However, it should be noted that there are many different ways of calculating 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub , producing different results.  For example, the threshold length might be a given constant, or might be determined statistically from the characteristics of the population.  Furthermore, some heterozygous sites might be discarded (to compensate for genotyping errors), a minimum SNP density might be required within a sliding window for an ROH to be diagnosed, and so forth \'96 it can get quite complex, as seen in the software PLINK (Purcell et al., 2007) and GARLIC (Szpiech, Blant and Pemberton, 2017).  The method used by 
\f1\fs18 calcMeanFroh()
\f2\fs20  is the simplest possible method, assessing ROH for each individual directly from the simulated mutations without filtering or modification, and applying a given constant threshold length.  If a more sophisticated 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  algorithm is desired, one could modify the implementation of 
\f1\fs18 calcMeanFroh()
\f2\fs20 , which is viewable with 
\f1\fs18 functionSource()
\f2\fs20 , or one could output VCF data from SLiM and analyze it with other tools, perhaps calling out from the running SLiM script with 
\f1\fs18 system()
\f2\fs20 .\
The threshold ROH length used by 
\f1\fs18 calcMeanFroh()
\f2\fs20  is supplied by the parameter 
\f1\fs18 minimumLength
\f2\fs20 .  It defaults to 
\f1\fs18 1e6
\f2\fs20 , or 1 Mbp, since that is a length commonly used in the literature, but can be adjusted as desired.\
The 
\f1\fs18 chromosome
\f2\fs20  parameter can be supplied to focus the 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  calculation on a specific chromosome; otherwise, the calculation spans all chromosomes for which the individual is actually diploid (without a null haplosome).  If 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  cannot be calculated for an individual (due to the presence of null haplosomes for every intrinsically diploid chromosome being analyzed), that individual is omitted from the mean 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  calculation; for example, if an X chromosome is the focal chromosome being analyzed, all males will be omitted from the mean 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  calculation.  If all individuals are omitted from the mean 
\f3\i F
\f2\i0\fs13\fsmilli6667 \sub roh
\fs20 \nosupersub  calculation for this reason, 
\f1\fs18 NAN
\f2\fs20  is returned.\
This function was developed with advice from Ryan Chaffee.  Thanks, Ryan!\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcPairHeterozygosity(object<Haplosome>$\'a0haplosome1, object<Haplosome>$\'a0haplosome2, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL], [logical$\'a0infiniteSites\'a0=\'a0T])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates the heterozygosity for a pair of haplosomes; these will typically be two homologous haplosomes of the same diploid individual, but any two haplosomes associated with the same chromosome may be supplied.\
The calculation can be narrowed to apply to only a window \'96 a subrange of the full chromosome \'96 by passing the interval bounds [
\f1\fs18 start
\f2\fs20 , 
\f1\fs18 end
\f2\fs20 ] for the desired window.  In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.  The default behavior, with 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  of 
\f1\fs18 NULL
\f2\fs20 , provides the haplosome-wide heterozygosity.\
The implementation 
\f1\fs18 calcPairHeterozygosity()
\f2\fs20 , viewable with 
\f1\fs18 functionSource()
\f2\fs20 , treats every mutation as independent in the heterozygosity calculations by default (i.e., with 
\f1\fs18 infiniteSites=T
\f2\fs20 ).  If mutations are stacked, the heterozygosity calculated therefore depends upon the number of 
\f3\i unshared mutations
\f2\i0 , not the number of 
\f3\i differing sites
\f2\i0 .  Similarly, if multiple 
\f1\fs18 Mutation
\f2\fs20  objects exist in different haplosomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), each 
\f1\fs18 Mutation
\f2\fs20  object is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.  One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.  In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.  The behavior of 
\f1\fs18 calcPairHeterozygosity()
\f2\fs20  can be switched to calculate based upon the number of differing sites, rather than the number of unshared mutations, by passing 
\f1\fs18 infiniteSites=F
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcPi(object<Haplosome>\'a0haplosomes, [No<Mutation>\'a0muts\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates 
\f7\i \uc0\u960 
\f2\i0  (nucleotide diversity, a metric of genetic diversity) for a vector of haplosomes (containing at least two elements), based upon the mutations in the haplosomes.  
\f7\i \uc0\u960 
\f2\i0  is computed by calculating the mean number of pairwise differences at each site, summing across all sites, and dividing by the number of sites.  Therefore, it is interpretable as the number of differences per site expected between two randomly chosen sequences.  The mathematical formulation (as an estimator of the population parameter 
\f7\i \uc0\u952 
\f2\i0 ) is based on work in Nei and Li (1979), Nei and Tajima (1981), and Tajima (1983; equation A3).  The exact formula used here is common in textbooks (e.g., equations 9.1\'969.5 in Li 1997, equation 3.3 in Hahn 2018, or equation 2.2 in Coop 2020).\
Often 
\f1\fs18 haplosomes
\f2\fs20  will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.  By default, with 
\f1\fs18 muts=NULL
\f2\fs20 , the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for 
\f1\fs18 muts
\f2\fs20 .\
The calculation can be narrowed to apply to only a window \'96 a subrange of the full chromosome \'96 by passing the interval bounds [
\f1\fs18 start
\f2\fs20 , 
\f1\fs18 end
\f2\fs20 ] for the desired window.  In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.  The default behavior, with 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  of 
\f1\fs18 NULL
\f2\fs20 , provides the haplosome-wide value of 
\f7\i \uc0\u960 
\f2\i0 .\
The implementation of 
\f1\fs18 calcPi()
\f2\fs20 , viewable with 
\f1\fs18 functionSource()
\f2\fs20 , treats every mutation as independent in the heterozygosity calculations.  One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with 
\f1\fs18 calcHeterozygosity()
\f2\fs20 .  Indeed, finite-sites models of 
\f7\i \uc0\u960 
\f2\i0  have been derived (Tajima 1996) though are not used here.  In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.  See 
\f1\fs18 calcPairHeterozygosity()
\f2\fs20  for further discussion.  This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph and Chase Nelson.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (numeric)calcSFS([Ni$\'a0binCount\'a0=\'a0NULL], [No<Haplosome>\'a0haplosomes\'a0=\'a0NULL], [No<Mutation>\'a0muts\'a0=\'a0NULL], [string$\'a0metric\'a0=\'a0"density"], [logical$\'a0fold\'a0=\'a0F])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates the site frequency spectrum, or SFS, for the mutations specified by 
\f1\fs18 muts
\f2\fs20 , within the haplosomes specified by 
\f1\fs18 haplosomes
\f2\fs20 .  The site frequency spectrum or SFS (sometimes called the allele frequency spectrum, although some authors distinguish between the two) is essentially a histogram of the frequencies of the mutations within the haplosomes; the first bin spans the lowest range of frequencies (down to a frequency of 
\f1\fs18 0.0
\f2\fs20 , or a count of 
\f1\fs18 1
\f2\fs20 ), whereas the last bin spans the highest range of frequencies (up to a frequency of 
\f1\fs18 1.0
\f2\fs20 , or a count equal to number of haplosomes minus one).  The idea was introduced by Watterson (1975), and will be discussed in any population genetics textbook (e.g., A. Cutter, 2019, pp. 50\'9652).  This histogram can be returned as a 
\f1\fs18 float
\f2\fs20  vector of density values for each bin by specifying 
\f1\fs18 "density"
\f2\fs20  for 
\f1\fs18 metric
\f2\fs20  (the default), or as an 
\f1\fs18 integer
\f2\fs20  vector of count values for each bin by specifying 
\f1\fs18 "count"
\f2\fs20 .\
There are two modes of operation for 
\f1\fs18 calcSFS()
\f2\fs20 .  If a specific number of bins is passed for 
\f1\fs18 binCount
\f2\fs20 , then the frequency range 
\f1\fs18 [0.0, 1.0]
\f2\fs20  is subdivided into 
\f1\fs18 binCount
\f2\fs20  intervals of equal width, and the mutations are tallied into those bins according to their frequencies within the haplosomes to produce the histogram.  In this mode, there will be exactly 
\f1\fs18 binCount
\f2\fs20  elements in the returned vector.  Note that either 
\f1\fs18 "density"
\f2\fs20  or 
\f1\fs18 "count"
\f2\fs20  can be chosen in this mode; you can return the frequency bin tallies as either densities or counts.\
In the other mode of operation, chosen with a 
\f1\fs18 binCount
\f2\fs20  value of 
\f1\fs18 NULL
\f2\fs20 , the bins instead represent the count of the number of occurrences for each mutation, and range from a count of 
\f1\fs18 1
\f2\fs20  (the bin for mutations that occur only once in the haplosomes, sometimes called \'93singletons\'94) up to a count of 
\f1\fs18 N-1
\f2\fs20  where 
\f1\fs18 N
\f2\fs20  is the number of haplosomes.  (Note that mutations occurring in all 
\f1\fs18 N
\f2\fs20  haplosomes are not included in the tally, since they would not be empirically observable.)  In this mode, there will be exactly 
\f1\fs18 N-1
\f2\fs20  elements in the returned vector.  Again, either 
\f1\fs18 "density"
\f2\fs20  or 
\f1\fs18 "count"
\f2\fs20  can be chosen in this mode; you can return the count bin tallies as either densities or counts (it\'92s a bit confusing, but we\'92re talking about two different kinds of \'93counts\'94, the count of the number of times a mutation occurs in the haplosomes versus the count of the number of mutations that were tallied into a particular count bin).\
The 
\f1\fs18 haplosomes
\f2\fs20  parameter can be either a vector of 
\f1\fs18 Haplosome
\f2\fs20  objects or 
\f1\fs18 NULL
\f2\fs20 .  If 
\f1\fs18 NULL
\f2\fs20  is passed, 
\f1\fs18 calcSFS()
\f2\fs20  will calculate the SFS across the whole species, using all non-null haplosomes present (and thus there must be only a single species in the model, since an SFS cannot be calculated across multiple species).  Otherwise, 
\f1\fs18 haplosomes
\f2\fs20  can contain any set of haplosomes desired, such as from the individuals of one subpopulation, several subpopulations, or an entire species.  However, they must all belong to the same species, and null haplosomes will be automatically and silently excluded from the set.\
The 
\f1\fs18 muts
\f2\fs20  parameter can be either a vector of 
\f1\fs18 Mutation
\f2\fs20  objects or 
\f1\fs18 NULL
\f2\fs20 .  If 
\f1\fs18 NULL
\f2\fs20  is passed, 
\f1\fs18 calcSFS()
\f2\fs20  will calculate the SFS across all mutations belonging to the focal species (as determined from the species of the haplosomes).  Otherwise, 
\f1\fs18 muts
\f2\fs20  can contain any set of mutations desired, such as mutations belonging to a specific mutation type, mutations within a specific range of positions along the chromosome, or all of the mutations in the focal species.\
The 
\f1\fs18 binCount
\f2\fs20  and 
\f1\fs18 metric
\f2\fs20  parameters have already been discussed.  Finally, the 
\f1\fs18 fold
\f2\fs20  parameter, if 
\f1\fs18 T
\f2\fs20 , \'93folds\'94 the calculated SFS, adding the first and last bins, the second and next-to-last bins, etc., until the center is reached.  Folding is common when working with empirical data, where one often doesn\'92t know the \'93polarity\'94 \'96 which allele at a site is ancestral and which is derived.  Folding solves this problem, because the polarity then doesn\'92t matter; the tally for a given mutation ends up in the same bin regardless.  If the number of bins is even, folding can be performed without ambiguity; the final number of bins is exactly half the original number of bins, and each final bin is the sum of two original bins.  If the number of bins is odd, the correct treatment of the central bin is somewhat ambiguous.  In 
\f1\fs18 calcFST()
\f2\fs20 , the central bin is added to itself \'96 doubled \'96 and the number of bins is equal to half the original number of bins rounded up.  If you would prefer to exclude the central bin altogether \'96 another population treatment \'96 then when the original number of bins is odd, you can simply discard the final value in the returned vector (and, if you wish to work with densities rather than counts, re-normalize the result to sum to 1.0).\
The implementation of 
\f1\fs18 calcSFS()
\f2\fs20 , viewable with 
\f1\fs18 functionSource()
\f2\fs20 , tallies each mutation separately, even if more than one mutation occurs at the same position (or is even stacked with another mutation).  One could regard this choice as embodying an infinite-sites interpretation of the SFS, perhaps; in any case, it follows SLiM\'92s behavior in other population-genetics utility functions.  In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.\
This function is compatible with multi-chromosome models, in the following sense.  When 
\f1\fs18 binCount
\f2\fs20  is specified with an 
\f1\fs18 integer
\f2\fs20  value, mutations are binned according to their frequencies, as described above.  In a multi-chromosome model, the haplosomes and mutations used by 
\f1\fs18 calcSFS()
\f2\fs20  may be associated with more than one chromosome, and the frequency assessed for each mutation is its frequency specifically within the haplosomes associated with its chromosome (as you would expect).  Mutations occurring in different chromosomes can therefore be tallied together into the same frequency bins, and combined into a single SFS; this produces a meaningful.  (If you want an SFS for just a single chromosome, then of course you can pass just those haplosomes and mutations to 
\f1\fs18 calcSFS()
\f2\fs20 .)  When 
\f1\fs18 binCount
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20 , on the other hand, mutations are binned according to their counts, as described above.  In a multi-chromosome model, it would not make sense to bin counts together from different chromosomes, since those counts might not be on the same scale \'96 the number of haplosomes associated with the various chromosomes might not be equal.  In this case, 
\f1\fs18 calcSFS()
\f2\fs20  will raise an error if haplosomes from more than one chromosome are supplied, or if haplosomes is 
\f1\fs18 NULL
\f2\fs20  (since it doesn\'92t know which chromosome to choose).  If you wish to tally according to counts, with 
\f1\fs18 binCount=NULL
\f2\fs20 , you must pass in a vector of haplosomes associated with a single chromosome.  (If you know what you are doing and wish to combine counts across multiple chromosomes, you can simply call 
\f1\fs18 calcSFS()
\f2\fs20  once per chromosome, and combine the resulting vectors by adding them together.)\
Thanks to Ryan Chaffee and Chase Nelson for helpful input.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcTajimasD(object<Haplosome>\'a0haplosomes, [No<Mutation>\'a0muts\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates Tajima\'92s 
\f3\i D
\f2\i0  (a test of neutrality based on the allele frequency spectrum) for a vector of haplosomes (containing at least four elements), based upon the mutations in the haplosomes.  The mathematical formulation is given in Tajima 1989 (equation 38) and remains unchanged (e.g., equations 2.30 in Durrett 2008, 8.4 in Hahn 2018, and 4.44 in Coop 2020).  Often 
\f1\fs18 haplosomes
\f2\fs20  will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.  By default, with 
\f1\fs18 muts=NULL
\f2\fs20 , the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for 
\f1\fs18 muts
\f2\fs20 .\
The calculation can be narrowed to apply to only a window \'96 a subrange of the full chromosome \'96 by passing the interval bounds [
\f1\fs18 start
\f2\fs20 , 
\f1\fs18 end
\f2\fs20 ] for the desired window.  In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.  The default behavior, with 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  of 
\f1\fs18 NULL
\f2\fs20 , provides the haplosome-wide Tajima\'92s 
\f3\i D
\f2\i0 .\
If the genetic diversity contained within the haplosomes is insufficient for the calculation, 
\f1\fs18 calcTajimasD()
\f2\fs20  may return 
\f1\fs18 NAN
\f2\fs20 .  It is up to the caller to detect this with 
\f1\fs18 isNAN()
\f2\fs20  and handle it as necessary.\
The implementation of 
\f1\fs18 calcTajimasD()
\f2\fs20 , viewable with 
\f1\fs18 functionSource()
\f2\fs20 , treats every mutation as independent in the heterozygosity calculations.  One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with 
\f1\fs18 calcHeterozygosity()
\f2\fs20 .  Indeed, Tajima\'92s 
\f3\i D
\f2\i0  can be modified with finite-sites models of 
\f7\i \uc0\u960 
\f2\i0  and 
\f7\i \uc0\u952 
\f2\i0  (Misawa and Tajima 1997) though these are not used here.  In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.  See 
\f1\fs18 calcPairHeterozygosity()
\f2\fs20  for further discussion.  This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcVA(object<Individual>\'a0individuals, io<MutationType>$\'a0mutType)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates 
\f3\i V
\f2\i0\fs13\fsmilli6667 \sub A
\fs20 \nosupersub , the additive genetic variance, among a vector of individuals (containing at least two elements) passed in 
\f1\fs18 individuals
\f2\fs20 , in a particular mutation type 
\f1\fs18 mutType
\f2\fs20  that represents quantitative trait loci (QTLs) influencing a quantitative phenotypic trait.  The 
\f1\fs18 mutType
\f2\fs20  parameter may be either an 
\f1\fs18 integer
\f2\fs20  representing the ID of the desired mutation type, or a 
\f1\fs18 MutationType
\f2\fs20  object specified directly.\
This function assumes that mutations of type 
\f1\fs18 mutType
\f2\fs20  encode their effect size upon the quantitative trait in their 
\f1\fs18 selectionCoeff
\f2\fs20  property, as is fairly standard in SLiM.  The implementation of 
\f1\fs18 calcVA()
\f2\fs20 , which is viewable with 
\f1\fs18 functionSource()
\f2\fs20 , is quite simple; if effect sizes are stored elsewhere (such as with 
\f1\fs18 setValue()
\f2\fs20 ), a new user-defined function following the pattern of 
\f1\fs18 calcVA()
\f2\fs20  can easily be written.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)calcWattersonsTheta(object<Haplosome>\'a0haplosomes, [No<Mutation>\'a0muts\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Calculates Watterson\'92s theta (a metric of genetic diversity comparable to heterozygosity) for a vector of haplosomes (containing at least one element), based upon the mutations in the haplosomes.  Often 
\f1\fs18 haplosomes
\f2\fs20  will be all of the haplosomes in a subpopulation, or in the entire population, but any haplosome vector may be used.  By default, with 
\f1\fs18 muts=NULL
\f2\fs20 , the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations for 
\f1\fs18 muts
\f2\fs20 .\
The calculation can be narrowed to apply to only a window \'96 a subrange of the full chromosome \'96 by passing the interval bounds [
\f1\fs18 start
\f2\fs20 , 
\f1\fs18 end
\f2\fs20 ] for the desired window.  In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.  The default behavior, with 
\f1\fs18 start
\f2\fs20  and 
\f1\fs18 end
\f2\fs20  of 
\f1\fs18 NULL
\f2\fs20 , provides the haplosome-wide Watterson\'92s theta.\
The implementation of 
\f1\fs18 calcWattersonsTheta()
\f2\fs20 , viewable with 
\f1\fs18 functionSource()
\f2\fs20 , treats every mutation as independent in the heterozygosity calculations.  One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as with 
\f1\fs18 calcHeterozygosity()
\f2\fs20 .  In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.  See 
\f1\fs18 calcPairHeterozygosity()
\f2\fs20  for further discussion.\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.4.  Other utilities
\f2\b0\fs20 \cf2 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \kerning1\expnd0\expndtw0 (float)summarizeIndividuals(object<Individual>\'a0individuals, integer\'a0dim, numeric\'a0spatialBounds, string$\'a0operation, [Nlif$\'a0empty\'a0=\'a00.0], [logical$\'a0perUnitArea\'a0=\'a0F], [Ns$\'a0spatiality\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Returns a vector, matrix, or array that summarizes spatial patterns of information related to the individuals in 
\f1\fs18 individuals
\f2\fs20 .  In essence, those individuals are assigned into 
\f3\i bins
\f2\i0  according to their spatial position, and then a summary value for each bin is calculated based upon the individuals each bin contains.  The individuals might be binned in one dimension (resulting in a vector of summary values), in two dimensions (resulting in a matrix), or in three dimensions (resulting in an array).  Typically the spatiality of the result (the dimensions into which the individuals are binned) will match the dimensionality of the model, as indicated by the default value of 
\f1\fs18 NULL
\f2\fs20  for the optional 
\f1\fs18 spatiality
\f2\fs20  parameter; for example, a two-dimensional (
\f1\fs18 "xy"
\f2\fs20 ) model would by default produce a two-dimensional matrix as a summary.  However, a spatiality that is more restrictive than the model dimensionality may be passed; for example, in a two-dimensional (
\f1\fs18 "xy"
\f2\fs20 ) model a 
\f1\fs18 spatiality
\f2\fs20  of 
\f1\fs18 "y"
\f2\fs20  could be passed to summarize individuals into a vector, rather than a matrix, assigning them to bins based only upon their 
\f3\i y
\f2\i0  position (i.e., the value of their 
\f1\fs18 y
\f2\fs20  property).  Whatever spatiality is chosen, the parameter 
\f1\fs18 dim
\f2\fs20  provides the dimensions of the desired result, in the same form that the 
\f1\fs18 dim()
\f2\fs20  function does: first the number of rows, then the number of columns, and then the number of planes, as needed (see the Eidos manual for discussion of matrices, arrays, and 
\f1\fs18 dim()
\f2\fs20 ).  The length of 
\f1\fs18 dims
\f2\fs20  must match the requested spatiality; for spatiality 
\f1\fs18 "xy"
\f2\fs20 , for example, 
\f1\fs18 dims
\f2\fs20  might be 
\f1\fs18 c(50,100)
\f2\fs20  to request that the returned matrix have 
\f1\fs18 50
\f2\fs20  rows and 
\f1\fs18 100
\f2\fs20  columns.  The result vector/matrix/array is in the correct orientation to be directly usable as a spatial map, by passing it to the 
\f1\fs18 defineSpatialMap()
\f2\fs20  method of 
\f1\fs18 Subpopulation
\f2\fs20 .  For further discussion of dimensionality and spatiality, see 
\f1\fs18 initializeInteractionType()
\f2\fs20  and 
\f1\fs18 InteractionType
\f2\fs20 .\
The 
\f1\fs18 spatialBounds
\f2\fs20  parameter defines the spatial boundaries within which the individuals are binned.  Typically this is the spatial bounds of a particular subpopulation, within which the individuals reside; for individuals in 
\f1\fs18 p1
\f2\fs20 , for example, you would likely pass 
\f1\fs18 p1.spatialBounds
\f2\fs20  for this.  However, this is not required; individuals may come from any or all subpopulations in the model, and 
\f1\fs18 spatialBounds
\f2\fs20  may be any bounds of non-zero area (if an individual falls outside of the given spatial bounds, it is excluded, as if it were not in 
\f1\fs18 individuals
\f2\fs20  at all).  If you have multiple subpopulations that conceptually reside within the same overall coordinate space, for example, that can be accommodated here.  The bounds are supplied in the dimensionality of the model, in the same form as for 
\f1\fs18 Subpopulation
\f2\fs20 ; for an 
\f1\fs18 "xy"
\f2\fs20  model, for example, they are supplied as a four-element vector of the form 
\f1\fs18 c(x0, y0, x1, y1)
\f2\fs20  even if the summary is being produced with spatiality 
\f1\fs18 "y"
\f2\fs20 .  To produce the result, a grid with dimensions defined by 
\f1\fs18 dims
\f2\fs20  is conceptually stretched out across the given spatial bounds, such that the 
\f3\i centers
\f2\i0  of the edge and corner grid squares are aligned with the limits of the spatial bounds.  This matches the way that 
\f1\fs18 defineSpatialMap()
\f2\fs20  defines its maps.\
The particular summary produced depends upon the parameters 
\f1\fs18 operation
\f2\fs20  and 
\f1\fs18 empty
\f2\fs20 .  Consider a single grid square represented by a single element in the result.  That grid square contains zero or more of the individuals in 
\f1\fs18 individuals
\f2\fs20 .  If it contains zero individuals 
\f3\i and
\f2\i0  
\f1\fs18 empty
\f2\fs20  is not 
\f1\fs18 NULL
\f2\fs20 , the 
\f1\fs18 empty
\f2\fs20  value is used for the result, regardless of 
\f1\fs18 operation
\f2\fs20 , providing specific, separate control over the treatment of empty grid squares.  If 
\f1\fs18 empty
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20 , this separate control over the treatment of empty grid squares is declined; empty grid squares will be handled through the standard mechanism described next.  In all other cases for the given grid square \'96 when it contains more than zero individuals, or when 
\f1\fs18 empty
\f2\fs20  is 
\f1\fs18 NULL
\f2\fs20  \'96 
\f1\fs18 operation
\f2\fs20  is executed as an Eidos 
\f3\i lambda
\f2\i0 , a small snippet of code, supplied as a singleton 
\f1\fs18 string
\f2\fs20 , that is executed in a manner similar to a function call.  Within the execution of the 
\f1\fs18 operation
\f2\fs20  lambda, a constant named 
\f1\fs18 individuals
\f2\fs20  is defined to be the focal individuals being evaluated \'96 all of the individuals within that grid square.  This lambda should evaluate to a singleton 
\f1\fs18 logical
\f2\fs20 , 
\f1\fs18 integer
\f2\fs20 , or 
\f1\fs18 float
\f2\fs20  value, comprising the result value for the grid square; these types will all be coerced to 
\f1\fs18 float
\f2\fs20  (
\f1\fs18 T
\f2\fs20  being 
\f1\fs18 1
\f2\fs20  and 
\f1\fs18 F
\f2\fs20  being 
\f1\fs18 0
\f2\fs20 ).\
Two examples may illustrate the use of 
\f1\fs18 empty
\f2\fs20  and 
\f1\fs18 operation
\f2\fs20 .  To produce a summary indicating presence/absence, simply use the default of 
\f1\fs18 0.0
\f2\fs20  for 
\f1\fs18 empty
\f2\fs20 , and 
\f1\fs18 "1.0;
\f2\fs20  
\f1\fs18 "
\f2\fs20  (or 
\f1\fs18 "1;"
\f2\fs20 , or 
\f1\fs18 "T;"
\f2\fs20 ) for 
\f1\fs18 operation
\f2\fs20 .  This will produce 
\f1\fs18 0.0
\f2\fs20  for empty grid squares, and 
\f1\fs18 1.0
\f2\fs20  for those that contain at least one individual.  Note that the use of 
\f1\fs18 empty
\f2\fs20  is essential here, because 
\f1\fs18 operation
\f2\fs20  doesn\'92t even check whether individuals are present or not.  To produce a summary with a count of the number of individuals in each grid square, again use the default of 
\f1\fs18 0.0
\f2\fs20  for 
\f1\fs18 empty
\f2\fs20 , but now use an 
\f1\fs18 operation
\f2\fs20  of 
\f1\fs18 "individuals.size();"
\f2\fs20 , counting the number of individuals in each grid square.  In this case, 
\f1\fs18 empty
\f2\fs20  could be 
\f1\fs18 NULL
\f2\fs20  instead and 
\f1\fs18 operation
\f2\fs20  would still produce the correct result; but using 
\f1\fs18 empty
\f2\fs20  makes 
\f1\fs18 summarizeIndividuals()
\f2\fs20  more efficient since it allows the execution of 
\f1\fs18 operation
\f2\fs20  to be skipped for those squares.\
Lambdas are not limited in their complexity; they can use 
\f1\fs18 if
\f2\fs20 , 
\f1\fs18 for
\f2\fs20 , etc., and can call methods and functions.  A typical 
\f1\fs18 operation
\f2\fs20  to compute the mean phenotype in a quantitative genetic model that stores phenotype values in 
\f1\fs18 tagF
\f2\fs20 , for example, would be 
\f1\fs18 "mean(individuals.tagF);"
\f2\fs20 , and this is still quite simple compared to what is possible.  However, keep in mind that the lambda will be evaluated for every grid cell (or at least those that are non-empty), so efficiency can be a concern, and you may wish to pre-calculate values shared by all of the lambda calls, making them available to your lambda code using 
\f1\fs18 defineGlobal()
\f2\fs20  or 
\f1\fs18 defineConstant()
\f2\fs20 .\
There is one last twist, if 
\f1\fs18 perUnitArea
\f2\fs20  is 
\f1\fs18 T
\f2\fs20 : values are divided by the area (or length, in 1D, or volume, in 3D) that their corresponding grid cell comprises, so that each value is in units of \'93per unit area\'94 (or \'93per unit length\'94, or \'93per unit volume\'94).  The total area of the grid is defined by the spatial bounds, and the area of a given grid cell is defined by the portion of the spatial bounds that is within that cell.  This is not the same for all grid cells; grid cells that fall partially outside 
\f1\fs18 spatialBounds
\f2\fs20  (because, remember, the 
\f3\i centers
\f2\i0  of the edge/corner grid cells are aligned with the limits of 
\f1\fs18 spatialBounds
\f2\fs20 ) will have a smaller area inside the bounds.  For an 
\f1\fs18 "xy"
\f2\fs20  spatiality summary, for example, corner cells have only a quarter of their area inside 
\f1\fs18 spatialBounds
\f2\fs20 , while edge elements have half of their area inside 
\f1\fs18 spatialBounds
\f2\fs20 ; for purposes of 
\f1\fs18 perUnitArea
\f2\fs20 , then, their respective areas are \'bc and \'bd the area of an interior grid cell.  By default, 
\f1\fs18 perUnitArea
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 , and no scaling is performed.  Whether you want 
\f1\fs18 perUnitArea
\f2\fs20  to be 
\f1\fs18 F
\f2\fs20  or 
\f1\fs18 T
\f2\fs20  depends upon whether the summary you are producing is, conceptually, \'93per unit area\'94, such as density (individuals per unit area) or local competition strength (total interaction strength per unit area), or is not, such as \'93mean individual age\'94, or \'93maximum 
\f1\fs18 tag
\f2\fs20  value\'94.  For the previous example of counting individuals with an operation of 
\f1\fs18 "individuals.size();"
\f2\fs20 , a value of 
\f1\fs18 F
\f2\fs20  for 
\f1\fs18 perUnitArea
\f2\fs20  (the default) will produce a simple 
\f3\i count
\f2\i0  of individuals in each grid square, whereas with 
\f1\fs18 T
\f2\fs20  it would produce the 
\f3\i density
\f2\i0  of individuals in each grid square.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (object<Dictionary>$)treeSeqMetadata(string$\'a0filePath, [logical$\'a0userData\'a0=\'a0T])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f2\fs20 \cf2 Returns a 
\f1\fs18 Dictionary
\f2\fs20  containing top-level metadata from the 
\f1\fs18 .trees
\f2\fs20  (tree-sequence) file at 
\f1\fs18 filePath
\f2\fs20 .  If 
\f1\fs18 userData
\f2\fs20  is 
\f1\fs18 T
\f2\fs20  (the default), the top-level metadata under the 
\f1\fs18 SLiM/user_metadata
\f2\fs20  key is returned; this is the same metadata that can optionally be supplied to 
\f1\fs18 treeSeqOutput()
\f2\fs20  in its 
\f1\fs18 metadata
\f2\fs20  parameter, so it makes it easy to recover metadata that you attached to the tree sequence when it was saved.  If 
\f1\fs18 userData
\f2\fs20  is 
\f1\fs18 F
\f2\fs20 , the entire top-level metadata 
\f1\fs18 Dictionary
\f2\fs20  object is returned; this can be useful for examining the values of other keys under the 
\f1\fs18 SLiM
\f2\fs20  key, or values inside the top-level dictionary itself that might have been placed there by 
\f1\fs18 msprime
\f2\fs20  or other software.\
This function can be used to read in parameter values or other saved state (
\f1\fs18 tag
\f2\fs20  property values, for example), in order to resuscitate the complete state of a simulation that was written to a 
\f1\fs18 .trees
\f2\fs20  file.  It could be used for more esoteric purposes too, such as to search through 
\f1\fs18 .trees
\f2\fs20  files in a directory (with the help of the Eidos function 
\f1\fs18 filesAtPath()
\f2\fs20 ) to find those files that satisfy some metadata criterion.\
}